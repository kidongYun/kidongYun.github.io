<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />

    

    
    <title>oracle 튜닝하기 | Hexo</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="Database,Oracle,Tunning" />
    
    <meta name="description" content="튜닝의 시작  XPLAN을 통해서 실행 계획 일기. 12345SELECT  *FROM    HR.EMPLOYEESWHERE   EMPLOYEE_ID LIKE &amp;#x27;2%&amp;#x27;;SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(null, null, &amp;#x27;ALLSTATS LAST&amp;#x27;)); -&gt; 이거가">
<meta property="og:type" content="article">
<meta property="og:title" content="oracle 튜닝하기">
<meta property="og:url" content="http://kidongyun.github.io/2021/03/16/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="튜닝의 시작  XPLAN을 통해서 실행 계획 일기. 12345SELECT  *FROM    HR.EMPLOYEESWHERE   EMPLOYEE_ID LIKE &amp;#x27;2%&amp;#x27;;SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(null, null, &amp;#x27;ALLSTATS LAST&amp;#x27;)); -&gt; 이거가">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-15T15:54:00.000Z">
<meta property="article:modified_time" content="2022-05-31T07:39:32.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Database">
<meta property="article:tag" content="Oracle">
<meta property="article:tag" content="Tunning">
<meta name="twitter:card" content="summary">
    

    
        <link rel="alternate" href="/" title="Hexo" type="application/atom+xml" />
    

    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/titillium-web/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">


    
<script src="/libs/jquery/3.5.0/jquery.min.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


<meta name="generator" content="Hexo 6.1.0"></head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">Home</a>
                                </li>
                            
                                    <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Devlog/">Devlog</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Service/">Service</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Todo/">Todo</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Yunhwadngdng/">Yunhwadngdng</a></li></ul>
                                
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/about/index.html">About</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>

        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/Devlog/">Devlog</a>
    </h1>
</div>

                        <div class="main-body-content">
                            <article id="post-2021-03-16-db-tunning" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        oracle 튜닝하기
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/2021/03/16/" class="article-date">
       <time datetime="2021-03-15T15:54:00.000Z" itemprop="datePublished">2021-03-16</time>
    </a>
  </div>


<div class="article-date">
  <i class="fa fa-calendar-plus-o"></i>
  <a href="/2021/03/16/" class="article-date">
     <time datetime="2022-05-31T07:39:32.000Z" itemprop="dateModified">2022-05-31</time>
  </a>
</div>


                

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link-link" href="/tags/Database/" rel="tag">Database</a>, <a class="tag-link-link" href="/tags/Oracle/" rel="tag">Oracle</a>, <a class="tag-link-link" href="/tags/Tunning/" rel="tag">Tunning</a>
    </div>

                

                

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            

            

            

            <p>튜닝의 시작 </p>
<p>XPLAN을 통해서 실행 계획 일기.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>    HR.EMPLOYEES</span><br><span class="line"><span class="keyword">WHERE</span>   EMPLOYEE_ID <span class="keyword">LIKE</span> <span class="string">&#x27;2%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">TABLE</span>(DBMS_XPLAN.DISPLAY_CURSOR(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&#x27;ALLSTATS LAST&#x27;</span>)); <span class="operator">-</span><span class="operator">&gt;</span> 이거가 XPLAN 활용해서 실행계획을 보여주는 쿼리</span><br></pre></td></tr></table></figure>
<p>실행 계획을 수행하고 나면 Id, Operation, Name, Starts, E-Rows, A-Rows, A-Time, Buffers… </p>
<p>이렇게 테이블이 나타나는데. 읽을 때 Operation의 개행이 가장 안쪽인 것 부터 읽는다.</p>
<p>인덱스를 사용하고 나서 인덱스의 자료형을 준수해주지 않으면 내부적으로 해당 인덱스 컬럼 값을  변환하기 떄문에 인덱스를 제대로 활용할 수 없다.<br>즉 FULL SCAN이 일어난다.</p>
<p>튜닝이 정상적으로 되었는지를 알려면 기본적으로 Buffers 수가 줄었는지를 봐야 한다.</p>
<p>FULL SCAN<br>INDEX RANGE SCAN<br>INDEX UNIQUE SCAN</p>
<p>NESTED LOOPS -&gt; 프로그래밍 언어에서 for문이 중첩되어 있는 구조와 동일.</p>
<p>FULL SCAN -&gt; INDEX SCAN 으로 변경하여 성능 튜닝.</p>
<p>실행 계획을 봐야 우리가 작성한 쿼리가 정말 효율적인지. 아니라면 비효율적인 구간이 어딘지를 자세히 살펴볼 수 있다.<br>이런것들을 모두 알려면 사실 공부해야할 게 많음으로 모두 습득하고 튜닝된 쿼리를 작성할 수 있도록 하자.</p>
<p>오라클 힌트<br>-&gt; 힌트를 옵티마이저에게 주는 것.<br>힌트에 오류가 있어도 Syntax를 뱉지는 않는다.<br>실행 계획에 영향을 미친다. 쿼리를 이런 방식으로 풀어라 라고 힌트를 주는 것이다.<br>즉 힌트를 주기 전에 그 이전에 쿼리가 어떻게 동작하는지를 알아야 한느데 이를 알기 위해서는 실행 계획을 봐야한다.</p>
<p>JOIN 순서를 조절할 수도 있음. A-&gt;B를 조인하는게 더 성능이 좋을 경우 ORDERED 이런 힌트를 주어서 해결 가능.</p>
<p>기본적으로는 힌트를 주지 않는게 좋다.<br>즉 옵티마이저가 최적화된 쿼리를 동작할 것이다 라고 생각해야한다.</p>
<p>최종적으로 작성한 쿼리가 성능이 낮다면 그때 힌트를 줘야함. 튜닝 단계에서.</p>
<p>조인방식도 엄청 다양하다.</p>
<p>NESTED LOOP JOIN, HASH JOIN<br>..</p>
<h3 id="NETSTED-LOOP-JOIN"><a href="#NETSTED-LOOP-JOIN" class="headerlink" title="NETSTED LOOP JOIN"></a>NETSTED LOOP JOIN</h3><p>-&gt; 중첩 for문과 같은 원리.</p>
<p>IDOL_GROUP 과 IDOL_MEMBER 조인을 한다해보자.</p>
<p>소녀시대 -&gt; 태연<br>        -&gt; 티파니<br>        -&gt; 윤아<br>2ne1    -&gt; 박봄<br>        -&gt; 산다라박</p>
<p>이런 식으로 조인되며 IDOL_GROUP 테이블이 OUTER_TABLE 이 되고(for문에서 밖에있는 for문의 역할과 같다)<br>IDOL_MEMBER 테이블이 INNER_TABLE 이 된다.</p>
<p>이런 식으로 조인하는 방법이 NESTED LOOP JOIN 이라고 한다.</p>
<p>보통 이럴떄에는 INNER TABLE에 해당하는 영역을 INDEX로 걸어서 성능을 높인다.</p>
<p>건건이 테이블을 조인하기 때문에 대량의 테이블을 조인하는 방법으로는 적절하지 않다.</p>
<p>아이돌 그룹 - 아이돌 멤버 처럼 1:M 관계를 가질 떄 1에 해당하는 테이블이 OUTER TABLE로 가야 성능에 유리하다.</p>
<h3 id="SORT-MERGE-JOIN"><a href="#SORT-MERGE-JOIN" class="headerlink" title="SORT MERGE JOIN"></a>SORT MERGE JOIN</h3><p>NESTED LOOP JOIN 방법과 유사하나. 다른점이 있다면 조인 이전에 먼저 조인 테이블 기준으로 정렬을 하고 조인을 시작한다.</p>
<p>INNER TABLE 에 인덱스가 걸려있지 않아서 NESTED LOOP JOIN을 사용하기가 너무 비효율적이다 할 떄 사용할 수 있다.</p>
<h3 id="오라클-메모리-PGA-SGA"><a href="#오라클-메모리-PGA-SGA" class="headerlink" title="오라클 메모리 (PGA, SGA)"></a>오라클 메모리 (PGA, SGA)</h3><p>오라클이 사용하는 메모리는 크게 두가지가 존재.</p>
<p>SGA(System Global Area) - 모든 사용자가 공유 가능하여 사용</p>
<p>PGA(Program Global Area) - 사용자마다 공유하지 않고 개별적으로 사용</p>
<p>데이터베이스를 사용하는 구조를 그려보면 아래와 같다.</p>
<p>유저 프로세스 -&gt; 서버 프로세스 + PGA -&gt; 데이터 베이스</p>
<p>유저 프로세스에서 쿼리를 날리면 서버 프로세스가 이를 받고 데이터 베이스에서 데이터들을 가져오는 작업을 한다.<br>이떄 요청 받은 내용 및 기타 정보들을 저장하기 위해 서버 프로세스는 자신만의 메모리 공간인 PGA를 사용한다.</p>
<p>PGA - 데이터베이스에 접속하는 모든 유저에게 할당되는 각각의 서버 프로세스가 독자적으로 사용하는 오라클 메모리 영역.</p>
<h3 id="HASH-JOIN"><a href="#HASH-JOIN" class="headerlink" title="HASH JOIN"></a>HASH JOIN</h3><p>배치에서 쓰면 좋은 수행 원리다.</p>
<p>PGA 영역 중 sorted area 부분을 hash key로 두고 조인을 하는 방법?</p>
<p>데이터 크기가 메모리 크기보다 커지면 디스크를 써야하기 떄문에 오히려 성능이 떨어질 수 있다.</p>
<h3 id="서브쿼리의-종류"><a href="#서브쿼리의-종류" class="headerlink" title="서브쿼리의 종류"></a>서브쿼리의 종류</h3><ol>
<li><p>select 절에 사용하는 scalar subquery</p>
</li>
<li><p>from 절에 사용하는 inline view</p>
</li>
<li><p>where 절에 사용하는 중첩 서브쿼리.</p>
</li>
</ol>
<p>서브쿼리 자체가 성능에 무조건 안좋다는 것은 선입견</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 서브쿼리를 활용한 경우 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> HR.EMPLOYEES A</span><br><span class="line"> <span class="keyword">WHERE</span> A.DEPARTMENT_ID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> B.DEPARTMENT_ID</span><br><span class="line">                            <span class="keyword">FROM</span> HR.DEPARTMENTS B</span><br><span class="line">                            <span class="keyword">WHERE</span> B.LOCATION_ID<span class="operator">=</span><span class="number">1700</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FROM 절에서 조인 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> HR.EMPLOYEES A,</span><br><span class="line">       HR.DEPARTMENTS B</span><br><span class="line"> <span class="keyword">WHERE</span> A.DEPARTMENT_ID <span class="operator">=</span> B.DEPARTMENT_ID</span><br><span class="line">   <span class="keyword">AND</span> B.LOCATION_ID <span class="operator">=</span> <span class="number">1700</span>;          </span><br><span class="line"></span><br><span class="line"><span class="comment">/* NO_UNNEST 힌트문 적용한 경우 (성능이 더 떨어짐 원래 서브쿼리 방식)*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> HR.EMPLOYEES A</span><br><span class="line"> <span class="keyword">WHERE</span> A.DEPARTMENT_ID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="comment">/*+NO_UNNEST*/</span></span><br><span class="line">                                 B.DEPARTMENT_ID</span><br><span class="line">                            <span class="keyword">FROM</span> HR.DEPARTMENTS B</span><br><span class="line">                            <span class="keyword">WHERE</span> B.LOCATION_ID<span class="operator">=</span><span class="number">1700</span>);                </span><br></pre></td></tr></table></figure>
<p>실행계획을 살펴보면 위 두 쿼리가 둘다 HASH JOIN을 사용해서 동일한 형태로 동작하고 있음을 알수 있다.</p>
<p>원래 서브쿼리는 NO_UNNEST 이 방식을 동작하는데 서브쿼리를 푼 두번째 쿼리가 더 효과적으로 데이터를 가져오기 때문에<br>옵티마이저가 이 방식으로 HASH JOIN을 해서 데이터를 가져온다.</p>
<h3 id="서브쿼리를-반드시-쓰면-안되는-경우"><a href="#서브쿼리를-반드시-쓰면-안되는-경우" class="headerlink" title="서브쿼리를 반드시 쓰면 안되는 경우."></a>서브쿼리를 반드시 쓰면 안되는 경우.</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.EMPLOYEE_ID,</span><br><span class="line">       A.FIRST_NAME,</span><br><span class="line">       A.LAST_NAME,</span><br><span class="line">       A.SALARY</span><br><span class="line">  <span class="keyword">FROM</span> HR.EMPLOYEES A</span><br><span class="line"> <span class="keyword">WHERE</span> A.SALARY <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(SALARY) <span class="keyword">FROM</span> HR.EMPLOYEES)</span><br><span class="line">    <span class="keyword">OR</span> A.SALARY <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(SALARY) <span class="keyword">FROM</span> HR.EMPLOYEES);</span><br></pre></td></tr></table></figure>
<p>위의 케이스를 잘 보면 HR.EMPLOYEES 이 동일한 테이블을 다른 차이 없이 3번 접근하고 있다,<br>그러면 이 테이블을 3번 액세스 한다. 비효율적이겠찌..</p>
<p>어떻게 수정해야 할까.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> B.EMPLOYEE_ID,</span><br><span class="line">       B.FIRST_NAME,</span><br><span class="line">       B.LAST_NAME,</span><br><span class="line">       B.SALARY</span><br><span class="line">  <span class="keyword">FROM</span> (                </span><br><span class="line">            <span class="keyword">SELECT</span> A.EMPLOYEE_ID,</span><br><span class="line">                   A.FIRST_NAME,</span><br><span class="line">                   A.LAST_NAME,</span><br><span class="line">                   A.SALARY,</span><br><span class="line">                   <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> SALARY) MINSAL,</span><br><span class="line">                   <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> SALARY <span class="keyword">DESC</span>) MAXSAL</span><br><span class="line">              <span class="keyword">FROM</span> HR.EMPLOYEES A</span><br><span class="line">       ) B</span><br><span class="line"> <span class="keyword">WHERE</span> B.MINSAL <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> B.MAXSAL <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>이렇게 하면 같은 내용의 쿼리지만. EMPLOYEE_ID 이 테이블을 한번만 액세스 하고 있다. 훨씬 더 효율적</p>
<p>실행계획으로 살펴봐라.</p>
<p>테이블을 여러번 액세스 한다는 것이 성능이 떨어지는 이유는 기본적으로 테이블이 디스크에 존재하기 때문이다. 성능 튜닝을 할 때 우선적으로 포커스를 두는 것은 디스크 I/O 발생을 줄이는 것인데.<br>이 부분이 속도가 가장 느리기 때문이다.</p>
<p>그렇기 떄문에 테이블을 여러번 접근하는 것은 디스크 I/O 발생빈도가 늘어난다는 의미 임으로 이를 개선할 필요성이 있따.</p>
<h4 id="동일한-테이블을-바라보는-방법으로-서브쿼리를-작성하는-것은-안된다"><a href="#동일한-테이블을-바라보는-방법으로-서브쿼리를-작성하는-것은-안된다" class="headerlink" title="동일한 테이블을 바라보는 방법으로 서브쿼리를 작성하는 것은 안된다."></a>동일한 테이블을 바라보는 방법으로 서브쿼리를 작성하는 것은 안된다.</h4><h3 id="4-1-B-TREE-INDEX-구조"><a href="#4-1-B-TREE-INDEX-구조" class="headerlink" title="4.1 B-TREE INDEX 구조"></a>4.1 B-TREE INDEX 구조</h3><p>B-TREE INDEX 구조는 ROOT BLOCK, BRANCH BLOCK, LEAF BLOCK 으로 우선 구분된다. 각 BLOCK 들은 아래와 같은 데이터를 가진다.</p>
<p>ROOT BLOCK = BRANCH BLOCK 주소, 인덱스 컬럼 값<br>BRANCH BLOCK = LEAF BLOCK 주소, 인덱스 컬럼 값<br>LEAF BLOCK = 인덱스 컬럼 값, TABLE의 ROW ID</p>
<p>여기서 인덱스 컬럼 값은 테이블에서 인덱스를 설정한 컬럼 값을 의미한다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> COL1, COL2, COL3, COL4 <span class="keyword">FROM</span> TAB <span class="keyword">WHERE</span> COL1 <span class="keyword">BETWEEN</span> :VAL1 <span class="keyword">AND</span> :VAL2;</span><br></pre></td></tr></table></figure>
<p>위와 같은 SQL에서 만약 COL1 값에만 인덱스가 걸려 있다면 SELECT 절에 있는 COL2, COL3, COL4 데이터들은 인덱스 테이블을 통해서 가져올 수 없다.<br>이런 경우에는 LEAF BLOCK 이 가지고 있는 TABLE ROW ID 값을 통해 접근해서 가져온다.</p>
<h3 id="4-2-INDEX-RANGE-SCAN"><a href="#4-2-INDEX-RANGE-SCAN" class="headerlink" title="4.2 INDEX RANGE SCAN"></a>4.2 INDEX RANGE SCAN</h3><p>INDEX RANGE SCAN은 말그대로 INDEX 테이블에서 특정 범위 내 BLOCK 순차적으로 탐색하는 것이다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> COL1, COL2, COL3, COL4 <span class="keyword">FROM</span> TAB <span class="keyword">WHERE</span> COL1 <span class="keyword">BETWEEN</span> :VAL1 <span class="keyword">AND</span> :VAL2;</span><br></pre></td></tr></table></figure>
<p>위와 같은 쿼리가 있고 COl1 값이 인덱스로 설정되어 있다면. 우선 COL1 컬럼 기준으로 :VAL1 값을 찾아간다.<br>이 값을 찾기 위해서 ROOT BLOCK -&gt; BRANCH BLOCK -&gt; LEAF BLOCK 순으로 탐색할 것이다.<br>:VAL1 에 해당하는 LEAF BLOCK을 찾았다면. :VAL2에 해당하는 값이 나올때 까지 LEAF BLOCK을 선형적으로, 순차적으로 탐색한다.</p>
<p>인덱스를 순차적으로 읽으면서 한 건씩 ROWID를 가지고 TABLE BLOCK을 한 개씩 ACCESS 하기 때문에 이를 RANDOM SINGLE BLOCK I/O 라고 부르며<br>TABLE ACCES BY INDEX ROWID 라는 실행계획으로 전시된다.</p>
<p>이 방법은 최악의 경우 조회 건수 만큼(즉 인덱스를 사용한 이유가 없이 FULL SCAN을 한다는 의미) I/O가 발생할 수 있다.<br>-&gt; 아니네. FULL TABLE SCAN 방법은 멀티로 동작하기 때문에 오히려 최악의 케이스 일때는 이 방법이 더 빠르다고 언급함.</p>
<p>위에서 계속 언급한 BLOCK 이라는 것은 저장된 데이터의 묶음 단위로 보면 된다</p>
<p>ROOT BLOCK과 BRANCH BLOCK에 들어가는 주소값 들은 가상으 ㅣ값을 활용 한다.</p>
<p>만약 SELECT * 이 절에 인덱스에서 사용되는 컬럼만 조회하고 다른 컬럼들이 없다면 TABLE BLOCK을 ACCESS 할 필요가 없다.</p>
<p>XPLAN 실행 계획 테이블에서 Name 필드는 테이블 명이 들어간다. 인덱스 테이블이나, 일반 테이블 등.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IX_ORDERS_N1 : ORDER_DATE, ORDER_MODE, EMPLOYEE_ID</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX(A IX_ORDERS_N1) */</span></span><br><span class="line">       ORDER_DATE, CUSTOMER_ID,</span><br><span class="line">       ORDER_MODE, ORDER_TOTAL</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS A</span><br><span class="line"> <span class="keyword">WHERE</span> ORDER_DATE <span class="keyword">BETWEEN</span> TO_DATE(<span class="string">&#x27;20210101&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line">                      <span class="keyword">AND</span> TO_DATE(<span class="string">&#x27;20210102&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 실행 계획                      </span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID</span><br><span class="line">    INDEX <span class="keyword">RANGE</span> SCAN</span><br></pre></td></tr></table></figure>
<p>위와 같이 실행계획이 나타난다면 TABLE ACCESS BY INDEX ROWID 는 위에서 설명했듯이 INDEX BLOCK -&gt; TABLE BLOCK 으로 ACCESS하는 RANDOM SINGLE BLOCK I/O를 나타내는 OPERATION이다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*+ INDEX(A IX_ORDERS_N1) */</span><br></pre></td></tr></table></figure>
<p>와 같인 힌트를 주면 INDEX RANGE SCAㅜ, INDEX FULL SCAN 으로 수행한다.</p>
<h3 id="4-3-INDEX-RANGE-SCAN-DESCENDING"><a href="#4-3-INDEX-RANGE-SCAN-DESCENDING" class="headerlink" title="4.3 INDEX RANGE SCAN DESCENDING"></a>4.3 INDEX RANGE SCAN DESCENDING</h3><p>INDEX RANGE SCAN DESCENING 실행계획의 특징은 INDEX RANGE SCAN과 동일하다. 다른 점이 있다면 INDEX를 역순으로 읽는 다는 점이다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">IX_ORDERS_N1 : ORDER_DATE</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX_DESC(A IX_ORDERS_N1) */</span></span><br><span class="line">       ORDER_DATE, CUSTOMER_ID,</span><br><span class="line">       ORDER_MODE, ORDER_TOTAL</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS A</span><br><span class="line"> <span class="keyword">WHERE</span> ORDER_DATE <span class="keyword">BETWEEN</span> TO_DATE(<span class="string">&#x27;20120101&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line">                      <span class="keyword">AND</span> TO_DATE(<span class="string">&#x27;20210102&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> ORDER_DATE <span class="keyword">DESC</span>;                    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 실행 계획</span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID</span><br><span class="line">    INDEX <span class="keyword">RANGE</span> SCAN DESCENDING</span><br></pre></td></tr></table></figure>
<p>위 쿼리를 실행하게 되면 아래와 같은 실행 계획이 발생할 것이다. 여기서 INDEX RANGE SCAN DESCENDING 이 나타나는 걸 볼 수 있는데. INDEX_DESC() 힌트를 줘서 그런것도 있지만.<br>기본적으로 ORDER BY DESC 정렬을 이처럼 역순으로 하게 되면 이처럼 동작한다. 즉 힌트문을 제거해도 동일하게 동작할 것이다.</p>
<p>OPTIMIZER는 인덱스를 역순으로 읽으면서 ORDER BY에 의한 SORT(ORDER BY) OPERATION 작업을 생략할 수 있다. -&gt; 더 성능이 좋아진다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IX_ORDERS_N1 : ORDER_DATE</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(ORDER_DATE)</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS</span><br><span class="line"> <span class="keyword">WHERE</span> ORDER_MODE <span class="operator">=</span> <span class="string">&#x27;direct&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 실행 계획</span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  SORT AGGREGATE</span><br><span class="line">    <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span></span><br></pre></td></tr></table></figure>
<p>ORDER_DATE 기준으로 인덱스가 설정되어 있기 때문에 만약 ORDER_MODE 조건이 없다면. INDEX FULL SCAN(MIN/MAX) OPERATION 이 발생해서 Bufffers 수치가 낮을 것이다. 하지만 저 조건으로 인해 FULL TABLE SCAN 이 발생한다.</p>
<p>이를 튜닝할 수 있는 방법 중 하나는 INDEX DESCENDING을 이용한 TOP N 쿼리를 사용하는 방법이다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ORDER_DATE</span><br><span class="line">  <span class="keyword">FROM</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="comment">/*+ INDEX_DESC(A IX_ORDERS_N1) */</span></span><br><span class="line">               ORDER_DATE</span><br><span class="line">          <span class="keyword">FROM</span> ORDERS A</span><br><span class="line">         <span class="keyword">WHERE</span> ORDER_DATE <span class="operator">&gt;</span> TO_DATE(<span class="string">&#x27;10000101&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line">           <span class="keyword">AND</span> ORDER_MODE <span class="operator">=</span> <span class="string">&#x27;direct&#x27;</span></span><br><span class="line">         <span class="keyword">ORDER</span> <span class="keyword">BY</span> ORDER_DATE <span class="keyword">DESC</span>   </span><br><span class="line">  )</span><br><span class="line"> <span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 실행 계획</span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  COUNT STOPKEY</span><br><span class="line">    <span class="keyword">VIEW</span></span><br><span class="line">      <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID</span><br><span class="line">        INDEX <span class="keyword">RANGE</span> SCAN DESCENDING</span><br></pre></td></tr></table></figure>
<p>인덱스는 컬럼 기준으로 정렬이 되어있음을 이용하는 테크닉 같다. 서브 쿼리 부분을 보면 ORDER_DATE 컬럼을 조회하고, 이 값을 DESC 형태로 정렬하게끔 보여지도록 하는데.<br>이렇게 하면 INDEX RANGE SCAN DESCENDING OPERATION 이 수행되고 인덱스 테이블의 가장 큰쪽에 존재하는 값이 가장 큰 값임을 바로 알 수 있다 이 곳에서 순차적으로 탐색하면서 ORDER_MODE 조건에 맞는 데이터가 나타나면 바로 반환한다. ROWNUM &lt;= 1 조건이 하나의 값만 반환하라고 명시하고 있기 때문이다.</p>
<p>실행 계획을 보면 COUNT STOPKEY OPERATION이 있는데 이부분이 ROWNUM &lt;= 1 조건으로 인해 발생한 동작이다.</p>
<p>만약 ORDER_MODE 와 같이 조건에 해당하는 부분이 PK 처럼 구분되는 값들이 많다면. 큰쪽부터 검색한다 해도. 조건에 맞는 데이터를 찾는 데에 오래 걸리기 때문에 성능이 매우 저하된다.<br>조건이 선택지가 적고 자주 발견되는 데이터인지를 우선 파악해야 한다.</p>
<h3 id="4-4-INDEX-RANGE-SCAN-MIN-MAX"><a href="#4-4-INDEX-RANGE-SCAN-MIN-MAX" class="headerlink" title="4.4 INDEX RANGE SCAN (MIN/MAX)"></a>4.4 INDEX RANGE SCAN (MIN/MAX)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IX_ORDERS_N2 : EMPLOYEE_ID, ORDER_DATE</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX(A IX_ORDERS_N2) */</span></span><br><span class="line">       <span class="built_in">MAX</span>(ORDER_DATE)</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS A</span><br><span class="line"> <span class="keyword">WHERE</span> EMPLOYEE_ID <span class="operator">=</span> <span class="string">&#x27;E402&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="operator">/</span><span class="operator">/</span> 실행 계획</span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  SORT AGGREGATE</span><br><span class="line">    <span class="keyword">FIRST</span> <span class="type">ROW</span></span><br><span class="line">      INDEX <span class="keyword">RANGE</span> SCAN (MIN<span class="operator">/</span>MAX)</span><br></pre></td></tr></table></figure>
<p>INDEX 컬럼이 EMPLOYEE_ID, ORDER_DATE 와 같이 구성되어 있고 INDEX 선두 컬럼이 조건 절에 들어오며 두 번째 컬럼인 ORDER_DATE가 MAX 처리 되었을 때 나타나는 실행계획이<br>INDEX RANGE SCAN (MIN/MAX) 이다. 조건에 해당하는 EMPLOYEE_ID = ‘E402’ 에 대한 많은 ORDER_DEATE 중에서 가장 끝에 있는 인덱스 만 읽고 빠져나온다.<br>인덱스는 정렬되어 있기 때문에 가능하다.</p>
<p>BUFFER가 3회로 나타날 텐데 그 이유는 ROOT BLOCK, BRANCH BLOCK, LEAF BLOCK을 각각 한번씩 총 3번 읽었기 때문이다.</p>
<h3 id="4-5-INDEX-컬럼-가공"><a href="#4-5-INDEX-컬럼-가공" class="headerlink" title="4.5 INDEX 컬럼 가공"></a>4.5 INDEX 컬럼 가공</h3><p>인덱스로 사용한 컬럼을 TRIM(COLUMN_NAME), TO_DATE(COLUMN_NAME, ‘YYYYMMDD’) 와 같이 가공하게 되면. OPTIMIZER가 인덱스를 인지하지 못하고 FULL TABLE SCAN을 수행한다.<br>주의해야하는 부분이다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IX_ORDERS_N3 : CUSTOMER_ID, ORDER_DATE</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ORDER_DATE, CUSTOMER_ID,</span><br><span class="line">       ORDER_MODE, ORDER_TOTAL</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS A</span><br><span class="line"> <span class="keyword">WHERE</span> RTRIM(CUSTOMER_ID) <span class="operator">=</span> <span class="string">&#x27;C01492&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> ORDER_DATE <span class="keyword">BETWEEN</span> TO_DATE(<span class="string">&#x27;20120101&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line">                      <span class="keyword">AND</span> TO_DATE(<span class="string">&#x27;20130101&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 실행 계획</span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span></span><br></pre></td></tr></table></figure>
<p>CUSTOMER_ID 스키마가 CHAR(7) 이라고 한다면 위처럼 6자리인 데이터를 조회할 수 없다. 이는 근본적으로는 스키마의 설계가 잘못된 것이지만. 만약 레거시로 존재한다고 했을 때<br>쿼리의 성능을 높이기 위해서는 어떤 방법이 있을까. </p>
<p>RTRIM을 써서 CUSTOMER_ID 인덱스 컬럼을 직접 수정하기 보다는 RPAD 를 사용해서 들어오는 데이터를 변환시키면 인덱스를 사용하 ㄹ수 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ORDER_DATE, CUSTOMER_ID</span><br><span class="line">       ORDER_MODE, ORDER_TOTAL</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS A</span><br><span class="line"> <span class="keyword">WHERE</span> CUSTOMER_ID <span class="operator">=</span> RPAD(<span class="string">&#x27;C01492&#x27;</span>, <span class="number">7</span>, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">   <span class="keyword">AND</span> ORDER_DATE <span class="keyword">BETWEEN</span> TO_DATE(<span class="string">&#x27;20120101&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line">                      <span class="keyword">AND</span> TO_DATE(<span class="string">&#x27;20130101&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 실행 계획</span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID</span><br><span class="line">    INDEX <span class="keyword">RANGE</span> SCAN</span><br></pre></td></tr></table></figure>
<p>기존 실행 게획에서는 TABLE ACCESS FULL 동작을 하다가 위처럼 변경하게 되면 INDEX RANGE SCAN 동작으로 변경됨을 알 수 있다.</p>
<h3 id="4-6-CLUSTERING-FACTORER"><a href="#4-6-CLUSTERING-FACTORER" class="headerlink" title="4.6 CLUSTERING FACTORER"></a>4.6 CLUSTERING FACTORER</h3><p>CLUSTERING FACTOR 라는 것은 무엇일까? 이것은 데이터가 모여 있는 정도 라고 볼 수 있다.</p>
<p>인덱스 테이블에서 LEAF BLOCK이 가지고 있는 ROWID를 가지고 테이블 데이터를 하나씩 찾아갈 때 계속 동일한 BLOCK를 액세스 한다면 이는 CF(CLUSTERING FACTOR)가 잘되어 있다고 볼 수 있고 반대의 경우로 서로 다른 BLOCk을 찾아갈 확률이 높다면 CF는 나쁜 것이다.</p>
<p>CF가 좋으면 BLOCK I/O 가 감소하고, 반대의 경우 증가한다.</p>
<p>위 4.2 에서 살펴본 INDEX RANGE SCAN은 DATA BLOCK의 위착 RANDOM하게 왔다 갔다하기 때문에 CF가 좋지 않은 예시로 볼 수 있다.</p>
<p>PS. BLOCK 이라는 것은 데이터 묶음 단위로 생각해야 한다. 하나의 데이터를 가지고 있는 것이 아니다.</p>
<p>CF가 가장 좋은 경우는 INDEX에 저장된 데이터의 순서가 완전히 일치하는 경우이며. 반대로 좋지 않은 경우는 INDEX의 데이터 블록 순서와는 상관 없이 흩어져 있는 경우가 된다.</p>
<p>중요한 점은. CF를 활용할 때 이 데이터 블록을 한번 접근했다고 해서 그 블록을 영구히 캐싱하는 것은 아니다. 바로 다음 로우를 조회하는 시점에만 이 블록을 캐싱으로 활용할 수 있기 때문에 만약 Data Block들이 밀집되어 있다고 해도 이를 연속적으로 접근하지 않는다면 CF가 좋지 않은 경우가 된다.</p>
<p>인덱스 테이블 순으로 정렬된 테이블을 만들고 이를 활용해 인덱스 테이블 순서와 동일한 새로운 테이블을 생성해보자. 즉 CF가 가장 좋은 경우를 얻어보는 거다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 인덱스 테이블과 일치하는 테이블 ORDERS_CF 생성</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ORDERS_CF</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> ORDERS</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> ORDER_DATE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ORDER_DATE 기준으로 인덱스 생성</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX IX_ORDERS_CF_N1</span><br><span class="line"><span class="keyword">ON</span> ORDERS_CF(ORDER_DATE);</span><br></pre></td></tr></table></figure>
<p>위와 같이하게 되면 인덱스 테이블 블록과 데이터 테이블 블록이 일치하기 때문에 CF는 최상이다.</p>
<p>CF를 조회하는 방법은 아래와 같다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.TABLE_NAME, A.INDEX_NAME, A.CLUSTERING_FACTOR, A.NUM_ROWS, B.BLOCKS TABLE_BLOCKS</span><br><span class="line">  <span class="keyword">FROM</span> DBA_INDEXES A, DBA_TABLES B</span><br><span class="line"> <span class="keyword">WHERE</span> A.TABLE_NAME <span class="operator">=</span> B.TABLE_NAME</span><br><span class="line">   <span class="keyword">AND</span> A.OWNER <span class="operator">=</span> B.OWNER</span><br><span class="line">   <span class="keyword">AND</span> A.INDEX_NAME <span class="keyword">IN</span> (<span class="string">&#x27;IX_ORDERS_N1&#x27;</span>, <span class="string">&#x27;IX_ORDERS_CF_N1&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>좋은 CF의 수치는 TABLE BLOCK 수에 근접하고 반대의 경우 테이블 전체 건수에 근접하게 된다.</p>
<p>의문) PK 같은 값을 인덱싱하면 효과가 없다고 배웠는데 잘 생각해보면.<br>데이터 테이블 탐색 방법은 선형 탐색 방법이고, 인덱스는 B-TREE 탐색 방법이기 때문에<br>PK 같은걸 인덱싱해도 성능이 좋지 않을까?? -&gt; 맞는 것 같다 확인해보니까 기본적으로 PK는 인덱스가 적용되어 있는거 같다.</p>
<p>일반적으로 인덱스 컬럼이 추가도리 수록 CF는 나빠진다. 추가도니 컬럼으로 정렬이 되어 INDEX의 저장 순서와 테이블의 저장 순서가 달라지게 되기 때문이다.<br>그러나 만약 선행적으로 적용된 인덱스 컬럼이 날짜 정보처럼 (시, 분, 초 까지 가지는) 거의 유니크한 값이라면. 다른 인덱스 컬럼과 같은 값을 가지는 경우가 거의 없어서<br>정렬 순서가 크게 달라지지 안흔다.</p>
<p>결론적으로 CF가 매우 좋은 INDEX의 컬럼이 UNIQUE에 가까울 경우에는 그 뒤에 컬럼이 추가 되더라도 CF가 나빠지지 않는다.</p>
<h4 id="FUNCTION-BASED-INDEX"><a href="#FUNCTION-BASED-INDEX" class="headerlink" title="FUNCTION BASED INDEX"></a>FUNCTION BASED INDEX</h4><p>컬럼에 TO_CHAR() 함수와 같은 것을 적용시켜서 그 데이터를 인덱스 컬럼으로 하는 인덱스 테이블을 말한다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX IX_ORDERS_CF_N3</span><br><span class="line"><span class="keyword">ON</span> ORDERS_CF(TO_CHAR(ORDER_DATE, <span class="string">&#x27;YYYYMMDD&#x27;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="4-7-INDEX-RANGE-SCAN-VS-FULL-TABLE-SCAN"><a href="#4-7-INDEX-RANGE-SCAN-VS-FULL-TABLE-SCAN" class="headerlink" title="4.7 INDEX RANGE SCAN VS FULL TABLE SCAN"></a>4.7 INDEX RANGE SCAN VS FULL TABLE SCAN</h3><p>FULL TABLE SCAN은 TABLE BLOCK 전체를 DB_FILE_MULTIBLOCK_READ_COUNT 파라미터 값에 비례해서 수십 BLOCK씩 MULTI BLOCK으로 읽는다.</p>
<p>이렇게 I/O를 하는 방법이 RANDOM SIGNLE BLOCK I/O, MULTI BLOCK I/O 로 상이한데. 그렇기 때문에 테이블 전체 건수의 1/20 이상이라면<br>FULl  TABLE SCAN을 사용하는 것이 유리하다.</p>
<p>즉 테이블의 많은 부분을 차지하는 row를 가져올 때에는 오히려 INDEX RANGE SCAN 방법이 역효과가 난다는 의미이다. SINGLE I/O 이기 때문에 그렇다.</p>
<p>이거는 아무래도 실행 계획을 보면서 Buffers, A-Times 등을 보면서 판단을 해야하지 않을까 싶다.</p>
<p>아무튼 결론은. 테이블 전체 만큼의 데이터를 가져 오려고 하면 INDEX를 사용하지 말고 그냥 FULL SCAN을 하라.</p>
<h3 id="4-8-INDEX-ACCESS-조건-FILTER-조건"><a href="#4-8-INDEX-ACCESS-조건-FILTER-조건" class="headerlink" title="4.8 INDEX ACCESS 조건, FILTER 조건"></a>4.8 INDEX ACCESS 조건, FILTER 조건</h3><p>INDEX ACCESS 조건이라는 것은 INDEX SCAN 시에 SCAN 범위를 줄여주는데에 참여한 조건을 의미한다.</p>
<p>INDEX FILTER 조건이라는 것은 실제 SCAN 범위는 줄여주지 못하고 말 그대로 데이터의 FILTER 역할 만을 한다는 의미이다.</p>
<p>인덱스 탐색량을 줄이기 위해서는 INDEX ACCESS 조건이 더 많이 발생하도록 하는게 좋다. SCAN 범위가 줄기 때문이다.</p>
<p>범위 조건 연산(&gt;=, &lt;=, BETWEEN, LIKE 등) 이 수행되기 이전에는 ACCESS 조건이 나타나지만 그 이후에는 FILTER 조건으로 사용되는게 인덱스의 특징이다.</p>
<p>COL1, COL2, COL3, COL4 컬럼으로 구성된 INDEX가 있다고 해보자.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> COL1 <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">AND</span> COL2 <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">AND</span> COL3 <span class="operator">=</span> <span class="string">&#x27;나&#x27;</span> <span class="keyword">AND</span> COL4 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>
<p>이렇게 모든 조건 연산들이 범위 조건 연산이 아니라면 모두 INDEX ACCESS 조건으로 사용되어 범위를 줄여줄 수 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> COL1<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">AND</span> COL2 <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">AND</span> COL3 <span class="keyword">BETWEEN</span> <span class="string">&#x27;가&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;다&#x27;</span> <span class="keyword">AND</span> COL4 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>
<p>COL1, COL2 는 범위 조건 연산인 COL3 이전에 발생했기 때문에 INDEX ACCESS 조건으로 사용되지만.<br>COL4 는 이 후이기 때문에 FILTER 조건으로 사용된다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> COL1<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">AND</span> COL2 <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">AND</span> COL4 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>
<p>COL3 컬럼에 대한 조건이 생략되어 있는데 생략된 것도 범위 조건 연산으로 보며. 그렇기 떄문에 COL1, COL2는 INDEX ACCESS 조건, COL4 는 INDEX FILTER 조건이 된다.</p>
<p>예시를 보자.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IX_ORDERS_N1 : ORDER_DATE, ORDER_MODE, EMPLOYEE_ID</span><br><span class="line">IX_ORDERS_N2 : EMPLOYEE_ID, ORDER_MOD, ORDER_DATE</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> TO_CHAR(ORDER_DATE, <span class="string">&#x27;YYYYMM&#x27;</span>) ORDER_MM</span><br><span class="line">       , <span class="built_in">COUNT</span>(<span class="operator">*</span>) ORDER_CNT</span><br><span class="line">       , <span class="built_in">SUM</span>(ORDER_TOTAL) ORDER_AMT</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS A</span><br><span class="line"> <span class="keyword">WHERE</span> ORDER_DATE <span class="keyword">BETWEEN</span> TO_DATE(<span class="string">&#x27;20110101&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line">                      <span class="keyword">AND</span> TO_DATE(<span class="string">&#x27;20120101&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line">   <span class="keyword">AND</span> EMPLOYEE_ID <span class="operator">=</span> <span class="string">&#x27;E123&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> ORDER_MODE <span class="operator">=</span> <span class="string">&#x27;direct&#x27;</span></span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> TO_CHAR(ORDER_DATE, <span class="string">&#x27;YYYYMM&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>IX_ORDERS_N2 의 조건이 범위 연산이 후위에 있기 때문에 INDEX_ACCESS 조건이 더 많이 생성되어서 더 좁은 범위를 스캔해도 되어 성능이 좋아진다.</p>
<h3 id="4-9-INDEX-SKIP-SCAN"><a href="#4-9-INDEX-SKIP-SCAN" class="headerlink" title="4.9 INDEX SKIP SCAN"></a>4.9 INDEX SKIP SCAN</h3><p>INDEX SKIP SCAN은 조회 조건이 INDEX의 ACCESS 조건이 아니라 FILTERING 조건으로 들어오는 경우 ACCESS 범위에 해당하는 모든 INDEX BLOCK을 순차적으로 SCAN하는 것이 아니라 (이 방법이 기존의 INDEX 방법) 불필요한 LEAF BLOCK들은 SKIP 해서 인덱스 범위를 줄여주는 동작이다.</p>
<p>이건 좋지는 않다고 했음. 왜냐하면 결국 선두 인덱스가 생략된 상태로 조회되었을때가 가정인데. 이 가정 자체가 사실 좋지 않은 가정임.</p>
<h3 id="4-10-INDEX-FULL-SCAN"><a href="#4-10-INDEX-FULL-SCAN" class="headerlink" title="4.10 INDEX FULL SCAN"></a>4.10 INDEX FULL SCAN</h3><p>INDEX FULL SCAN은 INDEX LEAF BLOCK 전체를 순차적으로 ACCESS 하는 동작을 말한다. 모든 LEAF BLOCK을 탐색하기 때문에 성능은 당연히 떨어지고, INDEX 건수가 많을 수록 더 느리다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IX_ORDERS_N3 : ORDER_STATUS, ORDER_MODE, EMPLOYEE_ID, ORDER_DATE</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX(A IX_ORDERS_N3) */</span></span><br><span class="line">       TO_CHAR(ORDER_DATE, <span class="string">&#x27;YYYYMM&#x27;</span>) ORDER_MM,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) ORDER_CNT,</span><br><span class="line">       <span class="built_in">SUM</span>(ORDER_TOTAL) ORDER_AMT</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS A</span><br><span class="line"> <span class="keyword">WHERE</span> ORDER_DATE <span class="keyword">BETWEEN</span> TO_DATE(<span class="string">&#x27;20120101&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line">                      <span class="keyword">AND</span> TO_DATE(<span class="string">&#x27;20120301&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> TO_CHAR(ORDER_DATE, <span class="string">&#x27;YYYYMM&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 실행 계획</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  HASH <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID</span><br><span class="line">      INDEX <span class="keyword">FULL</span> SCAN</span><br></pre></td></tr></table></figure>
<p>위와 같이 쿼리를 작성하면 원래는 TABLE FULL SCAN 이 발생할 것 같은데.. 힌트문을 줘서 INDEX FULL SCAN이 발생. INDEX 는 순차적 탐색이기 떄문에 상대적으로 더 느리다.</p>
<p>위와같은 INDEX FULL SCAN 방법이 유용한 케이스를 생각해보자.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ORDER_DATE, EMPLOYEE_ID, ORDER_MODE, ORDER_STATUS, ORDER_TOTAL</span><br><span class="line">  <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> ORDER_DATE, EMPLOYEE_ID, ORDER_MODE, ORDER_STATUS, ORDER_TOTAL</span><br><span class="line">      <span class="keyword">FROM</span> ORDERS A</span><br><span class="line">     <span class="keyword">ORDER</span> <span class="keyword">BY</span> ORDER_STATUS, ORDER_MODE, EMPLOYEE_ID, ORDER_DATE )</span><br><span class="line"> <span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 실행 계획</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  COUNT STOPKEY</span><br><span class="line">    <span class="keyword">VIEW</span></span><br><span class="line">      SORT <span class="keyword">ORDER</span> <span class="keyword">BY</span> STOPKEY</span><br><span class="line">        <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span></span><br></pre></td></tr></table></figure>
<p>위 쿼리에서 서브쿼리 내용이 TABLE ACCESS FULL을 하고 조건에 따라 정렬을 하게된다. 그러나 ORDER_DATE 기준으로 이미 인덱스가 있는 것을 알기 때문에 굳이 쿼리 수행시에 정렬을 하는 것 보다는. ORDER_DATE 조건을 주게되면 인덱스를 사용하게 되기때문에 이미 정렬된 상태로 데이터를 가져올 수 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ORDER_DATE, EMPLOYEE_ID, ORDER_MODE, ORDER_STATUS, ORDER_TOTAL</span><br><span class="line">  <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> ORDER_DATE, EMPLOYEE_ID, ORDER_MODE, ORDER_STATUS, ORDER_TOTAL</span><br><span class="line">      <span class="keyword">FROM</span> ORDERS A</span><br><span class="line">     <span class="keyword">WHERE</span> ORDER_DATE <span class="operator">&gt;</span> TO_DATE(<span class="string">&#x27;1999&#x27;</span>, <span class="string">&#x27;YYYY&#x27;</span>) </span><br><span class="line">     <span class="keyword">ORDER</span> <span class="keyword">BY</span> ORDER_STATUS, ORDER_MODE, EMPLOYEE_ID, ORDER_DATE )</span><br><span class="line"> <span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 실행 계획</span></span><br><span class="line"> <span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  COUNT STOPKEY</span><br><span class="line">    <span class="keyword">VIEW</span></span><br><span class="line">      <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID</span><br><span class="line">        INDEX <span class="keyword">FULL</span> SCAN</span><br></pre></td></tr></table></figure>
<p>즉 요약하면. 재정렬이 필요할 때 정렬해야하는 컬럼 기준으로 인덱스가 있다면. 인덱스에 이미 정렬되어 있기 때문에 그 인덱스를 활용하는 것이 보다 성능적으로 좋다.</p>
<h3 id="4-11-INDEX-FULL-SCAN-MIN-MAX"><a href="#4-11-INDEX-FULL-SCAN-MIN-MAX" class="headerlink" title="4.11 INDEX FULL SCAN(MIN/MAX)"></a>4.11 INDEX FULL SCAN(MIN/MAX)</h3><p>조건절(WHERE)  부분에 인덱스 컬럼이 존재하지 않고 MIN(), MAX() 함수로 데이터를 뽑을 때에는 INDEX FULL SCAN 이 일어난다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IX_ORDERS_N1 : ORDER_DATE</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(ORDER_DATE)</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 실행 계획</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  SORT AGGREGATE</span><br><span class="line">    INDEX <span class="keyword">FULL</span> SCAN (MIN<span class="operator">/</span>MAX)</span><br></pre></td></tr></table></figure>
<p>WHERE 절이 없기 때문에 INDEX FULL SCAN이 발생. 근데 buffers 수가 root block -&gt; branch block -&gt; leaf block 이렇게 3번 접근하는데 이게 INDEX RANGE SCAN 이랑 효율은 똑같은 거 같은데…</p>
<p>INDEX FULL SCAN 일때 아래와 같이 MIN, MAX 를 모두 가져오려고 한다면 FULL TABLE SCAN 이 발생.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(ORDER_DATE), <span class="built_in">MAX</span>(ORDER_DATE)</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 실행 계획</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  SORT AGGREGATE</span><br><span class="line">    <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span></span><br></pre></td></tr></table></figure>
<p>MIN, MAX를 하나씩 조회할 때 처럼 따로따로 가져오기 위해서는 아래처럼 쿼리를 작성해야 함.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(ORDER_DATE), <span class="built_in">MAX</span>(ORDER_DATE)</span><br><span class="line">  <span class="keyword">FROM</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(ORDER_DATE) ORDER_DATE</span><br><span class="line">          <span class="keyword">FROM</span> ORDERS</span><br><span class="line">         <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">        <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(ORDER_DATE)</span><br><span class="line">          <span class="keyword">FROM</span> ORDERS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 실행 계획</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  SORT AGGREGATE</span><br><span class="line">    <span class="keyword">VIEW</span></span><br><span class="line">      <span class="keyword">UNION</span><span class="operator">-</span><span class="keyword">ALL</span></span><br><span class="line">        SORT AGGREGATE</span><br><span class="line">          INDEX <span class="keyword">FULL</span> SCAN (MIN<span class="operator">/</span>MAX)</span><br><span class="line">        SORT AGGREGATE</span><br><span class="line">          INDEX <span class="keyword">FULL</span> SCAN (MIN<span class="operator">/</span>MAX)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-12-INDEX-FAST-FULL-SCAN"><a href="#4-12-INDEX-FAST-FULL-SCAN" class="headerlink" title="4.12 INDEX FAST FULL SCAN"></a>4.12 INDEX FAST FULL SCAN</h3><p>인덱스 테이블의 모든 스캔방법이 순차적이지는 않은데. 바로 INDEX FAST FULL SCAN 방법이 FULL TABLE SCAN 과 동일하게 MULTI BLOCK I/O를 지원한다.<br>다만 이 방식이 동작하기 위해서는 INDEX 컬럼 외에 테이블 컬럼이 SQL에 포함되어 있으면 안된다.</p>
<p>내 생각에는 조건만 성립한다면 가장 빠른 조회 방법이지 않을까 싶다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IX_ORDERS_N3 : ORDER_STATUS, ORDER_MODE, EMPLOYEE_ID, ORDER_DATE</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> TO_CHAR(ORDER_DATE, <span class="string">&#x27;YYYYMM&#x27;</span>) YYYYMM,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) CNT</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS</span><br><span class="line"> <span class="keyword">WHERE</span> ORDER_MODE <span class="operator">=</span> <span class="string">&#x27;online&#x27;</span></span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> TO_CHAR(ORDER_DATE, <span class="string">&#x27;YYYYMM&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 실행 계획</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  HASH <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    INDEX FAST <span class="keyword">FULL</span> SCAN   </span><br></pre></td></tr></table></figure>
<p>테이블 사이즈 보다 인덱스 사이즈가 일반적으로 작으니까 FULL TABLE SCAN 보다 INDEX FAST FULL SCAN 방법이 더 빠를거다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 실행 계획</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  SORT AGGREGATE</span><br><span class="line">    <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span></span><br></pre></td></tr></table></figure>
<p>위 쿼리의 경우 단순 COUNT 하는 것이기 때문에 컬럼 중에 인덱스가 걸린 컬럼만 조회해서 INDEX FAST FULL SCAN을 하면 보다 더 빠를 것 같은데.<br>실제로 동작한 OPERATION을 보면 TABLE ACCESS FULL이 동작되었다. 이는 NULL 값과 관련이 있다.</p>
<p>인덱스를 추가하거나 변경하는 것은 그 테이블을 참조하는 다른 SQL들의 실행 계획이 변경되어 성능에 영향이 갈 수 있기 때문에 쉬운 것은 아님을 알아야 한다.</p>
<h3 id="4-13-INDEX-COMBINATION"><a href="#4-13-INDEX-COMBINATION" class="headerlink" title="4.13 INDEX COMBINATION"></a>4.13 INDEX COMBINATION</h3><p>한 테이블에 여러 인덱스가 있을 때 인덱스를 조합해서 사용할 수 있는 형태를 말한다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">IX_SALES_N1 : CUSTOMER_ID, ORDER_DATE</span><br><span class="line">IX_SALES_N2 : EMPLOYEE_ID, ORDER_DATE</span><br><span class="line">IX_SALES_N3 : PRODUCT_ID, ORDER_DATE</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX_COMBILE(A IX_SALES_N3 IX_SALES_N2) */</span></span><br><span class="line">       ORDER_DATE, CUSTOMER_ID, ORDER_QTY, ORDER_AMT</span><br><span class="line">  <span class="keyword">FROM</span> SALES A</span><br><span class="line"> <span class="keyword">WHERE</span> (PRODUCT_ID <span class="operator">=</span> <span class="string">&#x27;P246&#x27;</span> <span class="keyword">AND</span> EMPLOYEE_ID <span class="operator">=</span> <span class="string">&#x27;E412&#x27;</span>)</span><br><span class="line">   <span class="keyword">AND</span> ORDER_DATE <span class="operator">&gt;=</span> <span class="string">&#x27;20210101&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> ORDER_DATE <span class="operator">&lt;</span> <span class="string">&#x27;20120601&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 실행 계획</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID</span><br><span class="line">    BITMAP CONVERSION <span class="keyword">TO</span> ROWIDS</span><br><span class="line">      BITMAP <span class="keyword">AND</span></span><br><span class="line">        BITMAP CONVERSION <span class="keyword">FROM</span> ROWIDS</span><br><span class="line">          SORT <span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">            INDEX <span class="keyword">RANGE</span> SCAN</span><br><span class="line">        BITMAP CONVERSION <span class="keyword">FROM</span> ROWIDS</span><br><span class="line">          SORT <span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">            INDX <span class="keyword">RANGE</span> SCAN</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-14-INDEX-JOIN"><a href="#4-14-INDEX-JOIN" class="headerlink" title="4.14 INDEX JOIN"></a>4.14 INDEX JOIN</h3><p>INDEX JOIN은 INDEX 끼리 JOIN 되는 형태이며 HASH JOIN 형태로 동작한다. 동작하기 위해서는 SELECT 절에 있는 모든 컬럼과 WHERE 절에 있는 모든 컬럼들이<br>INDEX 컬럼이여야 한다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IX_SALES_N1 : CUSTOMER_ID, ORDER_DATE</span><br><span class="line">IX_SALES_N2 : EMPLOYEE_ID, ORDER_DATE</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX_JOIN(A) */</span></span><br><span class="line">       ORDER_DATE, EMPLOYEE_ID, CUSTOMER_ID</span><br><span class="line">  <span class="keyword">FROM</span> SALES A</span><br><span class="line"> <span class="keyword">WHERE</span> (EMPLOYEE_ID <span class="operator">=</span> <span class="string">&#x27;E412&#x27;</span> <span class="keyword">AND</span> CUSTOMER_ID <span class="operator">=</span> <span class="string">&#x27;C03107&#x27;</span>)</span><br><span class="line">   <span class="keyword">AND</span> ORDER_DATE <span class="operator">&gt;=</span> <span class="string">&#x27;20120101&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> ORDER_DATE <span class="operator">&lt;</span> <span class="string">&#x27;20120601&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 실행 계획</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  <span class="keyword">VIEW</span></span><br><span class="line">    HASH <span class="keyword">JOIN</span></span><br><span class="line">      INDEX <span class="keyword">RANGE</span> SCAN    <span class="operator">|</span>   IX_SALES_N1</span><br><span class="line">      INDEX <span class="keyword">RANGE</span> SCAN    <span class="operator">|</span>   IX_SALES_N2</span><br></pre></td></tr></table></figure>
<h3 id="5-1-NESTED-LOOP-JOIN"><a href="#5-1-NESTED-LOOP-JOIN" class="headerlink" title="5.1 NESTED LOOP JOIN"></a>5.1 NESTED LOOP JOIN</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TAB1.COL2, TAB2.COL3, TAB3.COL4</span><br><span class="line">  <span class="keyword">FROM</span> TAB1, TAB2, TAB3</span><br><span class="line"> <span class="keyword">WHERE</span> TAB1.COL1 <span class="operator">=</span> TAB2.COL1</span><br><span class="line">   <span class="keyword">AND</span> TAB2.COL2 <span class="operator">=</span> TAB3.COL3</span><br><span class="line">   <span class="keyword">AND</span> TAB1.COL1 <span class="keyword">BETWEEN</span> VALUES1 <span class="keyword">AND</span> VALUES2 </span><br></pre></td></tr></table></figure>
<p>NL 방식의 특징은 아래와 같다.</p>
<p>먼저 수행되는 선행 테이블의 처리 결과 만큼 후행 테이블 작업이 반복되기 때문에 선행 테이블의 작업량이 전체 작업량을 좌우 한다.</p>
<p>선행 테이블의 결과 만들어진 셋이 후행 테이블에 상수 값으로 제공된다.</p>
<p>후행 테이블은 동일한 테이블을 선행 테이블의 결과 만큼 지속 반복함으로 인덱스가 존재해야 한다. 그렇지 않다면 그 반복 수 만큼 FULL TABLE SCAN을 하게 됨으로<br>성능에 매우 좋지 않다.</p>
<p>주로 처리해야하는 데이터가 적은 OLTP 서비스에서 주로 이용된다.</p>
<ul>
<li>INDEX SCAN 에서 가장 큰 부하 부분이 RANDOM SINGLE BLOCK I/O 부분이다. 따라서 대량 데이터 SCAN 시에는 INDEX SCAN이 불리하다고 언급함.</li>
</ul>
<p>NESTED LOOP JOIN 은 OLTP에서 부분적인 데이터를 보여줄 때 유용하다. 대용량 BATCH 프로그램에서 사용시에는 성능이 많이 저하된다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ LEADING(B A) USE_NL(A) */</span></span><br><span class="line">       A.EMPLOYEE_ID, A.LAST_NAME, B.DEPARTMENT_NAME</span><br><span class="line">  <span class="keyword">FROM</span> EMPLOYEES A, DEPARTMENTS B</span><br><span class="line"> <span class="keyword">WHERE</span> A.DEPARTMENT_ID <span class="operator">=</span> B.DEPARTMENT_ID; </span><br></pre></td></tr></table></figure>
<p>위 SQL은 LEADING(B A) 로 명시되어 있으믕로 DEPARTMENTS 테이블이 선행테이블로, 그리고 EMPLOYEES 테이블이 후행테이블로 조인된다.</p>
<p>DEPARTMENT 테이블에서 먼저 SCAN 작업이 이루어지고, “ WHERE A.DEPARTMENT_ID = ‘D001’ “ 의 형태로 상수값으로 바뀌어서 후행 테이블의 SCAN 이 동작된다.<br>여기서 EMPLOYEES 테이블에 DEPARTMENT_ID 에 대한 인덱스가 안걸려있다면 매번 FULL TABLE SCAN을 해야함으로 성능에 좋지 않다.</p>
<p>NL의 3가지 방식. - 기본 방식, PREFETCH 방식, BATCHING 방식 이건 좀 어렵다 ㅠㅠ.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.ORDER_ID, A.ORDER_STATUS, A.EMPLOYEE_ID, </span><br><span class="line">       B.PRODUCT_ID, B.QUANTITY</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS A,</span><br><span class="line">       ORDER_ITEMS B</span><br><span class="line"> <span class="keyword">WHERE</span> A.ORDER_ID <span class="operator">=</span> B.ORDER_ID</span><br><span class="line">   <span class="keyword">AND</span> A.ORDER_DATE <span class="operator">&gt;=</span> TO_DATE(<span class="string">&#x27;2012010100&#x27;</span>, <span class="string">&#x27;YYYYMMDDHH24&#x27;</span>)</span><br><span class="line">   <span class="keyword">AND</span> A.ORDER_DATE <span class="operator">&lt;</span> TO_DATE(<span class="string">&#x27;2012010101&#x27;</span>, <span class="string">&#x27;YYYYMMDDHH24&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 실행 계획 (기본 방식)</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  NESTED LOOPS</span><br><span class="line">    <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID     <span class="operator">|</span>   ORDERS</span><br><span class="line">      INDEX <span class="keyword">RANGE</span> SCAN              <span class="operator">|</span>   IX_ORDES_N1</span><br><span class="line">    <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID     <span class="operator">|</span>   ORDER_ITEMS</span><br><span class="line">      INDEX <span class="keyword">RANGE</span> SCAN              <span class="operator">|</span>   IX_ORDER_ITEMS_PK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 실행 계획 (PREFETCH 방식)</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID</span><br><span class="line">    NESTED LOOPS</span><br><span class="line">      <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID</span><br><span class="line">        INDEX <span class="keyword">RANGE</span> SCAN</span><br><span class="line">      INDEX <span class="keyword">RANGE</span> SCAN      </span><br></pre></td></tr></table></figure>
<p>IX_ORDER_ITEMS_PK 보면 후행테이블이 기본적으로 PK 인덱스를 사용함을 알 수 있다. FULL TABLE SCAN 이 정말 성능에 안좋다는 것을 암시하는 부분.</p>
<h3 id="5-2-HASH-JOIN"><a href="#5-2-HASH-JOIN" class="headerlink" title="5.2 HASH JOIN"></a>5.2 HASH JOIN</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ USE_HASH(A B)*/</span></span><br><span class="line">       A.ORDER_DATE A.EMPLOYEE_ID, A.CUSTOMER_ID,</span><br><span class="line">       B.UNIT_PRICE <span class="operator">*</span> B.QUANTITY SALES_AMT</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS A, ORDER_ITEMS B</span><br><span class="line"> <span class="keyword">WHERE</span> A.ORDER_ID <span class="operator">=</span> B.ORDER_ID</span><br><span class="line">   <span class="keyword">AND</span> A.ORDER_DATE <span class="operator">&gt;=</span> TO_DATE(<span class="string">&#x27;20120701&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line">   <span class="keyword">AND</span> A.ORDER_DATE <span class="operator">&lt;</span> TO_DATE(<span class="string">&#x27;20120702&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line">   <span class="keyword">AND</span> B.ORDER_DATE <span class="operator">&gt;=</span> TO_DATE(<span class="string">&#x27;20120701&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line">   <span class="keyword">AND</span> B.ORDER_DATE , TO_DATE(<span class="string">&#x27;20120702&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 실행 계획</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  HASH <span class="keyword">JOIN</span></span><br><span class="line">    <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID</span><br><span class="line">      INDEX <span class="keyword">RANGE</span> SCAN</span><br><span class="line">    <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID</span><br><span class="line">      INDEX <span class="keyword">RANGE</span> SCAN   </span><br></pre></td></tr></table></figure>
<p>선행 테이블인 ORDERS를 PGA 메모리에 HASH TABLE로 생성 후에 후행 테이블 ORDER_ITEMS를 SCAN하면서 PGA에서 컬럼 매핑하는 방식으로 수행.</p>
<p>조인조건이 equal인 경우에만 가능.</p>
<p>선행 테이블의 데이터가 소량일 때 성능이 극대화된다. 적은 SIZE의 테이블이 HASH TABLE로 생성되어야 한다.</p>
<p>메모리 내에서 수행될 때 빠른 속도를 보장하지만 이 메모리 사이즈를 초과하게 되면 디스크와 계속 SWAPPING을 해야하기 때문에 성능이 저하된다.</p>
<p>NL에 비해 상대적으로 CPU 사용량과 메모리 사용량이 높다.</p>
<p>배치처리, 테이블 FULL SCAN 시 유리하다.</p>
<p>OLTP 처리시 CPU 자원을 많이 사용할수 잇으니 주의해야 한다.</p>
<p>JOIN KEY의 중복이 많을수록 HASH KEY 충돌로 성능이 저한된다. 해시 충돌을 줄여야 한다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ LEADING(A B C) USE_HASH(A B C) </span></span><br><span class="line"><span class="comment">           NO_SWAP_JOIN_INPUTS(C) */</span></span><br><span class="line">       B.JOB_ID, C.GENDER,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) ORDER_CNT,</span><br><span class="line">       <span class="built_in">SUM</span>(ORDER_TOTAL) ORDER_AMT</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS A, EMPLOYEES B, CUSTOMERS C</span><br><span class="line"> <span class="keyword">WHERE</span> A.EMPLOYEE_ID <span class="operator">=</span> B.EMPLOYEE_ID</span><br><span class="line">   <span class="keyword">AND</span> A.CUSTOMER_ID <span class="operator">=</span> C.CUSTOMER_ID</span><br><span class="line">   <span class="keyword">AND</span> A.ORDER_DATE <span class="operator">&gt;=</span> TO_DATE(<span class="string">&#x27;20120101&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line">   <span class="keyword">AND</span> A.ORDER_DATE <span class="operator">&lt;</span> TO_DATE(<span class="string">&#x27;20121101&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> B.JOB_ID, C.GENDER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 실행 계획</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  HASH <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    HASH <span class="keyword">JOIN</span></span><br><span class="line">      HASH <span class="keyword">JOIN</span></span><br><span class="line">        <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span>      <span class="operator">|</span>   ORDERS</span><br><span class="line">        <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span>      <span class="operator">|</span>   EMPLOYEES</span><br><span class="line">      <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span>        <span class="operator">|</span>   CUSTOMERS</span><br></pre></td></tr></table></figure>
<p>HASH TABLE의 목적으로 생성되는 테이블을 BUILD INPUT 이라고 한다</p>
<p>위 테이블은 A -&gt; B -&gt; C 순서로 조인을 하고 있는데. 만약 A의 테이블 결과가 상대적으로 많다면. 이 A 테이블을 PGA 메모리에 올려두고 해쉬 테이블을 만들기 때문에.<br>메모리 사용량이 많을 수 밖에 없다. 그래서 이럴때에는 상대적으로 더 적은 결과가 도출되는 테이블을 먼저 선행 테이블 처리하는 것이 좋다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ LEADING(B A C) USE_HASH(A B C) </span></span><br><span class="line"><span class="comment">           SWAP_JOIN_INPUTS(C)  */</span></span><br><span class="line">       B.JOB_ID, C.GENDER, <span class="built_in">COUNT</span>(<span class="operator">*</span>) ORDER_CNT, <span class="built_in">SUM</span>(ORDER_TOTAL) ORDER_AMT</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS A, EMPLOYEES B, CUSTOMERS C</span><br><span class="line"> <span class="keyword">WHERE</span> A.EMPLOYEE_ID <span class="operator">=</span> B.EMPLOYEE_ID</span><br><span class="line">   <span class="keyword">AND</span> A.CUSTOMER_ID <span class="operator">=</span> C.CUSTOMER_ID</span><br><span class="line">   <span class="keyword">AND</span> A.ORDER_DATE <span class="operator">&gt;=</span> TO_DATE(<span class="string">&#x27;20120101&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line">   <span class="keyword">AND</span> A.ORDER_DATE <span class="operator">&lt;</span> TO_DATE(<span class="string">&#x27;20121101&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> B.JOB_ID, C.GENDER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 실행 계획.</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  HASH <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    HASH <span class="keyword">JOIN</span></span><br><span class="line">      <span class="keyword">TABLE</span> ACCESES <span class="keyword">FULL</span>        <span class="operator">|</span> CUSTOMERS</span><br><span class="line">      HASH <span class="keyword">JOIN</span></span><br><span class="line">        <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span>       <span class="operator">|</span> EMPLOYEES</span><br><span class="line">        <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span>       <span class="operator">|</span> ORDERS</span><br></pre></td></tr></table></figure>
<p>힌트문을 적용하지 않아도 OPTIMIZER가 알아서 더 좋은 성능을 위해 위처럼 테이블 SWAP을 했을 것이다.</p>
<p>보면 B -&gt; A -&gt; C 순서로 선행 테이블이 보다 작은 테이블이 되도록 하여 PGA 메모리 사용률을 줄였다.</p>
<p>SWAP_JOIN_INPUTS(C) 힌트문으로 인해서 C에 해당하는 CUSTOMER 테이블이 BUILD INPUT(해시 테이블) 로 생성이 되었다.</p>
<p>동작 과정을 서술하면 아래와 같다.</p>
<ol>
<li>CUSTOMERS를 HASH TABLE로 생성 (SWAP_JOIN_INPUTS(C))</li>
<li>EMPLOYEES를 HASH TABLE로 생성 (LEADING(B))</li>
<li>ORDERS를 SCAN하면서 2번에 생성한 HASH TABLE SCAN</li>
<li>3번 결과가 SCAN되면서 1번에서 생성한 HASH TABLE SCAN.</li>
</ol>
<p>XPLAN에서 Used-Mem 부분 중 괄호 안에 숫자가 (1) 로 전시된다면 그것은 PGA 메모리가 모자라서 DISK SWAPPING이 발생했다는 의미이다.<br>(0) - Optimal<br>(1) - One Pass<br>(2) - Multi Pass</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SWAP_JOIN_INPUTS(D) -&gt; D 에 해당하는 테이블을 해시 테이블로 먼저 넣겠다는 의미. 선행테이블로 쓰이게 된다.</span><br><span class="line">LEADING(C A B D E) -&gt; C -&gt; A -&gt; B -&gt; D -&gt; E 순서로 해시 조인하게 된다.</span><br></pre></td></tr></table></figure>
<h3 id="5-3-SORT-MERGE-JOIN"><a href="#5-3-SORT-MERGE-JOIN" class="headerlink" title="5.3 SORT MERGE JOIN"></a>5.3 SORT MERGE JOIN</h3><p>JOIN 하고자 하는 두 테이블의 JOIN COLUMN 값으로 각각 SORT를 한 후에 정렬된 컬럼값을 비교하면서 조인하는 방식.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ USE_MERGE(A B) */</span></span><br><span class="line">       A.ORDER_DATE, A.EMPLOYEE_ID, A.CUSTOMER_ID, B.PRODUCT_ID</span><br><span class="line">       B.UNIT_PRICE <span class="operator">*</span> B.QUANTITY SALES_AMT</span><br><span class="line">  <span class="keyword">FROM</span> ORDERS A,</span><br><span class="line">       ORDER_ITEMS B</span><br><span class="line"> <span class="keyword">WHERE</span> A.ORDER_ID <span class="operator">=</span> B.ORDER_ID</span><br><span class="line">   <span class="keyword">AND</span> A.ORDER_DATE <span class="operator">&gt;=</span> TO_DATE(<span class="string">&#x27;20120701&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line">   <span class="keyword">AND</span> A.ORDER_DATE <span class="operator">&lt;</span> TO_DATE(<span class="string">&#x27;20120702&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line">   <span class="keyword">AND</span> B.ORDER_DATE <span class="operator">&gt;=</span> TO_DATE(<span class="string">&#x27;20120701&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)</span><br><span class="line">   <span class="keyword">AND</span> B.ORDER_DATE <span class="operator">&lt;</span> TO_DATE(<span class="string">&#x27;20120702&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--- 실행 계획</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT</span><br><span class="line">  <span class="keyword">MERGE</span> <span class="keyword">JOIN</span></span><br><span class="line">    SORT <span class="keyword">JOIN</span></span><br><span class="line">      <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID       <span class="operator">|</span>   ORDERS</span><br><span class="line">        INDEX <span class="keyword">RANGE</span> SCAN                <span class="operator">|</span>   IX_ORDERS_N1</span><br><span class="line">    SORT <span class="keyword">JOIN</span></span><br><span class="line">      <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID       <span class="operator">|</span>   ORDER_ITEMS</span><br><span class="line">        INDEX <span class="keyword">RANGE</span> SCAN                <span class="operator">|</span>   IX_ORDER_ITEMS_N1</span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">SORT가 발생하기 때문에 PGA 메모리를 사용. SORT 시 PGA 메모리 사용량이 사이즈를 초과하게 되면 DISK SWAPPING이 발생.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 실장님의 가르침</span><br><span class="line"></span><br><span class="line">인덱스 스킵스캔을 타는 것은 결국 인덱스 설정이 적절하지 않는다는 의미이기 때문에 다시한번 재고 해봐야 한다.</span><br><span class="line"></span><br><span class="line">nested loop <span class="keyword">join</span> 방법은 <span class="keyword">outer</span> <span class="keyword">table</span>, <span class="keyword">inner</span> <span class="keyword">table</span> 둘다 디스크에 존재하며 <span class="keyword">outer</span> <span class="keyword">table</span>이 루프를 돌면서 <span class="keyword">inner</span> <span class="keyword">table</span>을 조인한다.</span><br><span class="line"></span><br><span class="line">hash <span class="keyword">join</span> 방법은 <span class="keyword">inner</span> <span class="keyword">table</span> 을 메모리에 올려두고 조인하기 때문에 보다 더 빠르다.</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">table</span>을 메모리에 올린다의 전제조건은 <span class="keyword">inner</span> <span class="keyword">table</span>을 <span class="keyword">full</span>로 사용할 경우이다.</span><br><span class="line"></span><br><span class="line">ctrl <span class="operator">+</span> e <span class="operator">-</span><span class="operator">&gt;</span> 실행계획이 보인다.</span><br><span class="line"></span><br><span class="line">```<span class="keyword">SQL</span></span><br><span class="line"><span class="comment">/*+ use_hash(aa, bb) */</span></span><br></pre></td></tr></table></figure>
<p>이 방법을 쓰면 HASH JOIN을 한다.</p>
<p>쿼리를 짤때에는 기본적으로 인덱스를 확인해야 한다. full 스캔이 나오면 안된다.</p>
<p>인덱스 컬럼을 가공 시 해당 컬럼을 인덱스로 사용이 안되는데 조인되는 테이블이 아니고 피 조인 테이블에 적용하면 가능하다.</p>
<p>실행 계획을 볼때에는 상수가 아니라 변수로 두고 해야지 더 정확하다.<br>상수가 있다면 기본적으로 오라클은 해당 데이터를 먼저 기준으로 두고 스캔한다.</p>
<p>변수 설정하는 방법 :aaa</p>
<p>스칼라 서브쿼리 vs 조인<br>만약 스칼라 서브쿼리 되는 곳에 작성한 쿼리가 충분히 캐쉬를 활용할 수 있는 쿼리라면 사용해도 좋지만 그렇지 않다면 그런 쿼리는 좋지 않다.<br>대신 조인을 써라.</p>
<p>CASE 키워드 보다는 DECODE 키워드가 좀더 빠르다. 구문을 파싱하는 작업이 덜하다.</p>
<p>80% 이상을 가져온다고 하면 인덱스 조회보다 FULL 조회가 더 빠르다.</p>
<p>캐싱된다고 하지만 결국 이거는 메모리에 올라가는 거기 때문에 TTL이 존재하지는 않는다 다만. 다른 쿼리에 의해 올라간 데이터에 의해 밀린다.</p>
<p>HAVING 절은 SORT GROUP BY 동작이 처리되고 난 다음에 수행되기 때문에 WHERE 절 처럼 성능을 향상시키지는 않는다.</p>

        </div>
        <footer class="article-footer">
            



    <a data-url="http://kidongyun.github.io/2021/03/16/" data-id="cl3vrg7i600x5ocwb93zoao7u" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "author": {
            "@type": "Person",
            "name": "John Doe"
        },
        "headline": "oracle 튜닝하기",
        "image": "http://kidongyun.github.io",
        "keywords": "Database Oracle Tunning",
        "genre": "Devlog",
        "datePublished": "2021-03-16",
        "dateCreated": "2021-03-16",
        "dateModified": "2022-05-31",
        "url": "http://kidongyun.github.io/2021/03/16/",
        "description": "튜닝의 시작 
XPLAN을 통해서 실행 계획 일기.
12345SELECT  *FROM    HR.EMPLOYEESWHERE   EMPLOYEE_ID LIKE &#x27;2%&#x27;;SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(null, null, &#x27;ALLSTATS LAST&#x27;)); -&gt; 이거가 ",
        "wordCount": 7527
    }
</script>

</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>


    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>follow:</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="twitter" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-twitter"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="facebook" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-facebook"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="stack-overflow" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-stack-overflow"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/ppoffice/hexo-theme-hueman" target="_blank" rel="noopener">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="weibo" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-weibo"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="rss" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-rss"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2021/03/16/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">newer</strong>
        <p class="article-nav-title">
        
            TCP vs UDP
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2021/03/15/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">older</strong>
        <p class="article-nav-title">우아한 객체지향</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                

            
                
    <div class="widget-wrap">
        <h3 class="widget-title">recents</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2022/06/01/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Todo/">Todo</a></p>
                            <p class="item-title"><a href="/2022/06/01/" class="title">Todo in 2022 June</a></p>
                            <p class="item-date"><time datetime="2022-06-01T02:38:54.000Z" itemprop="datePublished">2022-06-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2022/05/21/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Devlog/">Devlog</a></p>
                            <p class="item-title"><a href="/2022/05/21/" class="title">Cheate Engine</a></p>
                            <p class="item-date"><time datetime="2022-05-21T02:38:54.000Z" itemprop="datePublished">2022-05-21</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2022/05/15/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Devlog/">Devlog</a></p>
                            <p class="item-title"><a href="/2022/05/15/" class="title">Kotest</a></p>
                            <p class="item-date"><time datetime="2022-05-15T02:38:54.000Z" itemprop="datePublished">2022-05-15</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2022/05/14/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Devlog/">Devlog</a></p>
                            <p class="item-title"><a href="/2022/05/14/" class="title">Docker build</a></p>
                            <p class="item-date"><time datetime="2022-05-14T02:38:54.000Z" itemprop="datePublished">2022-05-14</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2022/05/14/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Devlog/">Devlog</a></p>
                            <p class="item-title"><a href="/2022/05/14/" class="title">Docker Compose commands</a></p>
                            <p class="item-date"><time datetime="2022-05-14T02:38:54.000Z" itemprop="datePublished">2022-05-14</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Devlog/">Devlog</a><span class="category-list-count">217</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Service/">Service</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Todo/">Todo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Yunhwadngdng/">Yunhwadngdng</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">6</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">tags</h3>
        <div class="widget">
            <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/A-O-P/" rel="tag">A.O.P</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/API/" rel="tag">API</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AWS/" rel="tag">AWS</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ableton/" rel="tag">Ableton</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Abstract-Class/" rel="tag">Abstract Class</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Adapter-Pattern/" rel="tag">Adapter Pattern</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a><span class="tag-list-count">27</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Annotation/" rel="tag">Annotation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Blog/" rel="tag">Blog</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Brew/" rel="tag">Brew</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Builder-Pattern/" rel="tag">Builder Pattern</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CORS/" rel="tag">CORS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cache/" rel="tag">Cache</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cheat-Engine/" rel="tag">Cheat Engine</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cloud/" rel="tag">Cloud</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer-Architecture/" rel="tag">Computer Architecture</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer-Science/" rel="tag">Computer Science</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ConfigurationProperties/" rel="tag">ConfigurationProperties</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Container/" rel="tag">Container</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Controller/" rel="tag">Controller</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Css/" rel="tag">Css</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DI/" rel="tag">DI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DSL/" rel="tag">DSL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dart/" rel="tag">Dart</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/" rel="tag">Database</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Decompile/" rel="tag">Decompile</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Design-Pattern/" rel="tag">Design Pattern</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker-Compose/" rel="tag">Docker Compose</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Draft/" rel="tag">Draft</a><span class="tag-list-count">24</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DslMarker/" rel="tag">DslMarker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dto/" rel="tag">Dto</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EC2/" rel="tag">EC2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Elastic-Search/" rel="tag">Elastic Search</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Entity/" rel="tag">Entity</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Enum/" rel="tag">Enum</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Enum-Inheritance/" rel="tag">Enum Inheritance</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Excel/" rel="tag">Excel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ExceptionHandling/" rel="tag">ExceptionHandling</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/F-P/" rel="tag">F.P</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Facade-Pattern/" rel="tag">Facade Pattern</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flyweight-Pattern/" rel="tag">Flyweight Pattern</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Functional-Programming/" rel="tag">Functional Programming</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FunctionalInterface/" rel="tag">FunctionalInterface</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git-Merge/" rel="tag">Git - Merge</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git-Flow/" rel="tag">Git Flow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitlab/" rel="tag">Gitlab</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GraalVM/" rel="tag">GraalVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/" rel="tag">Gradle</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Graphql/" rel="tag">Graphql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS/" rel="tag">HTTPS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HandlerMapping/" rel="tag">HandlerMapping</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/High-Level-ElasticSearch/" rel="tag">High Level ElasticSearch</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Html/" rel="tag">Html</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Index/" rel="tag">Index</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Intellij/" rel="tag">Intellij</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interview/" rel="tag">Interview</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ionic/" rel="tag">Ionic</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JQuery/" rel="tag">JQuery</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JUnit/" rel="tag">JUnit</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JWT/" rel="tag">JWT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jackson/" rel="tag">Jackson</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jad/" rel="tag">Jad</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">44</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-O-O-P/" rel="tag">Java - O.O.P</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/" rel="tag">Javascript</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jekyll/" rel="tag">Jekyll</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jira/" rel="tag">Jira</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jmeter/" rel="tag">Jmeter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jpa/" rel="tag">Jpa</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Json/" rel="tag">Json</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Junit/" rel="tag">Junit</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Keyboard-Event/" rel="tag">Keyboard Event</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kibana/" rel="tag">Kibana</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotest/" rel="tag">Kotest</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/" rel="tag">Kotlin</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LaTeX/" rel="tag">LaTeX</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lombok/" rel="tag">Lombok</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MSA/" rel="tag">MSA</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/" rel="tag">Mac</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Machine-learning/" rel="tag">Machine learning</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Matcher/" rel="tag">Matcher</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/" rel="tag">Maven</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Memory/" rel="tag">Memory</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Message-Queue/" rel="tag">Message Queue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Monitoring/" rel="tag">Monitoring</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/" rel="tag">Mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/" rel="tag">Node</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/O-O-P/" rel="tag">O.O.P</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Object/" rel="tag">Object</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Observer-Pattern/" rel="tag">Observer Pattern</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operating-System/" rel="tag">Operating System</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/" rel="tag">Oracle</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Php/" rel="tag">Php</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Postgresql/" rel="tag">Postgresql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Process/" rel="tag">Process</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RDS/" rel="tag">RDS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Mobx/" rel="tag">React - Mobx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/" rel="tag">Reactor</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Recording/" rel="tag">Recording</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Regression/" rel="tag">Regression</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rest/" rel="tag">Rest</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Roofline/" rel="tag">Roofline</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STT/" rel="tag">STT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sentry/" rel="tag">Sentry</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Serialize/" rel="tag">Serialize</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SfDatePicker/" rel="tag">SfDatePicker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Singleton-Pattern/" rel="tag">Singleton Pattern</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a><span class="tag-list-count">56</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-API-Response/" rel="tag">Spring - API - Response</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-HttpClient/" rel="tag">Spring - HttpClient</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Batch/" rel="tag">Spring Batch</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/" rel="tag">Spring Cloud</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Security/" rel="tag">Spring Security</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stub/" rel="tag">Stub</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swagger/" rel="tag">Swagger</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TLS/" rel="tag">TLS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Telnet/" rel="tag">Telnet</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test/" rel="tag">Test</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thread/" rel="tag">Thread</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Timestamp/" rel="tag">Timestamp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Transaction/" rel="tag">Transaction</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tunning/" rel="tag">Tunning</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typescript/" rel="tag">Typescript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UDP/" rel="tag">UDP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Validation/" rel="tag">Validation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webapp/" rel="tag">Webapp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webclient/" rel="tag">Webclient</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webflux/" rel="tag">Webflux</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xml/" rel="tag">Xml</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/" rel="tag">interview</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/A-O-P/" style="font-size: 10.77px;">A.O.P</a> <a href="/tags/API/" style="font-size: 10px;">API</a> <a href="/tags/AWS/" style="font-size: 14.62px;">AWS</a> <a href="/tags/Ableton/" style="font-size: 10px;">Ableton</a> <a href="/tags/Abstract-Class/" style="font-size: 10px;">Abstract Class</a> <a href="/tags/Adapter-Pattern/" style="font-size: 10px;">Adapter Pattern</a> <a href="/tags/Algorithm/" style="font-size: 18.46px;">Algorithm</a> <a href="/tags/Android/" style="font-size: 10.77px;">Android</a> <a href="/tags/Annotation/" style="font-size: 10px;">Annotation</a> <a href="/tags/Blog/" style="font-size: 13.85px;">Blog</a> <a href="/tags/Brew/" style="font-size: 10px;">Brew</a> <a href="/tags/Builder-Pattern/" style="font-size: 10px;">Builder Pattern</a> <a href="/tags/CORS/" style="font-size: 10px;">CORS</a> <a href="/tags/Cache/" style="font-size: 10px;">Cache</a> <a href="/tags/Cheat-Engine/" style="font-size: 10px;">Cheat Engine</a> <a href="/tags/Cloud/" style="font-size: 13.08px;">Cloud</a> <a href="/tags/Computer-Architecture/" style="font-size: 10px;">Computer Architecture</a> <a href="/tags/Computer-Science/" style="font-size: 13.85px;">Computer Science</a> <a href="/tags/ConfigurationProperties/" style="font-size: 10px;">ConfigurationProperties</a> <a href="/tags/Container/" style="font-size: 10.77px;">Container</a> <a href="/tags/Controller/" style="font-size: 10.77px;">Controller</a> <a href="/tags/Css/" style="font-size: 12.31px;">Css</a> <a href="/tags/DI/" style="font-size: 10px;">DI</a> <a href="/tags/DSL/" style="font-size: 10px;">DSL</a> <a href="/tags/Dart/" style="font-size: 10.77px;">Dart</a> <a href="/tags/Database/" style="font-size: 14.62px;">Database</a> <a href="/tags/Decompile/" style="font-size: 10px;">Decompile</a> <a href="/tags/Design-Pattern/" style="font-size: 10px;">Design Pattern</a> <a href="/tags/Docker/" style="font-size: 12.31px;">Docker</a> <a href="/tags/Docker-Compose/" style="font-size: 10px;">Docker Compose</a> <a href="/tags/Draft/" style="font-size: 17.69px;">Draft</a> <a href="/tags/DslMarker/" style="font-size: 10px;">DslMarker</a> <a href="/tags/Dto/" style="font-size: 10px;">Dto</a> <a href="/tags/EC2/" style="font-size: 10px;">EC2</a> <a href="/tags/Elastic-Search/" style="font-size: 10.77px;">Elastic Search</a> <a href="/tags/ElasticSearch/" style="font-size: 10.77px;">ElasticSearch</a> <a href="/tags/Entity/" style="font-size: 10px;">Entity</a> <a href="/tags/Enum/" style="font-size: 10.77px;">Enum</a> <a href="/tags/Enum-Inheritance/" style="font-size: 10px;">Enum Inheritance</a> <a href="/tags/Excel/" style="font-size: 10px;">Excel</a> <a href="/tags/ExceptionHandling/" style="font-size: 10px;">ExceptionHandling</a> <a href="/tags/F-P/" style="font-size: 10px;">F.P</a> <a href="/tags/Facade-Pattern/" style="font-size: 10px;">Facade Pattern</a> <a href="/tags/Flutter/" style="font-size: 12.31px;">Flutter</a> <a href="/tags/Flyweight-Pattern/" style="font-size: 10px;">Flyweight Pattern</a> <a href="/tags/Functional-Programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/FunctionalInterface/" style="font-size: 10px;">FunctionalInterface</a> <a href="/tags/Git/" style="font-size: 11.54px;">Git</a> <a href="/tags/Git-Merge/" style="font-size: 10px;">Git - Merge</a> <a href="/tags/Git-Flow/" style="font-size: 10px;">Git Flow</a> <a href="/tags/Gitlab/" style="font-size: 10px;">Gitlab</a> <a href="/tags/GraalVM/" style="font-size: 10px;">GraalVM</a> <a href="/tags/Gradle/" style="font-size: 13.85px;">Gradle</a> <a href="/tags/Graphql/" style="font-size: 10px;">Graphql</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/HandlerMapping/" style="font-size: 10px;">HandlerMapping</a> <a href="/tags/Hexo/" style="font-size: 11.54px;">Hexo</a> <a href="/tags/High-Level-ElasticSearch/" style="font-size: 10px;">High Level ElasticSearch</a> <a href="/tags/Html/" style="font-size: 10px;">Html</a> <a href="/tags/Index/" style="font-size: 10px;">Index</a> <a href="/tags/Intellij/" style="font-size: 10px;">Intellij</a> <a href="/tags/Interview/" style="font-size: 10px;">Interview</a> <a href="/tags/Ionic/" style="font-size: 10px;">Ionic</a> <a href="/tags/JPA/" style="font-size: 12.31px;">JPA</a> <a href="/tags/JQuery/" style="font-size: 10px;">JQuery</a> <a href="/tags/JUnit/" style="font-size: 10px;">JUnit</a> <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Jackson/" style="font-size: 10px;">Jackson</a> <a href="/tags/Jad/" style="font-size: 10px;">Jad</a> <a href="/tags/Java/" style="font-size: 19.23px;">Java</a> <a href="/tags/Java-O-O-P/" style="font-size: 10px;">Java - O.O.P</a> <a href="/tags/Javascript/" style="font-size: 16.92px;">Javascript</a> <a href="/tags/Jekyll/" style="font-size: 12.31px;">Jekyll</a> <a href="/tags/Jira/" style="font-size: 10.77px;">Jira</a> <a href="/tags/Jmeter/" style="font-size: 10px;">Jmeter</a> <a href="/tags/Jpa/" style="font-size: 10px;">Jpa</a> <a href="/tags/Json/" style="font-size: 10px;">Json</a> <a href="/tags/Junit/" style="font-size: 10px;">Junit</a> <a href="/tags/Keyboard-Event/" style="font-size: 10px;">Keyboard Event</a> <a href="/tags/Kibana/" style="font-size: 10px;">Kibana</a> <a href="/tags/Kotest/" style="font-size: 10px;">Kotest</a> <a href="/tags/Kotlin/" style="font-size: 13.85px;">Kotlin</a> <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Lombok/" style="font-size: 10.77px;">Lombok</a> <a href="/tags/MSA/" style="font-size: 10px;">MSA</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/Machine-learning/" style="font-size: 16.15px;">Machine learning</a> <a href="/tags/Matcher/" style="font-size: 10px;">Matcher</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/Memory/" style="font-size: 10px;">Memory</a> <a href="/tags/Message-Queue/" style="font-size: 10px;">Message Queue</a> <a href="/tags/Monitoring/" style="font-size: 10px;">Monitoring</a> <a href="/tags/Mybatis/" style="font-size: 11.54px;">Mybatis</a> <a href="/tags/Mysql/" style="font-size: 10px;">Mysql</a> <a href="/tags/Network/" style="font-size: 14.62px;">Network</a> <a href="/tags/Node/" style="font-size: 11.54px;">Node</a> <a href="/tags/O-O-P/" style="font-size: 10.77px;">O.O.P</a> <a href="/tags/Object/" style="font-size: 10px;">Object</a> <a href="/tags/Observer-Pattern/" style="font-size: 10px;">Observer Pattern</a> <a href="/tags/Operating-System/" style="font-size: 10px;">Operating System</a> <a href="/tags/Oracle/" style="font-size: 10px;">Oracle</a> <a href="/tags/Php/" style="font-size: 12.31px;">Php</a> <a href="/tags/Postgresql/" style="font-size: 10px;">Postgresql</a> <a href="/tags/Process/" style="font-size: 10.77px;">Process</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/RDS/" style="font-size: 10px;">RDS</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/React/" style="font-size: 13.85px;">React</a> <a href="/tags/React-Mobx/" style="font-size: 10px;">React - Mobx</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/Recording/" style="font-size: 10px;">Recording</a> <a href="/tags/Redis/" style="font-size: 13.08px;">Redis</a> <a href="/tags/Regression/" style="font-size: 10px;">Regression</a> <a href="/tags/Rest/" style="font-size: 10px;">Rest</a> <a href="/tags/Roofline/" style="font-size: 10px;">Roofline</a> <a href="/tags/STT/" style="font-size: 10px;">STT</a> <a href="/tags/Sentry/" style="font-size: 10px;">Sentry</a> <a href="/tags/Serialize/" style="font-size: 10px;">Serialize</a> <a href="/tags/SfDatePicker/" style="font-size: 10px;">SfDatePicker</a> <a href="/tags/Singleton-Pattern/" style="font-size: 10px;">Singleton Pattern</a> <a href="/tags/Spring/" style="font-size: 20px;">Spring</a> <a href="/tags/Spring-API-Response/" style="font-size: 10px;">Spring - API - Response</a> <a href="/tags/Spring-HttpClient/" style="font-size: 10px;">Spring - HttpClient</a> <a href="/tags/Spring-Batch/" style="font-size: 10px;">Spring Batch</a> <a href="/tags/Spring-Cloud/" style="font-size: 10.77px;">Spring Cloud</a> <a href="/tags/Spring-Security/" style="font-size: 10.77px;">Spring Security</a> <a href="/tags/Stub/" style="font-size: 10px;">Stub</a> <a href="/tags/Swagger/" style="font-size: 10px;">Swagger</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/TLS/" style="font-size: 10px;">TLS</a> <a href="/tags/Telnet/" style="font-size: 10px;">Telnet</a> <a href="/tags/Test/" style="font-size: 15.38px;">Test</a> <a href="/tags/Thread/" style="font-size: 10px;">Thread</a> <a href="/tags/Timestamp/" style="font-size: 10px;">Timestamp</a> <a href="/tags/Transaction/" style="font-size: 10px;">Transaction</a> <a href="/tags/Tunning/" style="font-size: 10px;">Tunning</a> <a href="/tags/Typescript/" style="font-size: 10px;">Typescript</a> <a href="/tags/UDP/" style="font-size: 10px;">UDP</a> <a href="/tags/Validation/" style="font-size: 10px;">Validation</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/Web/" style="font-size: 10.77px;">Web</a> <a href="/tags/Webapp/" style="font-size: 10px;">Webapp</a> <a href="/tags/Webclient/" style="font-size: 10px;">Webclient</a> <a href="/tags/Webflux/" style="font-size: 10.77px;">Webflux</a> <a href="/tags/Webpack/" style="font-size: 10.77px;">Webpack</a> <a href="/tags/Xml/" style="font-size: 10.77px;">Xml</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


            
        
    </div>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2022 John Doe</p>
                
                <p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="https://github.com/ppoffice" target="_blank">PPOffice</a></p>
                
            </div>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

    </div>
    
    
    <script>
    var disqus_shortname = 'hexo-theme-hueman';
    
    
    var disqus_url = 'http://kidongyun.github.io/2021/03/16/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>





    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    

    
    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
