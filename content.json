{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://kidongyun.github.io","root":"/"},"pages":[{"title":"","date":"2022-04-15T00:49:18.047Z","updated":"2022-04-15T00:49:04.280Z","comments":true,"path":"res/2020-1-7-request-page-with-redirection/index.html","permalink":"http://kidongyun.github.io/res/2020-1-7-request-page-with-redirection/index.html","excerpt":"","text":"REDIRECT TO THE BELOW PAGE. URL Please insert the target domain address you want. Parameters encode decode Please insert the parameters as the query string type. Parameter Type GET POST Character Type UTF-8 UTF-8 euc-kr REQUEST"},{"title":"","date":"2022-04-15T00:49:18.091Z","updated":"2022-04-15T00:49:04.281Z","comments":true,"path":"res/2020-1-7-request-page-with-redirection/requestPage.css","permalink":"http://kidongyun.github.io/res/2020-1-7-request-page-with-redirection/requestPage.css","excerpt":"","text":"body { padding-top: 2%; display: flex; justify-content: center; align-items: center; background-color: #efefef; }"},{"title":"","date":"2022-04-15T00:49:18.013Z","updated":"2022-04-15T00:49:04.282Z","comments":true,"path":"res/2020-1-7-request-page-with-redirection/requestPage.js","permalink":"http://kidongyun.github.io/res/2020-1-7-request-page-with-redirection/requestPage.js","excerpt":"","text":"jQry = jQuery.noConflict(); function request() { const form = document.createElement(\"form\"); let charset = getCharset(); let parameterType = getParameterType(); let url = getUrl(); let parameters = getQueryString().split(\"&\"); form.setAttribute(\"charset\", charset); form.setAttribute(\"method\", parameterType); form.setAttribute(\"action\", url); for(let i=0; i < parameters.length; i++) { const equalIndex = parameters[i].indexOf(\"=\"); let name = parameters[i].substring(0, equalIndex); console.log(\"name : \" + name); let value = parameters[i].substring(equalIndex + 1, parameters[i].length); console.log(\"value : \" + value); let param = document.createElement(\"input\"); param.setAttribute(\"type\", \"hidden\"); param.setAttribute(\"name\", name); param.setAttribute(\"value\", value); form.appendChild(param); } document.body.appendChild(form); form.submit(); } function getUrl() { return jQry(\"#url\").val(); } function getQueryString() { return jQry(\"#parameter\").val(); } function setQueryString(queryString) { jQry(\"#parameter\").val(queryString); } function getParameterType() { if(jQry(\"#getBtn\").parents(\"label\").hasClass(\"active\") === true) return \"GET\"; if(jQry(\"#postBtn\").parents(\"label\").hasClass(\"active\") === true) return \"POST\"; } function getCharset() { return jQry(\"#charset\").html(); } function setCharset(charset) { jQry(\"#charset\").html(charset); } function encode() { setQueryString(encodeURIComponent(getQueryString())); } function decode() { setQueryString(decodeURIComponent(getQueryString())); }"}],"posts":[{"title":"2022.06","slug":"2022-05-31-todo-june-2022","date":"2022-06-01T02:38:54.000Z","updated":"2022-06-02T00:02:21.543Z","comments":true,"path":"2022/06/01/","link":"","permalink":"http://kidongyun.github.io/2022/06/01/","excerpt":"","text":"First Week Renewal My blog site Changing the concept of categories and tags in all of my posts. [O] Adding Domain page for what i searched tho tags [O] Renewal house keeping excel sheet [] Being 81.5 kg [] Doing working out Push up [0/1000] Chin up [0/500] Leg forward rasing [0/300] Eating 1500 kcal for a week. Mon [X] Tue [X] Wed [X] Thu [] Fri [] Sat [] Sun [] Making Sheetshow service. [] Building ELK Monitoring system. [] Creating one devlog article about something [] Researching about moving the house. [] Second Week Third Week Fourth Week","categories":[{"name":"Todo","slug":"Todo","permalink":"http://kidongyun.github.io/categories/Todo/"}],"tags":[]},{"title":"Cheate Engine","slug":"2022-05-21-cheat-engine","date":"2022-05-21T02:38:54.000Z","updated":"2022-06-01T07:21:07.127Z","comments":true,"path":"2022/05/21/","link":"","permalink":"http://kidongyun.github.io/2022/05/21/","excerpt":"","text":"ebook drm 걸려있는 파일에서 순수 pdf 파일 얻는 방법cheat engine 프로그램을 실행한다. 각 회사에서 제공하는 ebook 리더기 프로그램을 실행한 후 변환하려는 서적을 연다. cheat engine 에서 %PDF-1.6 검색하고 난 후 나타난 메모리 주소를 기록해두자. (검색 목록이 없는 경우 %PDF-1 까지만 검색. 버전이 다를 수도 있음) cheat engine 에서 %EOF 검색하고 난 후 나타난 메모리 주소를 기록해두자. %PDF-1.6 메모리 번지가 순수 pdf 파일의 시작 메모리 번지이고, %EOF 메모리 번지가 순수 pdf 파일의 끝 메모리 번지이다. pdf 파일의 크기를 고려해서 시작 메모리 번지와 끝 메모리 번지의 차이 값이 파일 크기가 유사한 메모리 번지 쌍을 후보 군으로 고려한다. 해당 메모리 번지만큼 스캔해서 cem 파일로 export 하고 난 후 pdf 변환해서 정상적으로 열리는지 확인한다. 열리지 않는다면 다른 후보군을 고려해본다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Cheat Engine","slug":"Cheat-Engine","permalink":"http://kidongyun.github.io/tags/Cheat-Engine/"}]},{"title":"Kotest","slug":"2022-05-15-kotest","date":"2022-05-15T02:38:54.000Z","updated":"2022-06-01T07:20:56.762Z","comments":true,"path":"2022/05/15/","link":"","permalink":"http://kidongyun.github.io/2022/05/15/","excerpt":"","text":"https://techblog.woowahan.com/5825/","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"},{"name":"Kotest","slug":"Kotest","permalink":"http://kidongyun.github.io/tags/Kotest/"}]},{"title":"Docker build","slug":"2022-05-14-docker-build","date":"2022-05-14T02:38:54.000Z","updated":"2022-06-01T07:13:00.659Z","comments":true,"path":"2022/05/14/","link":"","permalink":"http://kidongyun.github.io/2022/05/14/","excerpt":"","text":"Docker 이미지들이 기본적으로 저장되는 위치 /var/lib/docker https://pjh37.github.io/springboot/2020/08/03/springboot-11.html https://doinge-coding.tistory.com/entry/Docker-docker-compose%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-Spring-boot-Mysql-%EB%B0%B0%ED%8F%AC-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"},{"name":"Docker","slug":"Docker","permalink":"http://kidongyun.github.io/tags/Docker/"}]},{"title":"Docker Compose commands","slug":"2022-05-14-docker-compose","date":"2022-05-14T02:38:54.000Z","updated":"2022-06-01T07:19:55.434Z","comments":true,"path":"2022/05/14/","link":"","permalink":"http://kidongyun.github.io/2022/05/14/","excerpt":"","text":"https://nirsa.tistory.com/81 1번은 어떤 베이스 이미지를 사용할 지 docker-compose 안에서 선언을 해주었다면, docker-compose에서 선언하여 Dockerfile을 이용해 자동으로 docker build 후 베이스 이미지로 사용할 수 있습니다. https://nirsa.tistory.com/79 docker-compose 에서 Dockerfile 활용해서 빌드할 때 ARG 에 값 넣어주는 방법 1234build: context: . args: PROFILE: &quot;local&quot; https://docs.docker.com/compose/environment-variables/ 도커 컴포즈에 .env 파일을 생성해서 environments 전달하기 https://translate.oofbird.me/compose/environment-variables.html ENV run 시점에만 사용되는 변수환경변수 지정$변수 혹은 ${변수} 형태로 표현 가능또한, ${변수:-값}으로 값을 기본값으로 표현 가능${변수:+값}의 경우는 반대에 경우인데 사용할 일이 있을까 싶다.docker run 시에 —e 옵션을 활용하여 오버라이딩 할 수 있다. ARG build 시점에만 사용되는 변수ARG 변수 혹은 ARG 변수=값 형태로 표현 가능ENV처럼 ${변수:+값}, ${변수:-값}으로도 표현 가능docker build 시에 —build-arg 옵션을 활용하여 오버라이딩 할 수 있다. https://github.com/heowc/programming-study/issues/90","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"},{"name":"Docker","slug":"Docker","permalink":"http://kidongyun.github.io/tags/Docker/"},{"name":"Docker Compose","slug":"Docker-Compose","permalink":"http://kidongyun.github.io/tags/Docker-Compose/"}]},{"title":"How to configure to record youtube sound in ableton 10","slug":"2022-05-14-how-to-configure-to-record-youtube-in-ableton","date":"2022-05-14T02:38:54.000Z","updated":"2022-06-01T07:20:22.815Z","comments":true,"path":"2022/05/14/","link":"","permalink":"http://kidongyun.github.io/2022/05/14/","excerpt":"","text":"https://www.youtube.com/watch?v=9THnTdJ1Ti0","categories":[{"name":"Yunhwadngdng","slug":"Yunhwadngdng","permalink":"http://kidongyun.github.io/categories/Yunhwadngdng/"}],"tags":[{"name":"Ableton","slug":"Ableton","permalink":"http://kidongyun.github.io/tags/Ableton/"},{"name":"Recording","slug":"Recording","permalink":"http://kidongyun.github.io/tags/Recording/"}]},{"title":"Facade pattern...","slug":"2022-05-12-facade-pattern","date":"2022-05-12T02:38:54.000Z","updated":"2022-06-01T07:11:22.875Z","comments":true,"path":"2022/05/12/","link":"","permalink":"http://kidongyun.github.io/2022/05/12/","excerpt":"","text":"https://ko.wikipedia.org/wiki/%ED%8D%BC%EC%82%AC%EB%93%9C_%ED%8C%A8%ED%84%B4","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"},{"name":"Facade Pattern","slug":"Facade-Pattern","permalink":"http://kidongyun.github.io/tags/Facade-Pattern/"}]},{"title":"About java enum inheritance","slug":"2022-05-12-enum-inheritance","date":"2022-05-12T02:38:54.000Z","updated":"2022-06-01T07:11:25.095Z","comments":true,"path":"2022/05/12/","link":"","permalink":"http://kidongyun.github.io/2022/05/12/","excerpt":"","text":"java enum object can express the relationship of inheritance easily. the calculator enum object implements the abstract method named ‘calculate()’ as you can see the below code. the each elements in the enum object is same with the children of calculator object like PLUS, SUBTRACT, MULTIPLE And This style code also keep the encapsulation. so the consumer of this calculator enum object will use it without any information of each calculator elements. 1234567891011121314151617181920212223enum calculator &#123; PLUS &#123; @Override public int calculate(int first, int second) &#123; return first + second; &#125; &#125;, SUBTRACT &#123; @Override public int calculate(int first, int second) &#123; return first - second; &#125; &#125;, MULTIPLE &#123; @Override public int calculate(int first, int second) &#123; return first * second; &#125; &#125;, ; public abstract int calculate(int first, int second);&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Enum","slug":"Enum","permalink":"http://kidongyun.github.io/tags/Enum/"},{"name":"Enum Inheritance","slug":"Enum-Inheritance","permalink":"http://kidongyun.github.io/tags/Enum-Inheritance/"}]},{"title":"Kotlin apply also with let run...","slug":"2022-05-12-kotlin-apply-also-with-let-run","date":"2022-05-12T02:38:54.000Z","updated":"2022-06-01T07:12:00.001Z","comments":true,"path":"2022/05/12/","link":"","permalink":"http://kidongyun.github.io/2022/05/12/","excerpt":"","text":"https://medium.com/@limgyumin/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%98-apply-with-let-also-run-%EC%9D%80-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80-4a517292df29","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://kidongyun.github.io/tags/Kotlin/"}]},{"title":"Kotlin dsl marker","slug":"2022-05-12-kotlin-dslmarker","date":"2022-05-12T02:38:54.000Z","updated":"2022-06-01T07:11:53.400Z","comments":true,"path":"2022/05/12/","link":"","permalink":"http://kidongyun.github.io/2022/05/12/","excerpt":"","text":"@DslMarkerThe problemWhen using DSLs, one might have come across the problem that too many functions can be called in the context https://kotlinlang.org/docs/type-safe-builders.html#scope-control-dslmarker @SpekDsl","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://kidongyun.github.io/tags/Kotlin/"},{"name":"DslMarker","slug":"DslMarker","permalink":"http://kidongyun.github.io/tags/DslMarker/"}]},{"title":"RabbitMQ","slug":"2022-05-03-rabbitmq","date":"2022-05-03T02:38:54.000Z","updated":"2022-06-01T07:11:01.309Z","comments":true,"path":"2022/05/03/","link":"","permalink":"http://kidongyun.github.io/2022/05/03/","excerpt":"","text":"AMQPAdvanced Message Queuing Protocol 메시지 통신을 할 때 과거에는 JMS 와 같이 API 수준에서 통신을 하였지만 RabbitMQ 의 경우 SMTP, HTTP 등과 같이 프로토콜 수준에서 정의된 AMQP 를 사용하여 메시지 통신을 한다. AMQP 자체가 프로토콜을 의미하기 때문에 이 프로토콜을 구현한 MQ제품들은 여러가지가 있으며 그 중 하나가 RabbitMQ이다. Exchange4 가지 종류의 Exchange 가 있다 Direct Fanout Topic Headers https://velog.io/@hellozin/Spring-Boot%EC%99%80-RabbitMQ-%EC%B4%88%EA%B0%84%EB%8B%A8-%EC%84%A4%EB%AA%85%EC%84%9C","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"},{"name":"Message Queue","slug":"Message-Queue","permalink":"http://kidongyun.github.io/tags/Message-Queue/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://kidongyun.github.io/tags/RabbitMQ/"}]},{"title":"Multi transaction manager","slug":"2022-04-29-multi-transaction-manager","date":"2022-04-29T02:38:54.000Z","updated":"2022-06-01T07:09:46.835Z","comments":true,"path":"2022/04/29/","link":"","permalink":"http://kidongyun.github.io/2022/04/29/","excerpt":"","text":"https://supawer0728.github.io/2018/03/22/spring-multi-transaction/","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"}]},{"title":"Spring Native with graalvm","slug":"2022-04-28-spring-native-with-graalvm","date":"2022-04-28T02:38:54.000Z","updated":"2022-06-01T07:08:58.772Z","comments":true,"path":"2022/04/28/","link":"","permalink":"http://kidongyun.github.io/2022/04/28/","excerpt":"","text":"https://giljae.medium.com/spring-native-%EB%B2%A0%ED%83%80-%EC%86%8C%EA%B0%9C-767d7bf46e01","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"},{"name":"GraalVM","slug":"GraalVM","permalink":"http://kidongyun.github.io/tags/GraalVM/"}]},{"title":"Webclient","slug":"2022-04-28-webclient","date":"2022-04-28T02:38:54.000Z","updated":"2022-06-01T07:09:48.513Z","comments":true,"path":"2022/04/28/","link":"","permalink":"http://kidongyun.github.io/2022/04/28/","excerpt":"","text":"https://happycloud-lee.tistory.com/220 https://godekdls.github.io/Reactive%20Spring/webclient/ retrieve()exchange()","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"},{"name":"Webclient","slug":"Webclient","permalink":"http://kidongyun.github.io/tags/Webclient/"}]},{"title":"Configure hexo","slug":"2022-04-27-configure-hexo","date":"2022-04-27T02:38:54.000Z","updated":"2022-06-01T07:07:14.351Z","comments":true,"path":"2022/04/27/","link":"","permalink":"http://kidongyun.github.io/2022/04/27/","excerpt":"","text":"Configuring Hexo Blog1234567891011&gt; yarn global add hexo-cli&gt; hexo init devlog&gt; cd devlog&gt; npm install&gt; yarn&gt; hexo server and then you can see the blog page if you access to localhost:4000 at the browser Connecting with git remote repository1&gt; npm install --save hexo-deployer-git change the _config.yml file in your hexo project follow the below code 123456// _config.ymldeploy: type: git repo: https://github.com/kidongYun/kidongYun.github.io.git branch: master 1&gt; hexo deploy --generate Install the theme pluginexecute the below command in your hexo project 1&gt; git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman change the file name is in the theme folder from _config.yml.exmaple -&gt; _config.yml.i mean the ‘example’ in the file name should be deleted. change the theme option in the _config.yml file 123// _config.ymltheme: hueman Apply search function1&gt; npm install -S hexo-generator-json-content Apply LaTeXhexo renderer 이게 JAVASCRIPT 를 Markdown 으로 바꿔주는 모듈이라고 하는데 그걸 default로 쓰이는 것 말고 따른걸ㄹ ㅗ바꿔야 하나봐. 123&gt; npm uninstall hexo-renderer-marked --save&gt; npm install hexo-renderer-kramed --save “/node_modules/hexo-renderer-kramed/lib/renderer.js” 여기로 가서 12345// Change inline math rulefunction formatText(text) &#123; // Fit kramed&#x27;s rule: $$ + \\1 + $$ return text.replace(/`\\$(.*?)\\$`/g, &#x27;$$$$$1$$$$&#x27;);&#125; 이부분을 1234// Change inline math rulefunction formatText(text) &#123; return text;&#125; 이렇게 변경 hexo-math 라이브러리가 이제 지원되지 안흔다고 함 이거를 제거 1&gt; npm uninstall hexo-math --save 대신에 아래 라이브러리를 설치 1&gt; npm install hexo-renderer-mathjax --save CDN 서비스를 더이상 mathjax 자체적으로는 제공하지 않는다고 함. 그래서 아래 경로에 있는 파일에서 cdn 경로를 cloudfare 로 변경. /node_modules/hexo-renderer-mathjax/mathjax.html 1&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt; 설정은 끝났고 mathjax 를 쓰고 싶다면 post header 부분에 아래처럼 mathjax: true 설정을 넣어주면 된다. 123456---title: Testing Mathjax with Hexocategory: Uncategorizeddate: 2017/05/03mathjax: true---","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://kidongyun.github.io/tags/Hexo/"},{"name":"LaTeX","slug":"LaTeX","permalink":"http://kidongyun.github.io/tags/LaTeX/"}]},{"title":"Cross Origin / Same Origin","slug":"2022-04-22-cross-origin-same-origin","date":"2022-04-22T02:38:54.000Z","updated":"2022-06-01T07:05:21.097Z","comments":true,"path":"2022/04/22/","link":"","permalink":"http://kidongyun.github.io/2022/04/22/","excerpt":"","text":"CROSS ORIGIN / SAME ORIGIN이는 HTTP 요청에 대해서 어떤 요청을 하느냐에 따라 각기 다른 특징을 가지고 있기 때문이다. HTML → 기본적으로 Cross-Origin 정책을 따름link 태그에서 다른 origin의 css 등의 리소스에 접근하는 것이 가능img 태그등에서 다른 리소스에 접근하는 것이 가능 XMLHttpRequest, Fetch API 등 script 태그 내 → 기본적으로 Same-Origin 정책을 따름자바스크립트는 서로 다른 도메인에 대한 요청을 보안상 제한한다. (브라우저 기본 설정은 하나의 서버 연결만 허용)이 정책을 Same-Origin-Policy라고 한다. CORSCORS (Cross-Origin Resource Sharing) &lt;교차&amp;다른 출처 리소스 공유&gt;교차 출처 리소스 공유(Cross-Origin Resource Sharing, CORS)는, 추가 HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제다. 즉, 위에서 시뻘겋게 CORS 어쩌구 에러는 CORS를 허용해서 아무런 탈 없이 다른 출처 리소스 공유를 해달라는 권고 사항 같은 것이라 볼 수 있다. 웹 애플리케이션은 리소스가 자신의 출처(도메인, 프로토콜, 포트)와 다를 때 교차 출처 HTTP 요청을 실행하게 된다. #HTTP 요청에 대해서 HTML은 기본적으로 Cross-Origin 요청이 가능하다. 왜냐하면 HTML은 Cross-Origin 정책을 따르기 때문이다. 예컨데 HTML에서 link 태그에서 다른 origin의 css 등의 리소스에 접근하는 것이 가능하며, img 태그에서 다른 jpg, png 등의 리소스에 접근하는 것이 가능하다. 그러나 script 태그 내에 있는 HTTP 요청(XmlHttpRequest, Fetch Api)에 대해서는 기본적으로 Same-Origin 정책을 따르고 있기 때문에 Cross-Origin 요청이 불가능하다. 그 이유는 보안상의 이슈라고 하는데, 아무리 검색해봐도 안나와서 일단 넘어가도록 하자.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://kidongyun.github.io/tags/Web/"},{"name":"CORS","slug":"CORS","permalink":"http://kidongyun.github.io/tags/CORS/"}]},{"title":"Webflux","slug":"2022-04-11-webflux","date":"2022-04-11T02:38:54.000Z","updated":"2022-06-01T07:04:44.458Z","comments":true,"path":"2022/04/11/","link":"","permalink":"http://kidongyun.github.io/2022/04/11/","excerpt":"","text":"Reative StreamsRxJava 와 같은 리액티브 라이브러리는 마이크로소프트 사에서 맨 처음에 그 생태계를 구축했는데, 이 후에 Reactive Streams 라는 리액티브 프로그래밍을 위한 표준 명세가 나오면서 지금은 Project Reactor 와 같은 그 기반에 다양한 구현체들이 등장하였다. a standardization for Java emerged through the Reactive Streams effort, a specification that defines a set of interfaces and interaction rules for reactive libraries on the JVM Webflux 의존성1implementation &#x27;org.springframework.boot:spring-boot-starter-webflux&#x27; ServerRequestWebflux 프로젝트에서 REST API 요청, 응답 객체를 ServerRequest, ServerResponse 를 통상적으로 사용하는 것 같다. 이 객체를 사용하면서 PathVariable 등과 같이 기존에는 어노테이션을 활용해서 값을 가져오는 방법들이 다소 달라진다.어려운 내용은 아니고 단지 사용 방법이 변경된 것이기 때문에 필요한 부분이 있을 때 마다 검색해서 사용해도 이슈 없을 듯. 쿼리스트링 값 가져오기 PathVariable 값 가져오기 RouterFunction route(RequestPredicate predicate, HandlerFunction handlerFunction)Spring RouterFunction is a functional interface with route functional method. The role of RouterFunction is routing incoming requests to specified handler function. 라우터와 핸들러를 매핑해주는 route() 함수는 두개의 파라미터를 받는데 첫번째 requestPredicate 에서 어떤 요청 정보를 매핑시켜줄지 결정할 수 있다. 가령 요청으로 들어오는 url path, http header 정보들 등이 있다. 두번째 파라미터인 HandlerFunction 에서 실제 작업이 이루어지는 handler 부분을 넣어주는데 이 HandlerFunction 함수 시그니처는 아래와 같다. HandlerFunction1234@FunctionalInterfacepublic interface HandlerFunction&lt;T extends ServerResponse&gt; &#123; Mono&lt;T&gt; handle(ServerRequest request);&#125; 이를 보면 알 수 있듯이, 요청 타입은 ServerRequest, 응답 타입은 ServerResponse 로 제한되어 있다. 즉 웹플럭스를 사용하게되면 REST API 부분에서 사용하게 될 요청 응답 객체로 ServerRequest, ServerResponse 가 필수 임을 알 수 있다. HandlderFunction 을 보면 리턴 타입이 Mono 로 되어있는데 왜 Mono 타입으로만 제한되어 제공이 될까? (왜 Flux 타입으로 REST 응답이 내려가지 않을까??) -&gt; REST API 에서는 최종적으로 Mono 타입으로만 내려간다. (HTTP 프로토콜의 한계가 아닐까?) ReactiveCrudRepository아직 JDBC 드라이버가 비동기 코드를 지원하지 않아 이부분은 아직까진 어쩔 수 없긴 합니다.MongoDB나 Redis처럼 비동기 client를 사용하는 NoSQL들은 현재 Reactive용 Repository를 따로 사용할 수 있습니다. ReactiveCrudRepository 등을 이용해서 Repository단에서 바로 Flux나 Mono로 조회가 가능합니다. QuerydslPredicateExecutorQuerydsl 에 있는 Predicate 객체 (= BooleanExpression 의 상위 객체) 를 파라미터로 받아서 이 값을 기준으로 Query 를 날릴 수 있도록 Spring JPA 에서 지원해주는 것 같음. Spring JPA 에서 Querydsl 을 서포트 해주는 중간 다리 느낌의 인터페이스 QuerydslRepositorySupportquerydsl 을 활용해서 쿼리를 작성할 때 뭔가 도움을 주는 클래스 같다. from() 활용하면 select 부분 생략하고 쿼리 작성이 가능하다. delegate patternhttps://kotlinworld.com/85 Scheduler (리액터 쓰레드 스케줄링)리액터를 사용할 때 쓰레드에 관련 작업을 처리해주는 객체. 기본적으로는 단일 쓰레드로 동작하지만 Scheduler 를 활용하면 다양한 형태로 쓰레드를 사용할 수 있음. parallel(): ExecutorService기반으로 단일 스레드 고정 크기(Fixed) 스레드 풀을 사용하여 병렬 작업에 적합함.single(): Runnable을 사용하여 지연이 적은 일회성 작업에 최적화elastic(): 스레드 갯수는 무한정으로 증가할 수 있고 수행시간이 오래걸리는 블로킹 작업에 대한 대안으로 사용할 수 있게 최적화 되어있다.boundedElastic(): 스레드 갯수가 정해져있고 elastic과 동일하게 수행시간이 오래걸리는 블로킹 작업에 대한 대안으로 사용할 수 있게 최적화 되어있다.immediate(): 호출자의 스레드를 즉시 실행한다.fromExecutorService(ExecutorService) : 새로운 Excutors 인스턴스를 생성한다. 기본적으로 리액티브 스트림은 subscribe 를 하고 주고 받아야할 데이터가 계속 있다면 next() 호출, 마지막 데이터를 주고 받을 때에는 onComplete() 혹은 실패의 경우 일 때 onError() 를 던진다. 여기서 이 next() 신호를 리액터는 시퀀스가 발생하는 next 신호를 병렬로 처리할 수 있는 방법을 제공한다 Flux#parallel(int parallelism)위 메서드는 Flux가 생성하는 next 신호를 parallelism 개수만큼 라운드 로빈 방식으로 신호를 나눈다. Mono.zip()@EnableWebFlux웹플럭스를 사용하기 위해서는 Router 관련 Config 객체에 @EnableWebFlux 어노테이션을 붙여줘야 하지만, 스프링 부트에서는 이를 기본적으로 자동설정해주고 있다. 그렇기 때문에 생략 가능하다. The @EnableWebFlux enables WebFlux features for annotated controller and functional web programming model. In Spring Boot Application, @EnableWebFlux is not needed because Spring Boot autoconfigures WebFlux features. WebClientSpring WebClient is a non-blocking reactive client API that performs HTTP requests. referencehttps://www.concretepage.com/spring-5/spring-webflux-functional-endpoints https://projectreactor.io/docs/core/release/reference/ R2DBChttps://gompangs.tistory.com/entry/Spring-R2DBC-MySQL https://taes-k.github.io/2020/08/17/spring-reactive-2/ Reactive 로 사용되는 Repository 의 벤더가 무엇일까현재 데이터베이스가 리액티브 형태로 제공되는 것은 없는 것 같다.. 블로킹 DB 에서 데이터를 webflux 에서 가져올 때 별도의 스레드를 사용해서 처리하지만, save 하는 경우는 이런 처리 없이 그냥 하는 거 같음. Persistablesave의 기본 동작은 식별자가 없으면 persist, 식별자가 있으면 merge 이다. merge 는 데이터베이스에서 식별자로 조회를 해본 후 없으면 insert, 있으면 update -&gt; 이게 성능이 떨어뜨리는 요인이 된다고 함. Persistance 인터페이스를 해당 엔티티에 구현하게 되면 id 자동 할당시에 동일 성능을 유지할 수 있다. 123456789@Override public String getId() &#123; return id; &#125; @Override public boolean isNew() &#123; return createdDate == null; &#125; isNew() 에서 DB 에 저장되지 않은 새로운 엔티티를 어떻게 식별할지 재정의가 가능하다 https://yoonbing9.tistory.com/39 https://stackoverflow.com/questions/59468908/reactive-repository-throws-exception-when-saving-a-new-object sharding sphere아파치 오픈소스로 구현된 분산 DB 미들웨어 솔류션으로 3개의 독립 제품으로 구성 Sharding-JDBC Sharding-Proxy Sharding-Sidecar https://velog.io/@ette9844/Sharding-Sphere-Sharding-Sphere-%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC FluxSinkWrapper API around a downstream Subscriber for emitting any number of next signals followed by zero or one onError/onComplete. 123456789101112public Mono&lt;ServerResponse&gt; flux(ServerRequest serverRequest) &#123; Flux&lt;Integer&gt; flux = Flux.create((FluxSink&lt;Integer&gt; sink) -&gt; &#123; sink.onRequest(request -&gt; &#123; for (int i=0; i&lt;=request + 3; i++) &#123; sink.next(i); &#125; &#125;); &#125;); log.info(flux.toString()); return Mono.empty();&#125; FluxSink#onRequest(LongConsumer) 메서드의 Consumer는 Subscriber가 데이터를 요청했을 때 불린다 https://javacan.tistory.com/entry/Reactor-Start-3-RS-create-stream ServerRequest.bodyToMono1&lt;T&gt; Mono&lt;T&gt; bodyToMono(Class&lt;? extends T&gt; elementClass); Webflux 에서는 ServerRequest 로 REST 요청을 받는데 여기서 body 에 해당하는 영역을 DTO로 매핑해주고 싶을 때 사용할 수 있는 함수. Mono.map : Transform the item emitted by this Mono by applying a synchronous function to it. Mono.flatMap : Transform the item emitted by this Mono asynchronously, returning the value emitted by another Mono (possibly changing the value type). Mono.flatmapmap과 flatMap은 둘 다 스트림의 중간에 값을 변환해주는 역할을 한다.map은 1 : 1로 반환을 보증하고 flatMap은 1 : N을 변환할 수 있다. flatMap을 사용하게 되는 경우는 다음과 같다.Mono -&gt; Mono 또는 Mono -&gt; Flux로 변환이 필요한 경우 map 은 반환 값이 대상 Object이고 flatMap은 reactor의 Publisher (Mono / Flux)이다. Mono -&gt; Mono의 flatMap의 경우 성능 상 이점이 아닌 Publisher 객체 타입 변환이 목적이기 때문에 flatMap을 사용한다. Mono -&gt; Flux의 flatMap의 경우 Publisher 객체 타입도 변환하고 변환된 이후 비동기로 병렬 동작하는 publisher를 사용하는 경우 forEach를 통한 동기로 실행하는 경우보다 빠른 처리가 가능해진다. Mono -&gt; Mono의 flatMap의 경우 비동기로 처리하는 의미가 없기 때문에 굳이 flatMap을 쓸 이유는 없다. https://luvstudy.tistory.com/95 null이 반환되면 reactive flow가 중지되기 때문에 Mono.empty(), Flux.empty()와 같이 지정된 빈 값 반환 처리를 해야 한다. collectList()Flux -&gt; Mono","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Webflux","slug":"Webflux","permalink":"http://kidongyun.github.io/tags/Webflux/"}]},{"title":"Webflux RouterFunction","slug":"2022-04-08-webflux-routerfunction","date":"2022-04-08T02:38:54.000Z","updated":"2022-06-01T07:03:34.689Z","comments":true,"path":"2022/04/08/","link":"","permalink":"http://kidongyun.github.io/2022/04/08/","excerpt":"","text":"RouterFunctionFunctional Endpoint를 사용 하기 위해서는 함수형 인터페이스인 RouterFunction의 구현체를 만들어서 스프링 빈으로 등록 시켜야 합니다. ServerRequest는 Request에 대한 모든 정보를 담고 있으며 클라에서 넘겨준 데이터를 추출 하여 사용 하면 됩니다. nest Method를 통해 공통으로 accept를 적용 시킬 수 도 있습니다. ServerRequestServerRequest.queryParam()ServerResponseMono.fromCallable() blocking calll 부분을 별도의 쓰레드에서 background로 돌리는 방법을 사용. Schedulers.elatic()","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"},{"name":"Webflux","slug":"Webflux","permalink":"http://kidongyun.github.io/tags/Webflux/"}]},{"title":"The way creating no-arg constructor in kotlin","slug":"2022-03-18-mockito-verify","date":"2022-03-18T02:38:54.000Z","updated":"2022-06-01T07:03:17.414Z","comments":true,"path":"2022/03/18/","link":"","permalink":"http://kidongyun.github.io/2022/03/18/","excerpt":"","text":"https://minkwon4.tistory.com/181 https://stackoverflow.com/questions/12862659/how-to-verify-that-a-specific-method-was-not-called-using-mockito https://sup2is.tistory.com/105","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"},{"name":"JUnit","slug":"JUnit","permalink":"http://kidongyun.github.io/tags/JUnit/"}]},{"title":"Eureka installation","slug":"2022-03-12-basic-installation-eureka","date":"2022-03-12T02:38:54.000Z","updated":"2022-06-01T07:33:59.286Z","comments":true,"path":"2022/03/12/","link":"","permalink":"http://kidongyun.github.io/2022/03/12/","excerpt":"","text":"import eureka-client 123456789101112131415161718// build.gradle.ktsrepositories &#123; // ... maven (url = &quot;https://repo.spring.io/milestone&quot;)&#125;dependencies &#123; // ... implementation (&quot;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&quot;)&#125;dependencyManagement &#123; imports &#123; mavenBom(&quot;org.springframework.cloud:spring-cloud-dependencies:2021.0.1&quot;) &#125;&#125; let’s inform that we will use client clent in this project through @EnableEurekaClient annotation 123456789// GatewayModuleApplication.kt// ...@EnableEurekaClientclass GatewayModuleApplicationfun main(args: Array&lt;String&gt;) &#123; runApplication&lt;GatewayModuleApplication&gt;(*args)&#125; set the name in each bootstrap.yml 123spring: application: name: gateway_module","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://kidongyun.github.io/tags/Kotlin/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://kidongyun.github.io/tags/Spring-Cloud/"}]},{"title":"Spring Cloud Version","slug":"2022-03-11-spring-cloud-version-error","date":"2022-03-11T02:38:54.000Z","updated":"2022-06-01T06:59:27.058Z","comments":true,"path":"2022/03/11/","link":"","permalink":"http://kidongyun.github.io/2022/03/11/","excerpt":"","text":"1.BeanCreationException: Error creating bean with name &#x27;configurationPropertiesBeans&#x27; defined in class path resource [org/springframework/cloud/autoconfigure/ConfigurationPropertiesRebinderAutoConfiguration.class]: Post-processing of merged bean definition failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [org.springframework.cloud.context.properties.ConfigurationPropertiesBeans] from ClassLoader [org.springframework.boot.loader.LaunchedURLClassLoader@238e0d81] I saw the above error log when i launch my spring project. firstly i didn’t know why it happened to me. but after i searched about it, i knew the answer. the reason is the miss matching of spring cloud version. you can find the version information into the below website. https://spring.io/projects/spring-cloud in the 2.6.X spring version case, you gotta use 2021.0.X versions","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://kidongyun.github.io/tags/Spring-Cloud/"}]},{"title":"Did you forget to provide one using @id?","slug":"2022-03-09-bean-registration-error-because-of-redis-id","date":"2022-03-09T02:38:54.000Z","updated":"2022-06-01T06:59:02.765Z","comments":true,"path":"2022/03/09/","link":"","permalink":"http://kidongyun.github.io/2022/03/09/","excerpt":"","text":"when you use Redis as a Jpa Repository, You should import org.springframework.data.annotation.Id not javax.persistence.Id. 1234567891011import org.springframework.data.annotation.Idimport org.springframework.data.redis.core.RedisHash@RedisHashclass Chord( @Id val key: String, val harmony: String)","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Redis","slug":"Redis","permalink":"http://kidongyun.github.io/tags/Redis/"}]},{"title":"About java compatibility in Gradle","slug":"2022-03-05-gradle-about-java-compatibility","date":"2022-03-05T02:38:54.000Z","updated":"2022-06-01T06:53:55.241Z","comments":true,"path":"2022/03/05/","link":"","permalink":"http://kidongyun.github.io/2022/03/05/","excerpt":"","text":"targetCompatibility and sourceCompatibility maps to -target release and -source release in javac. Source is basically the source language level and target is the level of the bytecode that is generated.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Gradle","slug":"Gradle","permalink":"http://kidongyun.github.io/tags/Gradle/"}]},{"title":"Troubleshooting error showed 'One To One' attribute type should not be ':entityname'","slug":"2022-03-05-entity-mapping-error-in-multi-module","date":"2022-03-05T02:38:54.000Z","updated":"2022-06-01T06:44:11.860Z","comments":true,"path":"2022/03/05/","link":"","permalink":"http://kidongyun.github.io/2022/03/05/","excerpt":"","text":"I saw the error with message ‘One To One’ attribute type should not be ‘Member’ when i mapped each entities are existed in different module. in this case, You should define @EntityScan annotation to find the entity is existed in other module like the below. 1234567@EntityScan(basePackages = [&quot;com.kian.yun.sheetshow&quot;])@SpringBootApplicationclass SheetModuleApplicationfun main(args: Array&lt;String&gt;) &#123; runApplication&lt;SheetModuleApplication&gt;(*args)&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"JPA","slug":"JPA","permalink":"http://kidongyun.github.io/tags/JPA/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://kidongyun.github.io/tags/Kotlin/"},{"name":"Entity","slug":"Entity","permalink":"http://kidongyun.github.io/tags/Entity/"}]},{"title":"let's customize jar archive file name","slug":"2022-03-05-gradlew-bootJar-archive-name","date":"2022-03-05T02:38:54.000Z","updated":"2022-06-01T06:54:13.128Z","comments":true,"path":"2022/03/05/","link":"","permalink":"http://kidongyun.github.io/2022/03/05/","excerpt":"","text":"gradlew p option can serve the user arguments into the build.gradle. 1./gradlew clean -Pgroup=com.github.kidongYun -Pversion=master-6cae222513-1 -xtest assemble publishToMavenLoca findProperty(String) method access these arguments as you can see the below code. and archiveFileName attribute in bootJar closure means the output of jar file name. 123bootJar &#123; archiveFileName = &quot;$&#123;archiveBaseName.get()&#125;-$&#123;findProperty(&quot;version&quot;)&#125;.$&#123;archiveExtension.get()&#125;&quot;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://kidongyun.github.io/tags/Gradle/"}]},{"title":"Error is occurred with '^M' character when gradlew script is run.","slug":"2022-03-05-gradlew-script-error","date":"2022-03-05T02:38:54.000Z","updated":"2022-06-01T06:54:32.193Z","comments":true,"path":"2022/03/05/","link":"","permalink":"http://kidongyun.github.io/2022/03/05/","excerpt":"","text":"I had a problem that i can’t build my project in the jitpack.io. but this project is built well in my local computer. so i don’t know why it is happend. and finally i found the reason. when i build my project in local, it based on Windows OS. and ‘gradlew’ script is works well in Windows. but jitpack.io site is built on Linux OS, and It’s not works well in Linux. the reason why it isn’t works well in Linux is the file format. I saw the below log in the result of build.log file in Jitpack. Reason1&gt; /script/gradleb.sh: ./gradlew: /bin/sh^M: bad interpreter: No such file or directory It means that the files related with gradle to build your project are based on the window file format. so to solve this problem you should change the format enable to read it in Linux. Solution1&gt; vi ./gradlew open the files and change the file format with the below command. and save it. 1:set fileformat=unix 1:wq after these, It will be good.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://kidongyun.github.io/tags/Gradle/"}]},{"title":"The way creating no-arg constructor in kotlin","slug":"2022-03-05-the-way-create-no-arg-constructor-in-kotlin","date":"2022-03-05T02:38:54.000Z","updated":"2022-06-01T06:57:26.333Z","comments":true,"path":"2022/03/05/","link":"","permalink":"http://kidongyun.github.io/2022/03/05/","excerpt":"","text":"Initialize default value for all of parameters.123456789class Sheet( @Id val id: Long = 1, val name: String = &quot;&quot;, val author: String = &quot;&quot;,) &#123;&#125; Create secondary constructor that initialize each fields.12345678910class Sheet( @Id val id: Long, val name: String, val author: String,) &#123; constructor(): this(1, &quot;&quot;, &quot;&quot;)&#125; Use no-arg plugin1234567// build.gradle.ktsplugins &#123; // ... kotlin(&quot;plugin.jpa&quot;) version &quot;1.6.10&quot;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://kidongyun.github.io/tags/Gradle/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://kidongyun.github.io/tags/Kotlin/"}]},{"title":"jar file push to maven local repository with gradle","slug":"2022-03-02-gradle-push-jar-to-mvn-local-repo","date":"2022-03-02T02:38:54.000Z","updated":"2022-06-01T06:41:34.256Z","comments":true,"path":"2022/03/02/","link":"","permalink":"http://kidongyun.github.io/2022/03/02/","excerpt":"","text":"12345678910111213141516plugins &#123; // ... id &#x27;maven-publish&#x27;&#125;publishing &#123; publications &#123; maven(MavenPublication) &#123; groupId = &#x27;com.kian.yun&#x27; artifactId = &#x27;jpaexl&#x27; version = &#x27;0.0.1-SNAPSHOT&#x27; from components.java &#125; &#125;&#125; after writing the above code in ‘build.gradle’ turning on the terminal and execute the below command. 1&gt; ./gradlew clean publishToMavenLocal local maven repository path example 1C:\\Users\\yun\\.m2\\repository\\org\\kian\\yun\\sheetshow\\filterable\\0.0.1-SNAPSHOT archiveClassifier -&gt; 여기에 들어가는 파라미터명이 최종생성되는 jar 파일의 뒷부분에 추가된다 publishToMavenLocal 을 통해서 local maven repository 에 bootjar 를 생성하기 위해서는 아래 옵션을 추가 123456789101112publishing &#123; publications &#123; create&lt;MavenPublication&gt;(&quot;maven&quot;) &#123; groupId = &quot;org.kian.yun.sheetshow&quot; artifactId = &quot;filterable&quot; version = &quot;0.0.1-SNAPSHOT&quot; from(components[&quot;java&quot;]) artifact(tasks.bootJar.get()) // 이거를 추가 &#125; &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://kidongyun.github.io/tags/Gradle/"}]},{"title":"Linux Commands","slug":"2022-02-08-linux-command","date":"2022-02-08T02:38:54.000Z","updated":"2022-06-01T06:41:29.055Z","comments":true,"path":"2022/02/08/","link":"","permalink":"http://kidongyun.github.io/2022/02/08/","excerpt":"","text":"Check hostname1&gt; hostname Check running process1&gt; ps -ef | grep &lt;substring of process name&gt;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kidongyun.github.io/tags/Linux/"}]},{"title":"Reactive Programming in Modern Java using Project Reactor","slug":"2022-01-27-reactive-programming-with-project-reactor","date":"2022-01-27T02:38:54.000Z","updated":"2022-06-01T06:36:39.200Z","comments":true,"path":"2022/01/27/","link":"","permalink":"http://kidongyun.github.io/2022/01/27/","excerpt":"","text":"Why Reactive Programming ?Traditional ProgrammingTraditional Programming makes a call to the DB and the code goes into a blocking phase and wait for the result. Once the result is retrieved from the DB, then the correct solution completes this way of writing code. This way is very common and this is also called synchronous or blocking style of writing code. Basically the thread is involved in the whole interaction is blocked until the response is received from the DB. What has changed? Internet usages spiked up Network interactions are pretty common Microservices Architectures are pretty much everywhere Applications are deployed in cloud environments Response times are expected in milliseconds No downtime Today’s Architecture (Backend Restful API) in the above case, the response time is the summation of a DB + the other API calls response time. This model works to a certain limit and you can’t have a thread pool based on the number of users you want to support. Let’s say you have a Usecase where you need to support 100,000 concurrent users. in that case, you can’t define a thread pool with 100,000 that you might be thinking why we can’t have a thead pool size that matches the number of users you want to support. Thread and it’s side effects Thread is an expensive resource It takes up 1MB of heap space More threads lead to more heap space which leads to shortage of JVM memory for handling the request. Can we do better ? Callbacks Asynchronous methods that accept a callback as a parameter and invokes it when the blocking call completes. Writing code with Callbacks are hard to compose and difficult to read and maintain There is a popular term tied with callbacks which is a Callbackhell Future Released in Java 5 Write Asynchronous Code No easy way to combine the result from multiple futures Future.get() is a blocking call CompletableFuture Released in Java 8 Write Asynchronous code in a functional style Easy to compose/combine MultipleFutures Future that returns many elements Eg., CompletableFuture","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Reactor","slug":"Reactor","permalink":"http://kidongyun.github.io/tags/Reactor/"}]},{"title":"Spring Batch","slug":"2022-01-24-spring-batch","date":"2022-01-24T02:38:54.000Z","updated":"2022-06-01T06:30:30.849Z","comments":true,"path":"2022/01/24/","link":"","permalink":"http://kidongyun.github.io/2022/01/24/","excerpt":"","text":"1. Concepts of Job, Step, TaskletYou should know one basic concept of them. that is one of the relationship between each them. ‘Job’ includes ‘Step’ ‘Step’ includes ‘Tasklet’ so You can remember the relationship between them like the below. 1Job &gt; Step &gt; Tasket Job It’s like a container for Step. It represents the one time of batch processing. Step It’s the object has components that is needed to batch processing. It’s actual used component when the batch system is operated. Tasklet Tasklet can have the business logic what you want to do. so what i’m saying is you just type your code in there. 2. Let’s build simple spring batch with Tasklet. add dependencies to process spring batch. 12345678910111213// build.gradle implementation &#x27;org.springframework.boot:spring-boot-starter-batch&#x27; implementation &#x27;com.h2database:h2:1.4.197&#x27; compileOnly &#x27;org.projectlombok:lombok&#x27; testCompileOnly &#x27;org.projectlombok:lombok&#x27; testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27; annotationProcessor &#x27;org.projectlombok:lombok&#x27; testAnnotationProcessor &#x27;org.projectlombok:lombok&#x27; turn on batch processing with @EnableBatchProcessing annotation. 123456789@EnableBatchProcessing // add this annotation.@SpringBootApplicationpublic class BatchExampleApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(BatchExampleApplication.class, args); &#125;&#125; create custom Tasklet has the business logics you want. 12345678@Slf4jpublic class SampleTasklet implements Tasklet &#123; @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123; log.info(&quot;executed tasklet !!&quot;); return RepeatStatus.FINISHED; &#125;&#125; Basically, You should create job, step to operate batch processing. the below code is for that. as you can see, job includes step and step includes tasklet. 1234567891011121314151617181920@Configuration@RequiredArgsConstructorpublic class SampleConfig &#123; private final JobBuilderFactory jobBuilderFactory; private final StepBuilderFactory stepBuilderFactory; @Bean public Job sampleJob() &#123; return jobBuilderFactory.get(&quot;sampleJob&quot;) .start(sampleStep()) .build(); &#125; @Bean public Step sampleStep() &#123; return stepBuilderFactory.get(&quot;sampleStep&quot;) .tasklet(new SampleTasklet()) .build(); &#125;&#125; 12345672022-01-24 10:24:57.075 INFO 12160 --- [ main] c.k.y.b.BatchExampleApplication : Started BatchExampleApplication in 0.907 seconds (JVM running for 1.273)2022-01-24 10:24:57.076 INFO 12160 --- [ main] o.s.b.a.b.JobLauncherApplicationRunner : Running default command line with: []2022-01-24 10:24:57.123 INFO 12160 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=sampleJob]] launched with the following parameters: [&#123;&#125;]2022-01-24 10:24:57.142 INFO 12160 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [sampleStep]2022-01-24 10:24:57.147 INFO 12160 --- [ main] c.kian.yun.batch_example.SampleTasklet : executed tasklet !!2022-01-24 10:24:57.151 INFO 12160 --- [ main] o.s.batch.core.step.AbstractStep : Step: [sampleStep] executed in 8ms2022-01-24 10:24:57.154 INFO 12160 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=sampleJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 18ms you can see the log created in SampleTasklet at the console. 3. the three ways to implement Tasklet.as you see before, the first way is that creating sub class of Tasklet class like SampleTasklet. 1234567public class SampleTasklet implements Tasklet &#123; @Override public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception &#123; log.info(&quot;executed tasklet !!&quot;); return RepeatStatus.FINISHED; &#125;&#125; second way is the best simple one. It is that you create sub class of Tasklet with lambda expression. 123456789101112131415161718192021222324@Configuration@RequiredArgsConstructorpublic class SampleConfig &#123; private final JobBuilderFactory jobBuilderFactory; private final StepBuilderFactory stepBuilderFactory; // ... @Bean public Job lambdaJob() &#123; return jobBuilderFactory.get(&quot;lambdaJob&quot;) .start(lambdaStep()) .build(); &#125; @Bean public Step lambdaStep() &#123; return stepBuilderFactory.get(&quot;lambdaStep&quot;) .tasklet((contribution, chunkContext) -&gt; &#123; log.info(&quot;executed tasklet created by lambda !!&quot;); return RepeatStatus.FINISHED; &#125;).build(); &#125;&#125; Last way would able to use the special case like you need the function is included at other service. 12345public class OtherService &#123; public void businessLogic() &#123; log.info(&quot;executed Tasklet in OtherService.businessLogic !!&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637@Configuration@RequiredArgsConstructorpublic class SampleConfig &#123; private final JobBuilderFactory jobBuilderFactory; private final StepBuilderFactory stepBuilderFactory; // ... @Bean public Job invokedJob() &#123; return jobBuilderFactory.get(&quot;invokedJob&quot;) .start(invokedStep()) .build(); &#125; @Bean public Step invokedStep() &#123; return stepBuilderFactory.get(&quot;invokedStep&quot;) .tasklet(invokedTasklet()) .build(); &#125; @Bean public OtherService otherService() &#123; return new OtherService(); &#125; @Bean public MethodInvokingTaskletAdapter invokedTasklet() &#123; MethodInvokingTaskletAdapter adapter = new MethodInvokingTaskletAdapter(); adapter.setTargetObject(otherService()); adapter.setTargetMethod(&quot;businessLogic&quot;); return adapter; &#125;&#125; 4. configure step with flowSpring batch offers the service that can control batch execution by the condition of other each step status. on() function decides whether the to() function located on the below should be executed or not by the ExitStatus condition. “*” condition means that every requests will be passed. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Configuration@RequiredArgsConstructorpublic class SampleConfig &#123; private final JobBuilderFactory jobBuilderFactory; private final StepBuilderFactory stepBuilderFactory; // ... @Bean public Job flowJob() &#123; return jobBuilderFactory.get(&quot;flowJob&quot;) .start(conditionStep()) .on(&quot;COMPLETED&quot;) .to(completedStep()) .on(&quot;*&quot;) .end() .from(conditionStep()) .on(&quot;FAILED&quot;) .to(failedStep()) .on(&quot;*&quot;) .end() .end().build(); &#125; @Bean public Step conditionStep() &#123; return stepBuilderFactory.get(&quot;conditionStep&quot;) .tasklet((contribution, chunkContext) -&gt; &#123; log.info(&quot;condition step !!&quot;); contribution.setExitStatus(ExitStatus.COMPLETED); return RepeatStatus.FINISHED; &#125;).build(); &#125; @Bean public Step completedStep() &#123; return stepBuilderFactory.get(&quot;completedStep&quot;) .tasklet((contribution, chunkContext) -&gt; &#123; log.info(&quot;completed step !!&quot;); return RepeatStatus.FINISHED; &#125;).build(); &#125; @Bean public Step failedStep() &#123; return stepBuilderFactory.get(&quot;failedStep&quot;) .tasklet((contribution, chunkContext) -&gt; &#123; log.info(&quot;failed step !!&quot;); return RepeatStatus.FINISHED; &#125;).build(); &#125;&#125; 5. About Chunk","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Spring Batch","slug":"Spring-Batch","permalink":"http://kidongyun.github.io/tags/Spring-Batch/"}]},{"title":"Add Flutter sdk path in mac","slug":"2022-01-23-add-flutter-path-in-mac","date":"2022-01-23T02:38:54.000Z","updated":"2022-06-01T06:29:16.195Z","comments":true,"path":"2022/01/23/","link":"","permalink":"http://kidongyun.github.io/2022/01/23/","excerpt":"","text":"123&gt; touch ~/.zshrc&gt; vi ~/.zshrc 1export PATH=$PATH:~/Documents/Dropbox/kian.yun/2022/workspace/service/flutter_sdk_mac/flutter/bin 123&gt; source ~/.zshrc&gt; flutter 1&gt; flutter build apk --release --target-platform=android-arm64","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://kidongyun.github.io/tags/Flutter/"}]},{"title":"Dart equatable","slug":"2022-01-22-dart-equatable","date":"2022-01-22T02:38:54.000Z","updated":"2022-06-01T06:29:04.217Z","comments":true,"path":"2022/01/22/","link":"","permalink":"http://kidongyun.github.io/2022/01/22/","excerpt":"","text":"123456789101112131415class Person &#123; final String name; const Person(this.name); @override bool operator ==(Object other) =&gt; identical(this, other) || other is Person &amp;&amp; runtimeType == other.runtimeType &amp;&amp; name == other.name; @override int get hashCode =&gt; name.hashCode;&#125; https://pub.dev/packages/equatable 12345678910import &#x27;package:equatable/equatable.dart&#x27;;class Person extends Equatable &#123; final String name; Person(this.name); @override List&lt;Object&gt; get props =&gt; [name];&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://kidongyun.github.io/tags/Flutter/"},{"name":"Dart","slug":"Dart","permalink":"http://kidongyun.github.io/tags/Dart/"}]},{"title":"Configure swapfile in AWS free tier","slug":"2022-01-20-aws-swapfile","date":"2022-01-20T02:38:54.000Z","updated":"2022-06-01T06:28:44.317Z","comments":true,"path":"2022/01/20/","link":"","permalink":"http://kidongyun.github.io/2022/01/20/","excerpt":"","text":"What is the ‘swap’ ?‘swap’ means the technique enable use the HDD, SSD as a main memory when main memory is fulled. 1. Create swapfile with ‘dd’ commandlet’s create swapfile in linux file system. ‘bs’ option means the size of block and ‘count’ option means the number of blocks. simplely, the below command enable create the file with the size you defined in bs, count options. 1&gt; sudo dd if=/dev/zero of=/swapfile bs=128M count=32 2. Change the authority of ‘swap’ file‘600’ value is able to give the authority for reading and writing. 1&gt; sudo chmod 600 /swapfile 3. Define swap file as a swapthis command defines the swap file created just before will be used as a swap. 1&gt; sudo mkswap /swapfile 4. Add swap file1&gt; sudo swapon /swapfile 5. Check whether swap is success or not1&gt; sudo swapon -s 6. Configure automization for swap1&gt; sudo vi /etc/fstab in vi 1/swapfile swap swap defaults 0 0 7. Check whether it works well or not12345&gt; free total used free shared buff/cache availableMem: 988696 568720 193836 400 226140 277896Swap: 4194300 0 4194300","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"http://kidongyun.github.io/tags/AWS/"}]},{"title":"ClassNotFoundException: SpringApplication","slug":"2022-01-18-spring-application-class-not-found-exception","date":"2022-01-18T02:38:54.000Z","updated":"2022-06-01T06:28:25.409Z","comments":true,"path":"2022/01/18/","link":"","permalink":"http://kidongyun.github.io/2022/01/18/","excerpt":"","text":"1234567Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/springframework/boot/SpringApplication at com.kian.yun.bridge.server.goal.GoalApplication.main(GoalApplication.java:15)Caused by: java.lang.ClassNotFoundException: org.springframework.boot.SpringApplication at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581) at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522) ... 1 more the solution code is the below 123456789101112// ... bootJar &#123; enabled = true archiveClassifier.set(&quot;boot&quot;) &#125; jar &#123; enabled = true &#125;// ...","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Gradle","slug":"Gradle","permalink":"http://kidongyun.github.io/tags/Gradle/"}]},{"title":"About git","slug":"2022-01-18-git","date":"2022-01-18T02:38:54.000Z","updated":"2022-06-01T06:28:02.029Z","comments":true,"path":"2022/01/18/","link":"","permalink":"http://kidongyun.github.io/2022/01/18/","excerpt":"","text":"2021-07-26통합브랜치 (Intergration branch) master, develop 과 같은 역할을 하는 브랜치들을 말한다. feature 브랜치들을 생성하고 다시 통합하는 역할을 해서 이름이 통합브랜치라고 붙여진 것 같다. 토픽브랜치 (Topic branch) feature 브랜치라고도 말한다. 실제 운영 버그를 수정하거나, 새로운 기능을 추가하거나 등의 작업을 하는 브랜치라고 생각하면 된다. 인덱스 (index) git을 조금 사용할 수 있게 되면 보통 로컬 저장소와, 원격 저장소로 나뉜다는 것 쯤은 쉽게 인지하고 있다. 그러나 그 중간에 존재하는 index 저장공간은 종종 잊혀지는데, index 의 존재를 한번씩 상기하는 것이 git을 올바르게 이해하는데에 좀 더 도움이 될 수 있다. 예를 들어서 로컬 저장소에서 어떤 작업을 끝내고 그 작업에 대해 commit 을 하였다고 하자. 우리는 git을 통해서 각 commit 에 해당하는 형상들로 자유롭게 오고갈 수 잇다. 이를 위해서는 그 commit 들이 의미하는 형상을 저장하고 있어야 하는데, 이 저장공간을 index 라고 한다. index 는 로컬 저장소에 존재하며, commit 이 일어났을 때 이 commit 과 관련된 작업 내용들을 저장한다. 생각해보면 당연히 필요한 저장 공간이지만 막상 인지하지 않으면 index 공간은 쉽게 부각되지 않는다. 이 index 라는 공간은 단순히 알고 있는 것 만으로도 충분하다. 스태쉬 (stash) index 공간에서 commit 이전 단계에 수정 작업들을 임시적으로 저장하고 싶을 때에 사용할 수 있는 영역이다. commit 을 하지 않고 내가 작업한 내용들을 저장하고 싶을 때 사용할 수 있다. 이 작업물들은 나중에 현재 브랜치나 다른 브랜치에서 불러와 사용할 수 있다. 예를 들어서 A, B 두 브랜치가 있고, A 브랜치에서 꽤 많은 양의 코드를 수정했다고 하자. 이 상태에서 B 브랜치로 checkout 을 하려고 하면 git 은 기본적으로 이 수정된 많은 코드들을 B 브랜치로 들고 온다. 물론 만약 이 때 같은 파일을 수정하게 되어서 충돌이 발생한다면 이 또한 조치를 해주어야 한다. 이렇기 때문에 보통 commit 하지 않은 수정 내용들이 있는 상태에서 브랜치를 이동하는 것은 성가실 수 있는데, 이럴 때 stash 저장공간을 활용해서 이곳에 수정 내용을 넣어두고 다른 브랜치를 이동하게 되면 보다 수월하게 브랜치 이동이 가능하다. 리비전 (revision) 이전 commit 상태부터 현재 상태까지의 변경 이력들이 기록되며, 이를 확인할 수 있는 것을 의미한다. git history, git log 등과 유사한 개념으로 바라보면 될 것 같다. fast-forward merge master 브랜치에서 bugfix 브랜치를 땃고 이상태에서 master 브랜치가 더이상 커밋내역이 없다면. bugfix 브랜치를 빠르게 병합할 수 있다. 이를 fast-forward merge 라고 부른다. 이것은 커밋이 따로 생성되지 않으며 bugfix 브랜치의 방향을 master 브랜치가 그대로 따라간다. 병합 실행 시에 ‘fast-forward merge’ 가 가능한 경우라도, ‘non fast-forward’ 옵션을 지정하여 merge commit을 만들어낼 수 있다. 123456// Before mergeA -&gt; B ㄴ X -&gt; Y// After mergeA -&gt; B -&gt; X -&gt; Y merge commit 만약 bugfix 브랜치를 만들고 난 이후에 master 브랜치에 추가적인 commit 내역이 존재한다면 fast-forward merge 가 아닌 merge commit 이 실행된다 1234567// Before mergeA -&gt; B -&gt; C -&gt; D ㄴ X -&gt; Y// After mergeA -&gt; B -&gt; C -&gt; D -&gt; M ㄴ X -&gt; Y -&gt; (M 으로 병합) 리버트 (revert)rebase12A -&gt; B -&gt; C -&gt; D ㄴ -&gt; X -&gt; Y 위와 동일하게 master, bugfix 브랜치 두개가 존재한다고 할 때, rebase 방법은 X, Y 커밋 내역을 master 브랜치의 마지막 커밋내역인 D 뒤로 일자로 붙여서 통합하는 방법이다. 1A -&gt; B -&gt; C -&gt; D -&gt; X -&gt; Y C, D 의 작업과 X, Y 의 작업이 충돌이 발생할 수 있으며 이는 수동 수정해주어야 한다. 하나 주의할 점은 rebase 를 했다고 해서 master 브랜치의 커밋내역은 X, Y 가 들어와있지 않다. 이를 위해서 fast-forward 머지를 한번 더 호출해주어야 한다. 일반적인 사용방법 1234토픽(피처) 브랜치에 통합(마스터) 브랜치의 최신 코드를 적용할 경우에는 rebase 를 사용,통합(마스터) 브랜치에 토픽(피처) 브랜치를 불러올 경우에는 우선 rebase 를 한 후 merge리베이스할때는 보통 피쳐 브랜치에서 통합 브랜치를 리베이스! git flowmaster ‘배포 가능한 형상’ 만을 관리하는 브랜치. 커밋할 때에는 태그를 사용하여 배포번호를 기록. develop 위에서 언급한 통합 브랜치의 역할. 이 브랜치를 기반으로 개발을 진행한다. feature 위에서 언급한 토픽 브랜치의 역할. develop 브랜치로 부터 분기되어서 작업을 진행한다.이 브랜치의 작업들은 보통 공유될 필요가 없기 때문에, 원격으로는 관리하지 않는다. release 배포 이전에 배포 테스트를 위해서 사용하는 브랜치이다. 모든 기능이 정상적으로 동작하는지 확인하기 위해 사용.릴리즈 브랜치에서 수정될 내용을 수정하고 커밋을 하고 난 뒤 확인이 모두 끝나게 되면 이 브랜치는 develop 브랜치와master 두 브랜치에 머지가 되어야 한다. hotfix 이미 master 를 통해 배포된 형상에 문제가 있을 때에, 빠르게 수정하기 위한 브랜치. 원격 저장소의 브랜치와, 로컬 저장소의 브랜치도 결국 두 브랜치 라고 생각하면 될듯.그렇게 추상화가 되어있음. 단지 물리적으로 멀리 존재할 뿐. 테크닉은 동일함. 태그는 두 종류가 존재챼일반 태그(Lightweight tag)이름만 붙일 수 있어요 주석 태그(Annotated tag)이름을 붙일 수 있어요태그에 대한 설명도 포함할 수 있어요서명도 넣을 수 있어요이 태그를 만든 사람의 이름, 이메일과 태그를 만든 날짜 정보도 포함시킬 수 있어요 보통 ‘릴리스 브랜치(Release branch)’에서는 주석 태그를 사용하여 설명이나 서명을 넣은 보다 상세한 정보를 포함하는 태그를 사용하고, 로컬에서 일시적으로 사용하는 ‘토픽 브랜치(Topic branch)’에서는 이름만 만들어 붙이는 태그를 사용합니다. 태그를 활용해서 checkout, reset, pull, push 등이 가능하다. 1git tag 활용해서 checkout, reset, pull, push, 생성, 삭제 해보기 #‘—amend’ 옵션을 지정하여 커밋을 수행하면, 같은 브랜치 상에서 이전에 커밋했던 내용에 새로운 내용을 추가하거나 설명을 수정할 수 있습니다. reset 브랜치를 통합브랜치에서 사용하기는 어려운게. 만약 내가 작업한게 가장 마지막 커밋 내역이 아니라면. reset 을 썼을 경우 나의 다음에 적용된 커밋 내역들도 삭제가 된다. 그래서 보통 나의 커밋 작업만을 지우기 위해서 revert 커밋을 한다.revert 커밋은 내가 작업한 내용의 반대 작업을 하는 커밋을 새롭게 날리는 것. 그래서 커밋 이력도 지운 커밋이라고 새롭게 추가된다. (즉 이력도 남게됨.) reset 명령어를 이용하면 더 이상 필요 없어진 커밋들을 버릴 수 있습니다. 명령어 실행 시 어떤 모드로 실행할 지 지정하여 ‘HEAD’ 위치와 인덱스, 작업 트리 내용을 함께 되돌릴지 여부를 선택할 수 있습니다. cherry-pickcherry-pick 을 이용하면 다른 브랜치에서 지정한 커밋을 복사하여 현재 브랜치로 가져올 수 있습니다. 이럴 때 사용해 보세요 : 특정 브랜치에 잘못 추가한 커밋을 올바른 브랜치로 옮기려고 할 때다른 브랜치의 커밋을 현재 브랜치에도 추가하고 싶을 때 1cherry-pick 한번 활용해서 다른 브랜치 내용을 가져와보자. squash이번에는 병합(merge) 할 때 사용할 수 있는, 조금 특별한 옵션인 ‘—squash’를 소개합니다. 이 옵션을 지정하여 브랜치를 병합하면 해당 브랜치의 커밋 전체를 통합한 커밋이 추가됩니다. 이럴 때 사용해 보세요 : 토픽 브랜치 안의 커밋을 한꺼번에 모아서 통합 브랜치에 병합하고자 할 때 2021-07-28fast-forward merge, merge commit12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&gt; git init&gt; touch README.md&gt; vi README.md It&#x27;s written by Master branch:wq&gt; cat README.mdIt&#x27;s written by Master branch&gt; git add .&gt; git commit -m &quot;CREATE README.md&quot;&gt; git logcommit e1df99fddab2edd1b9638a926e57522864c901c3 (HEAD -&gt; master)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 20:39:05 2021 +0900 CREATE README.md&gt; git branch feature&gt; git checkout feature&gt; git branch* feature master&gt; vi README.mdIt&#x27;s written by Feature branch:wq&gt; cat README.mdIt&#x27;s written by Master branchIt&#x27;s written by Feature branch&gt; git add .&gt; git commit -m &quot;README.md is changed by Feature branch&quot;&gt; git logcommit 85fb4307b3ef7f9a4a99c63182868e3ad7aab2b8 (HEAD -&gt; feature)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 20:43:28 2021 +0900 README.md is changed by Feature branchcommit e1df99fddab2edd1b9638a926e57522864c901c3 (master)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 20:39:05 2021 +0900 CREATE README.md&gt; git checkout master&gt; git logcommit e1df99fddab2edd1b9638a926e57522864c901c3 (HEAD -&gt; master)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 20:39:05 2021 +0900 CREATE README.md// &#x27;README.md is changed by Feature branch&#x27; commit is not appear in here// because you can see this commit only in Feature branch.// Let&#x27;s try to merge feature into master.&gt; git merge featureUpdating e1df99f..85fb430Fast-forward README.md | 1 + 1 file changed, 1 insertion(+)// It&#x27;s operated as a fast-forward meging.// This way doesn&#x27;t create the new commit for merging.&gt; git logcommit 85fb4307b3ef7f9a4a99c63182868e3ad7aab2b8 (HEAD -&gt; master, feature)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 20:43:28 2021 +0900 README.md is changed by Feature branchcommit e1df99fddab2edd1b9638a926e57522864c901c3Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 20:39:05 2021 +0900 CREATE README.md// The log is same with Feature branch stuff. Merge Commit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&gt; git init&gt; touch README.md&gt; vi README.md It&#x27;s written by Master branch:wq&gt; cat README.mdIt&#x27;s written by Master branch&gt; git add .&gt; git commit -m &quot;CREATE README.md&quot;&gt; git logcommit e1df99fddab2edd1b9638a926e57522864c901c3 (HEAD -&gt; master)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 20:39:05 2021 +0900 CREATE README.md&gt; git branch feature&gt; git checkout feature&gt; git branch* feature master&gt; vi README.mdIt&#x27;s written by Feature branch:wq&gt; cat README.mdIt&#x27;s written by Master branchIt&#x27;s written by Feature branch&gt; git add .&gt; git commit -m &quot;README.md is changed by Feature branch&quot;&gt; git logcommit 85fb4307b3ef7f9a4a99c63182868e3ad7aab2b8 (HEAD -&gt; feature)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 20:43:28 2021 +0900 README.md is changed by Feature branchcommit e1df99fddab2edd1b9638a926e57522864c901c3 (master)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 20:39:05 2021 +0900 CREATE README.md&gt; git checkout master&gt; git logcommit e1df99fddab2edd1b9638a926e57522864c901c3 (HEAD -&gt; master)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 20:39:05 2021 +0900 CREATE README.md// &#x27;README.md is changed by Feature branch&#x27; commit is not appear in here// because you can see this commit only in Feature branch.// Let&#x27;s try to merge feature into master.&gt; vi README.mdIt&#x27;s written by Master branch twice:wq&gt; cat README.mdIt&#x27;s written by Master branch twiceIt&#x27;s written by Master branch&gt; git add .&gt; git commit -m &quot;README.md is changed by Master branch&quot;&gt; git logcommit 7486981874266e875d7d13543470a1131baf1e4f (HEAD -&gt; master)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 20:57:26 2021 +0900 README.md is changed by Master branchcommit 5c73ce60e2ac44ea7fdb90bb6a8935a1e48505d8Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 20:49:30 2021 +0900 CREATE README.md&gt; git merge featureAuto-merging README.mdMerge made by the &#x27;recursive&#x27; strategy. README.md | 1 + 1 file changed, 1 insertion(+)&gt; cat README.md It&#x27;s written by Master branch twiceIt&#x27;s written by Master branchIt&#x27;s written by Feature branch// The changes are from Master branch or Feature branch merged in one file.&gt; git logMerge: 7486981 c0f32b7Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 20:58:04 2021 +0900 Merge branch &#x27;feature&#x27;commit 7486981874266e875d7d13543470a1131baf1e4fAuthor: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 20:57:26 2021 +0900 README.md is changed by Master branchcommit c0f32b7d915d585736691889ba8ee330a4c7743d (feature)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 20:51:19 2021 +0900 README.md is changed by Feature branchcommit 5c73ce60e2ac44ea7fdb90bb6a8935a1e48505d8Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 20:49:30 2021 +0900 CREATE README.md// It&#x27;s the log of master branch but you can see the history of feature&#x27;s thing.// because They are merged as master branch and importantly, this branch have had the new commit for merging them.// It&#x27;s called merge commit. revert123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201&gt; git init&gt; touch README.md&gt; vi README.mdIt&#x27;s written by Master branch:wq&gt; cat README.mdIt&#x27;s written by Master branch&gt; git add .&gt; git commit -m &quot;CREATE README.md&quot;&gt; git logcommit 08f9e9136f66c83ed3d82c268e3c995ae66dc2e5 (HEAD -&gt; master)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:06:06 2021 +0900 CREATE README.md&gt; git branch feature&gt; git checkout feature&gt; vi README.mdIt&#x27;s written by Feature branch:wq&gt; cat README.mdIt&#x27;s written by Master branchIt&#x27;s written by Feature branch&gt; git add .&gt; git commit -m &quot;README.md is changed by Feature branch&quot;&gt; git logkakaobank@KIANYUN-M-03A0AD revert % git logcommit 8cd37652e9ac36afbad397f7b297b1a1185d6af1 (HEAD -&gt; feature)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:10:44 2021 +0900 README.md is changed by Feature branchcommit 08f9e9136f66c83ed3d82c268e3c995ae66dc2e5 (master)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:06:06 2021 +0900 CREATE README.md&gt; git checkout master&gt; git branch develop&gt; git branch develop feature* master&gt; git checkout develop&gt; vi README.mdIt&#x27;s written by Develop branch&gt; cat README.mdIt&#x27;s written by Develop branchIt&#x27;s written by Master branch&gt; git add .&gt; git commit -m &quot;README.md is changed by Develop branch&quot;&gt; git logcommit 064a56d0c9c60dfa6ae66f418a258a324f1367d3 (HEAD -&gt; develop)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:15:28 2021 +0900 README.md is changed by Develop branchcommit 08f9e9136f66c83ed3d82c268e3c995ae66dc2e5 (master)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:06:06 2021 +0900 CREATE README.md&gt; git checkout master&gt; git merge developUpdating 08f9e91..064a56dFast-forward README.md | 1 + 1 file changed, 1 insertion(+)&gt; cat README.mdIt&#x27;s written by Develop branchIt&#x27;s written by Master branch&gt; git logcommit 064a56d0c9c60dfa6ae66f418a258a324f1367d3 (HEAD -&gt; master, develop)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:15:28 2021 +0900 README.md is changed by Develop branchcommit 08f9e9136f66c83ed3d82c268e3c995ae66dc2e5Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:06:06 2021 +0900 CREATE README.md&gt; git merge featureAuto-merging README.mdMerge made by the &#x27;recursive&#x27; strategy. README.md | 1 + 1 file changed, 1 insertion(+)&gt; cat README.mdIt&#x27;s written by Develop branchIt&#x27;s written by Master branchIt&#x27;s written by Feature branch&gt; git logcommit 1297f0c16a3eecb0bf52c9c3755355a0ef6cab95 (HEAD -&gt; master)Merge: 064a56d 8cd3765Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:17:33 2021 +0900 Merge branch &#x27;feature&#x27;commit 064a56d0c9c60dfa6ae66f418a258a324f1367d3 (develop)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:15:28 2021 +0900 README.md is changed by Develop branchcommit 8cd37652e9ac36afbad397f7b297b1a1185d6af1 (feature)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:10:44 2021 +0900 README.md is changed by Feature branchcommit 08f9e9136f66c83ed3d82c268e3c995ae66dc2e5Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:06:06 2021 +0900 CREATE README.md&gt; git revert 064a56d0c9c60dfa6ae66f418a258a324f1367d3Auto-merging README.md[master 3699132] Revert &quot;README.md is changed by Develop branch&quot; 1 file changed, 1 deletion(-)&gt; cat README.md It&#x27;s written by Master branchIt&#x27;s written by Feature branch&gt; git logcommit 36991322d7791166fe69ceb0dffd04de930d3287 (HEAD -&gt; master)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:19:36 2021 +0900 Revert &quot;README.md is changed by Develop branch&quot; This reverts commit 064a56d0c9c60dfa6ae66f418a258a324f1367d3.commit 1297f0c16a3eecb0bf52c9c3755355a0ef6cab95Merge: 064a56d 8cd3765Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:17:33 2021 +0900 Merge branch &#x27;feature&#x27;commit 064a56d0c9c60dfa6ae66f418a258a324f1367d3 (develop)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:15:28 2021 +0900 README.md is changed by Develop branchcommit 8cd37652e9ac36afbad397f7b297b1a1185d6af1 (feature)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:10:44 2021 +0900 README.md is changed by Feature branchcommit 08f9e9136f66c83ed3d82c268e3c995ae66dc2e5Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:06:06 2021 +0900 CREATE README.md&gt; git revert 36991322d7791166fe69ceb0dffd04de930d3287&gt; cat README.mdIt&#x27;s written by Develop branchIt&#x27;s written by Master branchIt&#x27;s written by Feature branch&gt; git log rebase123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&gt; git init&gt; touch README.md&gt; vi README.mdIt&#x27;s written by Master branch:wq&gt; cat README.mdIt&#x27;s written by Master branch&gt; git add .&gt; git commit -m &quot;CREATE README.md&quot;&gt; git logcommit 6321ddb4ab5539d968cd0ab9ee3a6942fdd99fa2 (HEAD -&gt; master)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:28:19 2021 +0900 CREATE README.md&gt; git branch feature&gt; git checkout feature&gt; vi README.mdIt&#x27;s written by Feature branch&gt; cat README.mdIt&#x27;s written by Master branchIt&#x27;s written by Feature branch&gt; git add .&gt; git commit -m &quot;README.md is changed by Feature branch&quot;&gt; git logcommit 0b07d12243dfc3039ac670633e848adb5585682f (HEAD -&gt; feature)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:32:35 2021 +0900 README.md is changed by Feature branchcommit 6321ddb4ab5539d968cd0ab9ee3a6942fdd99fa2 (master)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:28:19 2021 +0900 CREATE README.md&gt; git checkout master&gt; git logcommit 6321ddb4ab5539d968cd0ab9ee3a6942fdd99fa2 (HEAD -&gt; master)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:28:19 2021 +0900 CREATE README.md&gt; vi README.mdIt&#x27;s written by Master branch to check rebase:wq&gt; cat README.mdIt&#x27;s written by Master branch to check rebaseIt&#x27;s written by Master branch&gt; git add .&gt; git commit -m &quot;README.md is changed by Master branch&quot;&gt; git logcommit 8532582ff5521f44b9f88fac8a260c139484abb2 (HEAD -&gt; master)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:38:46 2021 +0900 README.md is changed by Master branchcommit 6321ddb4ab5539d968cd0ab9ee3a6942fdd99fa2Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:28:19 2021 +0900 CREATE README.md&gt; git checkout feature&gt; git rebase masterSuccessfully rebased and updated refs/heads/feature.// The important thing is that you should use the rebase command in feature branch to master branch.&gt; git logcommit d344c80d471453d871301060bcb12d3ba06137b1 (HEAD -&gt; feature)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:32:35 2021 +0900 README.md is changed by Feature branchcommit 8532582ff5521f44b9f88fac8a260c139484abb2 (master)Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:38:46 2021 +0900 README.md is changed by Master branchcommit 6321ddb4ab5539d968cd0ab9ee3a6942fdd99fa2Author: kian.yun &lt;kian.yun@kakaobank.com&gt;Date: Wed Jul 28 21:28:19 2021 +0900 CREATE README.md 2021-08-17 (MON)How to delete untracked files ?123&gt; git clean -n -d&gt; git clean -f -d 위처럼 명령어 치면 add 안된 파일들 모두 제거 가능. 개꿀팁 git checkout 시 -b 속성-b 속성을 주면 checkout 할 때 source 에 해당하는 브랜치를 원격브랜치로 자동 설정한다. 그래서 이상태에서 단순 push 를하게되면 새로운 원격 브랜치가 생기는게 아니라 기존 source 에 해당하는 원격 브랜치로 푸쉬가 되니 이를 주의!! 2021-08-18 (TUE)personal access token 사용하기 spotlight -&gt; keychain Access.app 검색 -&gt; github 검색 -&gt; 인터넷 암호 클릭 -&gt; 암호보기 클릭 -&gt; personal access token 으로 변경 Please, commit your changes before merging. 오류 commit, stash 되어있지 않은 작업물이 있다는 의미이다. git status 쳐서 작업물들의 상태를 확인 2021-08-21 (SAT) .gitignore가 제대로 작동되지 않아서 ignore처리된 파일이 자꾸 changes에 나올때가 있습니다. git의 캐시가 문제가 되는거라 아래 명령어로 캐시 내용을 전부 삭제후 다시 add All해서 커밋하시면 됩니다. 123git rm -r --cached .git add .git commit -m &quot;fixed untracked files&quot;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://kidongyun.github.io/tags/Git/"}]},{"title":"Manifest missing error","slug":"2022-01-17-java-jar-missing-manifest-error","date":"2022-01-17T02:38:54.000Z","updated":"2022-06-01T06:27:41.555Z","comments":true,"path":"2022/01/17/","link":"","permalink":"http://kidongyun.github.io/2022/01/17/","excerpt":"","text":"if you build the project as a multi-module one, then you would be encoutered this error when you run .jar file. 1[project name].jar에 기본 Manifest 속성이 없습니다 the factor is the sub module can’t find the entry point to turn on the service like main() method. so you should define it in build.gradle file like the below 12345jar &#123; manifest &#123; attributes &#x27;Main-Class&#x27;: &#x27;com.kian.yun.bridge.server.goal.GoalApplication&#x27; &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"Change Java Version","slug":"2022-01-16-change-java-version","date":"2022-01-16T02:38:54.000Z","updated":"2022-06-01T06:27:15.193Z","comments":true,"path":"2022/01/16/","link":"","permalink":"http://kidongyun.github.io/2022/01/16/","excerpt":"","text":"Mac OSFirst of all, let’s check the java version in your local system via the below command. 1&gt; java -version the below command will able to check the list of installed JDK in OSX system. 1&gt; /usr/libexec/java_home -V if you want to change the JDK version among them. You just use ‘export’ command. like the below. 1&gt; export JAVA_HOME=$(/usr/libexec/java_home -v 11)","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"The basic configuration of AWS EC2","slug":"2022-01-09-aws-ec2","date":"2022-01-09T02:38:54.000Z","updated":"2022-06-01T06:26:40.617Z","comments":true,"path":"2022/01/09/","link":"","permalink":"http://kidongyun.github.io/2022/01/09/","excerpt":"","text":"It’s just the recording document to remember the way configuring AWS EC2 basically. 1. Create EC2 instance.Let’s go to EC2 page with search bar. and after that, you can see the instance tab in side menu. let’s click it. instance &gt; instance start You should choose linux image file will be installed in your EC2 instance. at here the important thing that is you should select free tier one. and also the images in AWS market place are also not free tier. You should keep this. Select ‘Amazon Linux 2 AMI (HVM) - kernel 5.10, SSD Volume Type’ After you choose instance type. It means that how much you want to need computer resources like cpu, memories, storages and so on. We will use free tier so let’s pick ‘t2.micro’ one. Select ‘t2.micro’ and let’s press next button for configuring detail. You don’t need to configure anything at here if you are begineer. just press next button for adding storage. The free tier can take up to 30 GB. so let’s change the volume sizes to that.and after that, please press next button for adding tags. Let’s add name tag at here. This tag will help you when you want to search this one. after that, press next button for configuring security group. First of all, You should restrict the inbound channel only for your ip. if you don’t, someone will access your EC2 via this SSH protocol and use this EC2 resources. then you have to pay the money. so maybe it’s really one of the important one. and You should add the protocol that would be TCP if you want to serve your service with web. and also you have to add the port what you need. after that, just press next button, start button. last of all, you should download and keep the .pem file for accessing your EC2 via ssh protocol.so just create it at the below page, and keep it. finally you can see your EC2 instance at instance tab like the below. 2. Apply Elastic IPEC2 ip is always changed whenever it is rebooted. so You should confirm the ip address when you want to access there. for solve it, AWS offers Elastic IP service. if you connect it to your EC2 service then you don’t need to confirm your EC2 ip address always. you just remember the Elastic IP connected with your EC2. Go to EC2 &gt; Elastic IP tab &gt; Assign Elastic IP You don’t need to configure anything for Elastic IP. so just press Assign button. and it, You should connect with your EC2 instance. you just follow the below images. 3. Access EC2 via ssh1&gt; sudo ssh -i [path]/[name].pem ec2-user@[Elastic IP] if you encounter the below error then change the authority of your .pem file. 123456@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: UNPROTECTED PRIVATE KEY FILE! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0644 for &#x27;/Users/kian.yun/Downloads/thenamewhatyouwant.pem&#x27; are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored. 1&gt; chmod 400 [path]/[name].pem 4. Change the envrionment of EC2 Install Java 8 1234567891011// Download Java 8&gt; sudo yum install -y java-1.8.0-openjdk-devel.x86_64// Select the one among Javas&gt; sudo /usr/sbin/alternatives --config java// Delete previous one&gt; sudo yum remove java-1.7.0-openjdk// Check java version&gt; java -version Install Java 11 1234567891011121314# Download aws coreetto&gt; sudo curl -L https://corretto.aws/downloads/latest/amazon-corretto-11-x64-linux-jdk.rpm -o jdk11.rpm# Install jdk11&gt; sudo yum localinstall jdk11.rpm# Select jdk version&gt; sudo /usr/sbin/alternatives --config java# Check java version&gt; java --version# Delete Install file&gt; rm -rf jdk11.rpm Change Time zone 12345678// Delete the timezone is installed now&gt; sudo rm /etc/localtime// Set Asia/Seoul timezone&gt; sudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime// Check timezone &gt; date Change hostname 1&gt; sudo vim /etc/sysconfig/network 12345678AS-IS)NETWORKING=yesNOZEROCONF=yesTO-BE)NETWORKING=yesHOSTNAME=freelecNOZEROCONF=yes 5. Install docker in EC21234567891011121314&gt; sudo yum -y upgrade&gt; sudo yum -y install docker&gt; sudo service docker start// docker-compose&gt; sudo curl -L https://github.com/docker/compose/releases/download/1.21.0/docker-compose-`uname -s`-`uname -m` | sudo tee /usr/local/bin/docker-compose &gt; /dev/null// 권한 변경&gt; sudo chmod +x /usr/local/bin/docker-compose// 심볼릭 링크 생성&gt; sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose 6. Install git int EC21234567891011&gt; sudo yum install git&gt; mkdir ~/app&gt; cd ~/app&gt; git clone [project] ./&gt; chmod +x ./gradlew&gt; sudo chmod 777 ./bridge.server 7. Build and launch server123&gt; ./gradlew build&gt; nohup java -jar [jar file name] --spring.profiles.active=test","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"http://kidongyun.github.io/tags/AWS/"},{"name":"EC2","slug":"EC2","permalink":"http://kidongyun.github.io/tags/EC2/"}]},{"title":"The basic configuration of AWS RDS","slug":"2022-01-09-aws-rds","date":"2022-01-09T02:38:54.000Z","updated":"2022-06-01T06:26:45.231Z","comments":true,"path":"2022/01/09/","link":"","permalink":"http://kidongyun.github.io/2022/01/09/","excerpt":"","text":"It’s just the recording document to remember the way configuring AWS RDS basically. 1. Create RDS instance.Let’s go to RDS page. Create RDS instance. Select the type of database. in my case, i choose MariaDB. Select free tier. Type database identifier, admin identifier and admin password. To use RDS at outer area, for check it as ‘YES’ you should decide the database name as you want. 2. Configure Parameter Group3. Configure Security GroupYou should change security group settings to access here from two places. first one is your local pc and last one is EC2. 4. Access Database from local5. Access Database from EC2","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"http://kidongyun.github.io/tags/AWS/"},{"name":"RDS","slug":"RDS","permalink":"http://kidongyun.github.io/tags/RDS/"}]},{"title":"SfDatePicker in Flutter","slug":"2021-12-28-flutter-sfdatepicker","date":"2021-12-28T02:38:54.000Z","updated":"2022-06-01T06:23:54.615Z","comments":true,"path":"2021/12/28/","link":"","permalink":"http://kidongyun.github.io/2021/12/28/","excerpt":"","text":"Official page https://pub.dev/packages/syncfusion_flutter_datepicker Import syncfusion_flutter_datepicker package1234dependencies: flutter: sdk: flutter syncfusion_flutter_datepicker: ^19.4.38 1import &#x27;package:syncfusion_flutter_datepicker/datepicker.dart&#x27;; Add date range picker to the widget treeAdd the SfDateRangePicker widget as a child of any widget. Here, the SfDateRangePicker widget is added as a child of the scaffold widget. 1234567@overrideWidget build(BuildContext context) &#123; return Scaffold( body: Container( child: SfDateRangePicker(), ));&#125; Change different viewsThe SfDateRangePicker widget provides four different types of views to display. It can be assigned to the widget constructor by using the view property. Default view of the widget is month view. By default the current date will be displayed initially for all the date range picker views. 1234567@overrideWidget build(BuildContext context) &#123; return Scaffold( body: SfDateRangePicker( view: DateRangePickerView.year, ));&#125; Change first day of weekThe DateRangePicker widget will be rendered with Sunday as the first day of the week, but you can customize it to any day by using the firstDayOfWeek property. 12345678@overrideWidget build(BuildContext context) &#123; return Scaffold( body: SfDateRangePicker( view: DateRangePickerView.month, monthViewSettings: DateRangePickerMonthViewSettings(firstDayOfWeek: 1), ));&#125; Date selectionThe DateRangePicker supports selecting single, multiple, and range of dates. It also supports programmatic selection. The selected date or range details can be obtained using the onSelectionChanged callback of date range picker. The callback will return the DateRangePickerSelectionChangedArgs which contains the selected date or range details. 1234567891011121314151617void _onSelectionChanged(DateRangePickerSelectionChangedArgs args) &#123; // TODO: implement your code here&#125;@overrideWidget build(BuildContext context) &#123; return MaterialApp( home: Scaffold( body: Container( child: SfDateRangePicker( onSelectionChanged: _onSelectionChanged, selectionMode: DateRangePickerSelectionMode.range, ), ), ), );&#125; SelectionModeDefault selection mode pick only one date. but if you configure selection mode like the below code, you can get the range of date. 12345SfDateRangePicker( view: DateRangePickerView.year, selectionMode: DateRangePickerSelectionMode.range, onSelectionChanged: _onSelectionChanged, ) args.valueI just arrange the properties name of start date and end date in DataRangePickerSelectionChangedArgs object. we should use these properties in onSelectionChanged callback function(). if) single date args.value if) multiple date args.value.startDate args.value.endDate 123456789101112131415161718192021222324252627void _onSelectionChanged(DateRangePickerSelectionChangedArgs args) &#123; /// The argument value will return the changed date as [DateTime] when the /// widget [SfDateRangeSelectionMode] set as single. /// /// The argument value will return the changed dates as [List&lt;DateTime&gt;] /// when the widget [SfDateRangeSelectionMode] set as multiple. /// /// The argument value will return the changed range as [PickerDateRange] /// when the widget [SfDateRangeSelectionMode] set as range. /// /// The argument value will return the changed ranges as /// [List&lt;PickerDateRange] when the widget [SfDateRangeSelectionMode] set as /// multi range. setState(() &#123; if (args.value is PickerDateRange) &#123; _range = &#x27;$&#123;DateFormat(&#x27;dd/MM/yyyy&#x27;).format(args.value.startDate)&#125; -&#x27; // ignore: lines_longer_than_80_chars &#x27; $&#123;DateFormat(&#x27;dd/MM/yyyy&#x27;).format(args.value.endDate ?? args.value.startDate)&#125;&#x27;; &#125; else if (args.value is DateTime) &#123; _selectedDate = args.value.toString(); &#125; else if (args.value is List&lt;DateTime&gt;) &#123; _dateCount = args.value.length.toString(); &#125; else &#123; _rangeCount = args.value.length.toString(); &#125; &#125;); &#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://kidongyun.github.io/tags/Flutter/"},{"name":"SfDatePicker","slug":"SfDatePicker","permalink":"http://kidongyun.github.io/tags/SfDatePicker/"}]},{"title":"Flutter","slug":"2021-12-23-flutter","date":"2021-12-23T02:38:54.000Z","updated":"2022-06-01T06:23:07.508Z","comments":true,"path":"2021/12/23/","link":"","permalink":"http://kidongyun.github.io/2021/12/23/","excerpt":"","text":"3. Dart PrimerYou can practice the grammer of Dart language in the below link https://dartpad.dartlang.org/ when you want to just print something in Dart language 123void main() &#123; print(&#x27;hello&#x27;);&#125; about variables Dart language doesn’t support dynamical variable type basically. as like another languages. if you want to use it, you should declare ‘dynamic’ keyword in front of the variable data. 123456789101112131415void main() &#123; int age = 30; print(age); String name = &quot;chun-li&quot;; print(name); bool isNight = false; print(isNight); dynamic dyName = &#x27;chun-li&#x27;; dyName = 30; print(dyName); &#125; about functions 1234567891011121314151617181920void main() &#123; String greet = greeting(); print(greet); int age = getAge(); print(age); String arrowGreet = arrowGreeting(); print(arrowGreet);&#125;String greeting() &#123; return &#x27;hello&#x27;;&#125;String arrowGreeting() =&gt; &#x27;hello&#x27;;int getAge() &#123; return 30;&#125;() &#123;&#125; // anonymous function about List It’s really similar with Java programming language. if you don’t declare the type of List then this is operated as the list as a dynamic typed. 12345678910111213void main() &#123; List untypedNames = [&#x27;chun-li&#x27;, &#x27;yoshi&#x27;, &#x27;mario&#x27;]; untypedNames.add(&#x27;luigi&#x27;); untypedNames.remove(&#x27;yoshi&#x27;); untypedNames.add(30); print(untypedNames); List&lt;String&gt; typedNames = [&#x27;chun-li&#x27;, &#x27;yoshi&#x27;, &#x27;mario&#x27;]; typedNames.add(&#x27;luigi&#x27;); typedNames.remove(&#x27;yoshi&#x27;); print(typedNames);&#125; about class 4. Creating a Flutter App in Android StudioFirst of all, You should turn on the android studio app and install the ‘flutter’ plugin. 1Double shift &gt; Search &#x27;plugins&#x27; &gt; Search flutter &gt; install the flutter app. 1File &gt; New &gt; New Flutter Project Flutter SDK path is the location of the git projecty you already cloned like from the below command. 1git clone https://github.com/flutter/flutter.git -b stable The below code is the main entry point of this Flutter app. as you learned before, main() method is the entry point of dart programming language. and It’s same with Java programming language. 12345// main.dartvoid main() &#123; runApp(const MyApp());&#125; MyApp class inherit StatelessWidget. What i am saying is MyApp is the root Widget in our Flutter app. and Flutter concept is all of components of flutter are consisted of Widgets. and Widget is represented by a class syntax of Dart language. 12345// main.dartclass MyApp extends StatelessWidget &#123; // ...&#125; The below code runs our own MaterialApp. 12345void main() &#123; runApp(MaterialApp( home: Text(&#x27;hey ninjas!&#x27;), ));&#125; 5. Scaffold &amp; AppBar WidgetsScaffold widget is going to allow us to implement a basic layout for our app. otherwords, Scaffold widget basically like a wrapper to a few different layout widgets things like the app bar, the body and also floating action button. You can get the more detail at the below link. https://api.flutter.dev/flutter/material/Scaffold-class.html in Flutter, if You want to insert some texts into widget, You should always use Text() widget 123456789101112131415161718void main() &#123; runApp(MaterialApp( home: Scaffold( appBar: AppBar( title: Text(&#x27;my first app&#x27;), centerTitle: true, ), body: Center( child: Text(&#x27;hello ninjas!&#x27;), ), floatingActionButton: FloatingActionButton( onPressed: () &#123; &#125;, child: Text(&#x27;click&#x27;), ), ), ));&#125; 6. Colours &amp; FontYou can get free google fonts from the below link https://fonts.google.com let’s create new folder named ‘fonts’ in your app root directory and please move your font files downloaded from fonts.google.com site in there. pubspec.yaml file is a configuration file about your flutter app. You should know one thing that the format in this file is really important. if you don’t keep the two spaces between each code then it will be not operated well. 7. Stateless Widgets &amp; Hot ReloadWe should consider when we create new custom widget whether is stateless widget or stateful widget. Stateless Widgets the state of the widget cannot change over time ex) Layout, Color Stateful Widgets the state of the widget can change over time ex) data the one of the reason why the widgets are separated as Stateless widget or Stateful widget is hot reload. The flutter should catch the change of the widgets for implementing hot-reload function. so that defining whether your widget is stateful or not is needed. The build() function in StatelessWidget is what is responsible for building up the widget tree inside the stateless home widgets so all of the stuff in build() function whenever we make a change to the code inside this widget tree flutter is going to detect that when we save it and it’s going to cause the build() function to rerun.that’s is hot reload in action. so if you create the widget inherited Stateless thing then the flutter will re run build() function when you save your code. 8. Images &amp; AssetsThe principle of Assets is same with font. You should change the pubspec.yaml file in your flutter app. 1234567891011121314class Home extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( // ... body: Center( child: Image.asset(&#x27;assets/space-1.jpg&#x27;) ), // ... ); &#125;&#125; 1234567flutter:## ... assets: - assets/ 9. Buttons &amp; IconsIcon is really simple 123456789101112131415161718class Home extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( // ... body: Center( child: Icon( Icons.airport_shuttle, color: Colors.lightBlue, size: 50.0, ) ), // ... ); &#125;&#125; RaisedButton means that itself has a shadow. it has a little shadow it’s raising it away from the page giving it that kind of 3D effect. 1234567891011121314151617181920class Home extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( // ... body: Center( child: RaisedButton( onPressed: () &#123; print(&#x27;you clicked me&#x27;); &#125;, child: Text(&#x27;click me&#x27;), color: Colors.lightBlue, ) ), // ... ); &#125;&#125; and Flatbutton doesn’t have a shawdow unlike RaisedButton. 12345678910111213141516171819class Home extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( // ... body: Center( child: FlatButton( onPressed: () &#123; print(&#x27;you clicked me&#x27;); &#125;, child: Text(&#x27;click me&#x27;), color: Colors.lightBlue, ) ), // ... ); &#125;&#125; if you want use a button with texts and icons then you should use RaisedButton.icon() widget or IconButton widget. 1234567891011121314151617181920class Home extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( // ... body: Center( child: RaisedButton.icon( onPressed: () &#123;&#125;, icon: Icon( Icons.mail ), label: Text(&#x27;mail me&#x27;), color: Colors.amber, ) ), // ... ); &#125;&#125; 1234567891011121314151617181920class Home extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( // ... body: Center( child: IconButton( onPressed: () &#123; print(&#x27;you clicked me&#x27;); &#125;, icon: Icon(Icons.alternate_email), color: Colors.amber, ) ), // ... ); &#125;&#125; 10. Containers &amp; Paddingthe container is only the same size as the widget inside it. if we don’t have a child which inside it then the container takes up the whole room available. but it has a child widget like a text widget then the container restricts itself to the size of that child widget. About EdgeInsets symmetric : top = bottom, left = right fromLTRB : each individual values all : having same value all of them. 1234567891011121314151617class Home extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( // ... body: Container( padding: EdgeInsets.fromLTRB(10.0, 20.0, 30.0, 40.0), margin: EdgeInsets.all(30.0), color: Colors.grey[400], child: Text(&#x27;hello&#x27;), ), // ... ); &#125;&#125; if you only need a padding option then you can type the code like the below. but you should know Padding widget doesn’t have another properties like margins, colors and so on. Padding widget is a padding itself. so You should don’t be misunderstanding. if you need to use all of the properties then you can use Container widget as you did it. 1234567891011121314class Home extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( // ... body: Padding( padding: EdgeInsets.all(90.0), child: Text(&#x27;hello&#x27;), ), // ... ); &#125;&#125; 11. RowsRows widget can align your widgets what should be located in Rows children property. It’s like a flexbox in CSS technique. main axis is the direction of the row. ad the cross axis is the perpendicular direction. MainAxisAlignment.start option is default.CrossAxisAlignment.start option is default also. 12345678910111213141516171819202122232425262728class Home extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( // ... body: Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text(&#x27;hello, world&#x27;), FlatButton( onPressed: () &#123;&#125;, color: Colors.amber, child: Text(&#x27;click me&#x27;), ), Container( color: Colors.cyan, padding: EdgeInsets.all(30.0), child: Text(&#x27;inside container&#x27;), ) ], ), // ... ); &#125;&#125; 12. ColumnsColumns axis is opposite with Rows one. the main axis in a column is vertical and the cross axis in a column is horizontal. 123456789101112131415161718192021222324252627282930313233343536373839class Home extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( // ... body: Column( mainAxisAlignment: MainAxisAlignment.end, crossAxisAlignment: CrossAxisAlignment.end, children: &lt;Widget&gt;[ Row( children: &lt;Widget&gt;[ Text(&#x27;hello,&#x27;), Text(&#x27; world&#x27;), ], ), Container( padding: EdgeInsets.all(20.0), color: Colors.cyan, child: Text(&#x27;one&#x27;), ), Container( padding: EdgeInsets.all(30.0), color: Colors.pinkAccent, child: Text(&#x27;two&#x27;), ), Container( padding: EdgeInsets.all(40.0), color: Colors.amber, child: Text(&#x27;three&#x27;), ), ], ), // ... ); &#125;&#125; 14. Expanded Widgetswe stil have second and third containers the same size which is the size of the content inside it but the first container now because it’s inside the expanded widget over here it’s taking up all the available space left over. flex property in Expanded widget is a portion of the width that we want it to take up. they’re basically fractions of the whole width that they take up. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Home extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( // ... body: Row( children: &lt;Widget&gt;[ Expanded( child: Image.asset(&#x27;assets/space-2.jpg&#x27;), flex: 3, ), Expanded( flex: 1, child: Container( padding: EdgeInsets.all(30.0), color: Colors.cyan, child: Text(&#x27;1&#x27;), ), ), Expanded( flex: 1, child: Container( padding: EdgeInsets.all(30.0), color: Colors.pinkAccent, child: Text(&#x27;2&#x27;), ), ), Expanded( flex: 1, child: Container( padding: EdgeInsets.all(30.0), color: Colors.amber, child: Text(&#x27;3&#x27;), ), ) ], ), // ... ); &#125;&#125; 15. Ninja ID ProjectI remember scaffold allows us to quickly make a layout for our app things like an app bar and the body all that kind of stuff. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293void main() &#123; runApp(MaterialApp( home: NinjaCard(), ));&#125;class NinjaCard extends StatelessWidget &#123; const NinjaCard(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( backgroundColor: Colors.grey[900], appBar: AppBar( title: Text(&#x27;Ninja ID Card&#x27;), centerTitle: true, backgroundColor: Colors.grey[850], elevation: 0.0, ), body: Padding( padding: EdgeInsets.fromLTRB(30.0, 40.0, 30.0, 0.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Center( child: CircleAvatar( backgroundImage: AssetImage(&#x27;assets/thumb.jpg&#x27;), radius: 40.0, ), ), Divider( height: 90.0, color: Colors.grey[800], ), Text( &#x27;NAME&#x27;, style: TextStyle( color: Colors.grey, letterSpacing: 2.0, ), ), SizedBox(height: 10.0), Text( &#x27;Chun-Li&#x27;, style: TextStyle( color: Colors.amberAccent[200], letterSpacing: 2.0, fontSize: 28.0, fontWeight: FontWeight.bold, ), ), SizedBox(height: 30.0), Text( &#x27;CURRENT NINJA LEVEL&#x27;, style: TextStyle( color: Colors.grey, letterSpacing: 2.0, ), ), SizedBox(height: 10.0), Text( &#x27;8&#x27;, style: TextStyle( color: Colors.amberAccent[200], letterSpacing: 2.0, fontSize: 28.0, fontWeight: FontWeight.bold, ), ), SizedBox(height: 30.0), Row( children: &lt;Widget&gt;[ Icon( Icons.email, color: Colors.grey[400], ), SizedBox(width: 10.0), Text( &#x27;chun.li@thenetninja.co.uk&#x27;, style: TextStyle( color: Colors.grey[400], fontSize: 18.0, letterSpacing: 1.0 ), ) ], ) ], ), ), ); &#125;&#125; 16. Stateful WidgetssetState() function takes in as an argument a function itself. this is a trigger of the build function sp then it rebuilt it with the new state. whenever we want to change the state or the data inside a state for Widget what we have to do is use setState() function. this is only way when we use set state that triggers the build function to rerun. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104class NinjaCard extends StatefulWidget &#123; const NinjaCard(&#123;Key? key&#125;) : super(key: key); @override State&lt;NinjaCard&gt; createState() =&gt; _NinjaCardState();&#125;class _NinjaCardState extends State&lt;NinjaCard&gt; &#123; int ninjaLevel = 0; @override Widget build(BuildContext context) &#123; return Scaffold( backgroundColor: Colors.grey[900], appBar: AppBar( title: Text(&#x27;Ninja ID Card&#x27;), centerTitle: true, backgroundColor: Colors.grey[850], elevation: 0.0, ), floatingActionButton: FloatingActionButton( onPressed: () &#123; setState(() &#123; ninjaLevel += 1; &#125;); &#125;, child: Icon(Icons.add), backgroundColor: Colors.grey[800], ), body: Padding( padding: EdgeInsets.fromLTRB(30.0, 40.0, 30.0, 0.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Center( child: CircleAvatar( backgroundImage: AssetImage(&#x27;assets/thumb.jpg&#x27;), radius: 40.0, ), ), Divider( height: 90.0, color: Colors.grey[800], ), Text( &#x27;NAME&#x27;, style: TextStyle( color: Colors.grey, letterSpacing: 2.0, ), ), SizedBox(height: 10.0), Text( &#x27;Chun-Li&#x27;, style: TextStyle( color: Colors.amberAccent[200], letterSpacing: 2.0, fontSize: 28.0, fontWeight: FontWeight.bold, ), ), SizedBox(height: 30.0), Text( &#x27;CURRENT NINJA LEVEL&#x27;, style: TextStyle( color: Colors.grey, letterSpacing: 2.0, ), ), SizedBox(height: 10.0), Text( &#x27;$ninjaLevel&#x27;, style: TextStyle( color: Colors.amberAccent[200], letterSpacing: 2.0, fontSize: 28.0, fontWeight: FontWeight.bold, ), ), SizedBox(height: 30.0), Row( children: &lt;Widget&gt;[ Icon( Icons.email, color: Colors.grey[400], ), SizedBox(width: 10.0), Text( &#x27;chun.li@thenetninja.co.uk&#x27;, style: TextStyle( color: Colors.grey[400], fontSize: 18.0, letterSpacing: 1.0 ), ) ], ) ], ), ), ); &#125;&#125; 17. Lists of Data1234567891011121314151617181920212223242526272829303132333435void main() &#123; runApp(MaterialApp( home: QuoteList(), ));&#125;class QuoteList extends StatefulWidget &#123; const QuoteList(&#123;Key? key&#125;) : super(key: key); @override _QuoteListState createState() =&gt; _QuoteListState();&#125;class _QuoteListState extends State&lt;QuoteList&gt; &#123; List&lt;String&gt; quotes = [ &#x27;Be yourself; everyone else is already taken&#x27;, &#x27;I have nothing to declare except my genius&#x27;, &#x27;The truth is rarely pure and never simple&#x27; ]; @override Widget build(BuildContext context) &#123; return Scaffold( backgroundColor: Colors.grey[200], appBar: AppBar( title: Text(&#x27;Awesome Quotes&#x27;), backgroundColor: Colors.redAccent, ), body: Column( children: quotes.map((quote) =&gt; Text(quote)).toList(), ), ); &#125;&#125; 18. Custom Classes1234567891011// Quote.dartclass Quote &#123; String text; String author; Quote(&#123; this.text = &quot;&quot;, this.author = &quot;&quot; &#125;);&#125;Quote myQuote = Quote(text: &#x27;this is the qite text&#x27;, author: &#x27;oscar wilde&#x27;); 1234567891011121314151617181920212223// main.dart// ...class _QuoteListState extends State&lt;QuoteList&gt; &#123; List&lt;Quote&gt; quotes = [ Quote(author: &#x27;Osca Wilde&#x27;, text: &#x27;Be yourself; everyone else 1&#x27;), Quote(author: &#x27;Osca Wilde&#x27;, text: &#x27;Be yourself; everyone else 2&#x27;), Quote(author: &#x27;Osca Wilde&#x27;, text: &#x27;Be yourself; everyone else 3&#x27;) ]; @override Widget build(BuildContext context) &#123; return Scaffold( // ... body: Column( children: quotes.map((quote) =&gt; Text(&#x27;$&#123;quote.text&#125; - $&#123;quote.author&#125;&#x27;)).toList(), ), ); &#125;&#125; 19. Cardshttps://api.flutter.dev/flutter/material/Card-class.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344class _QuoteListState extends State&lt;QuoteList&gt; &#123; // ... Widget quoteTemplate(quote) &#123; return Card( margin: EdgeInsets.fromLTRB(16.0, 16.0, 16.0, 0.0), child: Padding( padding: const EdgeInsets.all(12.0), child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ Text( quote.text, style: TextStyle( fontSize: 18.0, color: Colors.grey[600], ), ), SizedBox(height: 6.0), Text( quote.author, style: TextStyle( fontSize: 14.0, color: Colors.grey[800] ), ) ], ), ), ); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( // ... body: Column( children: quotes.map((quote) =&gt; quoteTemplate(quote)).toList(), ), ); &#125;&#125; 20. Extracting Widgets1234567891011121314151617181920212223242526272829303132333435363738import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:quotes/quote.dart&#x27;;class QuoteCard extends StatelessWidget &#123; final Quote quote; QuoteCard(&#123; required this.quote &#125;); @override Widget build(BuildContext context) &#123; return Card( margin: EdgeInsets.fromLTRB(16.0, 16.0, 16.0, 0.0), child: Padding( padding: const EdgeInsets.all(12.0), child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ Text( quote.text, style: TextStyle( fontSize: 18.0, color: Colors.grey[600], ), ), SizedBox(height: 6.0), Text( quote.author, style: TextStyle( fontSize: 14.0, color: Colors.grey[800] ), ) ], ), ), ); &#125;&#125; 1234567891011121314151617181920import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:quotes/quote.dart&#x27;;import &#x27;quote_card.dart&#x27;;// ...class _QuoteListState extends State&lt;QuoteList&gt; &#123; // ... @override Widget build(BuildContext context) &#123; return Scaffold( // ... body: Column( children: quotes.map((quote) =&gt; QuoteCard(quote: quote)).toList(), ), ); &#125;&#125; 21. Function Arguments1234567891011121314151617181920// quote_card.dartclass QuoteCard extends StatelessWidget &#123; final Quote quote; final Function() delete; QuoteCard(&#123; required this.quote, required this.delete &#125;); @override Widget build(BuildContext context) &#123; return Card( // ... FlatButton.icon( onPressed: delete, label: Text(&#x27;delete quote&#x27;), icon: Icon(Icons.delete) // ... ); &#125;&#125; 1234567891011121314class _QuoteListState extends State&lt;QuoteList&gt; &#123; // ... @override Widget build(BuildContext context) &#123; // ... delete: () &#123; setState(() &#123; quotes.remove(quote); &#125;); &#125; // ... &#125;&#125; 23. Maps &amp; RoutingNavigator.pushNamed() is named because we’re going to supply a named round we’re going to use the name of one o the routes to that router and then it’s called push because essentially what we do is push another screen on top of the screen. the screen is still going to exist underneath it’s just that we’re pushing another one on top of it. It is important concept to understand and we are going to be doing more routing as we go through the rest of this course so that we can see different ways to push and pop routes on and off this kind of stack and manage our routes in an efficient way. 24. Widget Lifecycle Stateless State does not change over time build function only runs once Stateful State Can change over time setState() triggers the build function initState() called only once when the widget is created subscribe to streams or any object that could change our widget data build() builds the widget tree a build is triggered every time we use setState() dispose() when the widget / set object is removed 25. Asynchronous Code123456789101112131415161718192021222324252627282930class _ChooseLocationState extends State&lt;ChooseLocation&gt; &#123; void getData() async &#123; // simulate network request for a username String username = await Future.delayed(Duration(seconds: 3), () &#123; return &#x27;yoshi&#x27;; &#125;); // simulate network request to get bio of the username String bio = await Future.delayed(Duration(seconds: 2), () &#123; return &#x27;vegan, musician &amp; egg collector&#x27;; &#125;); print(&#x27;$username - $bio&#x27;); &#125; int counter = 0; @override void initState() &#123; super.initState(); getData(); print(&#x27;hey there&#x27;); &#125; // ... &#125; 26. Flutter Packages (http) https://pub.dev/flutter 1234dependencies: flutter: sdk: flutter http: ^0.12.0+2 1234567891011class _LoadingState extends State&lt;Loading&gt; &#123; void getData() async &#123; Response response = await get(&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;); Map data = jsonDecode(response.body); print(data); print(data[&#x27;title&#x27;]); &#125; // ...&#125; 28. WorldTime Custom Classthe funcion with async is going to take some time to do it might take two seconds today because we have to go out and reach the data and bring it back. you should remember if we run an asynchronous function this doesn’t stop the code from carrying on. it just does this in the background and then the rest of the code carries on. to solve what it would be nice to do is maybe put await keyword in front of an asynchronous function. then we’re waiting for this to finish before it carries on. for that we should return specific type that we need in an asynchronous function if we want to use the await keyword in front of a cuson aynchronous function we have to place the Future keyword with return type. 12345678910111213141516171819202122232425262728293031// world_time.dartclass WorldTime &#123; String location; // location name for the UI late String time; // the time in that location String flag; // url to an asset flag icon String url; // location url for api endpoint WorldTime(&#123; required this.location, required this.flag, required this.url &#125;); Future&lt;void&gt; getTime() async &#123; // make the request Response response = await get(&#x27;http://worldtimeapi.org/api/timezone/$url&#x27;); Map data = jsonDecode(response.body); print(data); // get properties from data String datetime = data[&#x27;datetime&#x27;]; String offset = data[&#x27;utc_offset&#x27;].substring(1, 3); // print(datetime); // print(offset); // create DateTime object DateTime now = DateTime.parse(datetime); now.add(Duration(hours: int.parse(offset))); // set the time property time = now.toString(); &#125;&#125; 1234567891011121314151617181920212223242526272829class _LoadingState extends State&lt;Loading&gt; &#123; String time = &#x27;loading&#x27;; void setupWorldTime() async &#123; WorldTime instance = WorldTime(location: &#x27;Berlin&#x27;, flag: &#x27;germany.png&#x27;, url: &#x27;Europe/Berlin&#x27;); await instance.getTime(); print(instance.time); setState(() &#123; time = instance.time; &#125;); &#125; @override void initState() &#123; super.initState(); setupWorldTime(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: Padding( padding: EdgeInsets.all(50.0), child: Text(time), ), ); &#125;&#125; referencehttps://github.com/iamshaunjp/flutter-beginners-tutorial","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://kidongyun.github.io/tags/Flutter/"},{"name":"Dart","slug":"Dart","permalink":"http://kidongyun.github.io/tags/Dart/"}]},{"title":"Managing api version in Spring with HandlerMapping","slug":"2021-12-09-api-version","date":"2021-12-12T02:38:54.000Z","updated":"2022-06-01T06:22:52.913Z","comments":true,"path":"2021/12/12/","link":"","permalink":"http://kidongyun.github.io/2021/12/12/","excerpt":"","text":"HandlerMappingYou should understand what HandlerMapping is for before building api version technique in your project. The process from taking the client requests to returning the response in Spring framework is roughly same with the below. HandlerMapping HandlerAdapter ViewResolver // It’s the post processing Furthermore, You also should know about DispatcherServlet. It’s offered from Spring Framework and This object control all of the requests and the responses in Spring. so what i am saying is HandlerMapping, HandlerAdapter and ViewResolver will be controlled by DispatcherServlet. Actually, DispatcherServlet is the sub-class of the Servlet offered from Java official SDK. The purpose of HandlerMapping is for connecting between each the urls in request of clients and each the controllers to process for the request. and HandlerMapping will be started when the your Spring project is launched. and After the setting of HandlerMapping, All of urls in requests will be mapped with the controllers managed by HandlerMapping. The sort of Implementation of HandlerMapping.Most of Spring developers will use RequestMappingHandlerMapping via @RequestMapping annotation.It is the famous one of implementation of HandlerMapping. but I guess you wouldn’t know about the fact Spring Framework offers many kinds of implementation of HandlerMapping not only RequestMappingHandlerMapping. I will introduce them briefly. BeanNameUrlHandlerMapping The policy of it is the bean name is used as request urls. This strategy of HandlerMapping has the one condition you should know before you use it. That is the bean name should always include the slash (“/“) in front of itself. 1234@Bean(&quot;/accounts&quot;)public AccountController accountController() &#123; return new AccountController();&#125; SimpleUrlHandlerMapping This strategy you can initialize the relation between request urls and the controllers when this HandlerMapping is created with Map data type. (Map type express the key-value data type) 12345678910@BeanSimpleUrlHandlerMapping urlHandlerMapping() &#123; SimpleUrlHandlerMapping simpleHandlerMapping = new SimpleUrlHandlerMapping(); Map&lt;String, Object&gt; mapping = new HashMap&lt;&gt;(); mapping.put(&quot;/accounts&quot;, accountController()); simpleUrlHandlerMapping.setUrlMap(mapping); return simpleUrlHandlerMapping;&#125; RequestMappingHandlerMapping It is most famous one of implementation of HandlerMapping. You would use this one if you haven’t considered HandlerMapping ever. This implementation of HandlerMapping strategy is relation between urls and controllers are mapped by @RequestMapping annotation. This strategy might be used Java Reflection technique to map them via @RequestMapping. and This strategy also offers another annotation to map like @PostMapping, @GetMapping … and so on. but You should know they are based on @RequestMapping. I mean They are created via @RequestMapping. 12345@Controller@RequestMapping(&quot;/accounts&quot;)public class AccountController &#123;&#125; Api Versioning with customizing HandlerMappingWe will customize RequestMappingHandlerMapping to control api version as we want. api version information is can located any where in requests like the header, the parameters or in urls. but just only adding the version data into urls cannot control api version with flexibility. for example when you call the api that doesn’t be built in your system then the clients will take the response with 404 http status code. to solve this inconvenience, how about changing to the latest api version when api version requested is not existed. We have to customize RequestMappingHandlerMapping to implement it. the below code is my answer of considering about this problem. I created totally 5 objects to implement it as you can watch in the below. ApiVersion annotation is only for putting the api version in there. We will not use the way putting api version i said before like the header, the parameters or in urls of requests. because these way can’t overlapped between each same apis. 12345@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)public @interface ApiVersion &#123; int value() default 1;&#125; Version class is just a domain class only for expressing Version itself. This class implements Comparable interface. It means the function that compare with same type is needed in our business. 1234567891011121314public class Version implements Comparable&lt;Version&gt; &#123; public static final int MAX_VERSION = 9999999; private final int version; public Version(int version) &#123; this.version = version; &#125; @Override public int compareTo(Version other) &#123; return Integer.compare(this.version, other.version); &#125;&#125; VersionRange class has two Version typed variables. It is to show the api version ranges acceptable in your system. for example if one api is created from v1 to v10, then VersionRange class for this api will have the data like the below. from = 1 to = 10 1234567891011121314151617181920212223242526public class VersionRange &#123; private Version from; private Version to; public VersionRange(int from, int to) &#123; this.from = new Version(from); this.to = new Version(to); &#125; public boolean includes(int other) &#123; Version otherVersion = new Version(other); int fromCondition = from.compareTo(otherVersion); int toCondition = to.compareTo(otherVersion); if(fromCondition &lt;= 0 &amp;&amp; toCondition &gt;= 0) &#123; return true; &#125; else &#123; return false; &#125; &#125; public int compareTo(VersionRange other) &#123; return this.from.compareTo(other.from); &#125;&#125; and lastly the below two classes ApiVersionRequestMappingHandlerMapping, ApiVersionRequestCondition have our main business logic. ApiVersionRequestCondition.getMatchingCondition() method always is called whenever client requests are occured. request parameter in this method have the information associated with the client requests like the url or the parameters and so on. if this method returns same ApiVersionRequestCondition object for same client requests then ApiVersionRequestCondition.compareTo() method is called. and compareTo() method will decide what condition is best to each requests among duplicated ApiVersionRequestCondition. 123456789101112131415161718192021public class ApiVersionRequestMappingHandlerMapping extends RequestMappingHandlerMapping &#123; @Override protected RequestCondition&lt;?&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) &#123; ApiVersion typeAnnotation = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); return createCondition(typeAnnotation); &#125; @Override protected RequestCondition&lt;?&gt; getCustomMethodCondition(Method method) &#123; ApiVersion methodAnnotation = AnnotationUtils.findAnnotation(method, ApiVersion.class); return createCondition(methodAnnotation); &#125; private RequestCondition&lt;?&gt; createCondition(ApiVersion apiVersion) &#123; if (apiVersion == null) &#123; return null; &#125; return new ApiVersionRequestCondition(apiVersion.value(), Version.MAX_VERSION); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class ApiVersionRequestCondition extends AbstractRequestCondition&lt;ApiVersionRequestCondition&gt; &#123; private final Set&lt;VersionRange&gt; versions; public ApiVersionRequestCondition(int from, int to) &#123; this(versionRange(from, to)); &#125; public ApiVersionRequestCondition(Collection&lt;VersionRange&gt; versions) &#123; this.versions = Set.copyOf(versions); &#125; private static Set&lt;VersionRange&gt; versionRange(int from, int to) &#123; HashSet&lt;VersionRange&gt; versionRanges = new HashSet&lt;&gt;(); if(from &gt; 0) &#123; int toVersion = (to &gt; 1) ? to : Version.MAX_VERSION; VersionRange versionRange = new VersionRange(from, toVersion); versionRanges.add(versionRange); &#125; return versionRanges; &#125; @Override public ApiVersionRequestCondition combine(ApiVersionRequestCondition other) &#123; log.debug(&quot;version combining: &#123;&#125; + &#123;&#125;&quot;, this, other); Set&lt;VersionRange&gt; newVersions = new LinkedHashSet&lt;&gt;(this.versions); newVersions.addAll(other.versions); return new ApiVersionRequestCondition(newVersions); &#125; @Override public ApiVersionRequestCondition getMatchingCondition(HttpServletRequest request) &#123; String accept = request.getRequestURI(); Pattern regexPattern = Pattern.compile(&quot;(\\\\/api\\\\/v)(\\\\d+)(\\\\/).*&quot;); Matcher matcher = regexPattern.matcher(accept); if(matcher.matches()) &#123; int version = Integer.parseInt(matcher.group(2)); for(VersionRange versionRange : versions) &#123; if(versionRange.includes(version)) &#123; return this; &#125; &#125; &#125; return null; &#125; @Override public int compareTo(ApiVersionRequestCondition other, HttpServletRequest request) &#123; if(versions.size() == 1 &amp;&amp; other.versions.size() == 1) &#123; return versions.stream().findFirst().get().compareTo(other.versions.stream().findFirst().get()) * -1; &#125; return 0; &#125; @Override protected Collection&lt;?&gt; getContent() &#123; return versions; &#125; @Override protected String getToStringInfix() &#123; return &quot; &amp;&amp; &quot;; &#125;&#125; finally you should put api version with asterisk (“*”) in each urls. It will make the overlapped ApiversionRequestCondition when getMatchingCondition() method is called. 1@RequestMapping(&quot;/api/v*/accounts&quot;) and Don’t forget to register ApiVersionRequestMappingHandlerMapping to notice to Spring. 12345678@Configuration@EnableWebMvcpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Bean public RequestMappingHandlerMapping requestMappingHandlerMapping() &#123; return new ApiVersionRequestMappingHandlerMapping(); &#125;&#125; if you use latest Spring boot version, the below option is required by the spring policy changed. 1spring.main.allow-bean-definition-overriding=true","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"HandlerMapping","slug":"HandlerMapping","permalink":"http://kidongyun.github.io/tags/HandlerMapping/"}]},{"title":"Hexo Installation Document","slug":"2021-12-05-hexo","date":"2021-12-05T02:38:54.000Z","updated":"2022-06-01T06:20:46.992Z","comments":true,"path":"2021/12/05/","link":"","permalink":"http://kidongyun.github.io/2021/12/05/","excerpt":"","text":"기본테마로 설치hexo-cli 설치1&gt; yarn global add hexo-cli workspace 생성1&gt; hexo init devlog workspace 로 이동1&gt; cd devlog node-modules 가져오기1&gt; npm install node-modules 가져오기 (2)1&gt; yarn hexo 에서 git 으로 푸시하려면 아래 모듈 필요1&gt; npm install --save hexo-deployer-git _config.yml 수정1234deploy: type: git repo: https://github.com/kidongYun/kidongYun.github.io.git branch: master 파일 생성 후 배포1&gt; hexo deploy --generate 테마로 설치1&gt; git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman theme 안에있는 _config.yml.example -&gt; _config.yml 로 변경_config.yml 수정 테마로 변경1theme: hueman 테마에서 제공하는 검색 기능 (Insight earch)를 이용하기 위해서는 hexo-generator-json-content를 설치해야 합니다. npm 을 이용해서 설치합니다.1&gt; npm install -S hexo-generator-json-content LaTeX 적용hexo renderer 이게 JAVASCRIPT 를 Markdown 으로 바꿔주는 모듈이라고 하는데 그걸 default로 쓰이는 것 말고 따른걸로 바꿔야 하나봐. 1&gt; npm uninstall hexo-renderer-marked --save 1&gt; npm install hexo-renderer-kramed --save “/node_modules/hexo-renderer-kramed/lib/renderer.js” 여기로 가서 12345// Change inline math rulefunction formatText(text) &#123; // Fit kramed&#x27;s rule: $$ + \\1 + $$ return text.replace(/`\\$(.*?)\\$`/g, &#x27;$$$$$1$$$$&#x27;);&#125; 이부분을 1234// Change inline math rulefunction formatText(text) &#123; return text;&#125; 이렇게 변경 hexo-math 라이브러리가 이제 지원되지 안흔다고 함 이거를 제거 1&gt; npm uninstall hexo-math --save 대신에 아래 라이브러리를 설치 1&gt; npm install hexo-renderer-mathjax --save CDN 서비스를 더이상 mathjax 자체적으로는 제공하지 않는다고 함. 그래서 아래 경로에 있는 파일에서 cdn 경로를 cloudfare 로 변경. /node_modules/hexo-renderer-mathjax/mathjax.html 1&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt; 설정은 끝났고 mathjax 를 쓰고 싶다면 post header 부분에 아래처럼 mathjax: true 설정을 넣어주면 된다. 123456---title: Testing Mathjax with Hexocategory: Uncategorizeddate: 2017/05/03mathjax: true---","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://kidongyun.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"http://kidongyun.github.io/tags/Hexo/"}]},{"title":"Homebrew","slug":"2021-12-05-homebrew","date":"2021-12-05T02:38:54.000Z","updated":"2022-06-01T06:21:37.378Z","comments":true,"path":"2021/12/05/","link":"","permalink":"http://kidongyun.github.io/2021/12/05/","excerpt":"","text":"Installing Homebrew. 1&gt; /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; Installing git 1&gt; brew install git Installing docker 1&gt; brew install --cask docker Installing node 1brew install node Installing yarn 1brew install yarn","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Brew","slug":"Brew","permalink":"http://kidongyun.github.io/tags/Brew/"},{"name":"Mac","slug":"Mac","permalink":"http://kidongyun.github.io/tags/Mac/"}]},{"title":"Exception handling in stream","slug":"2021-11-18-exception-handling-in-stream","date":"2021-11-18T02:38:54.000Z","updated":"2022-06-01T06:20:15.397Z","comments":true,"path":"2021/11/18/","link":"","permalink":"http://kidongyun.github.io/2021/11/18/","excerpt":"","text":"123public interface ExceptionFunction&lt;T, R&gt; &#123; R apply(T t) throws Exception;&#125; 1234567891011public class ExceptionUtil &#123; public static &lt;T, R&gt; Function&lt;T, R&gt; wrap(ExceptionFunction&lt;T, R&gt; f) &#123; return (T t) -&gt; &#123; try &#123; return f.apply(t); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;; &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"The summary of git flow commands","slug":"2021-11-15-git-flow-command","date":"2021-11-15T02:38:54.000Z","updated":"2022-06-01T06:19:22.215Z","comments":true,"path":"2021/11/15/","link":"","permalink":"http://kidongyun.github.io/2021/11/15/","excerpt":"","text":"git flow initgit flow 초기 설정 작업을 진행한다. feature, develop 등에 해당하는 브랜치들을 어떻게 네이밍 할 것인지 각 회사의 룰에 맞게 변경이 가능하다. 기본 네이밍 방식대로 따르고 싶다면 계속 엔터 눌러주면 된다. git flow feature start feature 브랜치를 생성하고싶다면 위처럼 커맨드를 날리면 된다. git flow init 시에 설정한 feature 브랜치 네이밍 뒤에 원하는 붙어서 브랜치가 생성된다. feature/ git flow feature publish publish 명령을 수행하면 git push 와 동일한 형태로 remote repository 에 작업 커밋들을 푸쉬한다. git flow feature pull origin 반대로 remote repository 에 있는 커밋 내역들을 local 로 가져오고 싶다면 위와 같이 명령어를 사용하면 된다. git flow feature finish feature 작업이 끝나서 develop 브랜치에 묻고 마무리해야 할 때는 finish 커맨드를 사용하면 보다 손쉬워진다.이 커맨드가 작업해주는 내용은 다음과 같다. git merge feature/ // develop 기준으로 feature 브랜치를 머지한다 feature 브랜치 제거 git flow release start 이 명령어를 치면 release/ 에 해당하는 릴리즈 브랜치가 생성된다. git flow release publish feature 브랜치와 마찬가지로 publish 명령어를 치게되면 remote repository 로 커밋 내역을 푸시한다. git flow release finish git flow 에서 가장 많은 작업을 해주는 명령어 같다. 이 명령어를 사용하게되면 아래와 같은 작업들이 실행된다.-n 옵션을 주면 no tag 의 의미로 git tag 를 사용하지 않는다. release 브랜치를 master 브랜치에 머지 release 버전을 태그로 생성 release 브랜치를 develop 브랜치에 머지 release 브랜치 제거 tag 같이하는 방법 git flow release finish 1.11.2 -m ‘Tag 1.11.2’ develop push master push git push —tags git flow release delete release branch 제거 git flow hotfix start release 브랜치와 사용방법은 거의 동일하지만 hotfix 라는 점에서 사용 용도가 다르다. 이 명령어를 치게되면 hotfix/ 브랜치가 생성되고 체크아웃된다. git flow hotfix finish 이 명령어를 사용하게 되면 아래와 같은 작업들이 실행된다. hotfix 브랜치를 master 브랜치에 머지 hotfix 버전을 태그로 생성 hotfix 브랜치를 develop 브랜치에 머지 hotfix 브랜치 제거","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://kidongyun.github.io/tags/Git/"},{"name":"Git Flow","slug":"Git-Flow","permalink":"http://kidongyun.github.io/tags/Git-Flow/"}]},{"title":"Microservice Architecture of Spring","slug":"2021-11-13-spring-msa","date":"2021-11-13T02:38:54.000Z","updated":"2022-06-01T06:19:07.030Z","comments":true,"path":"2021/11/13/","link":"","permalink":"http://kidongyun.github.io/2021/11/13/","excerpt":"","text":"TDD 가 개발자에게 좋은 이유여러 이유가 있지만 가장 중요한 점은 TDD로 요구사항에 대해 더 깊이 있게 생각할 수 있다는 점입니다. 테스트 코드를 먼저 작성하면 특정 상황에서 코드가 어떻게 동작할지 생각하게 됩니다. 이런 과정에서 애매한 요구사항은 명확히 하고, 유효하지 않은 요구사항은 거부할 수 있습니다. 곱셈 하는 예제 프로그램을 만들어 보자123456789101112131415161718192021222324252627282930313233public class Multiplication &#123; private int factorA; private int factorB; private int result; public Multiplication(int factorA, int factorB) &#123; this.factorA = factorA; this.factorB = factorB; this.result = factorA * factorB; &#125; public int getFactorA() &#123; return factorA; &#125; public int getFactorB() &#123; return factorB; &#125; public int getResult() &#123; return result; &#125; @Override public String toString() &#123; return &quot;Multiplication&#123;&quot; + &quot;factorA=&quot; + factorA + &quot;, factorB=&quot; + factorB + &quot;, result(A*B)=&quot; + result + &#x27;&#125;&#x27;; &#125;&#125; 123456789public interface MultiplicationService &#123; /** * 두 개의 무작위 인수를 담은 &#123;@link Multiplication&#125; 객체를 생성한다. * 무작위로 생성되는 숫자의 범위는 11~99 * * @return 무작위 인수를 담은 &#123;@link Multiplication&#125; 객체 */ Multiplication createRandomMultiplication();&#125; 123456public interface RandomGeneratorService &#123; /** * @return 무작위로 만든 11 이상 99 이하의 인수 */ int generateRandomFactor();&#125; 곱셈을 계산하는 서비스 (MultiplicationService) 내에서 숫자를 무작위로 생성한다면 테스트를 작성하기 어려워지기 때문에 RandomGeneratorService 인터페이스를 두어서 숫자 생성 부분만 따로 만드는 것입니다. TDD 를 따르기 위해서 테스트 코드를 먼저 작성해보자. 1234567891011121314151617181920212223@RunWith(SpringRunner.class)@SpringBootTestclass MultiplicationServiceTest &#123; @MockBean private RandomGeneratorService randomGeneratorService; @Autowired private MultiplicationService multiplicationService; @Test public void createRandomMultiplicationTest() &#123; // given (randomGeneratorService가 처음에 50, 나중에 30을 반환하도록 설정) given(randomGeneratorService.generateRandomFactor()).willReturn(50, 30); // when Multiplication multiplication = multiplicationService.createRandomMultiplication(); // assert assertThat(multiplication.getFactorA()).isEqualTo(50); assertThat(multiplication.getFactorB()).isEqualTo(30); assertThat(multiplication.getResult()).isEqualTo(1500); &#125;&#125; 이 테스트에서 중요한건 @MockBean 입니다. 이 어노테이션은 스프링이 RandomGeneratorService 인터페이스에 맞는 구현 클래스를 찾아서 주입하는 대신 Mock 객체를 주입하는 것을 의미한다. 아직 MultiplicationService 의 구현체를 만들지 않았기 때문에 테스트 결과는 실패합니다. 이게 바로 TDD의 요점입니다. 1234567891011121314151617181920212223@RunWith(SpringRunner.class)@SpringBootTestclass MultiplicationServiceTest &#123; @MockBean private RandomGeneratorService randomGeneratorService; @Autowired private MultiplicationService multiplicationService; @Test public void createRandomMultiplicationTest() &#123; // given (randomGeneratorService가 처음에 50, 나중에 30을 반환하도록 설정) given(randomGeneratorService.generateRandomFactor()).willReturn(50, 30); // when Multiplication multiplication = multiplicationService.createRandomMultiplication(); // assert assertThat(multiplication.getFactorA()).isEqualTo(50); assertThat(multiplication.getFactorB()).isEqualTo(30); assertThat(multiplication.getResult()).isEqualTo(1500); &#125;&#125; TDD의 이점을 정리해보자 테스트를 작성하면서 요구사항을 코드로 바꿀 수 있습니다. 요구사항을 살펴보면서 필요한 것과 필요하지 않은 것에 대해 생각해볼 수 있습니다. 지금까진 우리의 첫 번째 요구사항인 무작위로 곱셈을 생성하는 서비스만 있으면 됩니다. 테스트 가능한 코드를 만들게 됩니다. 구현하는 클래스를 먼저 작성하게 된다면 무작위 생성 로직을 그 안에 넣었을 가능성이 높고 그렇게 되면 그 이후에 테스트하기가 굉장히 어려워진다. 테스트 코드를 미리 작성한 덕에 테스트 코드를 더 작성하기 쉬운 구조로 구성할 수 있습니다. 중요한 로직에 초점을 맞추고 나머지는 나중에 구현할 수가 있습니다. 무작위 숫자 생성을 개발하고 테스트할 때 RandomGeneratorService 의 구현체를 작성할 필요가 없습니다. @SpringBootTest 를 남용하지 말자.SpringRunner 와 @SpringBootTest 어노테이션은 애플리케이션 컨텍스트를 초기화하고 필요한 객체를 주입합니다. 다행이 컨텍스트는 캐싱이 되어 재사용이 가능해 테스트 당 한 번만 로딩됩니다. 그러나 여기 테스트 처럼 하나의 테스트만 필요할 때는 어플리케이션 컨텍스트를 초기화해서 사용하는 것 보다 그냥 해당 객체를 직접 구현해서 테스트하는 것이 보다 효율적입니다. 12345678910111213141516171819202122public class RandomGeneratorServiceImplTest &#123; private RandomGeneratorServiceImpl randomGeneratorServiceImpl; @Before public void setUp() &#123; randomGeneratorServiceImpl = new RandomGeneratorServiceImpl(); &#125; @Test public void generateRandomFactorIsBetweenExpectedLimits() throws Exception &#123; // 무작위 숫자를 생성 List&lt;Integer&gt; randomFactors = IntStream.range(0, 1000) .map(i -&gt; randomGeneratorServiceImpl.generateRandomFactor()) .boxed() .collect(Collectors.toList()); // 적당히 어려운 계산을 만들기 위해 // 생성한 인수가 11~99 범위에 있는지 확인 assertThat(randomFactors).containsOnlyElementsOf(IntStream.range(11, 100) .boxed().collect(Collectors.toList())); &#125;&#125; RandomGeneratorServiceImpl 은 어플리케이션 컨텍스트를 불러오지 않고 바로 객체를 구현해서 테스트를 진행하였다. 위 테스트가 통과될 수 있도록 실제 소스 코드를 작성하자. 123456789public class RandomGeneratorServiceImpl implements RandomGeneratorService &#123; final static int MINIMUM_FACTOR = 11; final static int MAXIMUM_FACTOR = 99; @Override public int generateRandomFactor() &#123; return new Random().nextInt((MAXIMUM_FACTOR - MINIMUM_FACTOR) + 1) + MINIMUM_FACTOR; &#125;&#125; MultiplicationServiceImplTest 에도 위처럼 어플리케이션 컨텍스트를 사용하지 않는 방식으로 테스트 코드를 추가해보자. 123456789101112131415161718192021222324252627public class MultiplicationServiceImplTest &#123; private MultiplicationServiceImpl multiplicationServiceImpl; @Mock private RandomGeneratorService randomGeneratorService; @Before public void setUp() &#123; // 목 객체를 초기화합니다. MockitoAnnotations.initMocks(this); multiplicationServiceImpl = new MultiplicationServiceImpl(randomGeneratorService); &#125; @Test public void createRandomMultiplicationTest() &#123; // given (목 객체가 처음에 50, 나중에 30 을 반환하도록 설정) given(randomGeneratorService.generateRandomFactor()).willReturn(50, 30); // when Multiplication multiplication = multiplicationServiceImpl.createRandomMultiplication(); // assert assertThat(multiplication.getFactorA()).isEqualTo(50); assertThat(multiplication.getFactorB()).isEqualTo(30); assertThat(multiplication.getResult()).isEqualTo(1500); &#125;&#125; @MockBean 대신 @Mock 을 사용해 목 객체를 생성하였다. 어플리케이션 컨텍스트를 띄우지 않으니 빈을 사용하지 않기 때문이다. 도메인은 설계하자 Multiplication : 곱셈의 인수와 연산을 포함 User : 곱셈 문제를 푸는 사용자를 식별 MultiplicationResultAttempt : Multiplication 과 User 의 참조를 포함하고 사용자가 제출한 값과 채점 결과를 포함. 1234567891011121314151617/** * 애플리케이션에서 곱셈을 나타내는 클래스 (a * b) */@RequiredArgsConstructor@Getter@ToString@EqualsAndHashCodepublic class Multiplication &#123; // 두 인수 private final int factorA; private final int factorB; // JSON (역)직렬화를 위한 빈 생성자 Multiplication() &#123; this(0, 0); &#125;&#125; 123456789101112131415/** * 사용자 정보를 저장하는 클래스 */@RequiredArgsConstructor@Getter@ToString@EqualsAndHashCodepublic final class User &#123; private final String alias; // JSON (역)직렬화를 위한 빈 생성자 protected User() &#123; alias = null; &#125;&#125; 12345678910111213141516@RequiredArgsConstructor@Getter@ToString@EqualsAndHashCodepublic class MultiplicationResultAttempt &#123; private final User user; private final Multiplication multiplication; private final int resultAttempt; // JSON (역)직렬화를 위한 빈 생성자 MultiplicationResultAttempt() &#123; user = null; multiplication = null; resultAttempt = -1; &#125;&#125; 이제 필요한 객체들의 책임 (= 비즈니스 로직) 을 생각해 봅시다. 요구사항을 고려해보면 앞으로 구현해야할 책임들은 아래와 같습니다. 제출한 답안의 정답 여부 확인 적당히 어려운 곱셈 만들어내기 ‘제출한 답안의 정답 여부 확인’ 책임을 MultiplicationService 인터페이스에 넣고, 해당 책임을 테스트하는 코드를 작성합니다. 12345678public interface MultiplicationService &#123; // ... /** * @return 곱셈 계산 결과가 맞으면 true, 아니면 false */ boolean checkAttempt(final MultiplicationResultAttempt resultAttempt);&#125; 12345678910111213141516171819202122232425262728293031public class MultiplicationServiceImplTest &#123; // ... @Test public void checkCorrectAttemptTest() &#123; // given Multiplication multiplication = new Multiplication(50, 60); User user = new User(&quot;john_doe&quot;); MultiplicationResultAttempt attempt = new MultiplicationResultAttempt(user, multiplication, 3000); // when boolean attemptResult = multiplicationServiceImpl.checkAttempt(attempt); // then assertThat(attemptResult).isTrue(); &#125; @Test public void checkWrongAttemptTest() &#123; // given Multiplication multiplication = new Multiplication(50, 60); User user = new User(&quot;john_doe&quot;); MultiplicationResultAttempt attempt = new MultiplicationResultAttempt(user, multiplication, 3010); // when boolean attemptResult = multiplicationServiceImpl.checkAttempt(attempt); // then assertThat(attemptResult).isFalse(); &#125;&#125; checkAttempt() 가 원하는 동작을 하도록 구현합시다 12345678910111213@Servicepublic class MultiplicationServiceImpl implements MultiplicationService &#123; // ... @Override public boolean checkAttempt(MultiplicationResultAttempt resultAttempt) &#123; return resultAttempt.getResultAttempt() == resultAttempt.getMultiplication().getFactorA() * resultAttempt.getMultiplication().getFactorB(); &#125;&#125; 이제 REST API 를 만들어 봅시다 만들어야 할 API 는 아래와 같습니다. GET /multiplications/random : 무작위로 생성한 곱셈을 반환 POST /results/ : 결과를 전송하는 엔드포인트 GET /results?user=[user_alias] : 특정 사용자의 계산 결과를 검색 123456789@RestControllerpublic class MultiplicationController &#123; private final MultiplicationService multiplicationService; @Autowired public MultiplicationController(final MultiplicationService multiplicationService) &#123; this.multiplicationService = multiplicationService; &#125;&#125; TDD 에 맞추어서 우선 컨트롤러 관련 테스트 코드를 먼저 작성하자 1234567891011121314151617181920212223242526272829303132333435@RunWith(SpringRunner.class)@WebMvcTest(MultiplicationController.class)public class MultiplicationControllerTest &#123; @MockBean private MultiplicationService multiplicationService; @Autowired private MockMvc mvc; // 이 객체는 initFields() 메서드를 이용해 자동으로 초기화 private JacksonTester&lt;Multiplication&gt; json; @Before public void setUp() &#123; JacksonTester.initFields(this, new ObjectMapper()); &#125; @Test public void getRandomMultiplicationTest() throws Exception &#123; // given given(multiplicationService.createRandomMultiplication()) .willReturn(new Multiplication(70, 20)); // when MockHttpServletResponse response = mvc.perform( get(&quot;/multiplication/random&quot;) .accept(MediaType.APPLICATION_JSON)) .andReturn().getResponse(); // then assertThat(response.getStatus()).isEqualTo(HttpStatus.OK.value()); assertThat(response.getContentAsString()) .isEqualTo(json.write(new Multiplication(70, 20)).getJson()); &#125;&#125; 아직 소스 코드 구현을 하지 않았기 때문에 테스트를 돌리면 실패할 것이다. 위 테스트 코드를 간단하게 살펴보면 @WebMvcTest 는 @SpringBootTest 어노테이션과 동일하게 스프링 웹 어플리케이션 컨텍스트를 초기화합니다. 그러나 다른 점은 오직 MVC 레이어 (컨트롤러) 와 관련된 설정만 불러옵니다. 이 어노테이션은 MockMvc 빈도 불러옵니다. JacksonTester 객체를 사용해 JSON 의 내용을 쉽게 확인할 수 있습니다. JacksonTester 객체는 자동으로 설정할 수 있고 @JsonTest 어노테이션을 이용해 자동으로 주입할 수 있습니다. 예제에서는 @WebMvcTest 어노테이션을 사용하기 때문에 수동으로 설정해야 합니다. (@Before 메서드 안에서 설정하고 있습니다) @WebMvcTest 와 @SpringBootTest 의 차이@WebMvcTest 는 컨트롤러를 테스트하는 어노테이션입니다. HTTP 요청과 응답은 Mock 을 이용해 가짜로 이뤄지고 실제 연결은 생성되지 않습니다. 반면 @SpringBootTest 는 웹 어플리케이션 컨텍스트와 설정을 모두 불러와서 실제 웹 서버 연결을 시도합니다. 이런 경우에는 MockMvc 가 아니라 RestTemplate 혹은 TestRestTemplate 을 대신 사용하면 된다. 보통 @WebMvcTest 는 서버에서 컨트롤러만 테스트할 때 사용하고, @SpringBootTest 는 클라이언트부터 상호작용을 확인하는 통합 테스트에서 사용하는 것이 좋습니다. 12345678910111213/** * 곱셈 어플리케이션의 REST API 를 구현한 클래스 */@RestControllerpublic class MultiplicationController &#123; // ... @GetMapping(&quot;/random&quot;) Multiplication getRandomMultiplication() &#123; return multiplicationService.createRandomMultiplication(); &#125;&#125; MultiplicationResultAttemptController 구현 전 테스트 코드를 작성하자. 사용자가 보낸 답안이 맞을 경우와 틀릴 경우를 모두 테스트한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@RunWith(SpringRunner.class)@WebMvcTest(MultiplicationResultAttemptController.class)public class MultiplicationResultAttemptControllerTest &#123; @MockBean private MultiplicationService multiplicationService; @Autowired private MockMvc mvc; private JacksonTester&lt;MultiplicationResultAttempt&gt; jsonResult; private JacksonTester&lt;ResultResponse&gt; jsonResponse; @Before public void setUp() &#123; JacksonTester.initFields(this, new ObjectMapper()); &#125; @Test public void postResultReturnCorrect() throws Exception &#123; genericParameterizedTest(true); &#125; @Test public void postResultReturnNotCorrect() throws Exception &#123; genericParameterizedTest(false); &#125; void genericParameterizedTest(final boolean correct) throws Exception &#123; // given (지금 서비스를 테스트하는 것이 아님) given(multiplicationService .checkAttempt(any(MultiplicationResultAttempt.class))) .willReturn(correct); User user = new User(&quot;john&quot;); Multiplication multiplication = new Multiplication(50, 70); MultiplicationResultAttempt attempt = new MultiplicationResultAttempt(user, multiplication, 3500); // when MockHttpServletResponse response = mvc.perform( post(&quot;/results&quot;).contentType(MediaType.APPLICATION_JSON) .content(jsonResult.write(attempt).getJson())) .andReturn().getResponse(); // then assertThat(response.getStatus()).isEqualTo(HttpStatus.OK.value()); assertThat(response.getContentAsString()).isEqualTo( jsonResponse.write(new ResultResponse(correct)).getJson()); &#125;&#125; 비슷한 기능을 하는 부분을 뽑아서 genericParameterizedTest 메서드를 만들었다. 서비스는 결과가 맞는지 아닌지를 판단하고 맞으면 true, 아니면 false 를 반환합니다. 테스트 코드 작성이 완료되면 소스를 구현해보자. 123456789101112131415@RestController@RequestMapping(&quot;/results&quot;)final class MultiplicationResultAttemptController &#123; // ... @PostMapping ResponseEntity&lt;ResultResponse&gt; postResult(@RequestBody MultiplicationResultAttempt multiplicationResultAttempt) &#123; return ResponseEntity.ok( new ResultResponse(multiplicationService .checkAttempt(multiplicationResultAttempt))); &#125; // ...&#125; REST API 까지 완성했으니, 이제 기본적인 UI를 만들어 봅시다. 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Multiplication v1&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt; &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;multiplication-client.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;h1&gt;안녕하세요, 소셜 곱셈입니다!&lt;/h1&gt; &lt;h2&gt;오늘의 문제:&lt;/h2&gt; &lt;h1&gt; &lt;span class=&quot;multiplication-a&quot;&gt;&lt;/span&gt; x &lt;span class=&quot;multiplication-b&quot;&gt;&lt;/span&gt; = &lt;/h1&gt; &lt;p&gt; &lt;form id=&quot;attempt-form&quot;&gt; 답은? &lt;input type=&quot;text&quot; name=&quot;result-attempt&quot;&gt;&lt;br&gt; 닉네임: &lt;input type=&quot;text&quot; name=&quot;user-alias&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;확인&quot;&gt; &lt;/form&gt; &lt;/p&gt; &lt;h2&gt;&lt;span class=&quot;result-message&quot;&gt;&lt;/span&gt;&lt;/h2&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213html, body &#123; height: 100%;&#125;html &#123; display: table; margin: auto;&#125;body &#123; display: table-cell; vertical-align: middle;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function updateMultiplication() &#123; $.ajax(&#123; url: &quot;http://localhost:8080/multiplications/random&quot; &#125;).then(function (data) &#123; // 폼 비우기 $(&quot;#attempt-form&quot;).find(&quot;input[name=&#x27;result-attempt&#x27;]&quot;).val(&quot;&quot;); $(&quot;#attempt-form&quot;).find(&quot;input[name=&#x27;user-alias&#x27;]&quot;).val(&quot;&quot;); // 무작위 문제를 API로 가져와서 추가하기 $(&#x27;.multiplication-a&#x27;).empty().append(data.factorA); $(&#x27;.multiplication-b&#x27;).empty().append(data.factorB); &#125;);&#125;$(document).ready(function () &#123; updateMultiplication(); $(&quot;#attempt-form&quot;).submit(function (event) &#123; // 폼 기본 제출 막기 event.preventDefault(); // 페이지에서 값 가져오기 var a = $(&#x27;.multiplication-a&#x27;).text(); var b = $(&#x27;.multiplication-b&#x27;).text(); var $form = $(this), attempt = $form.find(&quot;input[name=&#x27;result-attempt&#x27;]&quot;).val(), userAlias = $form.find(&quot;input[name=&#x27;user-alias&#x27;]&quot;).val(); // API 에 맞게 데이터를 조합하기 var data = &#123;user: &#123;alias: userAlias&#125;, multiplication: &#123;factorA: a, factorB: b&#125;, resultAttempt: attempt&#125;; // POST를 이용해서 데이터 보내기 $.ajax(&#123; url: &#x27;/results&#x27;, type: &#x27;POST&#x27;, data: JSON.stringify(data), contentType: &quot;application/json; charset=utf-8&quot;, dataType: &quot;json&quot;, success: function (result) &#123; if (result.correct) &#123; $(&#x27;.result-message&#x27;).empty().append(&quot;정답입니다! 축하드려요!&quot;); &#125; else &#123; $(&#x27;.result-message&#x27;).empty().append(&quot;오답입니다! 그래도 포기하지 마세요!&quot;); &#125; &#125; &#125;); updateMultiplication(); &#125;);&#125;); 화면작업 마무리 되었으면 어플리케이션을 실행해서 확인해보자. 새로운 요구사항 최근에 제출한 답안을 보고 싶어요. 그러면 시간이 지나면서 내가 얼마나 잘하고 있는지 또는 못하고 있는지 알 수 있어요. MultiplicationResultAttempt 클래스의 인스턴스를 모두 저장합니다. 그렇게 하면 나중에 추출해서 사용할 수 있습니다. 특정 사용자의 최근 답안을 가져오는 새로운 REST 엔드포인트를 만듭니다. 답안을 검색하는 새로운 서비스(비지니스 로직)을 만듭니다. 사용자가 답안을 제출하면 답안 내역을 보여주는 웹 페이지를 만듭니다. 애자일과 리팩토링애자일 방법론에 따라 일하려면 리팩토링을 일의 일부분으로 받아들여야 한다. 프로젝트 초기 단계에서 설계에 많은 시간을 투자하는 것은 잘못됐다는 것을 의미한다. 균형을 찾는 것이 핵심이다. 실제 비지니스는 사업이고 시간과의 싸움이기 때문에 기술적으로 완벽함을 찾는 것이나, 완벽한 설계도를 그리는 것에 시간을 쏟지 말아라는 의미 같다. 리팩토링은 필수적인 것이며, 요구사항이 바뀌어 가면서 소스도 바뀌어 가는 것. 그것이 애자일 방법론의 생각인 것 같다. 요구사항이 변경되어 소스에 점점 문제가 보이는 것을 방치한다면 그것은 기술부채가 되며 나중에 점점 큰 자원이 들어가게 되는 부분이 된다. 그렇기 때문에 이 애자일 방법론을 따를 때 중요한 것은 기술부채가 발생하지 않도록 문제가 발생했다면 바로바로 리팩토링하는 것이 중요하다. 불필요한 계산을 피하기 위해 코드를 수정합니다. 답안에 불린 값을 저장하고 데이터베이스에서 쿼리를 이용해 사용자가 맞춘 답안을 읽어올 수 있습니다. 123456789101112131415161718192021222324252627282930313233/** * &#123;@link User&#125;가 &#123;@link Multiplication&#125;을 계산한 답안을 정의한 클래스 */@RequiredArgsConstructor@Getter@ToString@EqualsAndHashCode@Entitypublic class MultiplicationResultAttempt &#123; @Id @GeneratedValue private Long id; @ManyToOne(cascade = CascadeType.PERSIST) @JoinColumn(name = &quot;USER_ID&quot;) private final User user; @ManyToOne(cascade = CascadeType.PERSIST) @JoinColumn(name = &quot;MULTIPLICATION_ID&quot;) private final Multiplication multiplication; private final int resultAttempt; private final boolean correct; // JSON (역)직렬화를 위한 빈 생성자 MultiplicationResultAttempt() &#123; user = null; multiplication = null; resultAttempt = -1; correct = false; &#125;&#125; 생성자가 변경되었기 때문에 오류가 발생하는 MultiplicationServiceImplTest 객체를 수정하자. 생성자 보면 correct 필드를 위해 false 값을 넣었다. 1234567891011121314151617181920212223242526272829303132public class MultiplicationServiceImplTest &#123; // ... @Test public void checkCorrectAttemptTest() &#123; // given Multiplication multiplication = new Multiplication(50, 60); User user = new User(&quot;john_doe&quot;); MultiplicationResultAttempt attempt = new MultiplicationResultAttempt(user, multiplication, 3000, false); // when boolean attemptResult = multiplicationServiceImpl.checkAttempt(attempt); // then assertThat(attemptResult).isTrue(); &#125; @Test public void checkWrongAttemptTest() &#123; // given Multiplication multiplication = new Multiplication(50, 60); User user = new User(&quot;john_doe&quot;); MultiplicationResultAttempt attempt = new MultiplicationResultAttempt(user, multiplication, 3010, false); // when boolean attemptResult = multiplicationServiceImpl.checkAttempt(attempt); // then assertThat(attemptResult).isFalse(); &#125;&#125; 실제 답안을 체크하는 비지니스 로직 checkAttemp() 함수를 수정하자여기 조금 의아한 부분이 객체지향 설계가 안되어 있다. MultiplicationResultAttempt 도메인이 가져야할 로직들이 이 서비스 로직에 드러나 있다. 이 글의 요점이 아니라 그런건가.. 1234567891011121314151617181920212223@Servicepublic class MultiplicationServiceImpl implements MultiplicationService &#123; // ... @Override public boolean checkAttempt(MultiplicationResultAttempt attempt) &#123; // 답안을 채점 boolean correct = attempt.getResultAttempt() == attempt.getMultiplication().getFactorA() * attempt.getMultiplication().getFactorB(); // 조작된 답안을 방지 Assert.isTrue(!attempt.isCorrect(), &quot;채점한 상태로 보낼 수 없습니다!!&quot;); // 복사본을 만들고 crrect 필드를 상황에 맞게 설정 MultiplicationResultAttempt checkAttempt = new MultiplicationResultAttempt(attempt.getUser(), attempt.getMultiplication(), attempt.getResultAttempt(), correct); // 결과를 반환 return correct; &#125;&#125; 기존에는 ResultResponse 객체를 사용해서 응답을 내렸는데, 이번에는 DTO 아예 없애고 MultiplicationResultAttempt 도메인 객체로 내린다.관련해서 컨트롤러 쪽도 수정하자. 1234567891011121314151617final class MultiplicationResultAttemptController &#123; // ... @PostMapping ResponseEntity&lt;MultiplicationResultAttempt&gt; postResult(@RequestBody MultiplicationResultAttempt multiplicationResultAttempt) &#123; boolean isCorrect = multiplicationService.checkAttempt(multiplicationResultAttempt); MultiplicationResultAttempt attemptCopy = new MultiplicationResultAttempt( multiplicationResultAttempt.getUser(), multiplicationResultAttempt.getMultiplication(), multiplicationResultAttempt.getResultAttempt(), isCorrect ); return ResponseEntity.ok(attemptCopy); &#125;&#125; MultiplicationResultAttemptController 컨트롤러 객체 응답이 변경되었으니 이에 맞추어 테스트 코드도 수정하자 123456789101112131415161718192021222324252627282930public class MultiplicationResultAttemptControllerTest &#123; // ... void genericParameterizedTest(final boolean correct) throws Exception &#123; // given (지금 서비스를 테스트하는 것이 아님) given(multiplicationService .checkAttempt(any(MultiplicationResultAttempt.class))) .willReturn(correct); User user = new User(&quot;john&quot;); Multiplication multiplication = new Multiplication(50, 70); MultiplicationResultAttempt attempt = new MultiplicationResultAttempt(user, multiplication, 3500, correct); // when MockHttpServletResponse response = mvc.perform( post(&quot;/results&quot;).contentType(MediaType.APPLICATION_JSON) .content(jsonResult.write(attempt).getJson())) .andReturn().getResponse(); // then assertThat(response.getStatus()).isEqualTo(HttpStatus.OK.value()); assertThat(response.getContentAsString()).isEqualTo( jsonResult.write( new MultiplicationResultAttempt( attempt.getUser(), attempt.getMultiplication(), attempt.getResultAttempt(), correct) ).getJson()); &#125;&#125; 데이터 레이어1234567891011121314&lt;!-- ... --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;!-- ... --&gt; 12345678# H2 데이터베이스 웹 콘솔에 접속spring.h2.console.enabled=true# 데이터베이스가 &#x27;없는 경우에만&#x27; 데이터베이스를 생성spring.jpa.hibernate.ddl-auto=update# 파일로 데이터베이스를 생성spring.datasource.url=jdbc:h2:file:~/social-multiplication;DB_CLOSE_ON_EXIT=FALSE;# 학습 목적으로 콘솔에 SQL을 출력spring.jpa.properties.hibernate.show_sql=true Multiplication 도메인도 JPA 를 활용해 데이터 모델로 변경해보자. 123456789101112131415161718192021222324/** * 애플리케이션에서 곱셈을 나타내는 클래스 (a * b) */@RequiredArgsConstructor@Getter@ToString@EqualsAndHashCode@Entitypublic class Multiplication &#123; @Id @GeneratedValue @Column(name = &quot;MULTIPLICATION_ID&quot;) private Long id; // 두 인수 private final int factorA; private final int factorB; // JSON (역)직렬화를 위한 빈 생성자 Multiplication() &#123; this(0, 0); &#125;&#125; @Entity 애너테이션으로 JPA 저장소에 저장할 수 있는 JPA의 개체임을 명시합니다. JPA에서 리플렉션을 통해 객체를 인스턴스화할 때 필요한 빈 생성자도 있습니다. 기본키로 유일한 식별자를 사용하기 위해 자바 Long 클래스를 활용합니다. @Id 애너테이션은 기본키를 의미하고 @GeneratedValue는 따로 값을 지정하지 않아도 자동으로 생성되는 값입니다. 컬럼명을 JPA가 지정해주는 대신 명시적으로 설정해야 할 경우가 있습니다. 이런 경우에는 @Column 애너테이션으로 컬럼명을 지정합니다. User 클래스도 수정하자 12345678910111213141516171819202122/** * 사용자 정보를 저장하는 클래스 */@RequiredArgsConstructor@Getter@ToString@EqualsAndHashCode@Entitypublic final class User &#123; @Id @GeneratedValue @Column(name = &quot;USER_ID&quot;) private Long id; private final String alias; // JSON (역)직렬화를 위한 빈 생성자 protected User() &#123; alias = null; &#125;&#125; Repository 쪽을 만들어보자. 123456789/** * 답안을 저장하고 조회하기 위한 인터페이스 */public interface MultiplicationResultAttemptRepository extends CrudRepository&lt;MultiplicationResultAttempt, Long&gt; &#123; /** * @return 닉네임에 해당하는 사용자의 최근 답안 5개 */ List&lt;MultiplicationResultAttempt&gt; findTop5ByUserAliasOrderByIdDesc(String userAlias);&#125; 12345/** * &#123;@link microservices.book.multiplication.multiplication.domain.Multiplication&#125; 을 저장하고 조회하기 위한 인터페이스 */public interface MultiplicationRepository extends CrudRepository&lt;Multiplication, Long&gt; &#123;&#125; 123456/** * &#123;@link microservices.book.multiplication.multiplication.domain.User&#125; 를 저장하고 조회하기 위한 인터페이스 */public interface UserRepository extends CrudRepository&lt;User, Long&gt; &#123; Optional&lt;User&gt; findByAlias(final String alias);&#125; 리포지토리를 만들때에는 왜 TDD를 사용하지 않는가? 간단합니다. 이건 새로운 코드가 아니라 스프링에서 제공하는 코드이기 때문에 믿을 수 있고 따로 단위 테스트를 작성할 필요가 없습니다 TDD로 돌아가서 위 Repository를 사용하는 Service 코드를 검증하는 단위 테스트 코드를 추가하자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class MultiplicationServiceImplTest &#123; // ... @Mock private MultiplicationResultAttemptRepository attemptRepository; @Mock private UserRepository userRepository; @Before public void setUp() &#123; // initMocks 를 호출해 Mockito 가 어노테이션을 처리하도록 지시 MockitoAnnotations.initMocks(this); multiplicationServiceImpl = new MultiplicationServiceImpl(randomGeneratorService, attemptRepository, userRepository); &#125; @Test public void createRandomMultiplicationTest() &#123; // given (목 객체가 처음에 50, 나중에 30 을 반환하도록 설정) given(randomGeneratorService.generateRandomFactor()).willReturn(50, 30); // when Multiplication multiplication = multiplicationServiceImpl.createRandomMultiplication(); // assert assertThat(multiplication.getFactorA()).isEqualTo(50); assertThat(multiplication.getFactorB()).isEqualTo(30); &#125; @Test public void checkCorrectAttemptTest() &#123; // given Multiplication multiplication = new Multiplication(50, 60); User user = new User(&quot;john_doe&quot;); MultiplicationResultAttempt attempt = new MultiplicationResultAttempt(user, multiplication, 3000, false); MultiplicationResultAttempt verifiedAttempt = new MultiplicationResultAttempt(user, multiplication, 3000, true); given(userRepository.findByAlias(&quot;john_doe&quot;)).willReturn(Optional.empty()); // when boolean attemptResult = multiplicationServiceImpl.checkAttempt(attempt); // then assertThat(attemptResult).isTrue(); verify(attemptRepository).save(verifiedAttempt); &#125; @Test public void checkWrongAttemptTest() &#123; // given Multiplication multiplication = new Multiplication(50, 60); User user = new User(&quot;john_doe&quot;); MultiplicationResultAttempt attempt = new MultiplicationResultAttempt(user, multiplication, 3010, false); given(userRepository.findByAlias(&quot;john_doe&quot;)).willReturn(Optional.empty()); // when boolean attemptResult = multiplicationServiceImpl.checkAttempt(attempt); // then assertThat(attemptResult).isFalse(); verify(attemptRepository).save(attempt); &#125;&#125; 서비스 계층의 단위 테스트에 집중하기 위해 MultiplicationResultAttemptRepository 와 UserRepository 의 목 객체가 필요합니다. MultiplicationServiceImpl 생성자에 인자로 넘겨주고 있는데, 나중에 해당 클래스를 수정할 때 수정하거나 아니면 지금 새로운 생성자를 만들 수도 있습니다. checkCorrectAttemptTest() 메서드는 실제처럼 하기 위해 attempt 의 복사본(verifiedAttempt)을 만듭니다. 사용자가 보낸 답안은 correct 필드가 false 여야만 합니다. 그리고 마지막 줄에서 Mockito 로 correct 가 true 인 답안을 저장하는 경우를 verify 합니다. checkWrongAttemptTest() 메서드는 틀린 답을 검증합니다. 호출이 실제로 실행되는 것은 아닙니다. 목 객체가 해당 인자를 가지고 동작하는지 테스트하는 것뿐입니다. Layer ConnectionTo show the list registed recently, let’s create new API and service unit. We should create the message at ‘MultiplicationService’ interface for getting the list graded recently. 123456public interface MultiplicationService &#123; // ... List&lt;MultiplicationResultAttempt&gt; getStatsForUser(final String userAlias);&#125; and let’s it implements. 12345678910@Servicepublic class MultiplicationServiceImpl implements MultiplicationService &#123; // ... @Override public List&lt;MultiplicationResultAttempt&gt; getStatsForUser(String userAlias) &#123; return attemptRepository.findTop5ByUserAliasOrderByIdDesc(userAlias); &#125;&#125; let’s make the test code for getStatsForUser(). 123456789101112131415161718192021222324252627public class MultiplicationServiceImplTest &#123; // ... @Test public void retrieveStatsTest() &#123; // given Multiplication multiplication = new Multiplication(50, 60); User user = new User(&quot;john_doe&quot;); MultiplicationResultAttempt attempt1 = new MultiplicationResultAttempt( user, multiplication, 3010, false); MultiplicationResultAttempt attempt2 = new MultiplicationResultAttempt( user, multiplication, 3051, false); List&lt;MultiplicationResultAttempt&gt; latestAttempts = Lists.newArrayList(attempt1, attempt2); given(userRepository.findByAlias(&quot;john_doe&quot;)).willReturn(Optional.empty()); given(attemptRepository.findTop5ByUserAliasOrderByIdDesc(&quot;john_doe&quot;)) .willReturn(latestAttempts); // when List&lt;MultiplicationResultAttempt&gt; latestAttemptsResult = multiplicationServiceImpl.getStatsForUser(&quot;john_doe&quot;); // then assertThat(latestAttemptsResult).isEqualTo(latestAttempts); &#125;&#125; and after that, We should add the function for rest api at MultiplicationResultAttemptController 12345678910// ...final class MultiplicationResultAttemptController &#123; // ... @GetMapping ResponseEntity&lt;List&lt;MultiplicationResultAttempt&gt;&gt; getStatistics(@RequestParam(&quot;alias&quot;) String alias) &#123; return ResponseEntity.ok(multiplicationService.getStatsForUser(alias)); &#125;&#125; 123456789101112131415161718192021222324252627public class MultiplicationResultAttemptControllerTest &#123; // ... @Test public void getUserStats() throws Exception &#123; // given User user = new User(&quot;john_doe&quot;); Multiplication multiplication = new Multiplication(50, 70); MultiplicationResultAttempt attempt = new MultiplicationResultAttempt( user, multiplication, 3500, true); List&lt;MultiplicationResultAttempt&gt; recentAttempts = Lists.newArrayList(attempt, attempt); given(multiplicationService .getStatsForUser(&quot;john_doe&quot;)) .willReturn(recentAttempts); // when MockHttpServletResponse response = mvc.perform( get(&quot;/results&quot;).param(&quot;alias&quot;, &quot;john_doe&quot;)) .andReturn().getResponse(); // then assertThat(response.getStatus()).isEqualTo(HttpStatus.OK.value()); assertThat(response.getContentAsString()).isEqualTo( jsonResultAttemptList.write(recentAttempts).getJson()); &#125;&#125; 12345678910111213function updateStats(alias) &#123; $.ajax(&#123; url: &quot;http://localhost:8080/results?alias=&quot; + alias, &#125;).then(function (data) &#123; $(&#x27;#stats-body&#x27;).empty(); data.forEach(function (row) &#123; $(&#x27;#stats-body&#x27;).append(&#x27;&lt;tr&gt;&lt;td&gt;&#x27; + row.id + &#x27;&lt;/td&gt;&#x27; + &#x27;&lt;td&gt;&#x27; + row.multiplication.factorA + &#x27; x &#x27; + row.multiplication.factorB + &#x27;&lt;/td&gt;&#x27; + &#x27;&lt;td&gt;&#x27; + row.resultAttempt + &#x27;&lt;/td&gt;&#x27; + &#x27;&lt;td&gt;&#x27; + (row.correct === true ? &#x27;YES&#x27; : &#x27;NO&#x27;) + &#x27;&lt;/td&gt;&lt;/tr&gt;&#x27;); &#125;); &#125;);&#125; 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Multiplication v1&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt; &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;multiplication-client.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;h1&gt;안녕하세요, 소셜 곱셈입니다!&lt;/h1&gt; &lt;h2&gt;오늘의 문제:&lt;/h2&gt; &lt;h1&gt; &lt;span class=&quot;multiplication-a&quot;&gt;&lt;/span&gt; x &lt;span class=&quot;multiplication-b&quot;&gt;&lt;/span&gt; = &lt;/h1&gt; &lt;p&gt; &lt;form id=&quot;attempt-form&quot;&gt; 답은? &lt;input type=&quot;text&quot; name=&quot;result-attempt&quot;&gt;&lt;br&gt; 닉네임: &lt;input type=&quot;text&quot; name=&quot;user-alias&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;확인&quot;&gt; &lt;/form&gt; &lt;/p&gt; &lt;h2&gt;&lt;span class=&quot;result-message&quot;&gt;&lt;/span&gt;&lt;/h2&gt; &lt;h2&gt;통계&lt;/h2&gt; &lt;table id=&quot;stats&quot; style=&quot;width:100%&quot;&gt; &lt;tr&gt; &lt;th&gt;답안 ID&lt;/th&gt; &lt;th&gt;곱셈&lt;/th&gt; &lt;th&gt;입력한 값&lt;/th&gt; &lt;th&gt;정답?&lt;/th&gt; &lt;/tr&gt; &lt;tbody id=&quot;stats-body&quot;&gt;&lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Let’s start to do microservicemicroservice isn’t fit with creating the prototype. because the prototype usually should be created as soon as possible. but building the microservice isn’t easier than the monolithic one. so when you launch the new service, I recommend you to build it as monolithic system. Refactoring is always needed in the agile progamming paradigm so Don’t be avoid it. Scalabilitylet’s suppose that the one of the microservices takes traffics a lot, then we gotta expand the microservice without anothers. but it’s impossible to control each service at monolithic system. Server and Infra are always the cost so Software enginner should consider it. Connecting each microservicesHow can do we connect between each microservices? Sharing the same database. This solution is not proper with microservice essentially. because the one of purpose of microservice is separating the business context, but this solution is not keep this rule. Building the batch service pushing the updated list between each one. but this way couldn’t offer the real time service. … Event Driven ArchitectureMost of companies with microservice structure use Event to notify any actions, changes for each microservices. Each microservices take the published event through Event Bus and they can publish the event when they want. The benfit and disadvantage of Event Driven Architecture Loose coupling Each microservices can have own context area. It should be independent, then the changes of their process are not affect to other one. Transaction Event Driven Architecture can’t keep ACID Transaction principle. if one transaction needs multiple services, we have to do lots of things to keep the ACID principle like Rollback processing. Fault Tolerance When the one of microservices is shuted down, another microservices depended it should have the policy how can handle this problem. Difficulty to trace log. Event Driven Architecture is really hard to trace the log because it is built separately. so We should have the occastration layer to check it like a gateway. RabbitMQlet’s inject dependency of amqp. 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; setting exchange key at application.properties 123## RabbitMQ 설정multiplication.exchange=multiplication_exchangemultiplication.solved.key=multiplication.solved Configuration RabbitTemplate, TopicExchange RabbitMQ is configured enable to communicate as Json type as you can see. 1234567891011121314151617181920@Configurationpublic class RabbitMQConfiguration &#123; @Bean public TopicExchange multiplicationExchange(@Value(&quot;$&#123;multiplication.exchange&#125;&quot;) final String exchangeName) &#123; return new TopicExchange(exchangeName); &#125; @Bean public RabbitTemplate rabbitTemplate(final ConnectionFactory connectionFactory) &#123; final RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory); rabbitTemplate.setMessageConverter(producerJackson2MessageConverter()); return rabbitTemplate; &#125; @Bean public Jackson2JsonMessageConverter producerJackson2MessageConverter() &#123; return new Jackson2JsonMessageConverter(); &#125;&#125; Modeling Event object. It’s dangerous to use the changeable data as the event field. these data will make any confuse to each microservices. 123456789@RequiredArgsConstructor@Getter@ToString@EqualsAndHashCodepublic class MultiplicationSolvedEvent implements Serializable &#123; private final Long multiplicationResultAttemptId; private final Long userId; private final boolean correct;&#125; 12345678910111213141516171819202122232425public class EventDispatcher &#123; private RabbitTemplate rabbitTemplate; // Multiplication 관련 정보를 전달하기 위한 익스체인지 private String multiplicationExchange; // 특정 이벤트를 전송하기 위한 라우팅 키 private String multiplicationSolvedRoutingKey; @Autowired EventDispatcher(final RabbitTemplate rabbitTemplate, @Value(&quot;$&#123;multiplication.exchange&#125;&quot;) final String multiplicationExchange, @Value(&quot;$&#123;multiplication.solved.key&#125;&quot;) final String multiplicationSolvedRoutingKey) &#123; this.rabbitTemplate = rabbitTemplate; this.multiplicationExchange = multiplicationExchange; this.multiplicationSolvedRoutingKey = multiplicationSolvedRoutingKey; &#125; public void send(final MultiplicationSolvedEvent multiplicationSolvedEvent) &#123; rabbitTemplate.convertAndSend( multiplicationExchange, multiplicationSolvedRoutingKey, multiplicationSolvedEvent); &#125;&#125; AMQP supports Transaction. so It will not send the event when the method occurs the exception with @Transaction annotation. 1234567891011121314151617181920public class MultiplicationServiceImpl implements MultiplicationService &#123; // ... @Transactional @Override public boolean checkAttempt(MultiplicationResultAttempt attempt) &#123; // ... // 이벤트로 결과를 전송 eventDispatcher.send( new MultiplicationSolvedEvent(checkAttempt.getId(), checkAttempt.getUser().getId(), checkAttempt.isCorrect()) ); return isCorrect; &#125;&#125; after this code, you should fix MultiplicationServiceImplTest class. because the existing one doesn’t have the code to check whether event message is sent well or not. 1234567891011public enum Badge &#123; // 점수로 획득하는 배지 BRONZE_MULTIPLICATOR, SILVER_MULTIPLICATOR, GOLD_MULTIPLICATOR, // 특정 조건으로 획득하는 배지 FIRST_ATTEMPT, FIRST_WON, LUCKY_NUMBER&#125; 1234567891011121314151617181920212223@RequiredArgsConstructor@Getter@ToString@EqualsAndHashCode@Entitypublic final class BadgeCard &#123; @Id @GeneratedValue @Column(name = &quot;BADGE_ID&quot;) private final Long badgeID; private final Long userId; private final long badgeTimestamp; private final Badge badge; public BadgeCard() &#123; this(null, null, 0, null); &#125; public BadgeCard(final Long userId, final Badge badge) &#123; this(null, userId, System.currentTimeMillis(), badge); &#125;&#125; 1234567891011121314151617181920212223@RequiredArgsConstructor@Getter@ToString@EqualsAndHashCodepublic final class GameStats &#123; private final Long userId; private final int score; private final List&lt;Badge&gt; badges; public GameStats() &#123; this.userId = 0L; this.score = 0; this.badges = new ArrayList&lt;&gt;(); &#125; public static GameStats emptyStats(final Long userId) &#123; return new GameStats(userId, 0, Collections.emptyList()); &#125; public List&lt;Badge&gt; getBadges() &#123; return Collections.unmodifiableList(badges); &#125;&#125; 123456789101112@RequiredArgsConstructor@Getter@ToString@EqualsAndHashCodepublic final class LeaderBoardRow &#123; private final Long userId; private final Long totalScore; public LeaderBoardRow() &#123; this(0L, 0L); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/** * 점수와 답안을 연결하는 클래스 * 사용자와 점수가 등록된 시간의 타임스탬프를 포함 */@RequiredArgsConstructor@Getter@ToString@EqualsAndHashCode@Entitypublic final class ScoreCard &#123; // 명시되지 않은 경우 이 카드에 할당되는 기본 점수 public static final int DEFAULT_SCORE = 10; @Id @GeneratedValue @Column(name = &quot;CARD_ID&quot;) private final Long cardId; @Column(name = &quot;USER_ID&quot;) private final Long userId; @Column(name = &quot;ATTEMPT_ID&quot;) private final Long attemptId; @Column(name = &quot;SCORE_TS&quot;) private final long scoreTimestamp; @Column(name = &quot;SCORE&quot;) private final int score; public ScoreCard() &#123; this(null, null, null, 0, 0); &#125; public ScoreCard(final Long userId, final Long attemptId) &#123; this(null, userId, attemptId, System.currentTimeMillis(), DEFAULT_SCORE); &#125;&#125; Only ScoreCard and BadgeCard are the domain what you should save in database through repository among those five domain classes. 123public interface BadgeCardRepository extends CrudRepository&lt;BadgeCard, Long&gt; &#123; List&lt;BadgeCard&gt; findByUserIdOrderByBadgeTimestampDesc(final Long userId);&#125; 123456789101112public interface ScoreCardRepository extends CrudRepository&lt;ScoreCard, Long&gt; &#123; @Query(&quot;SELECT SUM(s.score) FROM microservices.book.gamification.domain.ScoreCard s WHERE s.userId = :userId GROUP BY s.userId&quot;) int getTotalScoreForUser(@Param(&quot;userId&quot;) final Long userId); @Query(&quot;SELECT NEW microservices.book.gamification.domain.LeaderBoardRow(s.userId, SUM(s.score)) &quot; + &quot;FROM microservices.book.gamification.domain.ScoreCard s &quot; + &quot;GROUP BY s.userId ORDER BY SUM(s.score) DESC&quot;) List&lt;LeaderBoardRow&gt; findFirst10(); List&lt;ScoreCard&gt; findByUserIdOrderByScoreTimestampDesc(final Long userId);&#125; ScoreCardRepository is built by JPQL(Java Persistence Query Language). and JPQL keeps the abstraction rules to use itself for any database not for specific database. Business LogicsThis system is required two business logics. the one is GameService and the other is LeaderBoardService. GameService : It’s for calculating the scores and the badges based on grading what is taken. LeaderBoardService : It’s for Looking up the 10 users who takes highest the scores. Initialization RabbitMQ12345678910111213141516171819202122232425262728293031323334@Configurationpublic class RabbitMQConfiguration implements RabbitListenerConfigurer &#123; @Bean public TopicExchange multiplicationExchange(@Value(&quot;$&#123;multiplication.exchange&#125;&quot;) final String exchangeName) &#123; return new TopicExchange(exchangeName); &#125; @Bean public Queue gamificationMultiplicationQueue(@Value(&quot;$&#123;multiplication.queue&#125;&quot;) final String queueName) &#123; return new Queue(queueName, true); &#125; @Bean Binding binding(final Queue queue, final TopicExchange exchange, @Value(&quot;$&#123;multiplication.anything.routing-key&#125;&quot;) final String routingKey) &#123; return BindingBuilder.bind(queue).to(exchange).with(routingKey); &#125; @Bean public MappingJackson2MessageConverter consumerJackson2MessageConverter() &#123; return new MappingJackson2MessageConverter(); &#125; @Bean public DefaultMessageHandlerMethodFactory messageHandlerMethodFactory() &#123; DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory(); factory.setMessageConverter(consumerJackson2MessageConverter()); return factory; &#125; @Override public void configureRabbitListeners(final RabbitListenerEndpointRegistrar registrar) &#123; registrar.setMessageHandlerMethodFactory(messageHandlerMethodFactory()); &#125;&#125; this RabbitMQ configuration bind with Exchange and Routing Key to Queue. and consumerJackson2MessageConverter(), messageHandlerMethodFactory(), configureRabbitListeners() methods are for setting Json Deserialization. Data Communication between each microservices.Reactive pattern means communication based on Event and unlike that pattern, Request/Response pattern means communication based on REST API. Event only should have immutable data. and the reason was already refer the above. Keeping the domain as isolaed status.if the specific domain can be accessed all of microservices, then Each microservices have dependency between themselves because of this domain. It means that all of microservices using the domain have to be considered whenever the domain is changed. 1@JsonDeserialize(using = MultiplicationResultAttemptDeserializer.class) @JsonDeserialize annotation can offer the customization of Json type deserialization when RestTemplate is used. and that is MultiplicationResutAttemptDeserializer object 123456789101112public class MultiplicationResultAttemptDeserializer extends JsonDeserializer&lt;MultiplicationResultAttempt&gt; &#123; @Override public MultiplicationResultAttempt deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException &#123; ObjectCodec oc = jsonParser.getCodec(); JsonNode node = oc.readTree(jsonParser); return new MultiplicationResultAttempt(node.get(&quot;user&quot;).get(&quot;alias&quot;).asText(), node.get(&quot;multiplication&quot;).get(&quot;factorA&quot;).asInt(), node.get(&quot;multiplication&quot;).get(&quot;factorB&quot;).asInt(), node.get(&quot;resultAttempt&quot;).asInt(), node.get(&quot;correct&quot;).asBoolean()); &#125;&#125; Installing RabbitMQ server based on DockerFirstly, we should pull the rabbitmq image from dockerhurbs. and let’s launch this rabbitmq image. 123&gt; docker pull rabbitmq:management&gt; docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 -p 25672:25672 -p 35197:35197 --restart=unless-stopped -e RABBITMQ_DEFAULT_USER=guest -e RABBITMQ_DEFAULT_PASS=guest rabbitmq:management How can solve the problem what docker is not operated will with showing the error message ‘Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?’this situation is occured when your docker daemon process is stopped. in my case, i just solved this problem as re-installing docker program. Solving the error ‘homebrew-core is a shallow clone’ when you use brew command.the solution in already in the message what you taken in terminal with brew command. you just fetch the code from the below two repositories related with brew. 12git -C /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core fetch --unshallowgit -C /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask fetch --unshallow Installing rabbitmq in local with brew command1234567891011&gt; brew update&gt; brew install rabbitmq// set environment variable for rabbitmq&gt; export PATH=$PATH:/user/local/sbin&gt; rabbitmq-server// It&#x27;s the launching command without setting envrionment variables&gt; /usr/local/sbin/rabbitmq-server Creating new user with rabbitmqctl command12345&gt; rabbitmqctl add_user test test&gt; rabbitmqctl set_user_tags test administrator&gt; rabbitmqctl set_permissions -p / test &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; Creating new user with rabbitmqctl in Docker12345&gt; docker exec rabbitmq rabbitmqctl add_user test test&gt; docker exec rabbitmq rabbitmqctl set_user_tags test administrator&gt; docker exec rabbitmq rabbitmqctl set_permissions -p / test &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; Turning on rabbitmq management optionRabbitmq Web management service is basically not turned on. so You should change the rabbitmq-plugins option to use it. 1&gt; docker exec rabbitmq rabbitmq-plugins enable rabbitmq_management Migrating static contents from multiplication to new serverThe book use Jetty web server to service the UI contents First of all, We will install Jetty with Homebrew. 1&gt; brew install jetty Installing Jetty with Docker12345&gt; docker pull jetty&gt; docker run -d --name jetty -p 9090:8080 -p 9443:8443 jetty&gt; docker exec -it jetty /bin/bash The path of webapps directory in jetty docker container1&gt; /var/lib/jetty/webapps Copying file betweeen host system and docker container12345// host -&gt; container&gt; docker cp [host file] [container name]:[container path]// container -&gt; host&gt; docker cp [container name]:[container path] [host file] AopInvocationException: Null return value from advice does not match primitive return type forThis exception is occured when your entities has a primitive type data. These data should be changed to boxed type like Interger, Float.. access h2-console as file db.1spring.datasource.url=jdbc:h2:file:~/gamification;DB_CLOSE_ON_EXIT=FALSE;USER=myuser;PASSWORD=mypass if the above properties is configured in your h2 db, then you can access h2-console with the below information. 1234567http://localhost:8081/h2-consolejdbc:h2:file:~/gamificationuser : myuserpassword : mypass furthermore, you have to know one thing that you gotta delete the h2 file db when you want to change the user or password the location is almostly C:/User/USER/ The components of Service Discovery Service Registry Register Agent Service Discovery Client The version Error between Spring boot and Spring CloudThe latest version of Spring boot is 2.6.1 but i don’t know the way add the spring cloud dependencies with this spring boot version. someday, I should solve this problems.. actually i learned one thing about this. 1https://spring.io/projects/spring-cloud You can get the version information of spring cloud. Zuul routing setting123456789101112131415zuul: prefix: /api routes: multiplications: path: /multiplications/** url: http://localhost:8080/multiplications results: path: /results/** url: http://localhost:8080/results leaders: path: /leaders/** url: http://localhost:8081/leaders stats: path: /stats/** url: http://localhost:8081/stats prefix is deleted when Api Gateway call the each microservices.ex) http://localhost:8000/api/multiplications -&gt; http://localhost:8080/multiplications after applying Api gateway, the clients don’t need to remember each endpoints of microservices. it just only should keep the endpoint of api gateway. Spring Cloud Version IssueWhen you want to use Spring Cloud in your spring boot project. You must consider the version. the version is dependented deeply between spring boot and spring cloud. https://spring.io/projects/spring-cloud in Spring boot 2.6.0 version case, you can check how we add the proper dependency of Spring Cloud at the below site. https://spring.io/projects/spring-cloud The below code is the sample adding dependency of Spring Cloud in Maven and Gradle. 1234567891011121314151617181920212223242526272829303132 &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;2021.0.0-M1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; ...&lt;/dependencies&gt; 12345678910111213141516171819202122232425buildscript &#123;dependencies &#123;classpath &quot;io.spring.gradle:dependency-management-plugin:1.0.2.RELEASE&quot;&#125;&#125;repositories &#123;maven &#123;url &#x27;https://repo.spring.io/milestone&#x27;&#125;&#125;apply plugin: &quot;io.spring.dependency-management&quot;dependencyManagement &#123;imports &#123;mavenBom &#x27;org.springframework.cloud:spring-cloud-dependencies:2021.0.0-M1&#x27;&#125;&#125;dependencies &#123;compile &#x27;org.springframework.cloud:spring-cloud-starter-config&#x27;compile &#x27;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#x27;...&#125; as you can see at there, You should know the name of repositories for Spring Cloud is ‘https://repo.spring.io/milestone‘. It’s not default repository, so You have add the repository when you add Spring Cloud.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"MSA","slug":"MSA","permalink":"http://kidongyun.github.io/tags/MSA/"}]},{"title":"Configuration Properties","slug":"2021-11-11-configuration-properties","date":"2021-11-11T02:38:54.000Z","updated":"2022-06-01T06:16:58.236Z","comments":true,"path":"2021/11/11/","link":"","permalink":"http://kidongyun.github.io/2021/11/11/","excerpt":"","text":".properties, .yml 파일에 있는 속성 정보들을 가져와서 바인딩을 할 때 @Value 어노테이션을 사용할수도 있지만 한 클래스에서 동일한 도메인을 지속 사용한다면 @ConfigurationProperties 어노테이션으로 보다 심플하게 사용이 가능하다. 12url.naver=https://www.naver.comurl.goole=https://google.com 1234567@Component@ConfigurationProperties(prefix = &quot;url&quot;)@Datapublic class urlProperties &#123; private String naver; private Stirng google;&#125; 위 처럼 작성하면 naver, google 변수에 맞춰서 값이 들어가진다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"ConfigurationProperties","slug":"ConfigurationProperties","permalink":"http://kidongyun.github.io/tags/ConfigurationProperties/"}]},{"title":"Redis","slug":"2021-11-11-redis","date":"2021-11-11T02:38:54.000Z","updated":"2022-06-01T06:18:04.378Z","comments":true,"path":"2021/11/11/","link":"","permalink":"http://kidongyun.github.io/2021/11/11/","excerpt":"","text":"Jedis, Lettuce 와 같이 Redisson 는 Redis Client. keys *모든 값을 가져온다. 이거는 근데 서버 성능에 영향을 미치는 명령어 이기 때문에 바로 * 쓰기보다는 앞에 prefix를 두고 사용하는게 좋다. ex) keys PRE:* set “value”KEY 에 해당하는 value 값을 설정한다 get 에 해당하는 값을 가져온다. expire / expireat해당 키에 timeout 을 설정하는 명령어 expire key1 60 (60초후 삭제) expireat key1 13424324 ( unixtime 기준 삭제 ) ttl 에 설정된 남은 expire 시간을 확인한다","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://kidongyun.github.io/tags/Redis/"},{"name":"Database","slug":"Database","permalink":"http://kidongyun.github.io/tags/Database/"}]},{"title":"Object","slug":"2021-11-09-object","date":"2021-11-09T02:38:54.000Z","updated":"2022-06-01T06:16:33.731Z","comments":true,"path":"2021/11/09/","link":"","permalink":"http://kidongyun.github.io/2021/11/09/","excerpt":"","text":"1. 객체, 설계티켓 판매 어플리케이션 구현하기티켓 판매라는 도메인을 활용해서 객체, 설계에 대한 이야기를 해본다. 이 도메인에는 초대장 개념이 존재한다. 초대장 개념을 구현한 Invitation 클래스는 초대일자를 의미하는 when 인스턴스 변수를 포함한다. 123public class Invitation &#123; private LocalDateTime when;&#125; 공연을 관람하기 위해 필요한 티켓이라는 개념도 존재한다. 1234567public class Ticket &#123; private Long fee; public Long getFee() &#123; return fee; &#125;&#125; 초대장이 없는 관람객은 이 티켓을 현금으로 구매가 가능하다. 관람객이 초대장, 티켓, 현금을 들고 다닐 수 있는 가방 Bag 클래스가 있다. 12345678910111213141516171819202122232425public class Bag &#123; private Long amount; private Invitation invitation; private Ticket ticket; public boolean hasInvitation() &#123; return invitation != null; &#125; public boolean hasTicket() &#123; return ticket != null; &#125; public void setTicket(Ticket ticket) &#123; this.ticket = ticket; &#125; public void minusAmount(Long amount) &#123; this.amount -= amount; &#125; public void plusAmount(Long amount) &#123; this.amount += amount; &#125;&#125; 이 도메인에서 실제로 생성되는 Bag 인스턴스는 현금과 초대장을 함께 보관하거나, 초대장 없이 현금만 보관하는 두 가지 중 하나이다. 이런 제약을 강제할 수 있도록 생성자를 추가하자. 12345678910public class Bag &#123; public Bag(long amount) &#123; this(null, amount); &#125; public Bag(Invitation invitation, long amount) &#123; this.invitation = invitation; this.amount = amount; &#125;&#125; 이번에는 관람객 개념을 구현하는 Audience 클래스를 만들어보자. 이 관람객들은 소지품을 보관하기 위해 가방을 소지할 수 있다. 1234567891011public class Audience &#123; private Bag bag; public Audience(Bag bag) &#123; this.bag = bag; &#125; public Bag getBag() &#123; return bag; &#125;&#125; 관람객이 소극장에 입장하기 위해서는 매표소에서 초대장을 티켓으로 교환하거나 구매해야 한다. 따라서 매표소에는 관람객에게 판매할 티켓과 티켓의 판매 금액이 보관돼 있어야 한다. 123456789101112131415161718192021public class TicketOffice &#123; private Long amount; private List&lt;Ticket&gt; tickets = new ArrayList&lt;&gt;(); public TicketOffice(Long amount, Ticket ... tickets) &#123; this.amount = amount; this.tickets.addAll(Arrays.asList(tickets)); &#125; public Ticket getTicket() &#123; return tickets.remove(0); &#125; public void minusAmount(Long amount) &#123; this.amount -= amount; &#125; public void plusAmount(Long amount) &#123; this.amount += amount; &#125;&#125; 매표소에는 판매원이 있다. 판매우언은 매표소에서 초대장을 티켓으로 교환해 주거나 티켓을 판매하는 역할을 수행한다. 판매원을 구현한 TicketSeller 클래스는 자신이 일하는 매표소(ticketOffice)를 알고 있어야 한다. 1234567891011public class ticketSeller &#123; private TicketOffice ticketOffice; public TicketSeller(TicketOffice ticketOffice) &#123; this.ticketOffice = ticketOffice; &#125; public TicketOffice getTicketOffice() &#123; return ticketOffice; &#125;&#125; 마지막으로 소극장 클래스에서 관람객을 맞이할 수 있도록 enter 메서드를 구현하자. 123456789101112131415161718public class Theater &#123; private TicketSeller ticketSeller; public Theater(TicketSeller ticketSeller) &#123; this.ticketSeller = ticketSeller; &#125; public void enter(Audience audience) &#123; if(audience.getBag().hasInvitation()) &#123; Ticket ticket = ticketSeller.getTicketOffice().getTicket(); &#125; else &#123; Ticket ticket = ticketSeller.getTicketOffice().getTicket(); audience.getBag().minusAmount(ticket.getFee()); ticketSeller.getTicketOffice().plusAmount(ticket.getFee()); audience.getBag().setTicket(ticket); &#125; &#125;&#125; 무엇이 문제인가로버트 마틴이 언급한 소프트웨어 모듈이 가져야 하는 세가지 기능은 아래와 같다. 첫번째 목적은 실행 중에 제대로 동작하는 것이다. 두번째 목적은 변경을 위해 존재하는 것이다. 세번째 목적은 코드를 읽는 사람과 의사소통 하는 것이다. 즉 모든 모듈은 제대로 실행되야 하고, 변경이 용이해야 하며, 이해하기 쉬워야 한다. 위 코드는 첫번째 목적은 만족하지만 두번째와 세번째 즉 변경 용이성과 가독성의 목적은 만족시키지 못한다. 위 코드를 읽어보면 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는 점을 알 수 있다. 소극장이 관람객의 가방을 마음대로 열어보기도 하고 판매원의 매표소도 소극장이 마음대로 접근하고 있다. 이러한 동작 방식은 우리의 예상을 벗어난다 즉 이해하기가 어렵다. 또 위 코드에서 관람객이 가방을 들고 있다는 가정이 바뀌었다고 상상해보자. Audience 클래스에서 Bag을 제거해야 할 뿐만 아니라 Audience의 Bag에 직접 접근하는 Theater의 enter 메서드 역시 수정해야 한다. 즉 이것은 객체 사이의 의존성과 관련된 문제다. 좋은 코드로 가기 위해서 우리의 목표는 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것이다. 설계 개선하기다시말해서 관람객과 판매원이 자신의 일을 스스로 처리해야 한다는 우리의 직관을 벗어난다. 해결 방법은 간단하다. Theater가 Audience와 TicketSeller에 관해 너무 세세한 부분까지 알지 못하도록 정보를 차단하면 된다. 다시 말해서 관람객과 판매원을 자율적인 존재로 만들면 되는 것이다. 12345678910111213141516171819public class TicketSeller &#123; private TicketOffice ticketOffice; public TicketSeller(TicketOffice ticketOffice) &#123; this.ticketOffice = ticketOffice; &#125; public void sellTo(Audience audience) &#123; if (audience.getBag().hasInvitation()) &#123; Ticket ticket = ticketOffice.getTicket(); audience.getBag().setTicket(ticket); &#125; else &#123; Ticket ticket = ticketOffice.getTicket(); audience.getBag().minusAmount(ticket.getFee()); ticketOffice.plusAmount(ticket.getFee()); audience.getBag().setTicket(ticket); &#125; &#125;&#125; TicketSeller에서 getTicketOffice 메서드가 제거됐다는 사실에 주목하라. ticketOffice의 가시성이 private이고 접근 가능한 퍼블릭 메서드가 더 이상 존재하지 않기 때문에 외부에서는 ticketOffice에 직접 접근할 수 없다. 이처럼 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것은 캡슐화(encapsulation)이라고 부른다. 1234567891011public class Theater &#123; private TicketSeller ticketSeller; public Theater(TicketSeller ticketSeller) &#123; this.ticketSeller = ticketSeller; &#125; public void enter(Audience audience) &#123; ticketSeller.sellTo(audience); &#125;&#125; 수정된 Theater 클래스 어디서도 ticketOffice에 접근하지 않는다는 사실에 주목하라. Theater는 ticketOffice가 TicketSeller 내부에 존재한다는 사실을 알지 못한다. 위 구조에서 Theater는 오직 TicketSeller의 인터페이스(interface)에만 의존한다. TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 구현(implementation)의 영역에 속한다. 그 다음으로 Audience의 캡슐화를 개선해보자. 123456789101112131415161718public class Audience &#123; private Bag bag; public Audience(Bag bag) &#123; this.bag = bag; &#125; public Long buy(Ticket ticket) &#123; if(bag.hasInvitation()) &#123; bag.setTicket(ticket); return 0L; &#125; else &#123; bag.setTicket(ticket); bag.minusAmount(ticket.getFee()); return ticket.getFee(); &#125; &#125;&#125; Audience가 Bag을 직접 처리하기 때문에 외부에서는 더 이상 Audience가 Bag을 소유하고 있다는 사실을 알 필요가 없다. TicketSeller도 Audience의 인터페이스에만 의존하도록 수정하자. 1234567891011public class TicketSeller &#123; private TicketOffice ticketOffice; public TicketSeller(TIcketOffice ticketOffice) &#123; this.ticketOffice = ticketOffice; &#125; public void sellTo(Audience audience) &#123; ticketOffice.plusAmount(audience.buy(ticketOffice.getTicket())); &#125;&#125; 코드를 수정한 결과, TicketSeller와 Audience 사이의 결합도가 낮아졌다. 수정된 Audience와 TicketSeller는 자신이 가지고 있는 소지품을 스스로 관리한다. 더 중요한 점은 Audience나 TicketSeller의 내부 구현을 변경하더라도 Theater를 함께 변경할 필요가 없어졌다. 캡슐화와 응집도핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다. 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도(cohesion)가 높다고 말한다. 객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임져야 한다. 절차지향과 객체지향수정하기 전 코드를 살펴보자. 이 관점에서 Theater의 enter 메서드는 프로세스(Process)이며 Audience, TicketSeller, Bag, TicketOffice는 데이터(Data)다. 이처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍(Procedural Programming)이라고 부른다. 이러한 절차적 프로그래밍의 세상에서는 데이터의 변경으로 인한 영향을 지역적으로 고립시키기가 어렵다. 즉 Audience와 TicketSeller의 내부 구현을 변경하려면 Theater의 enter 메서드를 함께 변경해야 한다. 변경하기 쉬운 설계는 한 번에 하나의 클래스만 변경할 수 있는 설계다. 절차적 프로그래밍 방식과 다르게 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식을 객체지향 프로그래밍(Object-Oriented Programming)이라고 부른다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Object","slug":"Object","permalink":"http://kidongyun.github.io/tags/Object/"}]},{"title":"Jquery change() function.","slug":"2021-11-08-jquery-change-function","date":"2021-11-08T02:38:54.000Z","updated":"2022-06-01T06:14:51.482Z","comments":true,"path":"2021/11/08/","link":"","permalink":"http://kidongyun.github.io/2021/11/08/","excerpt":"","text":"JQuery 에 존재하는 change 함수는 기본적으로 대상 객체가 변경이 일어났을 때 어떤 이벤트를 발생시킬 수 있도록 해준다.일종의 이벤트 함수이다. 1$(&quot;selector&quot;).change(() -&gt; &#123;&#125;); jQuery 나 VanilaJS 를 통해 중에 단순히 필드 값을 변경시킬 수도 있는데 (예를 들면 체크박스를 체크시키는 것 처럼) 이렇게 하면 기존에 설정되어 있는 이벤트 들이 정상적으로 동작하지 않을 때도 있다. 이때 단순히 값이 변경되고 나서 $(“selector”).change() 함수를 콜백함수 없이 선언해주면 이벤트 콜이 발생된다. (정확한 원리는 모르겠다.) 해당 셀렉터에 걸려있는 모든 이벤트들이 발생함으로 주의하자. 아래는 예제 코드 12$(&quot;selector&quot;).prop(&quot;checked&quot;, true);$(&quot;selector&quot;).change();","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://kidongyun.github.io/tags/Javascript/"},{"name":"JQuery","slug":"JQuery","permalink":"http://kidongyun.github.io/tags/JQuery/"}]},{"title":"Removing rebase merge in git","slug":"2021-11-02-git-remove-rebase-merge","date":"2021-11-02T02:38:54.000Z","updated":"2022-06-01T06:14:19.421Z","comments":true,"path":"2021/11/02/","link":"","permalink":"http://kidongyun.github.io/2021/11/02/","excerpt":"","text":"The below command can remove the history of rebase merging. it sometimes makes you are angry because the branch can’t checkout to another if you are doing rebase-merge. You can remove the task of rebase-merge to checkout another branch. 1&gt; rm -fr &quot;.git/rebase-merge&quot;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://kidongyun.github.io/tags/Git/"}]},{"title":"Kibana and Sentry","slug":"2021-10-28-kibana_sentry","date":"2021-10-28T02:38:54.000Z","updated":"2022-06-01T06:09:25.343Z","comments":true,"path":"2021/10/28/","link":"","permalink":"http://kidongyun.github.io/2021/10/28/","excerpt":"","text":"센트리에는 아마 log warn 레벨부터 쌓일거에요~ Kibana belongs to “Monitoring Tools” category of the tech stack, while Sentry can be primarily classified under “Exception Monitoring”.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"},{"name":"Monitoring","slug":"Monitoring","permalink":"http://kidongyun.github.io/tags/Monitoring/"},{"name":"Sentry","slug":"Sentry","permalink":"http://kidongyun.github.io/tags/Sentry/"},{"name":"Kibana","slug":"Kibana","permalink":"http://kidongyun.github.io/tags/Kibana/"}]},{"title":"Spring A.O.P","slug":"2021-10-28-spring-aop","date":"2021-10-28T02:38:54.000Z","updated":"2022-06-01T06:13:53.755Z","comments":true,"path":"2021/10/28/","link":"","permalink":"http://kidongyun.github.io/2021/10/28/","excerpt":"","text":"프록시 패턴같은 인터페이스를 구현하고 있는 실제 요청 처리 객체와 프록시 객체를 만들고, 프록시 객체가 실제 요청 처리 객체를 가지고 있는 구조.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"},{"name":"A.O.P","slug":"A-O-P","permalink":"http://kidongyun.github.io/tags/A-O-P/"}]},{"title":"When you encounter the error 'No tests found for given includes'","slug":"2021-10-27-no-tests-found-for-given-includes","date":"2021-10-27T02:38:54.000Z","updated":"2022-06-01T06:00:32.334Z","comments":true,"path":"2021/10/27/","link":"","permalink":"http://kidongyun.github.io/2021/10/27/","excerpt":"","text":"This error means the your system couldn’t find the platfrom to execute your test code. let’s check your build.gradle file whether the below code is existed or not. 123test &#123; useJUnitPlatform()&#125; if this code is skipped, then you will encounter this error. let’s add !!","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Test","slug":"Test","permalink":"http://kidongyun.github.io/tags/Test/"},{"name":"Junit","slug":"Junit","permalink":"http://kidongyun.github.io/tags/Junit/"}]},{"title":"Vue event","slug":"2021-10-27-vue-binding-and-event","date":"2021-10-27T02:38:54.000Z","updated":"2022-06-01T06:09:39.753Z","comments":true,"path":"2021/10/27/","link":"","permalink":"http://kidongyun.github.io/2021/10/27/","excerpt":"","text":"아이폰 가상키보드로 backspace 버튼을 지속 누르고 있게 되면. 한글자씩 지워지다가 일정 수준이 지나면 단어단위로 지워지게 된다. 아마도 글이 많은 경우에 속도를 개선하기 위해 이렇게 처리된 것 같다. 여기서 알게된 점은 이 두 현상이 일으키는 이벤트는 사실상 다르다. 전자의 경우 event.inputType 값이 ‘deleteContentBackward’ 인 이벤트가 들어오게 되고 후자의 경우 ‘deleteWordBackward’ 인 이벤트가 들어오게 된다. 비즈니스 요건에 따라서 위 두 케이스를 구분해서 처리해야 하는 상황이 있었는데. 이벤트로 들어오는 객체의 inputType 속성을 참고하면 된다. deleteContentBackward 한 글자씩 지우는 이벤트 deleteWordBackward 한 단어씩 지우는 이벤트 안드로이드와 아이폰이 지워지는 방식이 조금은 달라서 위 이벤트가 안드로이드 쪽 웹뷰에서도 동일하게 나타날지는 모르겠다. 단말기 OS 뿐만아니라 웹 브라우저의 차이도 분명 존재할 것 같다. 찾아본 자료에 의하면 firefox, IE 의 경우는 event.inputType 속성 자체가 제공되지 않는다고 확인헀다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://kidongyun.github.io/tags/Vue/"},{"name":"Keyboard Event","slug":"Keyboard-Event","permalink":"http://kidongyun.github.io/tags/Keyboard-Event/"}]},{"title":"Kotlin cookbook","slug":"2021-10-25-kotlin-cookbook","date":"2021-10-25T02:38:54.000Z","updated":"2022-06-01T05:59:32.183Z","comments":true,"path":"2021/10/25/","link":"","permalink":"http://kidongyun.github.io/2021/10/25/","excerpt":"","text":"1.1 Executing Kotlin program without local compiler. You can execute Kotlin program in https://play.kotlinlang.org/ It’s IDE based on Web Platform. 1.2 Installing Kotlin compiler in your local computer. Itellij &gt; New Project &gt; Java &gt; Kotlin/JVM &gt; Src &gt; New File &gt; … 1.3 Compiling Kotlin file at Command line123&gt; kotlinc-jvm XXX.kt // creating class file for Jvm.&gt; kotlin HelloWorldKt // executing class file. 2.1 Using nullable type in KotlinUnlike Java, Kotlin basically remove the possibility of null. so you should define the type differently to use nullable type. 12345fun main() &#123; val jkRowling = Person(&quot;Joanne&quot;, null, &quot;Rowling&quot;)&#125;class Person(val first: String, val middle: String?, val last: String) somtimes someone doesn’t have a middle name. so defining the middle name as nullable type is proper. you can define nullable type as adding question mark(= ?). 1234567891011fun main() &#123; val jkRowling = Person(&quot;Joanne&quot;, null, &quot;Rowling&quot;) jkRowling.middle!!.length // you should add double exclamation mark to access nullable type. if(jkRowling.middle != null) &#123; val middleNameLength = jkRowling.middle.length; // after checking whether it is null or not, then you don&#x27;t need to use double exclamation mark. &#125;&#125;class Person(val first: String, val middle: String?, val last: String) prior to access middle name, if you checked nullable type whether it is null or not, then this type is automatically casted to non null type. so you don’t need to use double exclamation mark. but actually double exclamation mark (= !!) is code smell. This keyword would be one of the situation can occur NullPointerException. so Let’s use safe call operator (= ?.) instead of double exclamation mark. 12345678fun main() &#123; val jkRowling = Person(&quot;Joanne&quot;, null, &quot;Rowling&quot;) val middleNameLengthNullable = jkRowling.middle?.length // This code also return nullable type. (= Int?) val middleNameLength = jkRowling.middle?.length ?: 0 // if you use elvis operator (= ?:) then you can process when it is null&#125;class Person(val first: String, val middle: String?, val last: String) You can keep the safety as using the safe call operator and you always process visibly the null with Elvis operator. 2.3 Method overloading for JavaJava doesn’t support default value in parameters. so It’s doesn’t support also the constructor doesn’t have the value for optional parameters. 12345678fun main() &#123; println(addProduct(&quot;Name&quot;, 5.0, &quot;Desc&quot;)) println(addProduct(&quot;Name&quot;, 5.0)) println(addProduct(&quot;Name&quot;))&#125;fun addProduct(name: String, price: Double = 0.0, desc: String? = null) = &quot;Adding product with $name, $&#123;desc ?: &quot;None&quot;&#125;, and &quot; + NumberFormat.getCurrencyInstance().format(price) but if you define @JvmOverloads annotation on the addProduct() funcion, This function will compile many constructors to support method default parameter in Java with overloading technique. the below is the result when you decompile the addProduct() function that is included @JvmOverloads annotation. 123456789101112131415161718@JvmOverloads@NotNullpublic static final String addProduct(@NotNull String name, double price, @Nullable String desc) &#123; Intrinsics.checkParameterIsNotNull(name, &quot;name&quot;); // ...&#125;@JvmOverloads@NotNullpublic static final String addProduct(@NotNull String name, double price) &#123; return addProduct$default(name, price, (String)null, 4, (Object)null);&#125;@JvmOverloads@NotNullpublic static final String addProduct(@NotNull String name) &#123; return addProduct$default(name, 0.0D, (String)null, 6, (Object)null);&#125; You should remember the important one that @JvmOverloads annotation doesn’t call super keyword. so it means @JvmOverloads annotation only call all arguments constructor for super class. 2.4 Casting type explicitly.Kotlin doesn’t support cast the data type to more wide implicitly. it means that integer data type can’t assign to long type. but the kotlin offers the useful function like toInt(), toLong() to cast between them. 1234fun main() &#123; val intVar: Int = 3 val longVar: Long = intVar.toLong()&#125; 2.6 PowerMany languages basically support power operator (= ^). but unlike them, the kotlin doens’t support. but you can use Math.pow(double a, double b) function if you need it. additionally you can also use Double.pow(x: Double) or Float.pow(x: Float) functions. you should remember the important one that unlike double, float type, integer type doesn’t support pow() function. so you should make it yourself like the below if you want. 12fun Int.pow(x: Int) = toDouble().pow(x).toInt()fun Long.pow(x: Int) = toDouble().pow(x).toLong() infix keyword can make new custom operator that operate as you want. let’s try to make power operator with infix keyword. 1234567891011fun main() &#123; println(2 `**` 3) println(2L `**` 3) println(2F `**` 3) println(2.0 `**` 3)&#125;infix fun Int.`**`(x: Int) = toDouble().pow(x).toInt()infix fun Long.`**`(x: Int) = toDouble().pow(x).toLong()infix fun Float.`**`(x: Int) = pow(x)infix fun Double.`**`(x: Int) = pow(x) 2.9 Creating Pair instance with to keywordPair is the data class has two elements named first, second. It is same concept with Map type in Java. the kotlin language support to keyword to create Pair instance easily. 1public infix fun &lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt; = Pair(this, that) The below code show the usage of to keyword. the results of p1, p2 is same. (p1 = p2) 1234fun main() &#123; val p1 = Pair(&quot;a&quot;, 1) val p2 = &quot;a&quot; to 1&#125; You can create the Pair instance easily with mapOf() and to keyword. 123456fun main() &#123; val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2, &quot;c&quot; to 2) println(map.keys) println(map.values)&#125; You can separate key and value like the below code if you want. It’s so intutive. 1234567fun main() &#123; val pair = &quot;a&quot; to 1 val (x, y) = pair println(x) println(y)&#125; 3.1 Understaning the difference between const val and valall of them support to define the immutable data. butconst keyword support to initialize the data when the source code are compiled (compile time initialization). unlike this, val keyword initialize the data when the service is launched (run time initialization). You should know the role const and val is different. const do access control one like private, inline. but val is a keyword to define variables. 123456789101112131415class Task(val name: String, _priority: Int) &#123; companion object &#123; const val MIN_PRIORITY = 1 const val MAX_PRIORITY = 5 const val DEFAULT_PRIORITY = 3 &#125; var priority = validPriority(_priority) set(value) &#123; field = validPriority(value) &#125; private fun validPriority(p: Int) = p.coerceIn(MIN_PRIORITY, MAX_PRIORITY)&#125; MINPRIORITY, MAX_PRIORITY, DEFAULT_PRIORITY values will initialize when this source code is compiled because of _const. 3.2 Creating getter, setter자바에서 전통적으로 객체 내에 존재하는 필드들을 접근할 때에는 getter, setter 함수를 만들어서 사용했다. getter, setter 를 사용하는 이유는 객체지향 프로그래밍 관점에서 encapsulation, 정보은닉 등의 이유로 사용된 것인데 코틀린에서는 Java 코드로 변환할 때 이를 자체적으로 만들어주기 때문에 따로 getter / setter 함수를 정의하지 않고 직접 필드에 접근해도 상관 없다. 123456789101112fun main() &#123; val setTest = SetTest() println(setTest.priority) setTest.priority = 2 println(setTest.priority)&#125;class SetTest &#123; var priority = 1&#125; getter / setter 에서 로그를 추가한다거나, 데이터 검증, 전처리 작업, 후처리 작업 등도 진행할 수 있다. 이런 경우를 위해서 코틀린에서는 getter, setter 함수를 커스터마이징 할 수 있는 기능을 제공한다. get(), set() 함수의 형태로 제공한다. 1234567891011121314fun main() &#123; val setTest = SetTest() println(setTest.priority) setTest.priority = 3 println(setTest.priority)&#125;class SetTest &#123; var priority = 1 get() = field + 10 // getter 함수 커스터마이징 set(value) &#123; field = value.coerceIn(1..5) &#125; // setter 함수 커스터마이징&#125; get(), set() 함수에서 field 값을 사용하는 것을 볼 수 있는데, 이는 priority 값을 의미한다. 저 곳에 priority 값을 바로 넣어주면 재귀가 발생해서 결국 stackoverflowexception 이 발생한다. 이를 개선하기 위해서 코틀린은 accessor 영역에서 자기 값을 얻기 위해 field 라는 값을 제공한다. 이를 backing field 라고 부른다. 3.3 데이터 클래스 정의하기자바의 enum 처럼 데이터의 목적으로 사용하고 싶은 클래스를 만들어야 할 경우 클래스를 정의할 때 data 키워드를 사용하면 된다. 123456789fun main() &#123; val p1 = Product(&quot;baseball&quot;, 10.0); val p2 = Product(&quot;baseball&quot;, 10.0, false); val products = setOf(p1, p2) println(products.size)&#125;data class Product(val name: String, var price: Double, var onSale: Boolean = false) products.size 값은 1이 나올 것이다. data 클래스의 경우 동일한 값을 가지고 있는 객체끼리는 같은 객체로 본다. 그렇기 때문에 setOf() 함수를 통해 두 객체 p1, p2 를 넣을 때 같은 객체로 보고 중복되어 하나는 제거 된다. 객체의 동일성에 대한 이야기가 나온 김에 추가적으로 copy() 함수에 대한 이야기를 해보자. 이 함수는 깊은 복사가 아닌 얕은 복사를 수행한다. 그렇기 때문에 복사본 객체와 원본 객체는 서로 다른 객체이다. 123456789101112fun main() &#123; val item1 = OrderItem(Product(&quot;baseball&quot;, 10.0), 5) val item2 = item1.copy() println(item1 == item2) println(item1 === item2) println(item1.product == item2.product) println(item1.product === item2.product)&#125;data class OrderItem(val product: Product, val quantity: Int)data class Product(val name: String, var price: Double, var onSale: Boolean = false) 복사된 item2 객체와 원본 item1 객체가 서로 다른 객체임을 item1 === item2 연산을 통해 확인할 수 있다. 하나 더 중요한 부분은 그 안에서 공유하고 있는 Product 객체는 서로 같은 객체를 바라보고 있음을 item1.product === item2.product 에서 확인이 가능하다. 3.4 Backing property techniquewhen you want to control reading the properties, initializing the properties in the class, you can use getter function. 1234567891011121314151617181920212223fun main() &#123; val customer = Customer(&quot;Fred&quot;).apply &#123; messages &#125; println(customer.messages)&#125;class Customer(val name: String) &#123; private var _messages: List&lt;String&gt;? = null val messages: List&lt;String&gt; get() &#123; if (_messages == null) &#123; _messages = loadMessages() &#125; return _messages!! &#125; private fun loadMessages(): MutableList&lt;String&gt; = mutableListOf( &quot;Initial contact&quot;, &quot;Convinced them to use Kotlin&quot;, &quot;Sold training class. Sweet.&quot; ).also &#123; println(&quot;Loaded messages&quot;) &#125;&#125; in apply() function, messages’s getter method is called. and this coding style is for lazy initialization. the kotlin offers lazy delegation function so we can implement this code more easily. 123456789101112131415fun main() &#123; val customer = Customer(&quot;Fred&quot;).apply &#123; messages &#125; println(customer.messages)&#125;class Customer(val name: String) &#123; val messages: List&lt;String&gt; by lazy &#123; loadMessages() &#125; private fun loadMessages(): MutableList&lt;String&gt; = mutableListOf( &quot;Initial contact&quot;, &quot;Convinced them to use Kotlin&quot;, &quot;Sold training class. Sweet.&quot; ).also &#123; println(&quot;Loaded messages&quot;) &#125;&#125; 3.5 Operator Overloadingoperator keyword can re-define calculation way as you want. 123456789data class Point(val x: Int, val y: Int)operator fun Point.unaryMinus() = Point(-x, -y)val point = Point(10, 20)fun main() &#123; println(-point)&#125; unaryMinus() method is all of kotlin class would have. and you can overload it with operator keyword 3.6 lateinit keywordnon null properies in some class should be initialized in constructor block. but we sometimes encouter the case the parameters don’t have enough to call constructor at that time. we can use lateinit keyword to solve this problem. and you can often see this problen at the spring dependency injection (@Autowired) 1234567class OfficerControllerTests &#123; @Autowired lateinit var client: WebTestClient @Autowired lateinit var repository: OfficeRepository&#125; val : immutable type var : mutable type 3.7 overriding equals(), hashcode()the one of the features of data class is that you should keep the equality. (it’s little different with equivalence.) 123456789101112131415161718class Customer(val name: String) &#123; val messages: List&lt;String&gt; by lazy &#123; loadMessages() &#125; private fun loadMessages() : MutableList&lt;String&gt; = mutableListOf( &quot;Initial contact&quot;, &quot;Covinced them to use Kotlin&quot;, &quot;Sold training class. Sweet.&quot; ).also &#123; println(&quot;Loaded messages&quot;) &#125; override fun equals(other: Any?): Boolean &#123; if (this === other) return true val otherCustomer = (other as? Customer) ?: return false return this.name == otherCustomer.name &#125; override fun hashCode() = name.hashCode()&#125; you can override equals(), hashCode() methods like the above. 3.8 creating singleton objectyou should create singleton object like the below in Java 123456789101112public class Runtime &#123; private static final Runtime currentRuntime = new Runtime(); public static Runtime getRuntime() &#123; return currentRuntime; &#125; // protecting to create instance with constructor private Runtime() &#123;&#125; // ...&#125; but the kotlin language offers the easy way to create singleton object unlike java. 12345678910object MySingleton &#123; val myProperty = 3 fun myFunction() = &quot;hello&quot;&#125;fun main() &#123; println(MySingleton.myProperty) println(MySingleton.myFunction())&#125; you just change from class keyword to object keyword. then it will be created as the singleton type object. the below java code is the result of decompiled of MySingleton kotlin object. 1234567891011121314151617181920public final class MySingleton &#123; private static final int myProperty = 3; public static final MySingleton INSTANCE; private MySingleton() &#123;&#125; public final int getMyProperty() &#123; return myProperty; &#125; public final void myFunction() &#123; return &quot;Hello&quot;; &#125; static &#123; MySingleton var0 = new MySingleton(); INSTANCE = var0; myProperty = 3; &#125;&#125; 3.9 Nothing class1public class Nothing private constructor() the above code means that Nothing instance cannot be existed. because as you can see the above code, the constructor of Nothing class declared as a private type. and anywhere in Nothing class don’t create new instance. so Nothing instance is not existed in real. you can use this type for the value never is existed. 4.1 fold1234inline fun &lt;R&gt; Iterable&lt;T&gt;.fold( initial: R, operation: (acc: R, T) -&gt; R): R fold function needs two parameters (initial and operation). initial : it’s initialization value. operation : it’s the way how to calculate them. 12fun sum(vararg nums: Int) = nums.fold(0) &#123;acc, n -&gt; acc + n &#125; in lambda named operation, acc means a accumulated value and n means n-th value in nums array. the below is factoral function example with fold() function. 12345fun factorialFold(n: Long): BigInteger = when(n) &#123; 0L, 1L -&gt; BigInteger.ONE else -&gt; (2..n).fold(BigInteger.ONE) &#123; acc, i -&gt; acc * BigInteger.valueOf(i) &#125; &#125; 12fun fibonacciFold(n: Int) = (2 until n).fold(1 to 1) &#123; (prev, curr), _ -&gt; curr to (prev + curr) &#125;.second and it is another example to use fold() function. especially in this function, n value in lambda doesn’t need so just mark it with ‘_’. 4.2 reducethis function is fold() function without initial value. 123inline fun &lt;S, T : S&gt; Iterable&lt;T&gt;.reduce( operation: (acc: S, T) -&gt; S): S 123456789101112public inline fun IntArray.reduce( operation: (acc: Int, Int) -&gt; Int): Int &#123; if(isEmpty()) throw UnsupportedOperationException(&quot;Empty array can&#x27;t be reduced.&quot;) var accumulator = this[0] for (index in 1..lastIndex) &#123; accumulator = operation(accumulator, this[index]) &#125; return accumulator;&#125; this code is real implementation code of reduce in IntArray collection. 12fun sumReduce(vararg nums: Int) = nums.reduce &#123; acc, i -&gt; acc + i &#125; and it is the one of the example with reduce() function. this code calculate summation of nums array. 4.3 tail recursionfactorial calculation is usually implemented by recursion like the below. 12345fun recursiveFactorial(n: Long): BigInteger = when (n) &#123; 0L, 1L -&gt; BigInteger.ONE else -&gt; BigInteger.valueOf(n) * recursiveFactorial(n - 1) &#125; but recursiveFactorial() function will create new frame in call stack memory when it’s called. so someday it would encounter StackOverflowError. i mean this way would waste your memory. if you wanna optimize memory with recursive call then use tailrec. 1234567@JvmOverloadstailrec fun factorial(n: Long, acc: BigInteger = BigInteger.ONE): BigInteger = when (n) &#123; 0L -&gt; BigInteger.ONE 1L -&gt; acc else -&gt; factorial(n - 1, acc * BigInteger.valueOf(n)) &#125; this code is work well in 0L, 1L cases. because of @JvmOverloads annotation. I mean you can skip acc value if you want because it has default value (= BigInteger.ONE). and tailrec keyword change your code from recursive style to loop style to optimize call stack memory when it’s compiled to Java. 5.1 arrayThe kotlin create the array with arrayOf() function easily. 12345val strings = arrayOf(&quot;this&quot;, &quot;is&quot;, &quot;an&quot;, &quot;array&quot;, &quot;of&quot;, &quot;strings&quot;)val nullStringArray = arrayOfNulls&lt;String&gt;(5)val squares = Array(5) &#123;i -&gt; (i * i).toString() &#125; 123fun &lt;T&gt; Array&lt;out T&gt;.withIndex()data class IndexedValue&lt;out T&gt;(public val index: Int, public val value: T) when you need to get index value in array you can use IndexedValue type with withIndex() function. 5.2 creating collection immutable collection : listOf, setOf, mapOf mutable collection : mutableListOf, mutableSetOf, mutableMapOf 5.4 creating map with collectionassociate() function can create Map object from collection. 123val keys = &#x27;a&#x27;..&#x27;f&#x27;val map = keys.associate &#123; it to it.toString().repeat(5).capitalize() &#125;println(map) 5.5 returning default value when collection is empty12345678910111213data class Product(val name: String, var price: Double, var onSale: Boolean = false)fun onSaleProducts_ifEmptyCollection(products: List&lt;Product&gt;) = products.filter &#123; it.onSale &#125; .map &#123; it.name &#125; .ifEmpty &#123; listOf(&quot;none&quot;) &#125; .joinToString(separator = &quot;, &quot;)fun onSaleProducts_ifEmptyString(products: List&lt;Product&gt;) = products.filter &#123; it.onSale &#125; .map &#123; it.name &#125; .joinToString(separator = &quot;, &quot;) .ifEmpty &#123; &quot;none&quot; &#125; 5.8 destructuring list123val list = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;)val (a, b, c, d, e) = listprintln(&quot;$a $b $c $d $e&quot;) you can get the fields of the object like (a, b, c, d, e). 5.9 sorting with multiple options.1234567fun &lt;T&gt; Iterable&lt;T&gt;.sortedWith( comparator: Comparator&lt;in T&gt;): List&lt;T&gt;fun &lt;T&gt; compareBy( varargs seletors (T) -&gt; Comparable&lt;*&gt;?): Comparator&lt;T&gt; 123456789101112131415data class Golfer(val score: Int, val first: String, val last: String)val golfers = listOf( Golfer(70, &quot;Jack&quot;, &quot;Nicklaus&quot;), Golfer(68, &quot;Tom&quot;, &quot;Watson&quot;), Golfer(68, &quot;Bubba&quot;, &quot;Watson&quot;), Golfer(70, &quot;Tiger&quot;, &quot;Woods&quot;), Golfer(68, &quot;Try&quot;, &quot;Webb&quot;))fun main() &#123; val sorted = golfers.sortedWith(compareBy(&#123; it.score &#125;, &#123; it.last &#125;, &#123; it.first &#125;)) println(sorted)&#125; comparator be more complexible then the below code is better to read than the above. 123456789101112131415161718data class Golfer(val score: Int, val first: String, val last: String)val golfers = listOf( Golfer(70, &quot;Jack&quot;, &quot;Nicklaus&quot;), Golfer(68, &quot;Tom&quot;, &quot;Watson&quot;), Golfer(68, &quot;Bubba&quot;, &quot;Watson&quot;), Golfer(70, &quot;Tiger&quot;, &quot;Woods&quot;), Golfer(68, &quot;Try&quot;, &quot;Webb&quot;))fun main() &#123; val comparator = compareBy&lt;Golfer&gt;(Golfer::score) .thenBy(Golfer::last) .thenBy(Golfer::first) golfers.sortedWith(comparator) .forEach(::println)&#125; 5.10 defining custom iteratorIt is the definition of Iterator interface in kotlin. 1234interface Iterator&lt;out T&gt; &#123; operator fun next(): T operator fun hasNext(): Boolean&#125; It’s default way to use Iterator 12345678910111213141516data class Player(val name: String)class Team(val name: String, val players: MutableList&lt;Player&gt; = mutableListOf()) &#123; fun addPlayers(vararg people: Player) = players.addAll(people)&#125;fun main() &#123; val team = Team(&quot;Warriors&quot;) team.addPlayers(Player(&quot;Curry&quot;), Player(&quot;Thompson&quot;), Player(&quot;Durant&quot;), Player(&quot;Green&quot;), Player(&quot;Cousins&quot;)) for(player in team.players) &#123; println(player) &#125;&#125; you can access it easier. 12345operator fun Team.iterator() : Iterator&lt;Player&gt; = players.iterator()for (player in team) &#123; println(player)&#125; 5.11 Filtering collection by type.123456 val list = listOf(&quot;a&quot;, LocalDate.now(), 3, 1, 4, &quot;b&quot;) val strings = list.filter &#123; it is String &#125; for (s in strings) &#123;// s.length : it must not be compiled. because strings types is List&lt;Any&gt;. &#125; 1234567891011val list = listOf(&quot;a&quot;, LocalDate.now(), 3, 1, 4, &quot;b&quot;)val all = list.filterIsInstance&lt;Any&gt;()val strings = list.filterIsInstance&lt;String&gt;()val ints = list.filterIsInstance&lt;Int&gt;()val dates = list.filterIsInstance(LocalDate::class.java)println(all)println(strings)println(ints)println(dates) 5.12 Create array with range.12345678910operator fun &lt;T : Comparable&lt;T&gt;&gt; T.rangeTo(that: T) = ClosedRange&lt;T&gt; = ComparableRange(this, that)interface ClosedRange&lt;T: Comparable&lt;T&gt;&gt; &#123; val start: T val endInclusive: T operator fun contains(value: T): Boolean = value &gt;= start &amp;&amp; value &lt;= endInclusive fun isEmpty(): Boolean = start &gt; endInclusive&#125; 코틀린에서는 1..5 처럼 IntRange를 인스턴스화하는 2개의 점 연사자를 사용해서 범위를 생성한다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://kidongyun.github.io/tags/Kotlin/"}]},{"title":"Validation Annotation","slug":"2021-10-24-validation-annotation","date":"2021-10-24T02:38:54.000Z","updated":"2022-06-01T05:59:16.428Z","comments":true,"path":"2021/10/24/","link":"","permalink":"http://kidongyun.github.io/2021/10/24/","excerpt":"","text":"@NotNull Null 값을 허용하지 않는다. @NotEmpty Null 값과 “” 값을 허용하지 않는다. @NotBlank Null 값과 “” 값과 “ “ 값을 허용하지 않는다. @Email 입력 값이 이메일 형식이 아니라면 허용하지 않는다. @Min(1) 1자 이상의 값만을 허용한다. @Max(10) 10자 미만의 값만을 허용한다. @Size(min = 1, max = 10) 해당 필드의 길이가 1자 이상 10자 미만만 허용한다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Validation","slug":"Validation","permalink":"http://kidongyun.github.io/tags/Validation/"}]},{"title":"How do we change the serializing style with enum","slug":"2021-10-22-enum-jackson-serialize","date":"2021-10-22T02:38:54.000Z","updated":"2022-06-01T05:58:39.700Z","comments":true,"path":"2021/10/22/","link":"","permalink":"http://kidongyun.github.io/2021/10/22/","excerpt":"","text":"Enum objects usually return their value data (no field data) when you serialize it. if you want to change this, you can use @JsonValue, @JsonFormat annotation in Jackson library that is the main part for serialization in Spring Framework. @JsonValueYou can change the field to serialize with this annotation. 12345678910111213141516171819enum Season &#123; SPRING(&quot;S&quot;, &quot;봄&quot;), SUMMER(&quot;M&quot;, &quot;여름&quot;), FALL(&quot;F&quot;, &quot;가을&quot;), WINTER(&quot;W&quot;, &quot;겨울&quot;); Season(String code, String value) &#123; this.code = code; this.value = value; &#125; private final String code; private final String value; /* Jackson will use this value when it is serialized. */ @JsonValue public String code() &#123; return code; &#125; public String value() &#123; return value; &#125;&#125; @JsonFormat(shape = JsonFormat.Shape.OBJECT)If you want to serialize all of the fields in enum, this annotation will be helpful to you. 12345678910111213141516/* Jackson will use all of the fields in enum. */@JsonFormat(shape = JsonFormat.Shape.OBJECT)enum Season &#123; SPRING(&quot;S&quot;, &quot;봄&quot;), SUMMER(&quot;M&quot;, &quot;여름&quot;), FALL(&quot;F&quot;, &quot;가을&quot;), WINTER(&quot;W&quot;, &quot;겨울&quot;); Season(String code, String value) &#123; this.code = code; this.value = value; &#125; private final String code; private final String value; public String code() &#123; return code; &#125; public String value() &#123; return value; &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Enum","slug":"Enum","permalink":"http://kidongyun.github.io/tags/Enum/"},{"name":"Serialize","slug":"Serialize","permalink":"http://kidongyun.github.io/tags/Serialize/"}]},{"title":"LocalDate json timestamp","slug":"2021-04-15-localdate-object-to-json-type","date":"2021-04-14T15:54:00.000Z","updated":"2022-06-01T05:57:45.726Z","comments":true,"path":"2021/04/15/","link":"","permalink":"http://kidongyun.github.io/2021/04/15/","excerpt":"","text":"123ObjectMapper mapper = new ObjectMapper();mapper.registerModule(new JavaTimeModule()); // 추가mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); // 추가","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Timestamp","slug":"Timestamp","permalink":"http://kidongyun.github.io/tags/Timestamp/"}]},{"title":"추상클래스를 사용하는 이유","slug":"2021-04-15-why-do-we-use-abstract","date":"2021-04-14T15:54:00.000Z","updated":"2022-06-01T05:58:06.998Z","comments":true,"path":"2021/04/15/","link":"","permalink":"http://kidongyun.github.io/2021/04/15/","excerpt":"","text":"interface는 추상클래스랑은 다르게 규격, 규약에 가깝다. 준수해야하는 규칙이다. SOLID 에서 I 에 해당하는 ISP 보면 알 수 있듯이 이 Interface는 최소한으로 잡으며, Interface마다 분리해서 설계한다. 여기서 만약 특정 Interface를 준수하여 작성된 하위클래스 3개가 있다고 하자. 이 3개의 클래스들은 어느정도 공통성을 가진 기능을 구현해야할 수도 있을 것이다. 이럴때 추상클래스를 Interface와 하위클래스들 사이에 구현하며 이 추상클래스에서 공통된 기능들을 구현한다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Abstract Class","slug":"Abstract-Class","permalink":"http://kidongyun.github.io/tags/Abstract-Class/"}]},{"title":"Docker Postgreql Command","slug":"2021-04-08-docker-postgresql","date":"2021-04-07T15:54:00.000Z","updated":"2022-06-01T05:42:33.982Z","comments":true,"path":"2021/04/08/","link":"","permalink":"http://kidongyun.github.io/2021/04/08/","excerpt":"","text":"1234567docker start postgreql_bridgedocker exec -it postgresql_bridge /bin/bashdocker -d bridge -u kidong\\dt","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://kidongyun.github.io/tags/Database/"},{"name":"Postgresql","slug":"Postgresql","permalink":"http://kidongyun.github.io/tags/Postgresql/"}]},{"title":"스프링 부트에 high level 엘라스틱서치 클라이언트 적용","slug":"2021-04-07-high-level-elasticsearch-client","date":"2021-04-06T15:54:00.000Z","updated":"2022-06-01T05:42:24.620Z","comments":true,"path":"2021/04/07/","link":"","permalink":"http://kidongyun.github.io/2021/04/07/","excerpt":"","text":"dependencies1234&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;&lt;/dependency&gt; Config12345678910111213@Configuration@AllArgsConstructorpublic class ElasticsearchConfig &#123; private final String host = &quot;XXX.XXX.XXX.XXX&quot;; private final int port = 9200; @Bean public RestHighLevelClient client() &#123; return new RestHighLevelClient(RestClient.builder(new HttpHost(host, port, &quot;http&quot;))); &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://kidongyun.github.io/tags/ElasticSearch/"},{"name":"High Level ElasticSearch","slug":"High-Level-ElasticSearch","permalink":"http://kidongyun.github.io/tags/High-Level-ElasticSearch/"}]},{"title":"ElasticSearch DSL","slug":"2021-03-24-elasticsearch-querydsl","date":"2021-03-23T15:54:00.000Z","updated":"2022-06-01T05:41:57.067Z","comments":true,"path":"2021/03/24/","link":"","permalink":"http://kidongyun.github.io/2021/03/24/","excerpt":"","text":"클러스터 정보 조회하기.REQ1curl -XGET http://192.168.28.176:9200/_cluster/health?pretty RES1234567891011121314151617&#123; &quot;cluster_name&quot; : &quot;interCluster&quot;, &quot;status&quot; : &quot;red&quot;, &quot;timed_out&quot; : false, &quot;number_of_nodes&quot; : 1, &quot;number_of_data_nodes&quot; : 1, &quot;active_primary_shards&quot; : 348, &quot;active_shards&quot; : 348, &quot;relocating_shards&quot; : 0, &quot;initializing_shards&quot; : 0, &quot;unassigned_shards&quot; : 562, &quot;delayed_unassigned_shards&quot; : 0, &quot;number_of_pending_tasks&quot; : 0, &quot;number_of_in_flight_fetch&quot; : 0, &quot;task_max_waiting_in_queue_millis&quot; : 0, &quot;active_shards_percent_as_number&quot; : 38.24175824175824&#125; yellow 상태는 모든 데이터의 읽기/쓰기가 가능한 상태이지만 일부 replica shard가 아직 배정되지 않은 상태를 말합니다. RAID 0 (STRIPE)2개의 디스크가 있을때 데이터를 이 두개의 디스크에 나눠어 저장하는 방법. 디스크의 액세스 활동이 두 군데서 발생하기 때문에 데이터를 저장하는 속도를 높일 수 있다. 저장이 포인트. 검색이 아니다. RAID 1 (MIRROR)2개의 디스크가 있을 때 각 디스크에 데이터를 똑같이 저장하는 방법. 성능을 높이지는 않지만 백업의 효과를 가진다. SHARDRAID 0 와 유사한 개념. Shard 수치가 5라고 한다면, 하나의 인덱스(DB)에 내부적으로 논리적으로 5개의 샤드를 생성한다. 물론 또다른 index를 생성하게 되면 그에 대한 shard를 새로 생성된다. REPLICARAID 1 과 유사한 개념. 복제본을 가지고 있는 것으로. 원본 shard에 장애가 나더라 도 복제본 Shard를 통해 데이터를 제공할 수 있다. 한 노드안에는 PRIMARY, REPLICA SHARD가 서로 다르게 들어가게 되는데. 이는 특정 node가 장애가 났을 때 동일한 데이터를 잃지 않게 하기 위함이다. 또 REPLICA의 경우 동일한 데이터를 여러 SHARD에서 저장하고 있기 때문에 검색시에 성능향상을 가지고 있다. 검색이 포인트. 저장이 아니다. INDEX 생성하기.1curl -XPUT http://192.168.28.176:9200/test_index_by_ykd?pretty INDEX 조회하기.1curl -XGET http://192.168.28.176:9200/test_index_by_ykd?pretty INDEX 제거하기.1curl -XDELETE http://192.168.28.176:9200/test_index_by_ykd?pretty 현재 존재하는 인덱스 정보 조회하기.REQ1curl -XGET http://192.168.28.176:9200/_cat/indices?v RES12health status index pri rep docs.count docs.deleted store.size pri.store.sizeyellow open test_index_by_ykd 5 1 0 0 795b 795b health 상태랑, primary shard 개수와, replica shard 개수를 알 수 있다. 현재 존재하는 샤드 정보 조회하기.REQ1curl -XGET http://192.168.28.176:9200/_cat/shards?v RES1234567891011index shard prirep state docs store ip nodetest_index_by_ykd 1 p STARTED 0 159b 192.168.28.176 node-176-clienttest_index_by_ykd 1 r UNASSIGNEDtest_index_by_ykd 3 p STARTED 0 159b 192.168.28.176 node-176-clienttest_index_by_ykd 3 r UNASSIGNEDtest_index_by_ykd 4 p STARTED 0 159b 192.168.28.176 node-176-clienttest_index_by_ykd 4 r UNASSIGNEDtest_index_by_ykd 2 p STARTED 0 159b 192.168.28.176 node-176-clienttest_index_by_ykd 2 r UNASSIGNEDtest_index_by_ykd 0 p STARTED 0 159b 192.168.28.176 node-176-clienttest_index_by_ykd 0 r UNASSIGNED shard 항목이 shard 번호를 보여주는 것 같고 indces 조회를 통해서 shard 개수가 5개인 걸로 볼 수 있는데 보면 shard 번호가.1~5까지 있다. 2개씩있는 이유는 replica shard도 한개씩 더 있어야하기 때문이다. replica shard 들이 모두 UNASSIGNED 상태에 있는데. 그 이유는 primary shard와 replica shard의 같은 번호들은 같은 노드에 존재할 수 없다. 백업의 의미가 없어지기 때문. 문자열을 직접 넣어 DOCUMENT 생성하기.1hello it&#x27;s me","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://kidongyun.github.io/tags/Database/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://kidongyun.github.io/tags/ElasticSearch/"},{"name":"DSL","slug":"DSL","permalink":"http://kidongyun.github.io/tags/DSL/"}]},{"title":"2차 면접 준비","slug":"2021-03-23-second-interview-preparing","date":"2021-03-22T15:54:00.000Z","updated":"2022-06-01T05:41:20.664Z","comments":true,"path":"2021/03/23/","link":"","permalink":"http://kidongyun.github.io/2021/03/23/","excerpt":"","text":"1. TCP 특징 제어를 한다. 가상회선을 구축하고 해당 회선을 따라서 데이터를 주고 받는다. 주고받는 데이터가 오류가 있으면 안될때 사용. TCP Header 32비트 SYN, FIN, ACK 플래그 존재. SYN : 연결을 맺고싶을 때 FIN : 연결을 끊고싶을 때 ACK : 상대방의 정보를 잘 받았을 때. 3 ways HandShake 클라이언트가 SYN 신호가 1이 된 상태로 전송 서버가 이를 수신했다는 의미로 ACK 신호를 1로 바꾸고, 마찬가지로 SYN 신호도 1로 바꾸어 전송 클라이언트가 서버의 데이터를 수신했다는 의미로 ACK 플래그를 1로 바꾸어 전송. 4 ways handshake 클라이언트가 FIN 플래그를 전송 서버가 수신완료를 의미하기 위해 ACK 플래그를 전송 서버가 작업이 모두 완료되면 FIN 플래그를 전송 클라이언트가 수신완료를 알리기 위해 ACK 플래그를 전송 2. TLSTransport Layer Security netscape사에서 처음으로 발표한 SSL 기술을 IETF 에서 표준적으로 정의한 용어. 배경 기존 HTTP 데이터를 암호화하지 않고 주고 받는 다면 DCE 장비들에서 데이터들이 노출이 됨. 잘못된 상대방과 통신할 가능성이 있음. 기능 암복호화 인증 무결성 3. 웹 통신 흐름 웹브라우저 특정 URL 접속. DNS 서버 탐색을 해서 IP를 얻어냄 (local hosts 파일, 로컬 DNS 서버) ARP 프로토콜 IP -&gt; MAC 주소로 변경. MAC 주소에 해당하는 Destination terminal을 찾아간다 (OSPF, RIP) 포트번호를 통해서 웹서버 프로세스에 접근한다. 정적 리소스 파일 요청이라면 웹서버에서 처리. 동적 컨텐츠라면 WAS에게 넘긴다. WAS에 있는 서블릿 컨테이너가 DispatcherServlet 을 생성. DispatcherServlet이 RequestMapping에 맞춰서 실행. view 파일이라면 resolver 에 맞춰서 응답 값 전달. 아니면 String. 4. 웹서버와 WAS를 구분시켜서 두는 이유. 로드밸런싱 (modjk) - nginx의 경우 upstream 설정. 보안 (WAS는 데이터베이스 등을 접근하기 때문에 외부로부터 노출 X) 캐시 적중률 향상, 페이지 부재 감소 5. Sync vs Async시간이 주요 관점. 6. Blocking vs Non Blocking제어가 주요 관점. 7. 함수형 프로그래밍.특징 멱등성 : 동일한 입력에 대해서 동일한 출력이 나온다. 순수함수 : 멱등성을 지키는 함수. (의존성 문제, 테스트 코드 작성) 일급객체 : 함수를 일급객체로 볼 수 있다. 선언적 프로그래밍 방식 : 어떻게 할까보다 무엇을 할까가 포커스. 자바에서의 함수형 프로그래밍 익명클래스 람다, 메서드 레퍼런스. 스트림. 8. 프로세스 개념 : 메모리에 상주되어 있는 프로그램. PCB - 메모리 영역 (TEXT, DATA, HEAP, STACK) - PID : 프로세스 식별자. - 프로세스 상태 : new, ready, running, waiting, halted - 프로그램 카운터 : 다음 실행할 명령어의 주소. IPC 9. Docker10. MVC Model, View, Controller의 역할 업무의 분할, 디버깅이 용이 MODEL-VIEW-CONTROLLER 11. elasticsearch 노드, 샤드, 레플리카 역색인 querydsl 구조 키바나 : 로그 모니터링 엘라스틱서치 : 데이터 저장 및 데이터 조회 로그스태쉬 : 다른 저장소와 연동 12. GC Stop the worlld eden, survivor1, survivor2, old, minorGC, fullGC Parallel GC, CMS GC, G1GC Mark-Sweep-Compaction 13. JVM Class Loader - 디스크에 존재하는 class파일을 메인메모리에 적재. Runtime data area - Heap, Method, Stack, GC Execution engine - 자바 인터프리터, JIT 컴파일러. 14. Spring Framework. Spring IOC, DL, DI, AOP Spring Web MVC, Spring Data JPA, Spring DAta redis, Spring test 15. Spring AOP Advice - 언제. Weaving - Aspect를 Target에 넣는 행위 자체. JointPoint - Advice가 적용 가능한 지점. Aspect - 공통 기능. Target - 공통 기능을 넣을 대상 객체 16. 캐시 파레토 법칙 -&gt; 개념 지역성 Look aside, Write back 17. SOLID S : 단일책임의 원칙. 하나의 클래스는 하나의 기능을 가진다. O : 개방폐쇄의 원칙 코드를 확장하는 것에는 열려있고, 변경에는 닫혀있어야하는 원리 L : 리스코브 치환의 원칙. 서브타입은 언제나 기반타입과 호환이 될 수 있어야 한다. I : 인터페이스 분리의 원칙. 하나의 일반적인 인터페이스 보다는 여러 개의 구체적인 인터페이스가 좋다. D : 의존성 역전의 원칙. 18. TDD 테스트 코드를 먼저 작성하고 소스 코드를 작성하는 방법. 단점 : TDD를 하면 개발 시간이 늘어난다. 장점 : TDD를 하면 결함이 줄어든다. 지속적으로 테스트를 하면서 코드를 작성하기 때문. TDD를 하면 소스코드의 의존성을 감소시킬 수 있다. 리팩토링에 대한 비용이 줄어든다. 19. FunctionalInterfaceConsumer -&gt; 입력 : T타입, 출력 : voidSupplicer -&gt; 입력 : void, 출력 : T타입Function -&gt; 입력 : T, 출력 : RPredicate -&gt; 입력 : T, 출력 : boolean 20. Hash 해시 기본 구조 (해시코드, 해시테이블) 해시충돌 (체이닝, 이중해시) 21. Heap트리구조, 자식노드가 루트노드보다 우선순위가 높지 않다.삽입, 삭제 동작원리. 22. 이진 탐색 트리23. JPA (ORM의 장점)벤더사 독립적이다. persistent context 라는 캐싱 영역이 존재한다. 트랜잭션 관리가 용이하다. CRUD 쿼리를 직접 짜지않기 때문에 생산성이 좋아진다. 24. N+1 문제이렇게 하위 엔티티들을 첫 쿼리 실행시 한번에 가져오지 않고, Lazy Loading으로 필요한 곳에서 사용되어 쿼리가 실행될때 발생하는 문제가 N+1 쿼리 문제입니다. 해결방법 : joinFetch, EntityGraph 25. 인덱스. B-TREE 구조. INDEX RANGE SCAN, FULL TABLE SCAN INDEX ACCCESS 조건, FILTER 조건 26. JOIN NETSTED LOOP JOIN HASH JOIN SORT MERGE JOIN 27. Checked Exception, Unchecked Exception28. Redis 메모리에서 동작. 물리적 메모리 크기보다 크면, 디스크를 활용하게 되기 때문에 성능 감소 -&gt; 레디스를 쓰는 이유가 사라짐. Collection Set, SortedSet, List, Hash, RedisTemplate 레디스는 싱글스레드 처리 29. 프로세스 vs 쓰레드프로세스 : 프로그램이 메인 메모리에 올라감.PCB : PID, 메모리(Heap, Text, Stack, Data), PC 쓰레드 : 프로세스 내부에서의 코드의 흐름.Heap 영역 제외 공유.데이터 공유 비용이 더 쌈. IPC - Inter Process Communication 30. 쿠키, 세션, JWT31. Spring security Filter based 처리 인증, 권한 Security Context 32. JWTheader.payload.signature 장점. 사용자 인증에 필요한 모든 정보는 토큰 자체에 포함하기 때문에 저장소 X, 확장 유지보수에서 유리 단점. 유효기간. -&gt; Refresh Token 해결 33. RESTHTTP URL, HTTP Method Open API 34. ACID트랜잭션이란 논리적 작업 단위. A : 원자성 - 해당 작업이 논리적으로 데이터 정합성 관점에서 더 이상 나눠질 수 없음. C : 일관성 - 해당 트랜잭션의 결과가 항상 동일하다. I : 독립성 - 해당 트랜잭션이 동작될 떄 다른 트랜잭션 개입 X D : 지속성 - 해다 트랜잭션의 결과가 일시적이지 않고 영구히 지속되어야함. 35. 테스트 종류유닛테스트 통합테스트 기능테스트 36. DP, Greedy,37. 빌더패턴, 프록시패턴38. nginx 로드밸런싱 적용. upstream 설정 분배규칙 weight 39. HashhashAlgorithm을 설계 -&gt; hashAlgorithm은 HashCode를 반환 -&gt; hashCode를 hashtable 크기에 맞게 모듈러 연산 -&gt; 이 결과 값이 배열의 키가 되며 해당 인덱스에 value 값을 저장 value 가 여러개일 경우 충돌이 발생했다 하며 해결 방법은 연결리스트를 두는 Chanining 방법, Open Addressing 방법이 있음.여기서는 Chaining 방법을 고려 값이 여러개가 되면 연결리스트를 두고 차곡차곡 쌓음.충돌이 많이 나는 경우에는 이 부분을 트리구조로 변경하여 검색의 속도를 높일 수 있음.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://kidongyun.github.io/tags/Computer-Science/"},{"name":"Interview","slug":"Interview","permalink":"http://kidongyun.github.io/tags/Interview/"}]},{"title":"스프링 부트 레디스 적용","slug":"2021-03-23-spring-boot-redis","date":"2021-03-22T15:54:00.000Z","updated":"2022-06-01T05:41:34.526Z","comments":true,"path":"2021/03/23/","link":"","permalink":"http://kidongyun.github.io/2021/03/23/","excerpt":"","text":"스프링 부트 프로젝트 생성 후 아래 의존성 추가. 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; docker로 레디스를 띄운다. redis 이미지를 가져오며. 해당 컨테이너의 이름을 redis_boot 로 명명. 이 redis 컨테이너는 호스트와 6379 포트로 통신한다. 1docker run -p 6379:6379 --name redis_boot -d redis 레디스에 접속한다. 1docker exec -i -t redis_boot redis-cli Runner 클래스에 redis에 데이터 푸쉬하는 코드 작성. 12345678910111213@Componentpublic class RedisRunner implements ApplicationRunner &#123; @Autowired StringRedisTemplate redisTemplate; @Override public void run(ApplicationArguments args) throws Exception &#123; ValueOperations&lt;String, String&gt; values = redisTemplate.opsForValue(); values.set(&quot;keesun&quot;, &quot;whiteship&quot;); values.set(&quot;springboot&quot;, &quot;2.0&quot;); values.set(&quot;hello&quot;, &quot;world&quot;); &#125;&#125; keys * 명령어를 통해서 전체 키 목록 조회 가능. get {key} 입력하게 되면 value 값이 반환됨. remote dictionary server - 자료구조가 기본적으로 key-value 라는 이야기. spring boot 에서 redis 커스터마이징 할때에는 application.properties 에서 적용 가능.포트를 변경한다던지 등등 12spring.redis.url=spring.redis.port= repository 를 활용해서 레디스를 사용해보자. 123456789101112131415161718192021222324252627282930313233@RedisHash(&quot;accounts&quot;)public class Account &#123; @Id private String id; private String username; private String email; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; 1public interface AccountRepository extends CrudRepository&lt;Account, String&gt; &#123;&#125; 123456789101112131415161718192021222324252627@Componentpublic class RedisRunner implements ApplicationRunner &#123; @Autowired StringRedisTemplate redisTemplate; @Autowired AccountRepository accountRepository; @Override public void run(ApplicationArguments args) throws Exception &#123; ValueOperations&lt;String, String&gt; values = redisTemplate.opsForValue(); values.set(&quot;keesun&quot;, &quot;whiteship&quot;); values.set(&quot;springboot&quot;, &quot;2.0&quot;); values.set(&quot;hello&quot;, &quot;world&quot;); Account account = new Account(); account.setEmail(&quot;kidong@gmail.com&quot;); account.setUsername(&quot;kidong&quot;); accountRepository.save(account); Optional&lt;Account&gt; byId = accountRepository.findById(account.getId()); System.out.println(byId.get().getUsername()); System.out.println(byId.get().getEmail()); &#125;&#125; 레디스 명령어hget : hash 타입의 데이터에서 특정 필드를 가져옴. hgetall : hash 타입의 데이터 모두를 가져옴. (컬렉션을 가져옴) 레디스 명령어들 123// foo 라는 키를 가진 데이터의 유효기간을 10초로 설정. 10초가 지나면 사라짐// 캐시서버이기 때문에 유효기간 설정하는것은 중요.expire foo 10 12// 10초 후에 temp:key1 키를 가지고 &quot;...&quot; value 를 가지는 데이터가 사라진다.set temp:key1 &quot;it will delete after 10 seconds&quot; ex 10 12345// 한번에 여러 개의 key-value 를 저장한다. 여기서는 a와 1의 묶음과, b와 2의 묶음을 저장한다.mset a 1 b 2// 한번에 여러 개의 key 데이터를 조회한다. 여기서 c는 없기 때문에 nil 값이 나온당.mget a b c 123456//레디스에서 hash 구조는 key-subkey-value 구조를 가진다. hset key1 subkey1 &quot;hello&quot;hset key1 subkey2 &quot;world&quot;hget key1 subkey1hkeys key1 -&gt; 이 명령어는 레디스에 락이 걸리기 때문에 주의해야 한다. 1234567891011// list 구조// 리스트의 왼쪽에 a 값을 삽입lpush gdhong:test &quot;a&quot;// 리스트의 오른쪽에 b 값을 삽입.rpush gdhong:test &quot;b&quot;// 리스트의 왼쪽 부터 숫자 만큼 추출lpop gdhong:test 2// 리스트의 오른쪽 부터 숫자 만큼 추출rpop gdhong:test 2// 리스트를 주어진 숫자 범위만큼 검색.lrange gdhong:test 0 4 12345678910111213141516171819202122// set 구조// set 구조이고 gdhong:task 키에 &quot;programming&quot; value 삽입sadd gdhong:task &quot;programming&quot;// set 구조이고 gdhong:task 키에 &quot;reading&quot; value 삽입sadd gdhong:task &quot;reading&quot;// 위 명령어를 한번더 수행해도 삽입이 안됨. set이 중복이 안되는 구조이기 때문.// set 구조의 키를 넣으면 해당 value 값들을 조회할 수 있다smembers gdhong:task// 만약 존재하는 value면 1을 반환, 아니면 0을 반환.sismember gdhong:task reading - 1sismember gdhong:task writing - 0// 두 집합의 합집합을 구함 (중복은 제거된다는 의미)sunion gdhong:task gdhong:task2// 두 집합의 차집합을 구함sdiff gdhong:task gdhong:task2// 두 집합의 교집합을 구함sinter gdhong:task gdhong:task2 1234567// ordered set 집합이지만 오름차순으로 정렬되어 있음// ordered set 컬렉션에 데이터를 넣음. 가중치 값이 추가로 들어간다.zadd users:point 1 gdhong// 조회.zrange SpringTemplate 을 활용한 레디스 명령어 처리","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Redis","slug":"Redis","permalink":"http://kidongyun.github.io/tags/Redis/"}]},{"title":"Cache","slug":"2021-03-22-woowa-cache","date":"2021-03-21T15:54:00.000Z","updated":"2022-06-01T05:32:56.811Z","comments":true,"path":"2021/03/22/","link":"","permalink":"http://kidongyun.github.io/2021/03/22/","excerpt":"","text":"메모리 계층 구조.속도와 용량이 반비례 관계이기 때문에. 용도에 따라서 나누어 쓴다. 그게 메모리 계층 구조를 가진다. 파레토의 법칙.원인 중 상위 20%가 전체 결과의 80%를 만든다는 법칙. 이 20%만을 캐쉬로 처리할 수 있다면 보다 더 좋은 성능을 발휘할 수 있다는 의미. 데이터 지역성의 원리.시간 지역성, 공간 지역성. 순차지역성순차 지역성 = 시간 지역성 + 공간 지역성. cache - 나중에 필요할 수도 있는 무언가를 저장하였다가 신속하게 회수할 수 있는 보관 장소. 원본 데이터와는 별개로 자주 쓰이는 데이터들을 복사해둘 캐시 공간을 마련하고. 여기에서 접근하여 사용. 캐쉬의 활용방법도 두가지. aside 방식인가? 아래 참고 ㅋㅋ Look aside Cache메인은 DB이고 DB에서 캐쉬로 데이터를 가져와서 저장. 캐쉬에 데이터가 있으면 캐쉬 데이터를 사용하여 성능을 개선하고 없으면 디비에서 가져와서 다시 캐쉬에 저장.일반적인 구조 Write back캐쉬에 데이터를 특정기간 동안 먼저 저장하고 캐쉬에 있는 데이터들을 디비에 저장.휘발할 수 있는 가능성 있다. 하드디스크는 주기억장치에 비해 10만 배 이상 느린 장치. 데이터베이스도 일반적으로는 하드디스크에서 동작함. JPA의 Persistent Context 도 캐싱의 기능을 함. CDN (Content Delivery Network) 프록시 서버 같은 것들을 두는 것. 구글은 각 통신사마다 Google Global Cache를 두어 인기 있는 Youtube 동영상은 미국 서버까지 접속할 필요 없이 국내 서버에서 처리하도록 하였다.… 웹 캐시. 브라우저 캐시 - 웹 브라우저는 웹페이지에 접속할 때 HTML, CSS, JS, IMG 등을 하드디스크나 메모리에 캐싱해 뒀다가 다음 번에 다시 접속할 때 이를 재활용, 응답 캐시 - 웹 서버도 HTML 같은 정적 리소스들을 캐싱 처리해둠. 프록시 캐시 - 프론트 서버에서 사용자의 요청단에 다가 캐시를 두는 것..?? 레디스 NoSQL DBMS 의 일종. 메모리에 다 올려놓고 사용. Remote Dictionary Server - 파이썬에서는 딕셔너리, Java 에서는 HashMap 구조를 말한다. 자체적으로 여러 가지 자료형을 지원 - 컬렉션 EHcache ?? - 이건 처음 알았다.스프링 프레임워크나 Hibernate ORM에서 적용","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://kidongyun.github.io/tags/Computer-Science/"},{"name":"Cache","slug":"Cache","permalink":"http://kidongyun.github.io/tags/Cache/"}]},{"title":"INDEX","slug":"2021-03-22-woowa-index","date":"2021-03-21T15:54:00.000Z","updated":"2022-06-01T05:33:20.888Z","comments":true,"path":"2021/03/22/","link":"","permalink":"http://kidongyun.github.io/2021/03/22/","excerpt":"","text":"INDEX - 임의의 규칙대로 부여된 임의의 대상을 가리키는 무언가. SEQ 번호 같은 개념. Clusted vs Non-ClusteredCluster : 군집 Clustered : 군집화 Clustered Index : 군집화된 인덱스. 인덱스와 데이터가 아주 밀접하게 군집되어 있다. Clustered Index 의 특징이미 정렬되어 있는 데이터들임 검색할 때는 성능이 좋다. 새로운 데이터들이 들어올 때에는 다른 데이터들을 다 밀거나 넣거나 하기 때문에 추가, 수정하기가 성능이 안좋다. Clustered Index 는 데이터와 친밀, 정렬되어 있음. 그로인해 발생하는 특징. Non-Clustered Index 는 인덱스 번호가 데이터를 가지고 있는게 아니고 주소번지를 가지고 있음. 연결리스트 느낌이랄까.. 약한 참조 관계다. 보통 인덱스와 실제 데이터 간 주소를 해시테이블로 해서 빠르게 찾을 수 있도록 한다. PK를 index 처리를 한다면 그것은 보통 clustered index 방식이고 그렇기 때문에 auto_increment 방식을 사용할 수 있음. 만약에 그 중간에 숫자를 넣으려고하면 헬.. PK는 계속 숫자가 증가되기 때문에 괜찮음. Cardinaltiy -&gt; 인덱스를 평가 요소. 인덱스로 쓰는 값이 중복된다면 카디널리티가 낮아지고. 유일한 값들이라면 카디널리키가 높아진다. 카디널리티가 높을 수록 인덱스로 사용하는 것을 고려해봐야 한다. email을 PK로 가져갈 경우 DB 성능에 이슈가 있을수도 있다. PK는 보통 clustered index 방식.정렬를 해줘야함.이메일은 새로운 데이터가 들어오면 다시 다 재정렬 해야함.숫자로 되어있으면 auto_increment. PK 가 아닌 값으로 검색.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://kidongyun.github.io/tags/Database/"},{"name":"Index","slug":"Index","permalink":"http://kidongyun.github.io/tags/Index/"}]},{"title":"TLS","slug":"2021-03-22-woowa-tls","date":"2021-03-21T15:54:00.000Z","updated":"2022-06-01T05:33:53.898Z","comments":true,"path":"2021/03/22/","link":"","permalink":"http://kidongyun.github.io/2021/03/22/","excerpt":"","text":"TLS 기술의 탄생 배경. 특정 호스트에 접근하려고 할때 거쳐야하는 곳들이 많다. 즉 거쳐가는 곳들에서 내가 전송하는 데이터가 그 중간에 있는 DCE 장비들이 확인할 수 있다는 점이 문제다. 예를 들면 서버에서 전달하는 데이터가 그 사이에있는 라우터나, 스위치에서 해당 데이터를 볼 수 있다. 두번째는 목적지로 설정한 곳이 정말 내가 생각한 목적지가 아닐 수도 있다. 네이버를 생각하고 데이터를 보냈을 때 다른 곳에서 내가 네이버다 하고 할 수도 있다. TLS - Transport Layer Security 전송 계층 보안. 응용 계층의 데이터들을 하위 레이어로 내릴 때 암호화 시켜주고 반대의 경우 복호화를 해준다. SSL 기술은 회사에서 발표한 기술. 넷스케이스에서 말한 기술이다. 독점의 소지도 있기 때문에 IETF 라는 기구에서 TLS 라고 재발표를 함. TLS 1.0 = 1999~TLS 1.3 = 2018 SSL, TLS 둘을 같게끔 생각하는 곳이 많는데 엄연히는 다르며 SSL 보다는 TLS 라고 생각하는 것이 더 표준적이다. TLS 의 기능 3가지 암호화정해지 피어만 메시지의 내용을 확인할 수 있도록 암/복호화 기능을 제공. 인증메시지 발신자의 신원을 보장. how??신원을 보증해주는 인증서가 존재. 특정 업체에서 보증을 해줌. 은행과 같은 개념. CA 인증기관이 인증을 함. 무결성 TLS는 응용 계층과 전송 계층 사이에서 응용 계층 데이터의 암/복호화를 책임진다. 상대의 신원 보증, 메시지의 무결성을 보장한다. HTTPS의 기반 기술이다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://kidongyun.github.io/tags/Network/"},{"name":"Computer Science","slug":"Computer-Science","permalink":"http://kidongyun.github.io/tags/Computer-Science/"},{"name":"TLS","slug":"TLS","permalink":"http://kidongyun.github.io/tags/TLS/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://kidongyun.github.io/tags/HTTPS/"}]},{"title":"Functional Programming","slug":"2021-03-22-woowah-functional-programming","date":"2021-03-21T15:54:00.000Z","updated":"2022-06-01T05:40:54.897Z","comments":true,"path":"2021/03/22/","link":"","permalink":"http://kidongyun.github.io/2021/03/22/","excerpt":"","text":"함수형 프로그래밍의 요소들. 고계 함수. 일급 함수. 자기 자신만을 부르는 함수를 꼬리 재귀라고 한다. 멱등성 -&gt; 같은 입력에 대해서 계속 동일한 출력이 나온다. 기존의 자바 코드는 선언형보다는 명령형.즉 코드를 어떻게 할거냐가 포커스고, 무엇을 할거냐가 아니다. 그래서 가독성도 함수형 프로그래밍 언어가 높다. 무엇을 할거냐를 보이기 때문에. 소프트웨어 트랜잭셔널 메모리 -&gt; 멀티 쓰레드 환경에서 일단 락을 거는게 기본 생각이였는데. 락을 걸지 말고 그냥 처리하다가 오류가 발생하면 롤백하자. 이런느낌 패턴매칭?? LISP 언어 HASKELL 한번 공부해보고 싶다. 지연 평가 - f(3 + 5) 라는 수식이 있을 때 자바의 경우 일반적으로 f(8) 의 결과값을 바로 들고 가지만 지연 평가라는 것은 저 수식 자체 f(3 + 5) 라는 것을 얼마나 들고 가느냐를 의미한다고 함. 모나드?? 모노이드 - 항등원을 갖고 결합법칙을 따르는 이항연산을 갖춘 집합.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://kidongyun.github.io/tags/Computer-Science/"},{"name":"Functional Programming","slug":"Functional-Programming","permalink":"http://kidongyun.github.io/tags/Functional-Programming/"}]},{"title":"우아한 스프링 부트","slug":"2021-03-21-woowah-springboot","date":"2021-03-20T15:54:00.000Z","updated":"2022-06-01T05:32:43.917Z","comments":true,"path":"2021/03/21/","link":"","permalink":"http://kidongyun.github.io/2021/03/21/","excerpt":"","text":"packaging - jar, warwar 는 자바 웹어플리케이션 구조로 구축된 형태. WEB-INF 디렉토리를 가지고 있고 등등.. jar - java archive war - web application archive jar, war 차이점 찾아보기. spring boot 가 제공하는 첫번째 기능-&gt; 프로젝트를 생성하기가 간편하다. dispatcher-servlet 설정 등을 자동설정 해준다. 두번째 기능-&gt; 버전관리.빌드툴(메이븐, 그래들) 에서 특정 프로젝트를 가져 올 때 필요한 정보는 groupId, artifactId, version 인데 스프링부트에서 의존성 관리부분을 보면 버전 정보가 없는 것들이 있다. 이거는 메이븐의 경우 parent 에서 의존성을 미리 관리해주는 의존성들이 있는데 이것들은 버전들이 이미 관리되고 있기 떄문에 버전을 명시하지 않아도 된다. 가장 호환이 잘되는 버전을 찾는것 자체가 일이였음. 그걸 스프링 부트에서 관리해주기 때문에 하지 않아도 된다. mvnrepository.com - maven 중앙저장소에 있는 의존성들을 검색하고 다운받을 수 있는 사이트. 스프링부트 프로젝트를 띄우는 방법. ide를 활용해서 main() 함수 실행하기. mvn spring-boot:run 명령어 실행. ./mvnw 파일은??./mvnw 이 파일이 mvn 이 설치되어있지 않아도 mvn 을 사용할 수 있도록 하는 스크립크가 작성되어 있음. 서버에서 어플리케이션을 패키징한 후 해당 파일을 실행시키는 방법.(mvn package) mvn package 하면 /target 디렉토리에 jar 파일로 하나로 뭉쳐진다. 의존성, 라이브러리, 소스코드를 모두 포함해서 jar 파일을 패키징 한다. 기본적으로 이렇게 패키징할 때 자바에서 제안하는 표준은 없고 스프링 부트가 자체적으로 만든것.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"}]},{"title":"Mapper 클래스를 따로 두는 이유","slug":"2021-03-18-why-use-mapper","date":"2021-03-17T15:54:00.000Z","updated":"2022-06-01T05:32:51.127Z","comments":true,"path":"2021/03/18/","link":"","permalink":"http://kidongyun.github.io/2021/03/18/","excerpt":"","text":"정적 팩토리 메서드 패턴을 활용할 때 나는 일반적으로 도메인 클래스 안에 다가 넣어두었다. 그렇게 하면 코드를 읽을 때 훨씬 심플하기 때문이였다. 1Response.from(Something something) &#123;&#125; Something 으로 부터의 Response 객체 라고 확 읽혀진다. 근데 문제점이 있었으니. 기본적으로 static으로 선언해야 하기 때문에 제네릭 문법을 적용하기가 어렵다. 동적타입 추론을 하는 시점은 인스턴스가 생성되고 나서일 텐데 static은 애초에 그 영역에 있지 않음으로 타입 추론이 불가능하다. 그래서 mapper 클래스를 하나 만들고 이를 싱글톤으로 구현한다. 그러면 한개의 인스턴스만 생성되며 method 영역에 저장되는 게아니고 인스턴스로써 heap 메모리에 저장되기 때문에 타입 추론이 가능해진다. 물론 한개의 인스턴스에 하나의 타입만 생성이 가능한건 어쩔수 없겠지. 여하튼 으렇게하면 정적 팩토리 메서드 패턴에 동적 타입을 적용할 수 있다. 이렇게 작성하게 되면 MapStruct 라이브러리랑 동일한 형태가 되는 거 같다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"도커기반 ELK Stack 구축","slug":"2021-03-16-docker-elk-stack","date":"2021-03-15T15:54:00.000Z","updated":"2022-05-31T07:39:41.000Z","comments":true,"path":"2021/03/16/","link":"","permalink":"http://kidongyun.github.io/2021/03/16/","excerpt":"","text":"도커 활용하여 elasticsearch 설치 1docker run -d -p 9200:9200 -p 9300:9300 -it -h elasticsearch --name elasticsearch elasticsearch:7.9.3 버전 명시를 안하니까 docker hub 에서 이미지가 pull 이 안되었다. 1docker search elasticsearch 위 키워드로 공식 이미지 명을 찾은 다음. 1https://registry.hub.docker.com/v1/repositories/elasticsearch/tags 위 주소 접속하여 가장 최신 버전의 태그를 pull 받았다. 위 주소에서 elasticsearch 부분만 원하는 이미지 명으로 변경하면 다른 이미지들도 태그 확인이 가능하다. elk 를 다 구축해둔 깃 저장소가 있음.이거를 클론해서 설정만 좀 변경하고.docker-compose 로 실행해보겠음. https://judo0179.tistory.com/60 요기 나온대로 따라서 소스 수정하고 docker-compose 로 실행. 그러면 해당하는 이미지들을 pull 받고 (FROM 키워드)docker-compose 설정처럼 각 이미지들을 활용해 컨테이너를 띄운다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://kidongyun.github.io/tags/Database/"},{"name":"Elastic Search","slug":"Elastic-Search","permalink":"http://kidongyun.github.io/tags/Elastic-Search/"}]},{"title":"Process vs Thread","slug":"2021-03-16-process-thread","date":"2021-03-15T15:54:00.000Z","updated":"2022-05-31T07:40:02.000Z","comments":true,"path":"2021/03/16/","link":"","permalink":"http://kidongyun.github.io/2021/03/16/","excerpt":"","text":"Program.명령어, 코드 및 정적인 데이터의 묶음 Process실행 중인 Program운영체제로부터 시스템 자원을 할당 받는 작업의 단위. 프로세스의 4개의 메모리 영역stack -&gt; 매개변수, 지역변수heap -&gt; 동적으로 할당되는 메모리data -&gt; 정적 변수, 상수 (jvm에서 method 영역)text -&gt; 프로그램의 코드 운영체제가 Process를 관리하기 위해 PCB 라는 것을 정해뒀음. PCB (Process Control Block)각 프로세스는 운영체제에서 PCB로 표현.PID : 프로세스 식별자.프로세스 상태 : new, ready, running, waiting, halted프로그램 카운터 : 다음 실행할 명령어의 주소.스케줄리 정보 : 우선순위 등. 쓰레드프로세스 내에서 실행되는 흐름의 단위.CPU 이용의 기본 단위. 쓰레드는 한 프로세스 내에서 여러개 생성 될 수 있으며한 프로세스의 Text, Data, Heap 영역의 자료를 공유한다.그러나 각 Thread 별로 stack 영역은 별도로 가진다. Multi Thread vs Multi Process Multi Thread프로세스의 자원을 공유향상된 응답성Context Switching 비용이 적음.자원을 공유하는 만큼 충돌을 주의 (Thread-safe하게) -&gt; 임계영역이 됨. Multi Process하나의 작업을 여러 개의 프로세스가 처리프로세스간 통신 (IPC : Interprocess communication)Context switching 비용이 큼자식 프로세스 중 하나가 문제가 생겨도 다른 프로세스에 영향이 없음.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://kidongyun.github.io/tags/Computer-Science/"},{"name":"Process","slug":"Process","permalink":"http://kidongyun.github.io/tags/Process/"},{"name":"Thread","slug":"Thread","permalink":"http://kidongyun.github.io/tags/Thread/"}]},{"title":"TCP vs UDP","slug":"2021-03-16-tcp-udp","date":"2021-03-15T15:54:00.000Z","updated":"2022-05-31T07:40:17.000Z","comments":true,"path":"2021/03/16/","link":"","permalink":"http://kidongyun.github.io/2021/03/16/","excerpt":"","text":"TCP (Transfer Controler Protocol)UDP (User Datagram Protocol)전송계층 - 엔드 포인트간에 신뢰성있는 데이터 전송을 담당하는 계층.신뢰성 - 데이터를 순차적, 안정적인 전달. 전송 - 포트 번호에 해당하는 프로세스에 데이터를 전달.포트 번호에 맞는 프로세스를 찾아준다는 것. 이게 전송계층이 해주는 일이였구나. 송신자가 보낸 패킷이 순서 없이 무작위로 보냈다면 이걸 순서대로 정리해주는 것이 전송 계층. 네트워크가 바빠서 혼잡문제가 발생해서 패킷이 유실될 수도 있다. TCP이러한 신뢰성을 보장하는 전송계층의 프로토콜이 TCP (Transmission Control Protocol) TCP 의 가장 큰 특징은 가상회선을 연결하고 끊는다는 점. 어플리케이션 레이어에서 보내고 싶어하는 데이터가 있다고 하자. 이를 보내기 위해 전송계층이 받으면. 필요한 크기 만큼으로 이 데이터들을 자르고TCP 송 수신을 위한 헤더 정보를 그 잘린 데이터 앞에 추가한다. 이걸 세그먼트라고 함. (TCP Header + data) TCP Header 는 총 32비트로 이뤄져 있는데. 여기서 8번째부터 16번째까지 총 9개에 해당하는 비트가 TCP 연결 제어 및 데이터 관리를 한다. 여기 비트 안에 ACK, SYN, FIN 이런 플래그들이 들어있음. ACK : 수신자가 송신자에게 보내는 플래그. SYN : 커넥션을 연결할 때 플래그 FIN : 커넥션 연결을 끊을 때 쓰는 플래그 TCP 3-way handshake. 커넥션을 수립하는 과정. 1단계Client 가 SYN 비트를 1로 설정하고 Server 에게 패킷을 송신. (커넥션 연결 하려고 한다는 의미를 가짐) 2단계Server 가 SYN + ACK 비트를 1로 설정하고 Client 에게 패킷을 송신 (커넥션을 연결하려고 하며, 송신자에게 이전 패킷을 수신했다는 걸 알려줌) 3단계Client 가 ACK 비트를 1로 하여 Server 에게 송신.(서버에게 수신하였음을 알리기 위해 송신) 최종적으로 가상회선이 구축되면 둘다 모두 established 상태가 된다. TCP 데이터 전송 방식. Client가 패킷을 송신. -&gt; Server에서 ACK 송신. 만약 정상적으로 수신하지 못했다면.즉 Client가 ACK를 수신하지 못한다면. 클라이언트가 기다리다가 안오면 재전송. TCP 4 way-handshake 가상회선 해지하는 단계. 데이터 전부를 송신한 Client가 FIN 플래그를 1로 두고 송신. TIME_WAIT 상태로 바뀜. Server가 ACK 송신. 알겠다라는 의미. 서버 측에서 받은 데이터 마무리 작업이 아직 안 끝날 수도 있기 때문에. Client 가 ACK를 받아도 기다린다. FIN 신호가 와야 진짜로 끝나는 거임. Server의 작업이 완료되면 FIN 신로를 보냄. Client가 FIN 신호를 받으면 받았다는 의미로 ACK를 Server 한테 보내고 CLOSED 상태로 변경. 끝임. TCP 문제점.속도, 재전송 이슈. UDP (User Datagram Protocol)세그먼트가 TCP 와 동일하게 UDP Header 가 붙는다. 이건 근데 전송계층의 특성은. 아니고 OSI 의 특징이지.레이어가 내려갈수록 헤더가 추가되지.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://kidongyun.github.io/tags/Network/"},{"name":"Computer Science","slug":"Computer-Science","permalink":"http://kidongyun.github.io/tags/Computer-Science/"},{"name":"TCP","slug":"TCP","permalink":"http://kidongyun.github.io/tags/TCP/"},{"name":"UDP","slug":"UDP","permalink":"http://kidongyun.github.io/tags/UDP/"}]},{"title":"oracle 튜닝하기","slug":"2021-03-16-db-tunning","date":"2021-03-15T15:54:00.000Z","updated":"2022-05-31T07:39:32.000Z","comments":true,"path":"2021/03/16/","link":"","permalink":"http://kidongyun.github.io/2021/03/16/","excerpt":"","text":"튜닝의 시작 XPLAN을 통해서 실행 계획 일기. 12345SELECT *FROM HR.EMPLOYEESWHERE EMPLOYEE_ID LIKE &#x27;2%&#x27;;SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(null, null, &#x27;ALLSTATS LAST&#x27;)); -&gt; 이거가 XPLAN 활용해서 실행계획을 보여주는 쿼리 실행 계획을 수행하고 나면 Id, Operation, Name, Starts, E-Rows, A-Rows, A-Time, Buffers… 이렇게 테이블이 나타나는데. 읽을 때 Operation의 개행이 가장 안쪽인 것 부터 읽는다. 인덱스를 사용하고 나서 인덱스의 자료형을 준수해주지 않으면 내부적으로 해당 인덱스 컬럼 값을 변환하기 떄문에 인덱스를 제대로 활용할 수 없다.즉 FULL SCAN이 일어난다. 튜닝이 정상적으로 되었는지를 알려면 기본적으로 Buffers 수가 줄었는지를 봐야 한다. FULL SCANINDEX RANGE SCANINDEX UNIQUE SCAN NESTED LOOPS -&gt; 프로그래밍 언어에서 for문이 중첩되어 있는 구조와 동일. FULL SCAN -&gt; INDEX SCAN 으로 변경하여 성능 튜닝. 실행 계획을 봐야 우리가 작성한 쿼리가 정말 효율적인지. 아니라면 비효율적인 구간이 어딘지를 자세히 살펴볼 수 있다.이런것들을 모두 알려면 사실 공부해야할 게 많음으로 모두 습득하고 튜닝된 쿼리를 작성할 수 있도록 하자. 오라클 힌트-&gt; 힌트를 옵티마이저에게 주는 것.힌트에 오류가 있어도 Syntax를 뱉지는 않는다.실행 계획에 영향을 미친다. 쿼리를 이런 방식으로 풀어라 라고 힌트를 주는 것이다.즉 힌트를 주기 전에 그 이전에 쿼리가 어떻게 동작하는지를 알아야 한느데 이를 알기 위해서는 실행 계획을 봐야한다. JOIN 순서를 조절할 수도 있음. A-&gt;B를 조인하는게 더 성능이 좋을 경우 ORDERED 이런 힌트를 주어서 해결 가능. 기본적으로는 힌트를 주지 않는게 좋다.즉 옵티마이저가 최적화된 쿼리를 동작할 것이다 라고 생각해야한다. 최종적으로 작성한 쿼리가 성능이 낮다면 그때 힌트를 줘야함. 튜닝 단계에서. 조인방식도 엄청 다양하다. NESTED LOOP JOIN, HASH JOIN.. NETSTED LOOP JOIN-&gt; 중첩 for문과 같은 원리. IDOL_GROUP 과 IDOL_MEMBER 조인을 한다해보자. 소녀시대 -&gt; 태연 -&gt; 티파니 -&gt; 윤아2ne1 -&gt; 박봄 -&gt; 산다라박 이런 식으로 조인되며 IDOL_GROUP 테이블이 OUTER_TABLE 이 되고(for문에서 밖에있는 for문의 역할과 같다)IDOL_MEMBER 테이블이 INNER_TABLE 이 된다. 이런 식으로 조인하는 방법이 NESTED LOOP JOIN 이라고 한다. 보통 이럴떄에는 INNER TABLE에 해당하는 영역을 INDEX로 걸어서 성능을 높인다. 건건이 테이블을 조인하기 때문에 대량의 테이블을 조인하는 방법으로는 적절하지 않다. 아이돌 그룹 - 아이돌 멤버 처럼 1:M 관계를 가질 떄 1에 해당하는 테이블이 OUTER TABLE로 가야 성능에 유리하다. SORT MERGE JOINNESTED LOOP JOIN 방법과 유사하나. 다른점이 있다면 조인 이전에 먼저 조인 테이블 기준으로 정렬을 하고 조인을 시작한다. INNER TABLE 에 인덱스가 걸려있지 않아서 NESTED LOOP JOIN을 사용하기가 너무 비효율적이다 할 떄 사용할 수 있다. 오라클 메모리 (PGA, SGA)오라클이 사용하는 메모리는 크게 두가지가 존재. SGA(System Global Area) - 모든 사용자가 공유 가능하여 사용 PGA(Program Global Area) - 사용자마다 공유하지 않고 개별적으로 사용 데이터베이스를 사용하는 구조를 그려보면 아래와 같다. 유저 프로세스 -&gt; 서버 프로세스 + PGA -&gt; 데이터 베이스 유저 프로세스에서 쿼리를 날리면 서버 프로세스가 이를 받고 데이터 베이스에서 데이터들을 가져오는 작업을 한다.이떄 요청 받은 내용 및 기타 정보들을 저장하기 위해 서버 프로세스는 자신만의 메모리 공간인 PGA를 사용한다. PGA - 데이터베이스에 접속하는 모든 유저에게 할당되는 각각의 서버 프로세스가 독자적으로 사용하는 오라클 메모리 영역. HASH JOIN배치에서 쓰면 좋은 수행 원리다. PGA 영역 중 sorted area 부분을 hash key로 두고 조인을 하는 방법? 데이터 크기가 메모리 크기보다 커지면 디스크를 써야하기 떄문에 오히려 성능이 떨어질 수 있다. 서브쿼리의 종류 select 절에 사용하는 scalar subquery from 절에 사용하는 inline view where 절에 사용하는 중첩 서브쿼리. 서브쿼리 자체가 성능에 무조건 안좋다는 것은 선입견 12345678910111213141516171819/* 서브쿼리를 활용한 경우 */SELECT * FROM HR.EMPLOYEES A WHERE A.DEPARTMENT_ID IN (SELECT B.DEPARTMENT_ID FROM HR.DEPARTMENTS B WHERE B.LOCATION_ID=1700);/* FROM 절에서 조인 */SELECT * FROM HR.EMPLOYEES A, HR.DEPARTMENTS B WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID AND B.LOCATION_ID = 1700; /* NO_UNNEST 힌트문 적용한 경우 (성능이 더 떨어짐 원래 서브쿼리 방식)*/SELECT * FROM HR.EMPLOYEES A WHERE A.DEPARTMENT_ID IN (SELECT /*+NO_UNNEST*/ B.DEPARTMENT_ID FROM HR.DEPARTMENTS B WHERE B.LOCATION_ID=1700); 실행계획을 살펴보면 위 두 쿼리가 둘다 HASH JOIN을 사용해서 동일한 형태로 동작하고 있음을 알수 있다. 원래 서브쿼리는 NO_UNNEST 이 방식을 동작하는데 서브쿼리를 푼 두번째 쿼리가 더 효과적으로 데이터를 가져오기 때문에옵티마이저가 이 방식으로 HASH JOIN을 해서 데이터를 가져온다. 서브쿼리를 반드시 쓰면 안되는 경우.1234567SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.LAST_NAME, A.SALARY FROM HR.EMPLOYEES A WHERE A.SALARY = (SELECT MIN(SALARY) FROM HR.EMPLOYEES) OR A.SALARY = (SELECT MAX(SALARY) FROM HR.EMPLOYEES); 위의 케이스를 잘 보면 HR.EMPLOYEES 이 동일한 테이블을 다른 차이 없이 3번 접근하고 있다,그러면 이 테이블을 3번 액세스 한다. 비효율적이겠찌.. 어떻게 수정해야 할까. 1234567891011121314SELECT B.EMPLOYEE_ID, B.FIRST_NAME, B.LAST_NAME, B.SALARY FROM ( SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.LAST_NAME, A.SALARY, ROW_NUMBER() OVER(ORDER BY SALARY) MINSAL, ROW_NUMBER() OVER(ORDER BY SALARY DESC) MAXSAL FROM HR.EMPLOYEES A ) B WHERE B.MINSAL = 1 OR B.MAXSAL = 1; 이렇게 하면 같은 내용의 쿼리지만. EMPLOYEE_ID 이 테이블을 한번만 액세스 하고 있다. 훨씬 더 효율적 실행계획으로 살펴봐라. 테이블을 여러번 액세스 한다는 것이 성능이 떨어지는 이유는 기본적으로 테이블이 디스크에 존재하기 때문이다. 성능 튜닝을 할 때 우선적으로 포커스를 두는 것은 디스크 I/O 발생을 줄이는 것인데.이 부분이 속도가 가장 느리기 때문이다. 그렇기 떄문에 테이블을 여러번 접근하는 것은 디스크 I/O 발생빈도가 늘어난다는 의미 임으로 이를 개선할 필요성이 있따. 동일한 테이블을 바라보는 방법으로 서브쿼리를 작성하는 것은 안된다.4.1 B-TREE INDEX 구조B-TREE INDEX 구조는 ROOT BLOCK, BRANCH BLOCK, LEAF BLOCK 으로 우선 구분된다. 각 BLOCK 들은 아래와 같은 데이터를 가진다. ROOT BLOCK = BRANCH BLOCK 주소, 인덱스 컬럼 값BRANCH BLOCK = LEAF BLOCK 주소, 인덱스 컬럼 값LEAF BLOCK = 인덱스 컬럼 값, TABLE의 ROW ID 여기서 인덱스 컬럼 값은 테이블에서 인덱스를 설정한 컬럼 값을 의미한다. 1SELECT COL1, COL2, COL3, COL4 FROM TAB WHERE COL1 BETWEEN :VAL1 AND :VAL2; 위와 같은 SQL에서 만약 COL1 값에만 인덱스가 걸려 있다면 SELECT 절에 있는 COL2, COL3, COL4 데이터들은 인덱스 테이블을 통해서 가져올 수 없다.이런 경우에는 LEAF BLOCK 이 가지고 있는 TABLE ROW ID 값을 통해 접근해서 가져온다. 4.2 INDEX RANGE SCANINDEX RANGE SCAN은 말그대로 INDEX 테이블에서 특정 범위 내 BLOCK 순차적으로 탐색하는 것이다. 1SELECT COL1, COL2, COL3, COL4 FROM TAB WHERE COL1 BETWEEN :VAL1 AND :VAL2; 위와 같은 쿼리가 있고 COl1 값이 인덱스로 설정되어 있다면. 우선 COL1 컬럼 기준으로 :VAL1 값을 찾아간다.이 값을 찾기 위해서 ROOT BLOCK -&gt; BRANCH BLOCK -&gt; LEAF BLOCK 순으로 탐색할 것이다.:VAL1 에 해당하는 LEAF BLOCK을 찾았다면. :VAL2에 해당하는 값이 나올때 까지 LEAF BLOCK을 선형적으로, 순차적으로 탐색한다. 인덱스를 순차적으로 읽으면서 한 건씩 ROWID를 가지고 TABLE BLOCK을 한 개씩 ACCESS 하기 때문에 이를 RANDOM SINGLE BLOCK I/O 라고 부르며TABLE ACCES BY INDEX ROWID 라는 실행계획으로 전시된다. 이 방법은 최악의 경우 조회 건수 만큼(즉 인덱스를 사용한 이유가 없이 FULL SCAN을 한다는 의미) I/O가 발생할 수 있다.-&gt; 아니네. FULL TABLE SCAN 방법은 멀티로 동작하기 때문에 오히려 최악의 케이스 일때는 이 방법이 더 빠르다고 언급함. 위에서 계속 언급한 BLOCK 이라는 것은 저장된 데이터의 묶음 단위로 보면 된다 ROOT BLOCK과 BRANCH BLOCK에 들어가는 주소값 들은 가상으 ㅣ값을 활용 한다. 만약 SELECT * 이 절에 인덱스에서 사용되는 컬럼만 조회하고 다른 컬럼들이 없다면 TABLE BLOCK을 ACCESS 할 필요가 없다. XPLAN 실행 계획 테이블에서 Name 필드는 테이블 명이 들어간다. 인덱스 테이블이나, 일반 테이블 등. 1234567891011121314IX_ORDERS_N1 : ORDER_DATE, ORDER_MODE, EMPLOYEE_IDSELECT /*+ INDEX(A IX_ORDERS_N1) */ ORDER_DATE, CUSTOMER_ID, ORDER_MODE, ORDER_TOTAL FROM ORDERS A WHERE ORDER_DATE BETWEEN TO_DATE(&#x27;20210101&#x27;, &#x27;YYYYMMDD&#x27;) AND TO_DATE(&#x27;20210102&#x27;, &#x27;YYYYMMDD&#x27;);// 실행 계획 SELECT STATEMENT TABLE ACCESS BY INDEX ROWID INDEX RANGE SCAN 위와 같이 실행계획이 나타난다면 TABLE ACCESS BY INDEX ROWID 는 위에서 설명했듯이 INDEX BLOCK -&gt; TABLE BLOCK 으로 ACCESS하는 RANDOM SINGLE BLOCK I/O를 나타내는 OPERATION이다. 1/*+ INDEX(A IX_ORDERS_N1) */ 와 같인 힌트를 주면 INDEX RANGE SCAㅜ, INDEX FULL SCAN 으로 수행한다. 4.3 INDEX RANGE SCAN DESCENDINGINDEX RANGE SCAN DESCENING 실행계획의 특징은 INDEX RANGE SCAN과 동일하다. 다른 점이 있다면 INDEX를 역순으로 읽는 다는 점이다. 123456789101112131415IX_ORDERS_N1 : ORDER_DATESELECT /*+ INDEX_DESC(A IX_ORDERS_N1) */ ORDER_DATE, CUSTOMER_ID, ORDER_MODE, ORDER_TOTAL FROM ORDERS A WHERE ORDER_DATE BETWEEN TO_DATE(&#x27;20120101&#x27;, &#x27;YYYYMMDD&#x27;) AND TO_DATE(&#x27;20210102&#x27;, &#x27;YYYYMMDD&#x27;) ORDER BY ORDER_DATE DESC; // 실행 계획SELECT STATEMENT TABLE ACCESS BY INDEX ROWID INDEX RANGE SCAN DESCENDING 위 쿼리를 실행하게 되면 아래와 같은 실행 계획이 발생할 것이다. 여기서 INDEX RANGE SCAN DESCENDING 이 나타나는 걸 볼 수 있는데. INDEX_DESC() 힌트를 줘서 그런것도 있지만.기본적으로 ORDER BY DESC 정렬을 이처럼 역순으로 하게 되면 이처럼 동작한다. 즉 힌트문을 제거해도 동일하게 동작할 것이다. OPTIMIZER는 인덱스를 역순으로 읽으면서 ORDER BY에 의한 SORT(ORDER BY) OPERATION 작업을 생략할 수 있다. -&gt; 더 성능이 좋아진다. 1234567891011IX_ORDERS_N1 : ORDER_DATESELECT MAX(ORDER_DATE) FROM ORDERS WHERE ORDER_MODE = &#x27;direct&#x27;;// 실행 계획SELECT STATEMENT SORT AGGREGATE TABLE ACCESS FULL ORDER_DATE 기준으로 인덱스가 설정되어 있기 때문에 만약 ORDER_MODE 조건이 없다면. INDEX FULL SCAN(MIN/MAX) OPERATION 이 발생해서 Bufffers 수치가 낮을 것이다. 하지만 저 조건으로 인해 FULL TABLE SCAN 이 발생한다. 이를 튜닝할 수 있는 방법 중 하나는 INDEX DESCENDING을 이용한 TOP N 쿼리를 사용하는 방법이다. 123456789101112131415161718SELECT ORDER_DATE FROM ( SELECT /*+ INDEX_DESC(A IX_ORDERS_N1) */ ORDER_DATE FROM ORDERS A WHERE ORDER_DATE &gt; TO_DATE(&#x27;10000101&#x27;, &#x27;YYYYMMDD&#x27;) AND ORDER_MODE = &#x27;direct&#x27; ORDER BY ORDER_DATE DESC ) WHERE ROWNUM &lt;= 1;// 실행 계획SELECT STATEMENT COUNT STOPKEY VIEW TABLE ACCESS BY INDEX ROWID INDEX RANGE SCAN DESCENDING 인덱스는 컬럼 기준으로 정렬이 되어있음을 이용하는 테크닉 같다. 서브 쿼리 부분을 보면 ORDER_DATE 컬럼을 조회하고, 이 값을 DESC 형태로 정렬하게끔 보여지도록 하는데.이렇게 하면 INDEX RANGE SCAN DESCENDING OPERATION 이 수행되고 인덱스 테이블의 가장 큰쪽에 존재하는 값이 가장 큰 값임을 바로 알 수 있다 이 곳에서 순차적으로 탐색하면서 ORDER_MODE 조건에 맞는 데이터가 나타나면 바로 반환한다. ROWNUM &lt;= 1 조건이 하나의 값만 반환하라고 명시하고 있기 때문이다. 실행 계획을 보면 COUNT STOPKEY OPERATION이 있는데 이부분이 ROWNUM &lt;= 1 조건으로 인해 발생한 동작이다. 만약 ORDER_MODE 와 같이 조건에 해당하는 부분이 PK 처럼 구분되는 값들이 많다면. 큰쪽부터 검색한다 해도. 조건에 맞는 데이터를 찾는 데에 오래 걸리기 때문에 성능이 매우 저하된다.조건이 선택지가 적고 자주 발견되는 데이터인지를 우선 파악해야 한다. 4.4 INDEX RANGE SCAN (MIN/MAX)12345678910111213IX_ORDERS_N2 : EMPLOYEE_ID, ORDER_DATESELECT /*+ INDEX(A IX_ORDERS_N2) */ MAX(ORDER_DATE) FROM ORDERS A WHERE EMPLOYEE_ID = &#x27;E402&#x27;; // 실행 계획SELECT STATEMENT SORT AGGREGATE FIRST ROW INDEX RANGE SCAN (MIN/MAX) INDEX 컬럼이 EMPLOYEE_ID, ORDER_DATE 와 같이 구성되어 있고 INDEX 선두 컬럼이 조건 절에 들어오며 두 번째 컬럼인 ORDER_DATE가 MAX 처리 되었을 때 나타나는 실행계획이INDEX RANGE SCAN (MIN/MAX) 이다. 조건에 해당하는 EMPLOYEE_ID = ‘E402’ 에 대한 많은 ORDER_DEATE 중에서 가장 끝에 있는 인덱스 만 읽고 빠져나온다.인덱스는 정렬되어 있기 때문에 가능하다. BUFFER가 3회로 나타날 텐데 그 이유는 ROOT BLOCK, BRANCH BLOCK, LEAF BLOCK을 각각 한번씩 총 3번 읽었기 때문이다. 4.5 INDEX 컬럼 가공인덱스로 사용한 컬럼을 TRIM(COLUMN_NAME), TO_DATE(COLUMN_NAME, ‘YYYYMMDD’) 와 같이 가공하게 되면. OPTIMIZER가 인덱스를 인지하지 못하고 FULL TABLE SCAN을 수행한다.주의해야하는 부분이다. 123456789101112IX_ORDERS_N3 : CUSTOMER_ID, ORDER_DATESELECT ORDER_DATE, CUSTOMER_ID, ORDER_MODE, ORDER_TOTAL FROM ORDERS A WHERE RTRIM(CUSTOMER_ID) = &#x27;C01492&#x27; AND ORDER_DATE BETWEEN TO_DATE(&#x27;20120101&#x27;, &#x27;YYYYMMDD&#x27;) AND TO_DATE(&#x27;20130101&#x27;, &#x27;YYYYMMDD&#x27;);// 실행 계획SELECT STATEMENT TABLE ACCESS FULL CUSTOMER_ID 스키마가 CHAR(7) 이라고 한다면 위처럼 6자리인 데이터를 조회할 수 없다. 이는 근본적으로는 스키마의 설계가 잘못된 것이지만. 만약 레거시로 존재한다고 했을 때쿼리의 성능을 높이기 위해서는 어떤 방법이 있을까. RTRIM을 써서 CUSTOMER_ID 인덱스 컬럼을 직접 수정하기 보다는 RPAD 를 사용해서 들어오는 데이터를 변환시키면 인덱스를 사용하 ㄹ수 있다. 123456789101112SELECT ORDER_DATE, CUSTOMER_ID ORDER_MODE, ORDER_TOTAL FROM ORDERS A WHERE CUSTOMER_ID = RPAD(&#x27;C01492&#x27;, 7, &#x27; &#x27;) AND ORDER_DATE BETWEEN TO_DATE(&#x27;20120101&#x27;, &#x27;YYYYMMDD&#x27;) AND TO_DATE(&#x27;20130101&#x27;, &#x27;YYYYMMDD&#x27;);// 실행 계획SELECT STATEMENT TABLE ACCESS BY INDEX ROWID INDEX RANGE SCAN 기존 실행 게획에서는 TABLE ACCESS FULL 동작을 하다가 위처럼 변경하게 되면 INDEX RANGE SCAN 동작으로 변경됨을 알 수 있다. 4.6 CLUSTERING FACTORERCLUSTERING FACTOR 라는 것은 무엇일까? 이것은 데이터가 모여 있는 정도 라고 볼 수 있다. 인덱스 테이블에서 LEAF BLOCK이 가지고 있는 ROWID를 가지고 테이블 데이터를 하나씩 찾아갈 때 계속 동일한 BLOCK를 액세스 한다면 이는 CF(CLUSTERING FACTOR)가 잘되어 있다고 볼 수 있고 반대의 경우로 서로 다른 BLOCk을 찾아갈 확률이 높다면 CF는 나쁜 것이다. CF가 좋으면 BLOCK I/O 가 감소하고, 반대의 경우 증가한다. 위 4.2 에서 살펴본 INDEX RANGE SCAN은 DATA BLOCK의 위착 RANDOM하게 왔다 갔다하기 때문에 CF가 좋지 않은 예시로 볼 수 있다. PS. BLOCK 이라는 것은 데이터 묶음 단위로 생각해야 한다. 하나의 데이터를 가지고 있는 것이 아니다. CF가 가장 좋은 경우는 INDEX에 저장된 데이터의 순서가 완전히 일치하는 경우이며. 반대로 좋지 않은 경우는 INDEX의 데이터 블록 순서와는 상관 없이 흩어져 있는 경우가 된다. 중요한 점은. CF를 활용할 때 이 데이터 블록을 한번 접근했다고 해서 그 블록을 영구히 캐싱하는 것은 아니다. 바로 다음 로우를 조회하는 시점에만 이 블록을 캐싱으로 활용할 수 있기 때문에 만약 Data Block들이 밀집되어 있다고 해도 이를 연속적으로 접근하지 않는다면 CF가 좋지 않은 경우가 된다. 인덱스 테이블 순으로 정렬된 테이블을 만들고 이를 활용해 인덱스 테이블 순서와 동일한 새로운 테이블을 생성해보자. 즉 CF가 가장 좋은 경우를 얻어보는 거다. 12345678910-- 인덱스 테이블과 일치하는 테이블 ORDERS_CF 생성CREATE TABLE ORDERS_CFASSELECT * FROM ORDERS ORDER BY ORDER_DATE;-- ORDER_DATE 기준으로 인덱스 생성CREATE INDEX IX_ORDERS_CF_N1ON ORDERS_CF(ORDER_DATE); 위와 같이하게 되면 인덱스 테이블 블록과 데이터 테이블 블록이 일치하기 때문에 CF는 최상이다. CF를 조회하는 방법은 아래와 같다. 12345SELECT A.TABLE_NAME, A.INDEX_NAME, A.CLUSTERING_FACTOR, A.NUM_ROWS, B.BLOCKS TABLE_BLOCKS FROM DBA_INDEXES A, DBA_TABLES B WHERE A.TABLE_NAME = B.TABLE_NAME AND A.OWNER = B.OWNER AND A.INDEX_NAME IN (&#x27;IX_ORDERS_N1&#x27;, &#x27;IX_ORDERS_CF_N1&#x27;); 좋은 CF의 수치는 TABLE BLOCK 수에 근접하고 반대의 경우 테이블 전체 건수에 근접하게 된다. 의문) PK 같은 값을 인덱싱하면 효과가 없다고 배웠는데 잘 생각해보면.데이터 테이블 탐색 방법은 선형 탐색 방법이고, 인덱스는 B-TREE 탐색 방법이기 때문에PK 같은걸 인덱싱해도 성능이 좋지 않을까?? -&gt; 맞는 것 같다 확인해보니까 기본적으로 PK는 인덱스가 적용되어 있는거 같다. 일반적으로 인덱스 컬럼이 추가도리 수록 CF는 나빠진다. 추가도니 컬럼으로 정렬이 되어 INDEX의 저장 순서와 테이블의 저장 순서가 달라지게 되기 때문이다.그러나 만약 선행적으로 적용된 인덱스 컬럼이 날짜 정보처럼 (시, 분, 초 까지 가지는) 거의 유니크한 값이라면. 다른 인덱스 컬럼과 같은 값을 가지는 경우가 거의 없어서정렬 순서가 크게 달라지지 안흔다. 결론적으로 CF가 매우 좋은 INDEX의 컬럼이 UNIQUE에 가까울 경우에는 그 뒤에 컬럼이 추가 되더라도 CF가 나빠지지 않는다. FUNCTION BASED INDEX컬럼에 TO_CHAR() 함수와 같은 것을 적용시켜서 그 데이터를 인덱스 컬럼으로 하는 인덱스 테이블을 말한다. 12CREATE INDEX IX_ORDERS_CF_N3ON ORDERS_CF(TO_CHAR(ORDER_DATE, &#x27;YYYYMMDD&#x27;)); 4.7 INDEX RANGE SCAN VS FULL TABLE SCANFULL TABLE SCAN은 TABLE BLOCK 전체를 DB_FILE_MULTIBLOCK_READ_COUNT 파라미터 값에 비례해서 수십 BLOCK씩 MULTI BLOCK으로 읽는다. 이렇게 I/O를 하는 방법이 RANDOM SIGNLE BLOCK I/O, MULTI BLOCK I/O 로 상이한데. 그렇기 때문에 테이블 전체 건수의 1/20 이상이라면FULl TABLE SCAN을 사용하는 것이 유리하다. 즉 테이블의 많은 부분을 차지하는 row를 가져올 때에는 오히려 INDEX RANGE SCAN 방법이 역효과가 난다는 의미이다. SINGLE I/O 이기 때문에 그렇다. 이거는 아무래도 실행 계획을 보면서 Buffers, A-Times 등을 보면서 판단을 해야하지 않을까 싶다. 아무튼 결론은. 테이블 전체 만큼의 데이터를 가져 오려고 하면 INDEX를 사용하지 말고 그냥 FULL SCAN을 하라. 4.8 INDEX ACCESS 조건, FILTER 조건INDEX ACCESS 조건이라는 것은 INDEX SCAN 시에 SCAN 범위를 줄여주는데에 참여한 조건을 의미한다. INDEX FILTER 조건이라는 것은 실제 SCAN 범위는 줄여주지 못하고 말 그대로 데이터의 FILTER 역할 만을 한다는 의미이다. 인덱스 탐색량을 줄이기 위해서는 INDEX ACCESS 조건이 더 많이 발생하도록 하는게 좋다. SCAN 범위가 줄기 때문이다. 범위 조건 연산(&gt;=, &lt;=, BETWEEN, LIKE 등) 이 수행되기 이전에는 ACCESS 조건이 나타나지만 그 이후에는 FILTER 조건으로 사용되는게 인덱스의 특징이다. COL1, COL2, COL3, COL4 컬럼으로 구성된 INDEX가 있다고 해보자. 1WHERE COL1 = &#x27;1&#x27; AND COL2 = &#x27;A&#x27; AND COL3 = &#x27;나&#x27; AND COL4 = &#x27;a&#x27; 이렇게 모든 조건 연산들이 범위 조건 연산이 아니라면 모두 INDEX ACCESS 조건으로 사용되어 범위를 줄여줄 수 있다. 1WHERE COL1=&#x27;1&#x27; AND COL2 = &#x27;A&#x27; AND COL3 BETWEEN &#x27;가&#x27; AND &#x27;다&#x27; AND COL4 = &#x27;a&#x27; COL1, COL2 는 범위 조건 연산인 COL3 이전에 발생했기 때문에 INDEX ACCESS 조건으로 사용되지만.COL4 는 이 후이기 때문에 FILTER 조건으로 사용된다. 1WHERE COL1=&#x27;1&#x27; AND COL2 = &#x27;A&#x27; AND COL4 = &#x27;a&#x27; COL3 컬럼에 대한 조건이 생략되어 있는데 생략된 것도 범위 조건 연산으로 보며. 그렇기 떄문에 COL1, COL2는 INDEX ACCESS 조건, COL4 는 INDEX FILTER 조건이 된다. 예시를 보자. 123456789101112IX_ORDERS_N1 : ORDER_DATE, ORDER_MODE, EMPLOYEE_IDIX_ORDERS_N2 : EMPLOYEE_ID, ORDER_MOD, ORDER_DATESELECT TO_CHAR(ORDER_DATE, &#x27;YYYYMM&#x27;) ORDER_MM , COUNT(*) ORDER_CNT , SUM(ORDER_TOTAL) ORDER_AMT FROM ORDERS A WHERE ORDER_DATE BETWEEN TO_DATE(&#x27;20110101&#x27;, &#x27;YYYYMMDD&#x27;) AND TO_DATE(&#x27;20120101&#x27;, &#x27;YYYYMMDD&#x27;) AND EMPLOYEE_ID = &#x27;E123&#x27; AND ORDER_MODE = &#x27;direct&#x27; GROUP BY TO_CHAR(ORDER_DATE, &#x27;YYYYMM&#x27;); IX_ORDERS_N2 의 조건이 범위 연산이 후위에 있기 때문에 INDEX_ACCESS 조건이 더 많이 생성되어서 더 좁은 범위를 스캔해도 되어 성능이 좋아진다. 4.9 INDEX SKIP SCANINDEX SKIP SCAN은 조회 조건이 INDEX의 ACCESS 조건이 아니라 FILTERING 조건으로 들어오는 경우 ACCESS 범위에 해당하는 모든 INDEX BLOCK을 순차적으로 SCAN하는 것이 아니라 (이 방법이 기존의 INDEX 방법) 불필요한 LEAF BLOCK들은 SKIP 해서 인덱스 범위를 줄여주는 동작이다. 이건 좋지는 않다고 했음. 왜냐하면 결국 선두 인덱스가 생략된 상태로 조회되었을때가 가정인데. 이 가정 자체가 사실 좋지 않은 가정임. 4.10 INDEX FULL SCANINDEX FULL SCAN은 INDEX LEAF BLOCK 전체를 순차적으로 ACCESS 하는 동작을 말한다. 모든 LEAF BLOCK을 탐색하기 때문에 성능은 당연히 떨어지고, INDEX 건수가 많을 수록 더 느리다. 1234567891011121314151617IX_ORDERS_N3 : ORDER_STATUS, ORDER_MODE, EMPLOYEE_ID, ORDER_DATESELECT /*+ INDEX(A IX_ORDERS_N3) */ TO_CHAR(ORDER_DATE, &#x27;YYYYMM&#x27;) ORDER_MM, COUNT(*) ORDER_CNT, SUM(ORDER_TOTAL) ORDER_AMT FROM ORDERS A WHERE ORDER_DATE BETWEEN TO_DATE(&#x27;20120101&#x27;, &#x27;YYYYMMDD&#x27;) AND TO_DATE(&#x27;20120301&#x27;, &#x27;YYYYMMDD&#x27;) GROUP BY TO_CHAR(ORDER_DATE, &#x27;YYYYMM&#x27;);-- 실행 계획SELECT STATEMENT HASH GROUP BY TABLE ACCESS BY INDEX ROWID INDEX FULL SCAN 위와 같이 쿼리를 작성하면 원래는 TABLE FULL SCAN 이 발생할 것 같은데.. 힌트문을 줘서 INDEX FULL SCAN이 발생. INDEX 는 순차적 탐색이기 떄문에 상대적으로 더 느리다. 위와같은 INDEX FULL SCAN 방법이 유용한 케이스를 생각해보자. 1234567891011121314SELECT ORDER_DATE, EMPLOYEE_ID, ORDER_MODE, ORDER_STATUS, ORDER_TOTAL FROM ( SELECT ORDER_DATE, EMPLOYEE_ID, ORDER_MODE, ORDER_STATUS, ORDER_TOTAL FROM ORDERS A ORDER BY ORDER_STATUS, ORDER_MODE, EMPLOYEE_ID, ORDER_DATE ) WHERE ROWNUM &lt;= 1000;-- 실행 계획SELECT STATEMENT COUNT STOPKEY VIEW SORT ORDER BY STOPKEY TABLE ACCESS FULL 위 쿼리에서 서브쿼리 내용이 TABLE ACCESS FULL을 하고 조건에 따라 정렬을 하게된다. 그러나 ORDER_DATE 기준으로 이미 인덱스가 있는 것을 알기 때문에 굳이 쿼리 수행시에 정렬을 하는 것 보다는. ORDER_DATE 조건을 주게되면 인덱스를 사용하게 되기때문에 이미 정렬된 상태로 데이터를 가져올 수 있다. 123456789101112131415SELECT ORDER_DATE, EMPLOYEE_ID, ORDER_MODE, ORDER_STATUS, ORDER_TOTAL FROM ( SELECT ORDER_DATE, EMPLOYEE_ID, ORDER_MODE, ORDER_STATUS, ORDER_TOTAL FROM ORDERS A WHERE ORDER_DATE &gt; TO_DATE(&#x27;1999&#x27;, &#x27;YYYY&#x27;) ORDER BY ORDER_STATUS, ORDER_MODE, EMPLOYEE_ID, ORDER_DATE ) WHERE ROWNUM &lt;= 1000; -- 실행 계획 SELECT STATEMENT COUNT STOPKEY VIEW TABLE ACCESS BY INDEX ROWID INDEX FULL SCAN 즉 요약하면. 재정렬이 필요할 때 정렬해야하는 컬럼 기준으로 인덱스가 있다면. 인덱스에 이미 정렬되어 있기 때문에 그 인덱스를 활용하는 것이 보다 성능적으로 좋다. 4.11 INDEX FULL SCAN(MIN/MAX)조건절(WHERE) 부분에 인덱스 컬럼이 존재하지 않고 MIN(), MAX() 함수로 데이터를 뽑을 때에는 INDEX FULL SCAN 이 일어난다. 123456789IX_ORDERS_N1 : ORDER_DATESELECT MAX(ORDER_DATE) FROM ORDERS;-- 실행 계획SELECT STATEMENT SORT AGGREGATE INDEX FULL SCAN (MIN/MAX) WHERE 절이 없기 때문에 INDEX FULL SCAN이 발생. 근데 buffers 수가 root block -&gt; branch block -&gt; leaf block 이렇게 3번 접근하는데 이게 INDEX RANGE SCAN 이랑 효율은 똑같은 거 같은데… INDEX FULL SCAN 일때 아래와 같이 MIN, MAX 를 모두 가져오려고 한다면 FULL TABLE SCAN 이 발생. 1234567SELECT MIN(ORDER_DATE), MAX(ORDER_DATE) FROM ORDERS-- 실행 계획SELECT STATEMENT SORT AGGREGATE TABLE ACCESS FULL MIN, MAX를 하나씩 조회할 때 처럼 따로따로 가져오기 위해서는 아래처럼 쿼리를 작성해야 함. 12345678910111213141516171819SELECT MIN(ORDER_DATE), MAX(ORDER_DATE) FROM ( SELECT MAX(ORDER_DATE) ORDER_DATE FROM ORDERS UNION ALL SELECT MIN(ORDER_DATE) FROM ORDERS);-- 실행 계획SELECT STATEMENT SORT AGGREGATE VIEW UNION-ALL SORT AGGREGATE INDEX FULL SCAN (MIN/MAX) SORT AGGREGATE INDEX FULL SCAN (MIN/MAX) 4.12 INDEX FAST FULL SCAN인덱스 테이블의 모든 스캔방법이 순차적이지는 않은데. 바로 INDEX FAST FULL SCAN 방법이 FULL TABLE SCAN 과 동일하게 MULTI BLOCK I/O를 지원한다.다만 이 방식이 동작하기 위해서는 INDEX 컬럼 외에 테이블 컬럼이 SQL에 포함되어 있으면 안된다. 내 생각에는 조건만 성립한다면 가장 빠른 조회 방법이지 않을까 싶다. 12345678910111213IX_ORDERS_N3 : ORDER_STATUS, ORDER_MODE, EMPLOYEE_ID, ORDER_DATESELECT TO_CHAR(ORDER_DATE, &#x27;YYYYMM&#x27;) YYYYMM, COUNT(*) CNT FROM ORDERS WHERE ORDER_MODE = &#x27;online&#x27; GROUP BY TO_CHAR(ORDER_DATE, &#x27;YYYYMM&#x27;);-- 실행 계획SELECT STATEMENT HASH GROUP BY INDEX FAST FULL SCAN 테이블 사이즈 보다 인덱스 사이즈가 일반적으로 작으니까 FULL TABLE SCAN 보다 INDEX FAST FULL SCAN 방법이 더 빠를거다. 12345678SELECT COUNT(*) FROM ORDERS A-- 실행 계획SELECT STATEMENT SORT AGGREGATE TABLE ACCESS FULL 위 쿼리의 경우 단순 COUNT 하는 것이기 때문에 컬럼 중에 인덱스가 걸린 컬럼만 조회해서 INDEX FAST FULL SCAN을 하면 보다 더 빠를 것 같은데.실제로 동작한 OPERATION을 보면 TABLE ACCESS FULL이 동작되었다. 이는 NULL 값과 관련이 있다. 인덱스를 추가하거나 변경하는 것은 그 테이블을 참조하는 다른 SQL들의 실행 계획이 변경되어 성능에 영향이 갈 수 있기 때문에 쉬운 것은 아님을 알아야 한다. 4.13 INDEX COMBINATION한 테이블에 여러 인덱스가 있을 때 인덱스를 조합해서 사용할 수 있는 형태를 말한다. 12345678910111213141516171819202122232425IX_SALES_N1 : CUSTOMER_ID, ORDER_DATEIX_SALES_N2 : EMPLOYEE_ID, ORDER_DATEIX_SALES_N3 : PRODUCT_ID, ORDER_DATESELECT /*+ INDEX_COMBILE(A IX_SALES_N3 IX_SALES_N2) */ ORDER_DATE, CUSTOMER_ID, ORDER_QTY, ORDER_AMT FROM SALES A WHERE (PRODUCT_ID = &#x27;P246&#x27; AND EMPLOYEE_ID = &#x27;E412&#x27;) AND ORDER_DATE &gt;= &#x27;20210101&#x27; AND ORDER_DATE &lt; &#x27;20120601&#x27;;-- 실행 계획SELECT STATEMENT TABLE ACCESS BY INDEX ROWID BITMAP CONVERSION TO ROWIDS BITMAP AND BITMAP CONVERSION FROM ROWIDS SORT ORDER BY INDEX RANGE SCAN BITMAP CONVERSION FROM ROWIDS SORT ORDER BY INDX RANGE SCAN 4.14 INDEX JOININDEX JOIN은 INDEX 끼리 JOIN 되는 형태이며 HASH JOIN 형태로 동작한다. 동작하기 위해서는 SELECT 절에 있는 모든 컬럼과 WHERE 절에 있는 모든 컬럼들이INDEX 컬럼이여야 한다. 1234567891011121314151617IX_SALES_N1 : CUSTOMER_ID, ORDER_DATEIX_SALES_N2 : EMPLOYEE_ID, ORDER_DATESELECT /*+ INDEX_JOIN(A) */ ORDER_DATE, EMPLOYEE_ID, CUSTOMER_ID FROM SALES A WHERE (EMPLOYEE_ID = &#x27;E412&#x27; AND CUSTOMER_ID = &#x27;C03107&#x27;) AND ORDER_DATE &gt;= &#x27;20120101&#x27; AND ORDER_DATE &lt; &#x27;20120601&#x27;;-- 실행 계획SELECT STATEMENT VIEW HASH JOIN INDEX RANGE SCAN | IX_SALES_N1 INDEX RANGE SCAN | IX_SALES_N2 5.1 NESTED LOOP JOIN12345SELECT TAB1.COL2, TAB2.COL3, TAB3.COL4 FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1 AND TAB2.COL2 = TAB3.COL3 AND TAB1.COL1 BETWEEN VALUES1 AND VALUES2 NL 방식의 특징은 아래와 같다. 먼저 수행되는 선행 테이블의 처리 결과 만큼 후행 테이블 작업이 반복되기 때문에 선행 테이블의 작업량이 전체 작업량을 좌우 한다. 선행 테이블의 결과 만들어진 셋이 후행 테이블에 상수 값으로 제공된다. 후행 테이블은 동일한 테이블을 선행 테이블의 결과 만큼 지속 반복함으로 인덱스가 존재해야 한다. 그렇지 않다면 그 반복 수 만큼 FULL TABLE SCAN을 하게 됨으로성능에 매우 좋지 않다. 주로 처리해야하는 데이터가 적은 OLTP 서비스에서 주로 이용된다. INDEX SCAN 에서 가장 큰 부하 부분이 RANDOM SINGLE BLOCK I/O 부분이다. 따라서 대량 데이터 SCAN 시에는 INDEX SCAN이 불리하다고 언급함. NESTED LOOP JOIN 은 OLTP에서 부분적인 데이터를 보여줄 때 유용하다. 대용량 BATCH 프로그램에서 사용시에는 성능이 많이 저하된다. 1234SELECT /*+ LEADING(B A) USE_NL(A) */ A.EMPLOYEE_ID, A.LAST_NAME, B.DEPARTMENT_NAME FROM EMPLOYEES A, DEPARTMENTS B WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID; 위 SQL은 LEADING(B A) 로 명시되어 있으믕로 DEPARTMENTS 테이블이 선행테이블로, 그리고 EMPLOYEES 테이블이 후행테이블로 조인된다. DEPARTMENT 테이블에서 먼저 SCAN 작업이 이루어지고, “ WHERE A.DEPARTMENT_ID = ‘D001’ “ 의 형태로 상수값으로 바뀌어서 후행 테이블의 SCAN 이 동작된다.여기서 EMPLOYEES 테이블에 DEPARTMENT_ID 에 대한 인덱스가 안걸려있다면 매번 FULL TABLE SCAN을 해야함으로 성능에 좋지 않다. NL의 3가지 방식. - 기본 방식, PREFETCH 방식, BATCHING 방식 이건 좀 어렵다 ㅠㅠ. 12345678910111213141516171819202122232425SELECT A.ORDER_ID, A.ORDER_STATUS, A.EMPLOYEE_ID, B.PRODUCT_ID, B.QUANTITY FROM ORDERS A, ORDER_ITEMS B WHERE A.ORDER_ID = B.ORDER_ID AND A.ORDER_DATE &gt;= TO_DATE(&#x27;2012010100&#x27;, &#x27;YYYYMMDDHH24&#x27;) AND A.ORDER_DATE &lt; TO_DATE(&#x27;2012010101&#x27;, &#x27;YYYYMMDDHH24&#x27;);-- 실행 계획 (기본 방식)SELECT STATEMENT NESTED LOOPS TABLE ACCESS BY INDEX ROWID | ORDERS INDEX RANGE SCAN | IX_ORDES_N1 TABLE ACCESS BY INDEX ROWID | ORDER_ITEMS INDEX RANGE SCAN | IX_ORDER_ITEMS_PK-- 실행 계획 (PREFETCH 방식)SELECT STATEMENT TABLE ACCESS BY INDEX ROWID NESTED LOOPS TABLE ACCESS BY INDEX ROWID INDEX RANGE SCAN INDEX RANGE SCAN IX_ORDER_ITEMS_PK 보면 후행테이블이 기본적으로 PK 인덱스를 사용함을 알 수 있다. FULL TABLE SCAN 이 정말 성능에 안좋다는 것을 암시하는 부분. 5.2 HASH JOIN123456789101112131415161718SELECT /*+ USE_HASH(A B)*/ A.ORDER_DATE A.EMPLOYEE_ID, A.CUSTOMER_ID, B.UNIT_PRICE * B.QUANTITY SALES_AMT FROM ORDERS A, ORDER_ITEMS B WHERE A.ORDER_ID = B.ORDER_ID AND A.ORDER_DATE &gt;= TO_DATE(&#x27;20120701&#x27;, &#x27;YYYYMMDD&#x27;) AND A.ORDER_DATE &lt; TO_DATE(&#x27;20120702&#x27;, &#x27;YYYYMMDD&#x27;) AND B.ORDER_DATE &gt;= TO_DATE(&#x27;20120701&#x27;, &#x27;YYYYMMDD&#x27;) AND B.ORDER_DATE , TO_DATE(&#x27;20120702&#x27;, &#x27;YYYYMMDD&#x27;);-- 실행 계획SELECT STATEMENT HASH JOIN TABLE ACCESS BY INDEX ROWID INDEX RANGE SCAN TABLE ACCESS BY INDEX ROWID INDEX RANGE SCAN 선행 테이블인 ORDERS를 PGA 메모리에 HASH TABLE로 생성 후에 후행 테이블 ORDER_ITEMS를 SCAN하면서 PGA에서 컬럼 매핑하는 방식으로 수행. 조인조건이 equal인 경우에만 가능. 선행 테이블의 데이터가 소량일 때 성능이 극대화된다. 적은 SIZE의 테이블이 HASH TABLE로 생성되어야 한다. 메모리 내에서 수행될 때 빠른 속도를 보장하지만 이 메모리 사이즈를 초과하게 되면 디스크와 계속 SWAPPING을 해야하기 때문에 성능이 저하된다. NL에 비해 상대적으로 CPU 사용량과 메모리 사용량이 높다. 배치처리, 테이블 FULL SCAN 시 유리하다. OLTP 처리시 CPU 자원을 많이 사용할수 잇으니 주의해야 한다. JOIN KEY의 중복이 많을수록 HASH KEY 충돌로 성능이 저한된다. 해시 충돌을 줄여야 한다. 123456789101112131415161718192021SELECT /*+ LEADING(A B C) USE_HASH(A B C) NO_SWAP_JOIN_INPUTS(C) */ B.JOB_ID, C.GENDER, COUNT(*) ORDER_CNT, SUM(ORDER_TOTAL) ORDER_AMT FROM ORDERS A, EMPLOYEES B, CUSTOMERS C WHERE A.EMPLOYEE_ID = B.EMPLOYEE_ID AND A.CUSTOMER_ID = C.CUSTOMER_ID AND A.ORDER_DATE &gt;= TO_DATE(&#x27;20120101&#x27;, &#x27;YYYYMMDD&#x27;) AND A.ORDER_DATE &lt; TO_DATE(&#x27;20121101&#x27;, &#x27;YYYYMMDD&#x27;) GROUP BY B.JOB_ID, C.GENDER;-- 실행 계획SELECT STATEMENT HASH GROUP BY HASH JOIN HASH JOIN TABLE ACCESS FULL | ORDERS TABLE ACCESS FULL | EMPLOYEES TABLE ACCESS FULL | CUSTOMERS HASH TABLE의 목적으로 생성되는 테이블을 BUILD INPUT 이라고 한다 위 테이블은 A -&gt; B -&gt; C 순서로 조인을 하고 있는데. 만약 A의 테이블 결과가 상대적으로 많다면. 이 A 테이블을 PGA 메모리에 올려두고 해쉬 테이블을 만들기 때문에.메모리 사용량이 많을 수 밖에 없다. 그래서 이럴때에는 상대적으로 더 적은 결과가 도출되는 테이블을 먼저 선행 테이블 처리하는 것이 좋다. 12345678910111213141516171819SELECT /*+ LEADING(B A C) USE_HASH(A B C) SWAP_JOIN_INPUTS(C) */ B.JOB_ID, C.GENDER, COUNT(*) ORDER_CNT, SUM(ORDER_TOTAL) ORDER_AMT FROM ORDERS A, EMPLOYEES B, CUSTOMERS C WHERE A.EMPLOYEE_ID = B.EMPLOYEE_ID AND A.CUSTOMER_ID = C.CUSTOMER_ID AND A.ORDER_DATE &gt;= TO_DATE(&#x27;20120101&#x27;, &#x27;YYYYMMDD&#x27;) AND A.ORDER_DATE &lt; TO_DATE(&#x27;20121101&#x27;, &#x27;YYYYMMDD&#x27;) GROUP BY B.JOB_ID, C.GENDER;-- 실행 계획.SELECT STATEMENT HASH GROUP BY HASH JOIN TABLE ACCESES FULL | CUSTOMERS HASH JOIN TABLE ACCESS FULL | EMPLOYEES TABLE ACCESS FULL | ORDERS 힌트문을 적용하지 않아도 OPTIMIZER가 알아서 더 좋은 성능을 위해 위처럼 테이블 SWAP을 했을 것이다. 보면 B -&gt; A -&gt; C 순서로 선행 테이블이 보다 작은 테이블이 되도록 하여 PGA 메모리 사용률을 줄였다. SWAP_JOIN_INPUTS(C) 힌트문으로 인해서 C에 해당하는 CUSTOMER 테이블이 BUILD INPUT(해시 테이블) 로 생성이 되었다. 동작 과정을 서술하면 아래와 같다. CUSTOMERS를 HASH TABLE로 생성 (SWAP_JOIN_INPUTS(C)) EMPLOYEES를 HASH TABLE로 생성 (LEADING(B)) ORDERS를 SCAN하면서 2번에 생성한 HASH TABLE SCAN 3번 결과가 SCAN되면서 1번에서 생성한 HASH TABLE SCAN. XPLAN에서 Used-Mem 부분 중 괄호 안에 숫자가 (1) 로 전시된다면 그것은 PGA 메모리가 모자라서 DISK SWAPPING이 발생했다는 의미이다.(0) - Optimal(1) - One Pass(2) - Multi Pass 12SWAP_JOIN_INPUTS(D) -&gt; D 에 해당하는 테이블을 해시 테이블로 먼저 넣겠다는 의미. 선행테이블로 쓰이게 된다.LEADING(C A B D E) -&gt; C -&gt; A -&gt; B -&gt; D -&gt; E 순서로 해시 조인하게 된다. 5.3 SORT MERGE JOINJOIN 하고자 하는 두 테이블의 JOIN COLUMN 값으로 각각 SORT를 한 후에 정렬된 컬럼값을 비교하면서 조인하는 방식. 12345678910111213141516171819202122232425262728293031323334353637383940SELECT /*+ USE_MERGE(A B) */ A.ORDER_DATE, A.EMPLOYEE_ID, A.CUSTOMER_ID, B.PRODUCT_ID B.UNIT_PRICE * B.QUANTITY SALES_AMT FROM ORDERS A, ORDER_ITEMS B WHERE A.ORDER_ID = B.ORDER_ID AND A.ORDER_DATE &gt;= TO_DATE(&#x27;20120701&#x27;, &#x27;YYYYMMDD&#x27;) AND A.ORDER_DATE &lt; TO_DATE(&#x27;20120702&#x27;, &#x27;YYYYMMDD&#x27;) AND B.ORDER_DATE &gt;= TO_DATE(&#x27;20120701&#x27;, &#x27;YYYYMMDD&#x27;) AND B.ORDER_DATE &lt; TO_DATE(&#x27;20120702&#x27;, &#x27;YYYYMMDD&#x27;);--- 실행 계획SELECT STATEMENT MERGE JOIN SORT JOIN TABLE ACCESS BY INDEX ROWID | ORDERS INDEX RANGE SCAN | IX_ORDERS_N1 SORT JOIN TABLE ACCESS BY INDEX ROWID | ORDER_ITEMS INDEX RANGE SCAN | IX_ORDER_ITEMS_N1``` SORT가 발생하기 때문에 PGA 메모리를 사용. SORT 시 PGA 메모리 사용량이 사이즈를 초과하게 되면 DISK SWAPPING이 발생.### 실장님의 가르침인덱스 스킵스캔을 타는 것은 결국 인덱스 설정이 적절하지 않는다는 의미이기 때문에 다시한번 재고 해봐야 한다.nested loop join 방법은 outer table, inner table 둘다 디스크에 존재하며 outer table이 루프를 돌면서 inner table을 조인한다.hash join 방법은 inner table 을 메모리에 올려두고 조인하기 때문에 보다 더 빠르다.inner table을 메모리에 올린다의 전제조건은 inner table을 full로 사용할 경우이다.ctrl + e -&gt; 실행계획이 보인다.```SQL/*+ use_hash(aa, bb) */ 이 방법을 쓰면 HASH JOIN을 한다. 쿼리를 짤때에는 기본적으로 인덱스를 확인해야 한다. full 스캔이 나오면 안된다. 인덱스 컬럼을 가공 시 해당 컬럼을 인덱스로 사용이 안되는데 조인되는 테이블이 아니고 피 조인 테이블에 적용하면 가능하다. 실행 계획을 볼때에는 상수가 아니라 변수로 두고 해야지 더 정확하다.상수가 있다면 기본적으로 오라클은 해당 데이터를 먼저 기준으로 두고 스캔한다. 변수 설정하는 방법 :aaa 스칼라 서브쿼리 vs 조인만약 스칼라 서브쿼리 되는 곳에 작성한 쿼리가 충분히 캐쉬를 활용할 수 있는 쿼리라면 사용해도 좋지만 그렇지 않다면 그런 쿼리는 좋지 않다.대신 조인을 써라. CASE 키워드 보다는 DECODE 키워드가 좀더 빠르다. 구문을 파싱하는 작업이 덜하다. 80% 이상을 가져온다고 하면 인덱스 조회보다 FULL 조회가 더 빠르다. 캐싱된다고 하지만 결국 이거는 메모리에 올라가는 거기 때문에 TTL이 존재하지는 않는다 다만. 다른 쿼리에 의해 올라간 데이터에 의해 밀린다. HAVING 절은 SORT GROUP BY 동작이 처리되고 난 다음에 수행되기 때문에 WHERE 절 처럼 성능을 향상시키지는 않는다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://kidongyun.github.io/tags/Database/"},{"name":"Oracle","slug":"Oracle","permalink":"http://kidongyun.github.io/tags/Oracle/"},{"name":"Tunning","slug":"Tunning","permalink":"http://kidongyun.github.io/tags/Tunning/"}]},{"title":"우아한 객체지향","slug":"2021-03-15-woowah-oop","date":"2021-03-14T15:54:00.000Z","updated":"2022-05-31T07:39:12.000Z","comments":true,"path":"2021/03/15/","link":"","permalink":"http://kidongyun.github.io/2021/03/15/","excerpt":"","text":"객체지향에서 설계에 대해서 굉장히 중요한 것은 의존성이다. 설계라는 것은 -&gt; 코드를 어떻게 배치할 것에 대한 의사결정.어떤 패키지에 어떤 코드를 넣을거고, 어떤 프로젝트에 어떤 코드를 넣을거고.. 이런 것들. 초점은 변경에 맞춰야한다. 같이 변경되는 코드는 함께두어야하고 그렇지 않으면 따로둬야한다.이 변경이라는 것이 결국은 의존성. A ———-&gt; BA가 B에 의존되고 있다 = B가 변경되면 A도 변경될 가능성이 있다. 의존성은 변경과 관련된 것. Class 사이의 Dependancy Package 사이의 Dependancy 두가지로 나뉜다. 클래스 의존성 종류. 연관관계 (Association) -&gt; A에서 B로 영구적으로 갈 수 있는 것123class A &#123; private B b;&#125; 의존관계 (Dependency) -&gt; 일시적으로 관계를 맺는 것.12345class A &#123; public B method(B b) &#123; return new B(); &#125;&#125; 상속관계 (Inheritance) -&gt; 구현이 바뀌더라도 영향을 받는다.12class A extends B &#123;&#125; 실체화 관계 -&gt; 인터페이스가 구현된것12class A implements B &#123;&#125; 설계를 할때 좋은 의존성을 관리하는 규칙 양방향 의존성을 피하라 (순환참조 관계)1234567891011121314151617/** BAD */class A &#123; private B b; public void setA(B b) &#123; this.b = b; this.b.setA(this); &#125;&#125;class B &#123; private A a; public void setA(A a) &#123; this. a = a; &#125;&#125; 1234567891011/** GOOD */ class A &#123; private B b; public void setA(B b) &#123; this.b = b; &#125;&#125;class B &#123;&#125; 만약 정말 이렇게 구현된 객체가 있다면 이것은 한 클래스로도 만들 수 있음에도 억지로 찢어 놓은 걸 수도 있다. 다중성이 적은 방향을 선택하라. 1234567/** BAD */class A &#123; private Collection&lt;B&gt; bs;&#125;class B &#123;&#125; 1234567/** GOOD */class A &#123;&#125;class B &#123; private A a;&#125; 의존성이 필요없다면 제거하라. 패키지 사이의 의존성 사이클을 제거하라. 설계에서 가장 중요한건 변경.의존성이 사이클이 돈다는 이야기는 -&gt; 원래 하나의 패키지로 볼수도 있음을 고려해야함. 시스템은 엄청 동적인것이지만 이걸 구현하는 코드는 정적인 것. 정적인 이 코드로 동적인 시스템을 구현하기 위해선 시스템이 가진 정적인 특징들을 잘 잡아쟈한다. 첫번째 클래스 다이어그램ㅇ르 그리고 이 클래스 끼리의 관계라고 하는것. 의존성이라고 하는 걸 잘 고려하자.의존성은 방향성이 존재. 디비의 릴레이션은 외래키 잡으면 방향성이 없음 관계의 방향 -&gt; 협력의 방향 -&gt; 의존성의 방향시스템상에서 실제로 플로우가 어떻게 흐르느냐에 따라서 그걸 따라서 클래스 다이어그램을 만들고, 관계를 그려야한다. 즉 의존성을 만들어내야 한다. 클래스 다이어그램을 그리라 -&gt; 협력의 방향을 상상해라 -&gt; 의존성을 잡아라. 이 의존성을 표현하는 방법은 4가지 아까 위에서 언급함. (1) 연관관계 (객체참조)협력을 위해 필요한 영구적 탐색 구조.실제적으로는 데이터에 영향을 받지만 우선은 잡는다. (2) 의존관계 (파라미터, 리턴타입, 지연변수)협력을 위해 일시적으로 필요한 의존성. 협력을 해야하는 이유, 의존성을 가져야 하는 이유를 항상 생각하라. 연관관계는 개념적인것. 이를 구현하기 위해 객체참조. 이 개념을 구현하기 위한 방법이 여러가지가 있음.대표적인 방법은 객체참조. 메세지를 받는다 = 메서드를 호출한다.메세지라는 개념적인 것을 먼저 생각하고 그다음에 메서드라는 구현의 관점을 떠올려라. ** Layered Archutecture ** Presentation Layer Service Layer Domain Layer -&gt; 이 계층을 내가 맨날 생각했었는데 한번도 이게 언급된적이 없길래 내가 잘못생각하나 싶었는데. 이게 진짜 중요하네. 와 리얼 명강의다. 꿀정보를 얻었다.비지니스 로직을 구현하는 레벨이 여기다ㅏ.Jpa를 쓴다면 이 엔티티라는 녀석이 도메인 레이어애 해당하는 거지. 근데 Sql Mapper를 쓰게 되면 이게 자동으로 매핑이 안되니까.도메인을 먼저 클래스 다이어그램으로 잡고 시작을 해야해 그거 기준으로 매퍼들을 만들어야해. Infrastructure Layer 와 서비스쪽 코드보니까 정적 팩토리 메서드로 매핑한다. 와 진짜 내가 쓰던 코딩 스타일이 다 여기나오네.. 진짜 헛으로 고민하고 짠 시간들이 아니였다. ㅠㅠ 설계를 개선하기. 클래스 다이어그램을 그리고, 의존성을 다 그려봐라. 그러면 좀 잘 보인다. 객체 참조로 인한 결합도 상승. 패키지의 양방향 의존성 관계. 의존성 역전 원리. -&gt; 클래스들의 추상화들에 의존하게 하라. 인터페이스를 바라보게하라.인터페이스이거나 추상 클래스여야 한다는 고정관념이 있다. 해결방법 첫번쨰. (1) 중간 객체를 이용한 의존성 사이클 끊기. (2) 연관관계를 다시 살펴보기. = 어떤 객체에서 어떤 객체로 탐색할수 있도록 하는 것.성능 문제 - 어디까지 조회할 것인가.연관관계가 끝까지 가있기 때문에.데이터들이 메모리에 올라가있으면 상관 없으나 Persistance Layer 까지 내려가게 되면 조인 문제 등으로 성능이슈가 발생한다. 어디까지 읽어야 하는가 말아야하는가 Lazy Loading을 어디까지 해야하는가. 근본적인 문제는 모두가 연결되어 있어서 그렇다. 객체 참조가 길어지면 = 트랜잭션도 길어진다. 클래스 다이어그램만 고려하고 객체 참조를 하게 되면 -&gt; 인프라적인 이슈들을 생각하지 않게 한다.너무 이상론이라는 거지. 롱 트랜잭션으로 묶여있는 곳을 냄새를 맡을떄 트랜잭션의 발생 빈도, 주기가 서로 맞는지를 봐야한다. 클래스 다이어그램 기준 객체 참조를 하면서 객체를 만들게 되면. 롱 트랜잭션이 발생하고 트랜잭션 경합으로 인한 성능 저하. 객체 참조의 문제점 -&gt; EVERYTHING IS CONNECTED 모든게 연결되는게 문제점.모든 객체가 연결되어 있기 때문에 어디라도 접근이 가능할 것 같지만 어디라도 함꼐 수정할 것 같지만 성능저하, 트랜잭션 문제, 이상론이고. 인프라적으로는 최대의 적. 객체 참조는 결합도가 가장 높은 의존성. -&gt; 필요하다면 객체 참조를 끊어야 함. 연관관계 = A를 알면 B를 알 수 있어.연관관계를 표현할 수 있는 방법 중 하나가 객체 참조. (강한 결합도) Repository를 통한 탐색(약한 결합도)연관관계를 A 라는 파라미터를 받으면 B를 얻을 수 있어요 이거를 보여줘야 함. 어디까지 객체 참조를 해야하는가.본질적으로 결합도가 굉장히 높은 애들. vs굳이 연결하지 않아도 Repository로 접근해서 해결 가능한 것들. 함께 생성되고 함께 삭제되는 객체들을 함께 묶어라 -&gt; 트랜잭션의 주기가 같아야 하기 떄문에. 도메인 제약사항을 공유하는 객체들을 함께 묶어라. 그러나 가능하면 분리하라. 약한 결합성을 가지게 하라. A가 B의 객체 참조 대신에 B의 PK를 가지게 해서 repository를 통해서 객체를 가져오도록 구현하자. 이게 보다 더 약한 결합성이다. ex) 장바구니와 장바구니 안에 들어가는 아이템들은 라이프 사이클이 다르다 (생성되는 시점, 지워지는 시점) 등등서로 연결되는 데이터가 별로 없다. 이런 경우에는 그냥 약한 결합성을 유지하도록 하는게 좋다. 객체를 묶을 때 라이프 사이클, 도메인 제약사항의 공통점을 찾아보자. 묶인 객체들 내부끼리는 객체 참조로 통신.경계 밖의 객체는 ID를 이용해 접근. 객체참조라는 개념이 메세지를 주고받는 것에 대해서 객체지향을 설명하기가 이론적으로 좋은데. 이상적이다.즉 실무적으로 자원을 생각하고, 성능을 고려해야 한다면 이것만 믿을 수 없다. 객체가 묶인 단위를 기준으로트랜잭션 단위 관리의 기준조회 경계 단위 관리의 기준.영속화 의 기준.이 될수 있다. 몽고DB 같은 NoSQL를 사용하게 되면 이 강한결합도를 가진 객체의 묶음 단위로 컬렉션을 구축하면 된다. 응집도를 다르게 표현하면 같이 변경되야하는 객체들이 같이 있는게 응집도가 높다는 것. 도메인들의 흐름을 표현하는 방법 첫번째 절차지향적인 OrderDeleveredService 코드를 작성하자. -&gt; 로직간의 결합도가 높다. 두번째 도메인 이벤트 중심 퍼블리싱. -&gt; 로직간의 결합도를 느슨하게 하지만 특정 코드가 호출되면 다음 코드가 호출되었으면 좋겠어 이런느낌. 객체 참조는 로직이 아닌 객체 끼리의 결합도였음. 도메인 단위로 패키지를 나누면 의존성 사이클이 엄청나게 생긴다. 그래서 레이어드 기준으로 보통 패키지를 만들어서 관리한다. 근데 도메인을 위에 언급한 강의들을 가지고 리팩토링을 한다면 도메인 단위로 패키지를 구분할 수 있다.도메인 단위로 패키지를 가지게 되면 시스템을 분리하기가 쉬워진다. 그말은 즉은 보다 더 훨씬 모듈화가 되어있다는 의미. 도메인 단위로 시스템을 분리할 수가 있다. 이게 진짜 개쩌는 팁이네. 도메인 관리를 잘해서 최종적으로는 도메인 단위로 객체를 관리. 의존성을 따라서 시스템을 진화시켜라.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"O.O.P","slug":"O-O-P","permalink":"http://kidongyun.github.io/tags/O-O-P/"}]},{"title":"Elastic Search","slug":"2021-03-13-elastic-search","date":"2021-03-12T15:54:00.000Z","updated":"2022-05-31T07:35:53.000Z","comments":true,"path":"2021/03/13/","link":"","permalink":"http://kidongyun.github.io/2021/03/13/","excerpt":"","text":"데이터 베이스 -&gt; 로그 스태쉬 -&gt; 엘라스틱 서치 -&gt; 키바나 엘라스틱서치는 jvm 위에서 동작하기 때문에 jdk 8 이상 있어야한다. 엘라스틱서치는 역색인 기능 덕분에 검색의 기능 관점에서는 RDB보다 훨씬 빠르다. 123456Elastic Search Relational DBIndex DatabaseType TableDocument RowField ColumnMapping Schema REST API 데이터를 CRUD 조작이 가능하다. 12345Elastic Search Relational DB CRUDGET Select ReadPUT Update UpdatePOST Inster CreateDELETE Delete Delete Elastic Search GET 예제1curl -XGET http://localhost:9200/classseslocalhost:9200 이 부분이 elasticsearch 서버 IP 주소 및 포트이고 그다음 classes 이거가 인덱스 1curl -XGET http://localhost:9200/classses?pretty 뒤에 pretty 속성을 주면 결과가 보기 좋게 반환된다. 인덱스 생성하기 예제 (PUT을 사용했다.)1curl -XPUT http://localhost:9200/classes 인덱스 제거하기 예제 (DELETE를 사용한다.)1curl -XDELETE http://localhost:9200/classes 문자열을 직접 넣어서 document 만들기.12curl -XPOST http://localhost:9200/classes/class/1/ -d &#x27;&#123;&quot;title&quot; : &quot;Algorithm&quot;, &quot;professor&quot;, &quot;john&quot;&#125; &#x27; 파일을 활용해서 document 만들기.1curl -XPOST http://localhost:9200/classes/class/1/ -d @oneclass.json 기존에 존재하는 document에 필드 추가하기.12curl -XPOST http://localhost:9200/classes/class/1/ update -d &#x27;&#123;&quot;doc&quot; : &#123;&quot;unit&quot; : 1&#125;&#125; &#x27; 스크립트를 활용해서 다큐먼트 수정하기.12curl -XPOST http://localhost:9200/classes/class/1/ update -d ‘&#123; “script” : “ctx._source.unit += 5” &#125; ’ 벌크 (여러가지 다큐먼트를 한번에 삽입하는 방법)1curl -XPOST http://localhost:9200/_bulk?pretty —data-binary @classes.json 매핑 (Schema)매핑이 없이도 데이터를 넣을 수 있다.그러나 실무에서 매핑없이 넣는 것은 위험한 일. 자바스크립트를 사용하는 것 대신 타입스크립트를 쓰는것과 동일. 매핑에서 geo_point 는 지도 위의 위치를 의미.인덱스를 조회해 보면 mapping 영역이 있음 거기를 처리하는 것. 키바나로 시각화를 할때 매핑된 데이터를 활용해야 더 디테일하게 조작이 가능하다. ——————————————— 몽고디비 레플리카 서버 + 엘라스틱서치 검색엔진 적용. 엘라스틱서치 간략한 정리. 왜 엘라스틱서치 검색방법이 더 빠른가. -&gt; 역색인 방법.빅데이터들을 빠르게 검색하고 처리가 가능하다. 엘라스틱서치 만으로 그러면 서비스를 할수 있지 않나.단점이 있다 단점이 뭐냐면. 엘라스틱 서치의 search을 알아보자. 1curl -XGET localhost:9200/basketball/record/_search?pretty URI의 q 파라미터 값을 활용하여 쿼리를 작성할 수 있다.1curl -XGET &#x27;localhost:9200/basketball/record/_search?q=points:30&amp;pretty&#x27; REQUEST BODY 를 활용해서도 쿼리를 날릴 수 있다.123456curl -XGET &#x27;localhost:9200/basketball/record/_search -d `&#123; &quot;query&quot; : &#123; &quot;term&quot; : &#123; &quot;points&quot; : 30 &#125; &#125;&#125;`&#x27; REquest body 옵션은 다양한 질의가 가능하다 나중에 찾아보자. elastic aggregation. aggs = aggregations metry aggs -&gt; 산술 어그리게이션. BUCKET AGGS -&gt; 그룹 바이로 보면 된다. 뭔가 다큐먼트 통합적으로 연산을 할 떄 사용하는 거 같은데. 디비에서 있는 SUM(), MAX() 이런 연산을 지원하는 거 같다. 키바나 설정. 키바나 management 메뉴. index pattern -&gt; index 설정하는 곳에 엘라스틱서치의 인덱스를 넣는다. 엘라스틱 서치 인강. 루씬 기반의 검색 엔진.자바 기반으로 만들어짐. (JVM 위에서 돈다. jdk8이상 필요) Elastic stack -&gt; Elaticsearch + Logstash + Kibana 빅데이터 사업쪽에서 많이 사용하나봄.엘라스틱 개발자가 돈을 잘번대. 클라우드, 온오프라믹스? 엘라스틱 설치 데이터베이스가 있고 이걸 로그스태쉬를 활용해서 엘라스틱서치에 연동을 할 수 있다. postgresql -&gt; logstash -&gt; elasticsearch -&gt; kibana이거 구축을 해보자. ———————————————— 오픈소스 검색 및 분석 엔진.방대한 양의 데이터를 신속하게, 거의 실시간으로 저장, 검색, 분석할 수 있도록 지원. 활용 예시로그 또는 트랜잭션 데이터들을 모아서 의미 있는 데이터화.두번째 데이터들 빅데이터들을 모아서 의미 있는 데이터화. 엘라스틱 스택.엘라스틱 서치 + 키바나 + 로그스태쉬","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Elastic Search","slug":"Elastic-Search","permalink":"http://kidongyun.github.io/tags/Elastic-Search/"}]},{"title":"우아한레디스, 디디의 Redis","slug":"2021-03-13-wooah-redis","date":"2021-03-12T15:54:00.000Z","updated":"2022-05-31T07:39:08.000Z","comments":true,"path":"2021/03/13/","link":"","permalink":"http://kidongyun.github.io/2021/03/13/","excerpt":"","text":"캐쉬의 구조 2가지 형태 Look aside Cache메인은 DB이고 DB에서 캐쉬로 데이터를 가져와서 저장. 캐쉬에 데이터가 있으면 캐쉬 데이터를 사용하여 성능을 개선하고 없으면 디비에서 가져와서 다시 캐쉬에 저장.일반적인 구조 Write back캐쉬에 데이터를 특정기간 동안 먼저 저장하고 캐쉬에 있는 데이터들을 디비에 저장.휘발할 수 있는 가능성 있다. Collection개발의 편의성, 개발의 난이도. Memcached 보다 redis가 나은 점 -&gt; 레디스는 collection을 제공하고, memcached는 이걸 제공하지 않느다.컬렉션이 제공되면 개발의 편의성이 높아지고, 생산성이 올라간다. 즉 멤캐시드는 이런걸 제공하지 않기 때문에 다 직접 구현해야한다는 의미. 두 트랜잭션의 레이스 컨디션이 발생하는 문제 -&gt; 멤캐시드는 이런거 세마포어나 뮤텍스 기법으로 해결을 해야하는데 레디스는 기본적으로 ACID의 A가 지원된다. 레이스 컨디션 오류를 기본적으로 잡아준다. 레디스의 컬렉션이 이런걸 지원한다. 레디스를 주로 쓰는경우여러대의 서버에서 접근해야하는 원격 저장소가 필요할때EX) 인증 토큰, 랭킹 보드, 유저 API LIMIT, 잡 큐 레디스 컬렉션String : key-value 구조List :Set : 중복 데이터 방지Sorted set : 기본적으로 set인데 스토어를 줘서 순서를 제공 StringSet get msetmget여러개를 넣거나 가져올 수 있다 List 타입 : 왼쪽 오른쪽으로 넣거나 뺄 수 있다.Lpust Rpust Lpop Rpop 데이터 성질에 따라서 컬렉션 구조를 잘 골라야한다. setsadd smembers sismember smembers 는 데이터를 모두 가져오는 건데 이런거 성능 주의. sorted set : 이거 많이 사용한다고 한zadd zrange zrange 레디스는 인메모리 저장소 이기 떄문에. 물리적메모리 공간보다 더 클수 없다.물론 불가하다는건 아닌데 swap이 발생하게 되고 결국 디스크를 활용하게 되서레디스를 제대로 활용하는 방법이 아니다.그래서 레디스는 메모리 사용률을 모니터링 해야한다. 메모리 관리.64기가바이트 메모리를 가진 서버에 인스턴스라는 적을 작은 단위로 사용하는 것이 안전함.이해가 안되는 군. 뭔가 어렵다. jemalloc -&gt; java 쪽에서메모리 할당하는 함수같은데. 이거가 4096 이런 단위로 할당함 메모리가 부족할 때는-&gt; Cache is Cash 캐쉬가돈이다.보통 70% 정도 사용하고 있다면 더 큰 시스템을 사용하거나, 데이터량을 줄여야하는 선택지를 고려해야함. Collection 들이 아래 자료구조를 사용.Hash -&gt; HashTableSorted Set -&gt; Skiplist, HashTableSet -&gt; HashTable 실제 위와 같은 컬렉션을 사용하게 되면 메모리 사용률은 조금 더 나온다. 포인터 등 오버헤드 작업에서 필요한 메모리가 존재 Ziplist 이거를 사용하면 조금 더 느리지만 메모리는 좀더 절약할 수 있다.인메모리기 때문에 그냥 선형탐색을 하더라도 빠르다. 즉 메모리 공간 사용률을 줄이고 시간복잡도를 그냥 높게 가져간다는 의미인거 같음. O(N) 관련 명령어는 주의하다.Redis는 싱글 스레드.레디스는 싱글 스레드이기 떄문에 여러 개의 명령을 처리할 수 없다. 싱글 스레드이기 때문에 하나의 명령어가 시간이 오래걸리는걸 사용하면 다른 명령어들이 밀려서 타임아웃이 발생.그래서 조심히 사용해야 한다. ex) KEYS, FLUSHALL, FLUSHDB, Delete Collections, Get All Collections 실수 사례 - Key가 백만개 이상인데 확인을 위해 KEYS 명령을 사용하는 경우.KEYS 명령은 scan 명령으로 대체 가능.KEYS 는 한번에 처리, scan은 긴 명령을 짧은 여러번의 명령으로 바꾸기 때문에 타임아웃 발생 가능성 낮아짐.저 사이사이에 작업들을 함. Collection의모든 item을 가져와야 할 때.Collection 작은단위로 나눠서 관리하자. Springsecurity oauth Redis TokenStore 이슈. Redis Replication.Replication 이라는것은 A서버의 데이터를 B서버에 변경사항도 동일하게 복제가 가능하다. Async Replication-&gt; Replication Lag이 발생할 수 있다.마스터에 데이터가 변경되면 슬레이브에 변경내용을 콜. 근데 이 상황에 렉이 발생하면 미매칭 될 수도 있음.master-slave 용어에서 original-replica. Redis Replication 설정 과정. redis.conf 권장설정Maxclient 설정 50000 -&gt; 접속 가능한 고객 수RDB/AOF 설정 off -&gt; 성능개선 마스터는 꺼두고 레플리카에만 켜둔다. 필요하다면특정 commands disableKeysAWS의 ElasticCache 이미 하고 있음. Redis 데이터 분산 방법.Application - Consistent Hashing 서버0,서버1, 원래 서버 로드밸런싱할때 모듈러 연산을 하나?? -&gt; 리밸런싱에 취약하다. 서버가 증축되었을 때 데이터가 리밸런스가 50% 이상일어나고, 자주 일어나면 좋지 않은 현상.반대로 서버 하나가 장애가 일어나면 다시 리밸런스가 일어나야함.이런 형태가 서버가 장애에 취약한 방식.이걸 해결하기 위한 Consistent Hashing 방식. Consistent Hashing 방식서버가 모듈러 연산이 아니고 해쉬 코드를 가진다. ex) 10000, 20000, 30000해쉬코드 값이 서버랑 비교해서 가장 크고 가장 가까운 곳으로 가게끔 한다.더 큰 코드가 없으면 원형구조로 가장 해쉬코드가 작은 작은 서버로 간다.서버가 추가되거나 제거될때이런식으로 하면 기존의 데이터들의 리밸런스가 영향이 있는 데이터만 하고 다른 데이터들은 수정될 필요가 없다. Sharding 방식데이터를 어떻게 나눌 것인가.데이터를 어떻게 찾을 것인가. 하나의 데이터를 모든 서버에서 찾아야 하면? 상황마다 샤딩 전략이 달라짐. 가장 간단한 방법 Range 적용.하나의 샤딩이 1~1000 Key를 가지고 두번째는 2~2000 이런식으로. 이렇게 되면 ID가 몰리면 하나의 서버에 데이터가 집중되서 특정 서버는 놀게되는 현상이 발생.다른 데이터들을 다른 서버로 옮길 수가 없고. 불균등하다. 서버를 확장하는것은 쉽다 단순히 키를 증가시키면 되기 때문에. 두번째 방법 modular 적용.2배씩 늘리는 이유는 데이터 이주가 심플해진다. 가는 곳이 정해지기 떄문.서버가 2배로 늘어나면 가야할 서버가 0 -&gt; 2, 1 -&gt; 3 이렇게 간다먼 느낌인지 알듯.문제가 32개의 서버에서 64개로 늘리기는 쉽지 않다. 서버 한대씩 늘어나는 것은 리밸런싱이 많이 일어남. Indexed해당 키가 어디에 저장되어야 할 관리 서버가 따로 존재. 그때그떄 서버들의 상태를 이서버를 확인이 인덱스 서버가 죽으면 관리를 못하는 단점. Redis Clusterclient - primary #1 - Secondary #1 primary #2 - Secondary #2 primary #3 - Secondary #3 Slot 단위의 데이터 관리. -&gt; 메모리 사용량이 더 많음.라이브러리 구현이 필요. Redis Failover Coorinator - Zookeeper, etcd, consul? VIP 기반, DNS기반 API Server 가 특정 VIP, DNS 로레디스 서버를 호출하고. 레디스 서버는 기본적으로 #1 이 이 DNS, VIP를 가리키고 있는데 장애가 발생하면. Health-checker 이거가 #2로 변경한다.API Server 가 추가적인 구현이 필요없다. DNS 기반은 DNS Cache TTL을 확인해봐야함.만약 이 유효기간이 길면 장애처리가 이 기간동안에는 안될 수 있음. Moitoring FactorRedis Info를 통한 정보RSS (Physical Memory를 얼마나 사용하고 있는가.) 이게 젤 중요Used MemoryConnection 수 -&gt; 레디스는 싱글 스레드라서 커넥션 맺꼬 끊은거를 계속 하면 성능이 떨어진다.초당 처리 요청 수 Monitor 명령을 통해 사용되고 있는 명령들의 모음을 볼 수 있음.이것도 성능에 영향이 있음으로 쓸때는 짧게 써야함. 기본적으로 레디스는 좋으나 메모리가 빡빡하게 사용할 경우 어렵다. Redis as Cache 로 바라본다면 그래도 문제가 적게 발생.이때에는 디비에 부하가 어느정도 증가하는지를 확인해야함. Redis as Persistent Store 로 본다면 좀더 주의해야 한다.메모리를 절대 빡빡하게 사용하면 안됨.RDB/AOF가필요하다면 Secondary에서만 구동.이 방법으로 쓰는거면 돈을 많이 투자할 수 밖에 없다. ——————————— 디디의레디스. 레디스의 개요. remote dictionary server 여기서 dictionary 는 python 에서 나오는데 map구조. In memory data structure. 다양한 자료구조를 제공한다. -&gt; Collection. Cache : 나중의 요청에 대한 미리 저장해두고 나중에 빠르게 사용하는 것. 메모리의 계층 구조. 디스크 -&gt; 메인메모리 -&gt; 캐쉬 -&gt; 레지스터 캐시(SRAM) vs 메인메로리(DRAM) ?? 구현 관점에서 궁금. 메인메모리는 휘발성. 원리 디비 개념은 디스크에 저장하고 가져오는 개념이였는데 메모리도 용량이 커지면서메모리에서 그냥 데이터 저장하고 캐쉬 형태로 사용하는 디비가 나왔는데 이게 레디스 컬렉션. (자료구조) 멤캐시드는 이걸 제공하지 않는다. 자바랑 비교 String : MapList : LinkedListSorted Set : TreeSet 자바랑 어떻게 다를 까. 왜 자바의 컬렉션 프레임워크를 안 쓸까. 서버가 여러대인 경우. 일관성문제 발생.특정 서버에는 있고 다른 서버에서 없다. Multi-Threading 환경에서 레이스 컨디션 발생.근데 레디스는 애초에 싱글 스레드인데.레디스 자료구조는 임계구역에 대해서 기본적으로 동기화 처리를 제공한다.그렇기 때문에 컬렉션 프레임워크를 안쓰는 거구나. 여러 서버에서 공유를 해야하고, 임계구역에 대한 조치가 컬렉션 프레임워크랑 레디스의 컬렉션이 다른 점. 레디스가 근데 무슨 언어로 구현되어있지? 레디스가 싱글 스레드 방식으로 동작하는 이유.IO 작업이 많기 때문에 -&gt; IO 쪽은 리소스가 애초에 적기 때문에 스레드가 많아도 병목현상이 발생하고 실제적으로 성능을 끌어올리기 어렵다. 싱글 스레드이기 때문에 시간 복잡도가 O(N) 부터 주의해서 사용해야함. 왜냐하면 다른 작업들이 밀리게 되고 타임아웃이 발생하게 됨. 메모리 관리.메모리 파편화 -&gt; 실제로 더 많이 사용하는 걸로 보임. 파편화된 부분도 운영체제는 사용하는 메모리라고 인지.가상 메모리의 swap -&gt; 메인메모리가 가득차게되면 이게 필수적. 디스크를 접근하는거기 때문에 지연시간이 필연적.Replication -&gt; 데이터 복제하는 기능. 슬레이브 영역에 저장하는 방법.복제하는 방법 Fork() -&gt; Redis Persistant -&gt; 레디스를 캐쉬의 목적이 아닌 RDB 목적으로 사용하는 방법.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://kidongyun.github.io/tags/Redis/"},{"name":"Database","slug":"Database","permalink":"http://kidongyun.github.io/tags/Database/"}]},{"title":"Matcher any 여러 개일때와 null 있을 때","slug":"2021-03-12-matcher-any","date":"2021-03-11T15:54:00.000Z","updated":"2022-05-31T07:35:43.000Z","comments":true,"path":"2021/03/12/","link":"","permalink":"http://kidongyun.github.io/2021/03/12/","excerpt":"","text":"Test Code 작성시 Mocking을 위해서 Matcher 클래스는 유용하게 사용되는데. 파라미터가 여러 개 들어갈 경우. 실제 값과 any를 활용한 값이 섞여서 전달되면 정상적으로 Mocking이 되지 않는다. Matcher 클래스를 쓴다면 모든 파라미터 값을 Matcher 클래스의 형태로 제공되어야 한다. 두번째로 null 객체를 넣고 싶을 때에는 isNull(T) 이 함수를 활용하면 된다. 12when(mypageServiceMock.retrieve(isNull(PartnerVO.class), anyString(), anyString(), anyString(), anyString(), anyString(), anyBoolean(), Matchers.&lt;BookingMapper&gt;any(), anyString())) .thenReturn(retrieveDetail);","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Test","slug":"Test","permalink":"http://kidongyun.github.io/tags/Test/"},{"name":"Matcher","slug":"Matcher","permalink":"http://kidongyun.github.io/tags/Matcher/"}]},{"title":"ACID features of transaction","slug":"2021-03-04-acid-transaction","date":"2021-03-03T15:54:00.000Z","updated":"2022-05-31T07:35:34.000Z","comments":true,"path":"2021/03/04/","link":"","permalink":"http://kidongyun.github.io/2021/03/04/","excerpt":"","text":"Atomicity(원자성) : DBMS는 완료되지 않은 트랜잭션의 중간 상태를 데이터베이스에 반영해서는 안 된다. ‘all or nothing’ Consistency(일관성) : Isolation(독립성) : 여러 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션의 수행에 영향을 받지 않고 독립적으로 수행되어야 한다. Durability(지속성) : 트랜잭션이 성공적으로 완료되어 커밋되고 나면, 해당 트랜잭션에 의한 모든 변경은 장애가 발생하더라도 보존되어야 한다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://kidongyun.github.io/tags/Database/"},{"name":"Transaction","slug":"Transaction","permalink":"http://kidongyun.github.io/tags/Transaction/"}]},{"title":"Effective Java","slug":"2021-03-02-effective-java","date":"2021-03-01T15:54:00.000Z","updated":"2022-05-31T07:35:25.000Z","comments":true,"path":"2021/03/02/","link":"","permalink":"http://kidongyun.github.io/2021/03/02/","excerpt":"","text":"Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라.장점이름을 가질 수 있다.호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.반환타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. from : 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드of : 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드valueOf : from과 of의 더 자세한 버전. Item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라.의존성을 이미 결정해버리기 때문에 다른 의존성을 주입할 수가 없다.의존성 주입시 일반적으로 좋다라고 생각하는 방식은 생성자를 활용한 주입이다.바로 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식.의존객체를 주입하는 것은 유연성과 테스트 용이성을 높여준다.이런 객체는 final을 선언하여 불변함을 보증해주면 다른 개발자들끼리 해당 객체를 안심하고 공유하고 사용할 수 있다.. 의존 객체 주입 방식의 확장 - 팩토리 메서드 패턴을 전달하자.Supplier 객체활용해보기. Item 7. 다 쓴 객체 참조를 해제하라.가비지 컬렉션이 메모리를 회수할 때 판단하는 첫번째 조건은 객체 참조 변수가 살아있는지이다.그렇기 때문에 객체를 사용하고 난 후 참조를 해제하는 것이 중요하다.계속 쌓이게 되면 성능에 악영향이 오고 나중엔 StackOverflow 오류가 발생한다. 선행적으로 Null을 검토하고 예외를 확인하는 습관은 중요하다.물론 나중에 null로 인해 다른 곳에서 예외가 발생하니 이걸 굳이 먼저 체크할 필요가 있느냐라고도생각할 수 있지만. 오류를 디버깅하는 관점에서 1번 라인에서null이발생하고 이로 인한 오류가 100번 라인에서발발하게 되면 StackTrace 를 찍는다고 해도 1번 라인이 null이기 때문에 발생한 오류라고 직관적으로 대답해주지 못한다. 그렇기 떄문에 모든 오류는 가능한 조기에 발견하는 것이 디버깅하는데에 좋다. 또 이렇게 되면. Exception의 message를 커스텀하게 전달이 가능함으로 더 상세한 오류 내용을 알려줄 수 있다. 객체 참조를 해제하기 위해서 해당 객체에 null 을 밀어 넣는 것 보다는 해당 참조변수의 범위를 최소화 시키는 방법이 가장 좋다. 이 범위를 벗어나게 되면. 해제작업은 알아서 이루어진다. 일반적으로 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야 한다. Item 10. equals는 일반 규약을 지켜 재정의하라.아래케이스에 해당한다면 equals() 함수를 재정의할 필요가 없다.1.각 인스턴스가 본질적으로 고유하다. 인스턴스의 ‘논리적 동치성’을 검사할 일이 없다. 상위 클래스에서 재정의한 equals가 하위클래스에도 딱 들어맞는다. 클래스가 private이거나 package-private 이고 equals 메서드를 호출할 일이 없다. 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스의 경우 equals 함수를 재정의하여 논리적 동치성을 보일 필요가 없다. 객체 식별자가 논리적 동치성이랑 동일하게 동작되기 때문. equals() 함수를 재정의할 때 지켜야할 속성. 반사성 : null이 아닌 모든 참조 값 x 에 대해, x.equals(x)는 true이다. 대칭성 : null이 아닌 모든 참조 값 x,y 에 대해, x.equals(y)가 true이면 y.equals(x) 도 true 이다. 추이성 : null이 아닌 모든 참조 값 x,y,z 에 대해, x.equals(y) 가 true, y.equals(z) true 이면 x.equals(z) 도 true이다. 일관성 : null이 아닌 모든 참조 값 x,y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다. null-아님 : null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false이다. Item 11. equals를 재정의하려거든 hashCode도 재정의하라.equal를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다. equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다. equals(Object)가두 객체를 같다고 판단했다면, 두 객체의 hashCode는똑같은 값을 반환해야 한다. equals(Object)가두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서롤 다른 값을 반환할 필요는 없다. 단 다른 객체에 대해서는 다른 값을 반환해야 해시 테이블 성능이 좋아진다. hashCode() 함수를 한가지 값만 반환하도록 구현하면 모든 객체에서 똑간은 해시코드를 반환하기 때문에 해시테이블의 버킷 하나에 모든 데이터들이 들어가기 때문에 연결 리스트 처럼 동작한다. 그결과 평균 수행시간이 O(1)인 해시테이블이 O(N)으로 느려진다. 해시의 속성을 잘 쓰기 위해서는 서로 다른 인스턴스에 다른 해시코드를 반환해야한다. 해시코드가 같다고 해서 두 객체가 같음을 의미하는 것은 아니다. 이것은 equals()함수로 처리하는 거다. hashCode() 함수는 말 그대로 해시테이블의 해시코드를 적용하는 것. 성능을 높인다고 해시코드를 계산할 때 핵심 필드를 생략해서는 안된다. 속도야 빨라질 수 있겠지만 해시 품질이 나빠져서 해시테이블의 성능을 심각하게 떨어뜨릴 수도 있다. 핵심 품질을 떨어뜨린다는 의미는 해시테이블에 값들이 골고루 분포해야 해시 테이블의 성능을 활용 할 수 있는데 한곳에 몰리는 경우를 말한다. hashCode가 반환하는 값의 생성 규칙을 API사용자에게 자세히 공표하지 말자. 그래야 클라이언트가 이 값에 의지하지 않게 되고, 추후에 계산 방식을 바꿀 수도 있다. AutoValue 프레임워크를 활용하면 equals(),hashCode() 함수들을자동으로 만들어준다. Item 57. 지역변수의 범위를 최소화하라.지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다. 지역변수의 범위를 줄이는 가장 강력한 기법은 역시 ‘가장 처음 쓰일 때 선언하기’ 또한 모든 지역변수는 선언과 동시에 초기화 해야한다. -&gt; try-catch 구문을 사용할 때는 이 규칙을 지키기가 어렵다.변수를 초기화하는 표현식에서 검사 예외를 던질 가능성이 있다면 try블록안에서 초기화 해야하기 때문이고 또변수 값을 try 블록 밖에서도 사용한다면. 이를 위해 지역변수의 범위를 try 블록 밖 까지 넓혀줘야하기 때문이다. 반복문에서 범위 줄이기while문 보다 for문이 가지는 장점 중 하나는 지역변수 반복자의 범위 제한이다.while문을사용할 경우 반복자를 바깥쪽에서 초기화하고 반복문 안에서 사용하기 때문에 반복문 블록을 나와서도 반복자 변수를 사용할 수 있다.for문은 이 반복자를 반복문 안에서 생성하기 떄문에 밖에서 사용할 수 없다. 보다 오류에 대해서 안전하다.반복자의 범위를 제한하게 되었을 때 가지는 또하나의 장점은 반복자의 네이밍을 고민할 필요가 없다. 모두 동일한 이름을 가지더라도 모두 구분된다. 메서드를 가장 작게 유지하고 한가지 기능에 집중하기.한 메서드에서 여러가지 기능을 처리한다면 그 중 한 기능과만 관련된 지역변수라도 다른 기능을 수행하는 코드에서 접근할 수 있을 것이다. 해결책은 간단하다. 단순히 메서드를 기능별로 쪼개면 된다. Item 45. 스트림은 주의해서 사용하라.스트림을 과용하면 프로그램이 읽거나 유지보수하기 어려워진다.람다에서는 타입 이름을 자주 생략하므로 매개변수 이름을 잘 지어야 스트림 파이프라인의 가독성이 유지된다.스트림으로 바꾸는게 가능할지라도 코드 가독성과 유지보수 측면에서 손해볼 수 있다.스트림과 반복문을 적절히 조합하는게 최선기존 코드는 스트림을 사용하도록 리팩토링하되, 새 코드가 더 나아 보일 떄만 반영. 스트림을 사용하기 어려운 케이스파이프라인 작업 안에서 return, break, continue 문으로블록 바깥의 반복문을 종료하거나 반복을 한 번 건너뛰어야 할때.스트림 파이프라인에서 바깥쪽의 지역변수를 사용하기 위해서는 final만 가능하다. 그렇기에 이를 수정해야하는 케이스라면 stream을 사용하기 어렵다. 좋은 케이스원소들의 시퀀스를 일관되게 변환한다.원소들의 시퀀스를 필터링한다.원소들의 시퀀스를 하나의 연산을 사용해 결합한다.원소들의 시퀀스를 컬렉션에 모은다.원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다. 스트림을 반환하는 메서드 이름은 원소의 정체를 알려주는 복수 명사로 쓰기를 강력히 추천. Item 46. 스트림에서는 부작용 없는 함수를 사용하라.스트림 패러다임의 핵심은 계산을 일련의 변환으로 재구성하는 부분이다. 이때 각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 순수 함수여야 한다.순수 함수란 오직 입력만이 결과에 영향을 주는 함수를 말한다. 다른 가변 상태를 참조하지 않고, 함수 스스로도 다른 상태를 변경하지 안흔다.이렇게 하려면 스트림 연산에 건네는 함수 객체는 모두 부작용이 없어야 한다. 스트림 종단연산 중 forEach() 는 스트림 계싼 결과를 보고할 때만 사용하고, 계산하는ㄷ ㅔ에는 사용하지 말자. Item 58. 전통적인 for문보다는 for-each문을 사용하자.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"Interview Preparing","slug":"2021-03-01-interview.preparing","date":"2021-02-28T15:54:00.000Z","updated":"2022-05-31T07:34:42.000Z","comments":true,"path":"2021/03/01/","link":"","permalink":"http://kidongyun.github.io/2021/03/01/","excerpt":"","text":"1. Dead Lock (교착상태) O교착상태 정의두 A, B 프로세스가 한 공유될 수 있는 자원을 바라보고 있다고 하자. 만약 A 프로세스가 이 자원을 선점하고 있고 A 프로세스는 B 자원이 이 자원을 선점해야 이 자원 선점을 해지할 수 있다. 또 B 프로세스는 이 공유되는 자원을 선점해야 다음 작업이 진행이 가능하다. 이런 경우 두 프로세스의 진행이 불가능 하기 때문에 교착상태, dead lock 이라고 표현한다. 이론적으로 교착상태는 아래의 조건이 모두 성립해야 발생한다. 교착상태 예방상호배제 - 공유되는 자원을 두개 이상의 프로세스가 점유할 수 없다라는 논리는 무시한다는 의미. 비선점 - 선점이 가능하도록 수정 교착상태 회피은행원 알고리즘. 2. Transaction O트랜잭션 정의데이터 정합성을 유지하기 위해 정해놓은 최소한의 논리적 작업 단위. RDB DBMS의 트랜잭션 관리DBMS는 기본적으로 질의 처리기와 저장 시스템 두 부분으로 나누어진다. 그리고 저장 시스템에 메인 메모리에 유지하는 페이지들을 관리하는 페이지 버퍼라는 모듈이있다.이 페이지 버퍼라는 모듈이 트랜잭션 관점에서 굉장히 중요하다. 수행한 질의에 대해서 커밋을 하지 않았다면 이 버퍼에 수정 내용들이 존재하는데. 이를 활용해서 롤백을 할 수 있다. 하나의 트랜잭션에서 오류가 발생할 경우 데이터 정합성을 맞추기 위해 롤백이 필요하다. Mybatis 같은 SQLMapper 에서의 트랜잭션 관리.java에서 RDB 접근할때에는 JDBC API를 주로 사용한다. 이 API 기본적으로 질의를 했을 때 해당 내용을 auto commit하는 옵션이 true로 되어있다. 왜 그렇게 되어있을까. 왜 이렇게 되어있어서 트랜잭션 관리를 하기 어렵게 만들었을까… 그건 나도 모르지 그렇기 때문에 위 버퍼를 활용하기 어렵고 롤백시키가 까다롭다. 해결할 수 있는 방법 중 하나는 쿼리 자체를 한번에 하도록 하는 것 쿼리 한번에 커밋이 되니까 한번의 쿼리에 데이터 정합성이 맞게 모두 처리하는 방법 해결할 수 있는 두번째 방법은 auto commit 옵션을 해지하기. 세번째 방법 @Transactional 어노테이션 적용. JDBC 트랜잭션 유지 방법JDBC API를 사용할 때 트랜잭션 유지 방법 cath 블록에서 rollback 작업 명시 DatasourceTransactionManager @Transactional JPA 에서의 트랜잭션 관리.Persistent Context 에서 애초에 커밋을 바로 하지 않고 트랜잭션이 완료되었을 때 리얼 DB에 커밋을 함.그렇기 때문에 한 트랜잭션 내에서 오류가 발생하면 아에 DB에 넣은 내용이 없기 때문에 롤백 처리가 간단함. 3. Spring IoC DI, DL OIoC (Inversion Of Control)객체의 생성이나 의존성 주입에 대한 관리 주체를 개발자가 가지는게 아니라 프레임워크, 컨테이너가 가지는 개념이다. 기존에는 개발자가 했었는데 이 책임을 프레임워크가 가져갔다 해서 IoC 라고 부른다. 의존성 관리라는 것이 커지면 커질수록 개발자에게는 부담이 되는 요소인데 이를 스프링의 경우 스프링 컨테이너에 빈등록을 하고 바로바로 의존성을 주입할 수 있도록 도와준다. DI (Depedency Injection)의존성을 주입하는 행위. DI 종류 : 필드 주입, 생성자 주입, Setter 주입. -&gt; 생성자 주입을 권장하는데 이유는 순환참조를 방지할 수 있기 떄문. DL (Dependency Lookup)의존성을 찾는 행위. 순환 참조와 그 문제 그리고 해결방법.A도 B를 의존하고, B도 A를 의존하는 구조. 이렇게 되면 나중에 A`이 등장했을 때 B에 버무리지 못한다. 확장 가능성이 있기 떄문에 이럴때는 B는 A를 추상화 시킨 인터페이스를 의존성으로 가지게 하고, A, A’ 이 이 인터페이스 규격에 맞추어 설계한다. 5. MVC (Model View Controller)정의Model, View, Controller 세가지 영역으로 나누어서 개발하는 방법. Model은 데이터를 담당하고 View는 화면을 담당합니다. 이 둘사이에서 조건에 따른 처리달라지거나 제어의 목적으로 사용되는 것이 Controller 영역입니다. Spring Framework로 Web MVC를 구현했을 때 JSP, Thymeleaf는 View 영역에 해당하고, Model, Service 쪽은 Model 영역에 해당합니다. Spring Controller가 MVC에서 Controller 영역에 해당합니다. 장점 각 영역이 담당하는 업무 주제가 날카로워지기 때문에 분업의 효과를 가져올 수 있다. 코드들이 분리가 되기 때문에 상호간 의존성이 감소해서 어플리케이션의 유연성과 확장성을 증가시킬 수 있습니다. 각 영역이 담당하는 업무가 확실해지기 때문에 디버깅하기가 쉬워진다. 예를 들어 팝업이 안뜨는 오류가 발생했다면 이 오류는 View 영역의 오류일 것입니다. 6. 웹서버 O정의HTTP 프로토콜 기반의 요청을 받아들이고 그 요청에서 원하는 HTML 문서, 이와 관련된 데이터를 반환해주는 프로그램. 구현 방법MPM (Multi Processing Module)prefork (process)각 요청을 프로세스로 받아서 처리한다. 각 요청에 따라 다른 프로세스를 사용하기 때문에 사용되는 메모리도 독립적이며, 다른 요청들에게 영향을 주지 않는다.매번 PCB를 새로 생성하기 때문에 자원을 많이 사용하게 된다. 멀티 프로세스 방식 마스터 프로세스가 있고 요청이 들어오면 슬레이브 프로세스를 fork 하여 만들고 이 슬레이브 프로세스에서 요청에 대한 처리를 한다. 매 요청에 맞춰서 슬레이브 프로세스를 만들어야 하기때문에 프로세스가 계속 늘어나는 문제점과, 매번 요청에 따라서 슬레이브 프로세스로 바꾸는 context switching 비용이 있다. worker (thread)각 요청을 스레드로 받아 처리한다. 프로세별로 제한하는 스레드 개수 만큼 스레드를 생성하며 이를 초과하게 되면 새로운 프로세스를 생성하여 처리. 쓰레드 기반이기 때문에 프로세스 기반인 prefork 보다는 리소스 부하가 적다. 매번 쓰레드를 생성하는 비용은 쓰레드 풀을 만들어서 해결할 수 있다고 해도, 쓰레드끼리의 문맥교환 비용이 존재함. worker 방법이 prefork 방법에 비해 고속처리, 대량처리가 가능한 것은 아니지만 리소스 부하를 줄일 수 있다. eventnginx 에 대응하기 위해서 apache 에서 event-driven 구조를 지원하도록 업데이트함. Event-driven7. WAS O정의기존의 웹서버 기능에 Servlet Container가 포함된 프로그램.동적 컨텐츠를 제공할 수 있다. 서버의 비즈니스 로직을 실행하여 해당 결과물을 요청 객체에게 반환해주는 프로그램 웹서버와 WAS를 병행해서 사용하는 이유 2티어 구조로 변경함으로써 각자 역할에 대해서 응집도를 높이고 Loose Coupling. 디버깅도 하기 쉬워진다. 성능 향상 - 각자의 서버의 관심사가 몰입되기 때문에 캐시 적중률이 높아질 것 같습니다. 웹서버 1대 WAS 여러 대를 둘때 로드밸런싱을 해주는 역할이 웹서버. 웹서버만 대외적으로 드러나고 이 웹서버를 통해서 WAS를 접근하게 됨으로 보안이 강화된다. WAS에서는 대부분 DB를 접속하는 기능도 포함되어 있기 때문에 노출시키지 않는 것이 좋다. 웹서버에서 WAS까지 데이터 흐름 이해하기톰캣은 apache의 웹서버의 역할도 가지고 있기 때문에 내부적으로는 웹서버 + 서블릿 컨테이너로 구분된다고 할 수 있다. 웹서버가 처리할 수 없는 동적 컨텐츠에 대한 요청이 들어오면 서블릿 컨테이너에서 이 요청을 처리하기 위한 서블릿을 생성한다. 실제로 DispatcherServlet 이 녀석은 Servlet 인터페이스를 구현한 객체이다. 그래서 스프링을 띄우고 있는 WAS라면 Servlet Container에서 DispatcherServlet을 실행한다. DispatcherServlet은 요청 데이터와 mapping되는 컨트롤러를 찾고 연결한다. 서버쪽의 비지니스 로직 처리가 완료되면 해당 결과물을 ViewResolver를 통해 반환한다. WAS의 종류tomcat vs undertow vs netty 8. Docker ODocker 정의컨테이너 기반의 오픈소스 가상화 플랫폼이다. VM 기술과 유사하며, 동일한 하드웨어를 사용하여 어플리케이션을 띄우는 독립된 소프트웨어 공간을 구현한다. VM vs ContainerVM이 Container 방법보다 훨씬 더 강력하게 가상화하고 격리한다. VM은 가상화된 공간에 독립적인 OS를 온전하게 올리는 형태로 거의 완벽하게 Host와 분리된다. 이와 반대로 Cotainer 방법은 호스트와 공유할수 있는 커널들을 공유하며, 어플리케이션을 띄울 때 필요한 커널들만 가상화 공간에 띄운다. 예를 들어서 VM을 활용해서 가상화된 서비스 3개를 띄운다고 하면, 이 호스트 하드웨어는 총 4개의 운영체제를 띄워야 한다. 그만큼 많은 메모리를 사용하게 되며, 특히나 하드웨어 리소스에 의존된 커널들의 경우. 호스트만 사용하는 기존의 구조과 달리 4개의 커널이 리소스를 사용하려고 하기 때문에 리소스를 모두 사용하게 되면 병목현상도 발생하게 된다. 하지만 Container는 이러한 커널들은 호스트의 것을 공유해서 사용하기 때문에 이 문제가 발생하지 않습니다. Container는 완벽히 독립된 공간을 만들지 않기 때문에 얻는 성능적인 부분들이 있지만. 반대로 말 그대로 완전히 독립적이지 않기 때문에 보안적으로는 VM보다 더 취약하다. 도커의 장점 호스트의 환경에 의존되지 않은 서비스 제공이 가능하다. 서비스의 실행 환경이 모두 다르다면 이는 개발환경에서는 정상적으로 동작하던 코드가 실제 운영환경에서도 정상적으로 동작한다라고 보장하기 어려워진다. 도커를 활용하면 하나의 가상화된 공간에서 어플리케이션을 띄울 수 있기 때문에 호스트의 환경에 구애받지 않는다. 예를 들어서 깃랩 서비스를 우분투 서버에 올릴 때와 CentOS에 올릴 때 사용되는 명령어가 다르다. 즉 환경에 어플리케이션이 영향을 받고 있다는 의미인데, 도커를 활용하면 동일한 도커 명령어로 실행이 가능하다. 이미지를 활용해 CI/CD 단순화가 가능하다. 9. Docker-Compose. 쿠버네티스MSA가 유행하게되었고 그에 따라 도커와 컨테이너에 대한 기술이 주목받게되었다. 그러다 다수의 컨테이너를 관리할 필요가 생겼고 다수의 컨테이너를 관리할 수 있는 도구인 컨테이너 오케스트레이션 이 등장하게되었다. 그럼 도커 컴포즈는 무엇인가? 도커 컴포즈는 여러개의 컨테이너를 쉽게 실행할 수 있는 도구이다. 여러 개의 docker container 들을 관리하는 만들어진 도구이다. Docker Compose 는 간단하게 여러 Docker application 들을 어떻게 실행할지 정의하고 실행할 수 있는 툴입니다 이렇게 local 환경 관리에 Docker Compose 를 이용했을 때 어떤 장점들이 있을까요? 띄우고 내리는 등의 행위가 편하다Docker 환경이 파일로 관리된다협업 하는 모두가 명령어 하나로 쉽게 같은 환경을 사용할 수 있게된다 도커는 ‘이미지를 만들고 컨테이너에 띄우는 도구’이고 쿠버네티스는 ‘도커를 관리하는 툴’이다. 도커라는 것은 컨테이너 기반으로 서비스를 운영할 수 있도록 하는 것.도커의 장점? 12. SQL vs NoSQLSQL은 기본적으로 데이터의 정합성을 맞추는 것을 가장 중요하게 생각한다. 이를 위해 스키마를 엄격하게 관리하는데. 그렇기 때문에 스키마에 맞지 않는 데이터는 추가할 수 없다. 데이터의 정합성을 맞추기 위해서 가장 기본적으로 지켜야 하는 룰은 동일한 데이터가 해당 데이터베이스에 중복이 되지 않아야 한다. 이를 위해서 정규화라는 과정을 거치며 이 과정을 거치게 되면 일반적으로 테이블들이 작아지고 관계 중심적으로 데이터들을 표현해나간다. (여기서 중요한 점은 데이터 중복이 발생하지 않음을 RDB가 강제하는 것은 아니고, DB 설계를 이렇게 동작하도록 해야 한다. 만약 정규화가 제대로 이루어지지 않는다면 RDB의 목적을 제대로 달성하고 있지 않다고 할 수 있다.) NoSQL은 기본적으로 성능을 보다 중요하게 생각한다. 이를 위해 스키마를 없애고. 관계 중심적인 데이터 서술이 아니고 하나의 컬렉션에 이와 관련된 모든 데이터를 넣는다. 즉 SQL 관점에서 여러 테이블이 조인된 형태로 한 다큐먼트에 저장된다. 이렇게 되면 관계되어있는 데이터 검색시 조인을 하는 작업이 필요 없어지기 때문에 성능이 더 좋아진다. 그러나 데이터의 정합성을 보장할 수 없다. NoSQL의 용어 컬렉션 == 테이블 다큐먼트 == 로우 13. 수직적 확장 (Scale Up) &amp; 수평적 확장 (Scale Out)수직적 확장 -&gt; 단순히 데이터베이스 서버의 성능을 향상시키는 것.수평적 확장 -&gt; 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미. SQL 데이터베이스는 데이터가 저장되는 엄격한 스키마 때문에 수직적 확장만이 가능. 여러 대의 데이터베이스를 가지기가 어렵다. 그럼에도 불구하고, 이러한 방식의 커다란 장점은 복잡하고 (어떤 순간에는 느린) 조인을 사용할 필요가 없다는 것입니다. SQL의 장점명확하게 정의 된 스키마, 데이터 무결성 보장관계는 각 데이터를 중복없이 한번만 저장됩니다. NoSQL의 장점스키마가 없기때문에, 훨씬 더 유연합니다. 즉, 언제든지 저장된 데이터를 조정하고 새로운 “필드”를 추가 할 수 있습니다.데이터는 애플리케이션이 필요로 하는 형식으로 저장됩니다. 이렇게 하면 데이터를 읽어오는 속도가 빨라집니다.수직 및 수평 확장이 가능하므로 데이터베이스가 애플리케이션에서 발생시키는 모든 읽기 / 쓰기 요청을 처리 할 수 있습니다. 그리고 단점은 아래와 같습니다. SQL의 단점상대적으로 덜 유연합니다. 데이터 스키마는 사전에 계획되고 알려져야 합니다. (나중에 수정하기가 번거롭거나 불가능 할 수 도 있습니다.)관계를 맺고 있기 때문에, JOIN문이 많은 매우 복잡한 쿼리가 만들어 질 수 있습니다.수평적 확장이 어렵고, 대체로 수직적 확장만 가능합니다. 즉 어떤 시점에서 (처리 할 수 있는 처리량과 관련하여) 성장 한계에 직면하게 됩니다. NoSQL의 단점 유연성 때문에, 데이터 구조 결정을 하지 못하고 미루게 될 수 있습니다.데이터 중복은 여러 컬렉션과 문서가 (SQL 세계에서 처럼 하나의 테이블에 하나의 레코드가 아니라) 여러 개의 레코드가 변경된 경우 업데이트를 해야 합니다.데이터가 여러 컬렉션에 중복되어 있기 때문에, 수정(update)를 해야 하는 경우 모든 컬렉션에서 수행해야 함을 의미합니다. (SQL 세계에서는 중복된 데이터가 없기 때문에 한번만 수행하면 됩니다.) 14. MongoDB vs Redisredis 는 인 메모리 데이터 구조 저장소. 그러면 이건 디스크에는 저장을 못하나? Redis는 휘발성 메모리, 즉 RAM에 키-값 쌍으로 데이터를 저장하는 메모리 내 데이터 저장소이며 매우 빠릅니다.MongoDB 데이터는 디스크에 저장됩니다 Redis는 효율적인 캐시 메커니즘으로 작동하지만 데이터베이스로 redis를 선택 하려면 추가 오버 헤드가 필요합니다. -&gt; 레디스는 전체적인 저장소로 사용하기에는 무리가 있고, 캐싱의 목적으로 쓰는게 맞다고 본다메모리도 제한되고. 성능을 위해 많은 것들을 포기한 케이스. Spring의 세션 클러스터링은 기본적으로 Redis를 이용하여 진행됩니다. NoSQL은 RDBMS에 비해 속도와 확장성이 뛰어납니다. 위 문서를 통해 MySQL과 같은 RDBMS는 속도가 중요한 캐싱에는 적합하지 않다는 것을 알 수 있었습니다. 15. ELK (Elasticsearch, Logstash, Kibana)Elasticsearch 는 JSON 기반의 분산형 오픈 소스 RESTful 검색 엔진. 예전에 먼가 Redis 처럼 저장소로 생각했는데 그게 아니고 단순히 검색엔진이 아니고 저장소도 있따. 그러면 데이터는 어디에 저장이 되어 있는 거지? 내부에 자체적으로 저장소를 가지는 거 같다. ES는 JVM위에서 구동되기 때문에 JDK를 설치해야 합니다. 자바로 구현되어 있다. 1.8 이상의 버전을 활용해야 한다. Elasticsearch 용어 Database = IndexTable = TypeRow = DocumentColumn = FieldIndex = AnalyzePrimary Key = _idSchema = MappingPhysical partition = ShardLocal Partition = RouteSQL = Query DSL 클러스터 - elasticsearch 에서 가장 큰 시스템 단위를 의미. 최소 하나 이상의 노드로 이루어짐. 클러스터간 데이터 접근,교환이 불가능. 인덱스 - RDBMS에서 데이터베이스에 대응되는 개념. 샤드 - 데이터를 분산해서 저장하는 방법 (파티션 같은 느낌). 스케일 아웃을 위해서 index를 여러 shard로 쪼갠 것. elasticsearch 특징 scale out - 샤드를 통해서 규모가 수평적으로 늘어날 수 있다. schema free - json 문서를 통해 데이터 검색을 수행함으로 스키마 개념이 없다. restful - 데이터 CRUD 작업은 HTTP Method 에 맞춰서 수행된다. elasticsearch가 강점을 보이는 부분은 문장이나 여러 단어들의 조합이 저장될 때이다. 문장은 여러 단어들로 구성이 되어있고 그 중 중요한 키워도 있고 큰 의미가 없는 단어들도 있다. elasticsearch는 데이터를 저장할 때 의미있는 단어들을 추출해 해당 단어들로 inverted index를 생성한다. elasticsearch는 수많은 analyzer와 tokenizer가 존재하는데 이를 잘 활용해야 elasticsearch를 제대로 활용한다 볼 수 있다. Logstash로그 수집 파이프라인 -&gt; Logstash 16. 운영체제 - 파이프라인차를 만들떄 분업을 하는데 차체를 만들고,안에 엔진을 만들고, 도색을하고 여러 단계를 거치지. 근데 차를 만들어달라는 요구가 들어옴.5단계의 업무들이 차 한대에 대해서 집중을함. 그래서 만약에 1단계에서 업무를 하고있으면 다른 단계들이 idle 상태이다. 놀고있다는 의미. 비효율적. 파이프 라인 구조는 다른 단계가 어떤 상태인지는 고려안하고 단지 요구사항 즉 업무가 들어오면 자신의 일을 바로바로 처리하는 구조. 파이프라인 구조. 17. 파이프라인 하자드구조적 해저드. structural hazard다른 단계에 있는 명령어들이 동시에 같은 자원을 사용하려고 하는 상황 -&gt; 해당 자원을 여러개 설치하는 방법으로 해결. 데이터 해저드. data hazard앞 명령어 결과를 사용해야 하는데 앞이 아직 끝이 안나서 그 결과를 사용 못하는 상황 -&gt; 파이프라인 지연, 전발전달로 해결 시각화 도구 -&gt; Kibana 18. Java Executor태스크와 쓰레드를 생성하고 관리하는 것을 분리 태스크 큐를 이용해 태스크를 관리 shutdown()을 해줘야만 thread가 모두 중지된다. 만약 빼먹으면 leakage가 발생하는 것이니 주의하자. 12345ExecutorService execService = Executors.newFixedThreadPool(2); execService.execute(new MyThreadTask());execService.shutdown(); 16. Pub-Sub메시지를 보내고 (Publish : 발행) 받는 (Subscribe : 구독) 형태의 통신 즉 우체부라고 불리는 Publisher가 편지라고 불리는 Message를 Channel 혹은 Broker라고 불리는 우체통에 넣으면 Subscriber라고 불리는 우리가 편지를 가져갈 수 있는 것. Topic 은 501호와 같은 주소를 의미. Topic이 있는 Broker 혹은 Channel을 이용한 메시징 시스템이다. 16. Kafka17. RabbitMQ18. CDN (Content Delivery Network)원거리에 있는 서버의 컨텐츠를 매번 네트워크 상으로 데이터를 받는 것은 성능적인 문제가 있기 때문에. 보다 가깐 곳에 프록시 서버를 두고 캐싱하는 방법을 말하는 것 같음. CDN은 콘텐츠에 대한 요청이 발생하면 사용자와 가장 가까운 위치에 존재하는 서버로 매핑시켜, 요청된 파일의 캐싱된(사전 저장된) 버전으로 요청을 처리합니다 인터넷 트래픽의 절반 이상이 CDN(콘텐츠 전송 네트워크)을 통해 전송됩니다. CDN의 목표는 웹 페이지에 대한 요청이 이동해야 하는 물리적 거리를 줄여 요청 제출 시간과 장치에 완전히 로딩되는 웹 페이지 간의 지연 시간을 줄이는 것입니다. 기본적으로 전세계적으로 인터넷을 연결시켜주는 가장 큰 매체는 해저케이블. 19. CORS20. RESTful APIResource State Transfer API Resource 중심으로 API를 설계한다. 서버에게 Resource 들은 다양하게 있지만 여기서는 주로 모델, 도메인을 의미. API를 설계할때 도메인을 중심으로 설계한다는 것. 도메인을 조작할 수 있는 CRUD API 를 Http Method에 따라 제공 URI를 활용하여 Resource를 표현. Open API 가 주로 RESTful API 를 사용. RESTful API 의 장점 : 클라이언트가 없어도 API를 설계할 수 있따. - 즉 범용적으로 모든 클라이언트들에게 제공 가능한 API를 만듬.특정 클라이언트를 위한 API 가 아니기 때문에 한 클라이언트에게 맞춰진 API를 만들 수는 없지만 매번 API 개발 요청이 들어왔을 때새롭게 만들지 않아도 됨. A B C 도메인이 있을 때 RESTful API는 A 를 조작하기 위한 CRUD API, B, c 모두 제공 21. 함수형 프로그래밍.일급 함수.변수나 데이터 구조안에 담을 수 있다.파라미터로 전달할 수 있다.반환값으로 사용할 수 있다. 전통적인 자바 언어 진영에서 함수형 프로그래밍은 사실 조금은 낯설다. 기본적으로 OOP를 위해 만들어졌기 때문.그 사유로 자바에서는 함수가 클래스 없이 만들수가 없다. java8 이후에 람다, 메소드 참조 문법이 생겨나면서 함수형 프로그래밍이 보편화되기 시작. 함수형 프로그래밍이란. 함수를 일급변수로 볼수 있다는 것.풀어서 설명하자면. 함수를 값처럼 변수에 저장하고 사용할 수 있다. 함수는 값과 다르게 데이터 그 자체가 아닌 어떠한 처리 동작, 일련의 순서를 표현하는데 이걸 변수에 저장할 수 있다는 의미.함수형 프로그래밍을 활용하면 기존에는 OOP에서 다형성을 활용해서 해결하던 문제들을 FP 방식으로 보다 심플하게 해결할 수 있음. 예를 들어 항공사 벤더가 다양하게 있고. 이 벤더들이 공통적으로 상품조회, 결제, 예약 같은 기능을 제공.개념적으로는 동일하지만 실제 구현되는 내용은 다름. 이럴때 OOP는 상품조회, 결제 등을 표준으로 정의하는 interface를 생성하고. 이를 규격으로 각 항공사 벤더들이 이거에 맞춰서 구현함. 이런 문제를 FP는 항공사마다 다른 이런 구현 방법을 파라미터로 넘겨줄 수 있음. 뭔가 개념적으로 동일하고 실제 구현방법이 다를때. OOP적 해결방법이 있고, FP적 해결 방법이있음. 이둘을 그러면 어떻게 구분해야할까. 뭔가 규모가 크다면 OOP를 활용한 방법이 더 맞다고 봄.근데 만약 심플하다면 FP로 처리. 순수 함수그리고 함수형 프로그래밍은 순수함수를 적극 활용함. 순수함수는 기본적으로 데이터의 불변성을 요구함.부수효과(Side Effect)가 없는 함수. 즉 어떤 함수에 동일한 값을 주었을 때 항상 같은 값을 반환하는 함수.입력 값에 대한 결과 값이 항상 동일해야 한다. 즉 한 함수 범위 내에서 동작되는 내용들은 파라미터로 제공된 값만을 활용해서 처리되어야 하며 외부에서 받게되는 데이터들을 최대한 자제한다. 실제로 순수함수 형태로 코드를 짜야 테스트 코드를 작성하기도 쉽다. 쓰레드에도 안전하다. 객체에 값을 넣어놓고 함수에서 이를 호출하는 구조로 만들게 되면. 이 객체들은멀티쓰레드 환경이 되었을 때 각 쓰레드에 의해서 공유되는 데이터가 된다.그래서 이 데이터가 thread-safe하도록 추가적인 작업이 필요하다. 순수함수 패러다임을 사용할 수 없는 경우는 값을 stateful 해야하는 경우다.예를 들면 빌더패턴이나 java의 stream 기능같은 것이다. 고차함수, 합성함수이 내용들은 함수를 일급 객체로써 바라볼 수 있기 때문에 나타나는 내용인데.함수 안에서 함수를 받을 수 있고 그러면서 서로 조합이 가능하다는 부분이다. 22. Call By Value Call By Reference값을 담고있는 메모리를 복사한후 그 복사한 메모리 번지를 넘겨주느냐 값을 가리키고 있는 메모리번지를 담고 있는 메모리를 복사한 후 그 번지를 넘겨주느냐. 23. Stack세로로된 바구니같은 구조. 밑에있는 데이터들은 위에있는 데이터가 빠져나가야만 빼낼 수 있다.즉 먼저 넣는 자료가 마지막으로 나오게 되는 First In Last Out (FILO), 선입선출 구조. 프로세서 사이클 (메이저 사이클)CPU가 동작하는 기본적인 원리는 메이저 사이클 혹은 프로세스 사이클 따른다. 명령어 인출 -&gt; 명령어 해독 -&gt; 오퍼랜드 인출 -&gt; 실행 -&gt; 인터럽트 조사 인터럽트가 걸리게 되면 Stack 구조로 구현된 저장소에 이전 프로세스의 메모리 번지를 저장시키고 인터럽트 걸린 프로세스를 시작한다.이게 해결이 되면 해결된 프로세스는 pop 하고 그 아래에 있는 프로세스가 다시 시작. 스택은 CPU가 명령어들을 수행할 때 가장 기본적으로 사용하는 구조. 24. 인터럽트 vs 폴링지금하고 있는 프로세스보다 더 중요한 프로세스가 등장하게 되면 더 중요한 프로세스를 처리하게 되는데.이러한 것이 새로운게 기존것을 방해한거로 생각되어 인터럽트 걸렸다라고 표현한다. 각 CPU 인터럽트의 우선순위가 정해져 있음. 인터럽트 벡터 : 인터럽트가 발생했을 때 해야할 일을 정해놓은 것으로 바로 인터럽트 서비스 루틴의 시작 주소. 메모리 번지. 폴링 방법은 계속 대기하는 방법 “폴링”은 한 프로그램이나 장치에서 다른 프로그램이나 장치들이 어떤 상태에 있는지를 지속적으로 체크하는 전송제어 방식 시스템 내에 동작 중에 폴링 방식과 이벤트 방식이 있다. 폴링 방식은 어떤 상태인지를 주기적으로 확인해보는 것이다. 폴링 방식을 예를 든다면 우편물이 왔는지를 매번 내가 가서 보는 것이다. 이렇게 매번 오가는게 폴링이다. 주기적으로 알아보는 만큼 오지 않았을 때 나가보는 동안 비효율이 발생을 한다. 이벤트 방식은 어떤 상태가 되면 알려주는 것이다. 매번 가는 것이 아니라 우편물이 도착했을 때 문자를 보내는 것이다. 훨씬 효율적일 수 있다. 이벤트 방식로 해당 사람이 오면 알려 주는 방식이다. 두 방식에는 차이가 있지만, 언듯 폴링 방식은 비효율적일 거 같다는 생각을 할 수 있다. 하지만 정기적으로 뭔가를 감시하거나 검사를 해야 한다면 폴링방식도 필요할 것이다. 하지만 이벤트 방식을 통해서 트리거를 발생 시켜서 인지를 하게 되면 그 비효율이 줄어들어서 효율적으로 처리 할 수 있다. 25. 큐가로로 된 통과 같은 구조로 먼저 넣게 되는 자료가 가장 먼저 나오는 First-In First-Out(FIFO) 구조이다. 26. 해시해시 테이블은 key, value 타입의 데이터를 저장하는 자료구조. key 값을 해시함수로 생성하는데 이 key 값이 해시테이블 크기만큼 우선 고유하게 만든다.만약 데이터가 이 해시테이블보다 많다면 이 key 값이 중복될 수도 있다. 해시값이 중복된 경우 연결리스트 구조로 데이터가 저장이 되며 그 안에서 탐색을 한다.해시테이블보다 데이터 양이 작다면 시간복잡도는 O(1) 이 되며.시간 복잡도를 공간복잡도로 바꾼 형태라고 볼 수 있다. 해시 값을 생성할때 중요한 포인트는 해시코드가 골고루 분포할 수 있도록 하는게 중요하다.해시코드가 특정 코드에 집중되있다면 해시테이블의 기능을 효과적으로 이용할 수 없다. 27. 리스트배열리스트데이터를 추가/삭제하는데에는 배열리스트가 데이터를 밀고 당기고 해야하기 떄문에 추가적인 연산작업이 있어 오래걸린다. 데이터를 검색할 때에는 단순히 해당 번지를 조회하면 되기 때문에 연결리스트 보다 빠르다. 연결리스트데이터를 추가/삭제할 때 노드가 가리키는 대상만 바꿔주면 되어 배열리스트에 비해 빠르다. 데이터를 검색할 때에는 순차접근만 가능하기 때문에 느리다. 28. 우선순위 큐기본적으로 큐는 FIFO 구조로 먼저 들어간 데이터가 먼저 나와야 한다. 우선순위 큐는 기본적으로 큐 형태지만. 우선순위를 고려하고. 우선순위가 더 높은 값이 있다면 그 데이터를 먼저 처리한다. 보통 우선순위 큐를 구현하기 위해서 힙 구조를 활용한다. 삽입: 데이터가 들어오면 각 노드별로 들어온 데이터가 크거나 작은지를 비교하고 정책에 따라서 크면 왼쪽 노드로 작으면 오른쪽 노드로 진행된다. 29. 힙최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조로, 각 노드의 값이 우선순위가 자식노드 보다 높은 구조다. 모든 노드에 저장된 값(우선순위)들은 자식 노드들의 것보다 (우선순위가) 크거나 같다. 따라서 힙은 루트 노드에 우선순위가 가장 높은 데이터를 위치시키는 구조가 됨. 삽입 : 새로들어오는 데이터를 우선순위가 가장 낮다고 가정하고 가장 단말 노드에 추가한다. 그 후에 부모노드와 값을 비교하면서우선순위가 맞게 될때까지 반복. 새로 들어온 값의 우선순위가 부모보다 낮으면 끝. 삭제 : 루트노드가 제거되고 난 후. 가장 우선순위가 낮은 데이터를 루트노드로 옮긴다. 그리고 자식노드들과 우선순위를 비교하면서 swap 31. ARP (Address Resolution Protocol)Data Link 계층에서 각 함소들끼리 데이터를 주고받고 연결하는 기준은 바로 맥어드레스.이 맥어드레스는 NIC (Network Interface Card) 가 고유하게 가지고 있따. IP로 실제로 통신하는게 아니고 맥어드레스를 기준으로 통신을 함. 그렇기 때문에IP를 맥어드레스로 바꿔주는 과정이 필요한데 이게 ARP 프로토콜. 맥주소는 기본적으로 48비트 32. 패킷데이터를 통신망을 통해 전송하기 쉽도록 자른 데이터 전송 단위. 33. 경력기간동안 진행한 업무를 어필신규 항공사 API 연동 서버 구축.OTA(Online Travel Agency) 서비스를 하는 부서에서 업무를 함 여기서 주요 상품들은 항공권인데,실시간 항공권 예매 시스템에서 가져야할 대표적인 기능들이 상품조회, 예약, 발권, 결제, 취소 정도가 있음.이거가 항공사 벤더마다 다른 형태로 구현이 되어있어서 이를 하나의 인터페이스로 추상화, 표준화를 하고 클라이언트가 항공사 벤더를 신경쓰지 않고 추상화된 규격을 기준으로 비지니스 로직을 작성할 수 있도록 하였음. 기존 API 서버는 항공사 상품조회 연동을 실시간적으로 가져오도록 구현되어 있었음. 항공사가 총 8곳, 평균적으로 항공상품을 가져오는데 3~4초 정도 소요가 되었는데. 매번 연동하는 방식보다. 레디스 캐쉬 서버를 두고. 클라이언트들은 이곳에서 스케줄 정보를 가져올 수 있도록 하고. 레디스 캐쉬 서버에서 각 항공사에 주기적으로 상품조회를 함. 34. TCP vs UDP두 프로토콜 모두 OSI 7 Layer 중 4계층에서 사용되는 프로토콜. TCP는 연결지향형 프로토콜입니다. WAN 구간에 구성되어있는 네트워크에 임시적인 가상회선을 구축하고. 이 회선을 통해서만 패킷들을 주고받습니다. 패킷들은 정해진 순서대로 주고받아지며, 패킷을 주고받으면서 오류가 발생하면 재전송을 요청합니다. UDP 프로토콜보다 상대적으로 더 오류율이 적지만 속도가 느리다. 한 비트가 깨지면 파일 전체를 사용할 수 없는 형태의 데이터는 TCP를 사용합니다. UDP는 비연결지향형 프로토콜입니다. 패킷들이 네트워크상에서 동일한 목적지를 가지고 서로 다른 루트로 달려옵니다. 도착 순서도 상관이 없으며 이 패킷들이 가지고 있는 번호로 재조합해 OSI 상위 계층으로 넘겨줍니다. 순서를 고려하지 않고, 오류 발생시 재전송을 요청하지 않기 때문에 속도가 상대적으로 높으며 오류율은 높다. 동영상처럼 한 비트가 깨져도 큰 문제가 없는 스트리밍 서비스에 주로 사용됩니다. HTTP 프로토콜은 TCP 기반으로 구현되었었지만. HTTP3 부터는 UDP 기반으로 전환되었습니다. QUIC 프로토콜 35. TCP 3, 4 way handshake.TCP 3 Way Handshake 실제 데이터를 주고받기 전에 정확한 전송을 보장하기 위해 상대방과 사전에 세션을 수립하는 과정. Client가 나 데이터 보낼거야 라고 SYN을 보낸다.Server는 이 SYN을 받고 나 받을 준비되었다는 ACK를 보낸다. 그러면 Client도 나도 받을 준비 되었어라고 ACK를 보낸다. 이렇게 되면 두 노드간에 데이터를 주고 받을 수 있는 상태가 된다. TCP 4 Way Handshake 데이터를 모두 주고 받고, 세션을 종료할 때 사용. Client가 나 다 보냈어라고 FIN을 보낸다.Server는 아 끝났구나 알겠어라고 먼저 ACK를 보내고, 세션 종료를 위한 작업을 한뒤 나 종료했어라고 FIN을 보낸다. Client는 너 종료한거 확인했어를 알리기 위해 ACK를 보낸다. 그리고 Client 세션을 종료한다. 36. HTTP vs HTTPS응용계층 HTTP 프로토콜에서 그 아래에 SSL 계층을 추가해서 보안을 강화. 37. 웹 통신클라이언트가 웹브라우저 프로그램을 킵니다. 웹브라우저 프로그램 상단에 특정 URl을 입력하고 엔터를 누릅니다. Domain에 사상된 IP 가져오기 (DNS Lookup)URL 정보 중 도메인 정보를 찾기 위해서 먼저 로컬에 있는 hosts 파일을 확인합니다. 이 곳에 해당 정보가 없다면 로컬 DNS서버의 캐시를 찾아보고 여기에도 없다면 로컬 DNS 서버가 상위 DNS 서버들을 재귀적으로 호춣하여 찾아본다. ARP 활용해서 IP -&gt; Mac 주소 변환데이터링크 계층에서 노드들끼리 데이터를 주고받을 때에는 IP 기준으로 찾는게 아니고 NIC에 기록되어 있는 맥주소를 기반으로 통신한다. Address Resolution Protocol이 IP를 맥주소로 변환해준다. Mac 주소와 포트번호를 활용하여 라우터들이 본인이 가지고 있는 라우팅 테이블과, 라우팅 정책을 기반으로 하여 웹서버의 목적지를 찾는다.라우팅 테이블은 라우터 인근에 연결되어 있는 라우터들의 맥주소를 사상하고 있는 테이블이며 RIP, OSPF 와 같은 라우팅 프로토콜들을 활용하여 목적지 까지의 길을 탐색한다. 웹 통신은 TCP 기반이기 때문에 3-way handshake 를 통해서 가상회선을 구축하고, 전송이 완료되면 4-way handshake를 한다.Client가 SYN를 보내고 Server가 받는다.Server가 Client에게 SYN, ACK를 보내고 Client가 받는다.Client가 ACK를 보낸다. 두 노드의 관점에서는 이렇고. WAN 구간의 관점에서보면. TCP는 연결지향형이기 때문에 이 3 way handshake를 통해서 가상회선을 구축을 한다. 그래서 패킷을 주고 받을 때 이 회선만을 타고 순서대로 전달. 목적지 맥 주소:포트에서 동작하고 있는 웹서버 프로그램 호출하게 되고, 요청이 정적 컨텐츠였다면 웹서버 응답을 내려주고, 동적 컨텐츠를 요구한다면 WAS 안에 있는 서블릿 컨테이너에서 서블릿을 생성하고 이 서블릿이 특정 비즈니스 로직을 수행 하고 결과를 반환합니다.38. GET/POSTGET은 서버의 리소스를 조회하기 위해 설계된 메서드. GET은 요청을 전송할 때 필요한 데이터를 Body에 담지 않고, 쿼리스트링을 통해 전송합니다 POST는 서버의 리소스를 생성/변경하기 위해 설계된 메서드. POST는 데이터가 Body로 전송되기 때문에 길이가 제한 없이 데이터를 전송할 수 있습니다. 39. HTTP 메서드GET POST PUT DELETE OPTIONS - HTTP OPTIONS method 는 목표 리소스와의 통신 옵션을 설명하기 위해 사용됩니다. 클라이언트는 OPTIONS 메소드의 URL을 특정지을 수 있으며, aterisk(*) 를 통해 서버 전체를 선택할 수 있습니다. HEAD - BODY 없이 HEAD 정보만 응답 받을 때 사용. PATCH - 자원의 전체를 수정할 때는 PUT, 자원의 일부를 수정할 때는 PATCH 40. RestfulGCStop-The-WorldGC를 실행하기 위해서 JVM이 그 위에서 동작하는 어플리케이션의 실행을 멈추는 것. top-the-world가 발생하면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 작업을 멈춘다 대개의 경우 GC 튜닝이란 이 stop-the-world 시간을 줄이는 것이다. gc는 말그대로 Garbage Collection을 수행하여 불필요한 Obejct를 Memory 상에서 제거하는 것을 의미합니다. System.gc() 가 안좋은 이유. -&gt; 이건 내 판단이데. System.GC() 함수는 FullGC 를 호출하는데. 보통 GC가 처리하는 쓰레기들은young 영역에서 끝이난다. 하지만 이함수는 fullGc 까지 호출하고 그러면 stop the world 를 하기때문에 성능에 무리가 간다. JVM의 구성인 Young 영역, Old 영역 모든 객체가 쓰레기인지 검사하는 무식한 방식의 가비지 컬렉션은 규모가 큰 프로그램에서 심각한 문제가 생길 수 있다. JVM GC 설계자들은 경험적으로 대부분의 객체가 생겨나자마자 쓰레기가 된다는 것을 알고 있었다. 이것을 ‘약한 세대 가설(weak generational hypothesis)’이라 부른다.따라서 매번 전체를 검사하지 않고 일부만 검사할 수 있도록 generational한 구조를 고안해 내었다. young generation객체 대부분이 생성될 때 이곳으로 들어간다.이곳이 가득차면 minor gc가 발생한다. minor gc가 발생하면 살아있는 객체들만 체크하고 나머지는 다 없애버린다.살아남은 객체들 중 더 오래 쓸 것 같은 것들은 tenured generation으로 옮긴다. tenured generation이곳이 가득 차면 major gc가 발생한다.major gc는 minor gc보다 더 오래 걸린다. Young 영역(Yong Generation 영역): 새롭게 생성한 객체의 대부분이 여기에 위치한다. 대부분의 객체가 금방 접근 불가능 상태가 되기 때문에 매우 많은 객체가 Young 영역에 생성되었다가 사라진다. 이 영역에서 객체가 사라질때 Minor GC가 발생한다고 말한다. Young 영역은 다시 3가지로 나뉨.Eden 영역Survivor 영역 2개 - 서로 계속 스왑함.Eden -&gt; Survivor로 가며, Survivor에서도 계속 살아나면 old 영역으로 간다. Old 영역(Old Generation 영역): 접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다. 대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC는 적게 발생한다. 이 영역에서 객체가 사라질 때 Major GC(혹은 Full GC)가 발생한다고 말한다. Old 영역은 기본적으로 데이터가 가득 차면 GC를 실행한다. Serial GC - Serial GC는 데스크톱의 CPU 코어가 하나만 있을 때 사용하기 위해서 만든 방식이다. Serial GC를 사용하면 애플리케이션의 성능이 많이 떨어진다. Parallel GC - Parallel GC는 Serial GC와 기본적인 알고리즘은 같지다. 그러나 Serial GC는 GC를 처리하는 스레드가 하나인 것에 비해, Parallel GC는 GC를 처리하는 쓰레드가 여러 개이다. 그렇기 때문에 Serial GC보다 빠른게 객체를 처리할 수 있다. Parallel GC는 메모리가 충분하고 코어의 개수가 많을 때 유리하다. Parallel GC는 Throughput GC라고도 부른다. Parallel Old GC(Parallel Compacting GC)Concurrent Mark &amp; Sweep GC(이하 CMS)G1(Garbage First) GC JVMJVM의 목적자바 가상 머신으로 자바 바이트 코드를 실행할 수 있는 주체다. (Class 파일이 바이트 코드로 작성되어 있다.) CPU나 운영체제(플랫폼)의 종류와 무관하게 실행이 가능하다. 즉 운영체제 위에서 동작하는 프로세스로 자바 코드를 컴파일해서 얻은 바이트 코드를 해당 운영체제가 이해할 수 있는 기계어로 바꿔 실행시켜주는 역할. JVM의 구성Class Loader, Execution Engine, Garbage Collector, Runtime Data Area Class Loader 자바에서 소스를 작성하면 Person.java 처럼 .java파일이 생성된다. .java 소스를 자바컴파일러가 컴파일하면 Person.class 같은 .class파일(바이트코드)이 생성된다. 이렇게 생성된 클래스파일들을 엮어서 JVM이 운영체제로부터 할당받은 메모리영역인 Runtime Data Area로 적재하는 역할을 Class Loader가 한다. (자바 애플리케이션이 실행중일 때 이런 작업이 수행된다.) Execution Engine Class Loader에 의해 메모리에 적재된 클래스(바이트 코드)들을 기계어로 변경해 명령어 단위로 실행하는 역할을 한다. 명령어를 하나 하나 실행하는 인터프리터(Interpreter)방식이 있고 JIT(Just-In-Time) 컴파일러를 이용하는 방식이 있다. JIT 컴파일러는 적절한 시간에 전체 바이트 코드를 네이티브 코드로 변경해서 Execution Engine이 네이티브로 컴파일된 코드를 실행하는 것으로 성능을 높이는 방식이다. 자바는 왜 자바 컴파일러로 바이트 코드를 생성하고 또 그 이후해 자바 인터프리터를 활용해서 기계어로 번역하는가. 자바를 활용하면 C 언어와 같이 완벽하게 기계어로 매핑된 컴파일이 불가능하다.왜냐하면 플랫폼에 종속적이지 않기 떄문이다. 왜 자바는 기본적으로 컴파일과 인터프리트를 병행 하는 것 일까? 바로 기계어로 변환하는 컴파일러의 경우는 프로그램이 작성된 기계상에서실행할 때 매우 효율적으로 실행된다. 이는 대부분의 하드웨어 제어 시스템의 프로그래밍언어가 C인 이유이다. 그러나 이와 동시에 기계 종류에 종속된다는 말이기도 하다. 자바 인터프리팅은 자바 컴파일러를 통해 생성된 클래스파일을 기계어로 변환한다. JIT 컴파일(just-in-time compilation) 또는 동적 번역(dynamic translation)은 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법이다. 전통적인 입장에서 컴퓨터 프로그램을 만드는 방법은 두 가지가 있는데, 인터프리트 방식과 정적 컴파일 방식으로 나눌 수 있다. 이 중 인터프리트 방식은 실행 중 프로그래밍 언어를 읽어가면서 해당 기능에 대응하는 기계어 코드를 실행하며, 반면 정적 컴파일은 실행하기 전에 프로그램 코드를 기계어로 번역한다. JIT 컴파일러는 두 가지의 방식을 혼합한 방식으로 생각할 수 있는데, 실행 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지한다. Garbage Collector Garbage Collector(GC)는 Heap 메모리 영역에 생성(적재)된 객체들 중에 참조되지 않는 객체들을 탐색 후 제거하는 역할을 한다. GC가 역할을 하는 시간은 정확히 언제인지를 알 수 없다. (참조가 없어지자마자 해제되는 것을 보장하지 않음) 또 다른 특징은 GC가 수행되는 동안 GC를 수행하는 쓰레드가 아닌 다른 모든 쓰레드가 일시정지된다. 특히 Full GC가 일어나서 수 초간 모든 쓰레드가 정지한다면 장애로 이어지는 치명적인 문제가 생길 수 있는 것이다. (GC와 관련된 내용은 아래 Heap영역 메모리를 설명할 때 더 자세히 알아본다.) Runtime Data Area JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다. 이 영역은 크게 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack로 나눌 수 있다. Method area (메소드 영역) 클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보같은 필드 정보와 메소드의 이름, 리턴 타입, 파라미터, 접근 제어자 정보같은 메소드 정보, Type정보(Interface인지 class인지), Constant Pool(상수 풀 : 문자 상수, 타입, 필드, 객체 참조가 저장됨), static 변수, final class 변수등이 생성되는 영역이다. Heap area (힙 영역) new 키워드로 생성된 객체와 배열이 생성되는 영역이다.메소드 영역에 로드된 클래스만 생성이 가능하고 Garbage Collector가 참조되지 않는 메모리를 확인하고 제거하는 영역이다. Stack area (스택 영역) 지역 변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값등이 생성되는 영역이다. int a = 10; 이라는 소스를 작성했다면 정수값이 할당될 수 있는 메모리공간을 a라고 잡아두고 그 메모리 영역에 값이 10이 들어간다. 즉, 스택에 메모리에 이름이 a라고 붙여주고 값이 10인 메모리 공간을 만든다. 클래스 Person p = new Person(); 이라는 소스를 작성했다면 Person p는 스택 영역에 생성되고 new로 생성된 Person 클래스의 인스턴스는 힙 영역에 생성된다. PC Register (PC 레지스터) Thread(쓰레드)가 생성될 때마다 생성되는 영역으로 Program Counter 즉, 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역이다. (*CPU의 레지스터와 다름) 이것을 이용해서 쓰레드를 돌아가면서 수행할 수 있게 한다. Native method stack 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역이다. 보통 C/C++등의 코드를 수행하기 위한 스택이다. (JNI) 1,2번인 메소드 영역과 힙 영역을 모든 쓰레드가 공유하고, 3,4,5번인 스택 영역과 PC 레지스터, Native method stack은 각각의 쓰레드마다 생성되고 공유되지 않는다. default 메소드Spring AOPAOP 는 OOP 설계론이 가지는 단점을 커버하기 위해 생겨난 방법. 객체 중심으로 디자인하기 때문에. 모든 객체들이 가지는 공통 속성에 대해서 중복이 일어난다. Spring IOCIoC란 말 그대로 제어의 역전. 즉 제어권이 바뀌었다는 것.개발자가 객체의 생성, 의존성 관리를 직접하는게 아니고 프레임워크, 컨테이너에서 대신 해준다는 의미. 이로 인해 개발자가 직접 객체를 관리해야하는 코드들을 줄일 수 있다 Spring DL (Dependency Lookup)Dependency Lookup - 의존대서을 검색을 통해 반환받는 방식ex) factory.getBean(id); DL은 의존성 검색이다. 이는 빈에 접근하기 위해 컨테이너가 제공하는 API를 이용하여 Bean을 Lookup하는 것이다. Spring DI (Dependency Injection)DI는 의존성 주입. 이는 각 클래스 간에 의존성을 자신이 아닌 외부에서 주입하는 개념. 의존성 주입을 사용하게 되면 객체 주입을 외부에서 하기 때문에 보다 유연한 코드를 작성할 수 있다. TDD (Test Driven Development)테스트 주도 개발은 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스 중 하나이다. 개발자는 먼저 요구사항을 검증하는 자동화된 테스트 케이스를 작성한다. 그런 후에, 그 테스트 케이스를 통과하기 위한 최소한의 코드를 생성한다. 마지막으로 작성한 코드를 표준에 맞도록 리팩토링한다. 이 기법을 개발했더나 ‘재발견’ 한 것으로 인정되는 켄트 백은 2003년에 TDD가 단순한 설계를 장려하고 자신감을 불어넣어준다고 말한다. 테스트유닛테스트 : 함수 하나하나와 같이 코드의 작은 부분을 테스트 하는 것. 또한, 유닛 테스트는 매우 간단하고 명확하여야 한다. 기본적으로 테스트를 위한 입력 값을 주어서 그에 대한 함수의 출력 값이 정확 한지 아닌지를 판단하는 것이 유닛 테스트라 할 수 있다. 코드의 설계가 별로 좋지 못하다면 유닛 테스트를 작성하기도 어려워진다. 비유하자면, 유닛 테스트는 척추에 비유할 수 있다. 유닛 테스트를 사용한다면 좋은 코드를 디자인할 수 있을 뿐만 아니라 어떤 함수(메소드)에 변화가 생겼을 때 그 함수가 안전하게 수행되는지를 보장해주고 같은 함수(메소드)를 다른 종류의 테스트에서도 적용하기 쉽게 만들어 준다. 따라서 함수(메소드) 하나하나 테스트 코드를 작성하는 유닛 테스트는 좀 더 나은 코드를 만들 수 있도록 도와준다. 통합 테스트 : 서로 다른 시스템들의 상호작용이 잘 이루어 지는지 테스트하는 것. 기능 테스트 : 사용자와 어플리케이션의 상호작용이 원활하게 이루어지는지 테스트하는 것. mod_jk캐시시간적 지역성한번 액세스한 메모리는 가까운 미래에 다시 액세스할 가능성이 높다. 공간적 지역성한번 액세스한 메모리 주변은 가까운 미래에 액세스할 가능성이 높다. 데이터베이스 인덱스B+ Tree 구조로 별도의 인덱스 테이블을 만듬. shell script스크립트는 일반적으로 인터럽트 방식으로 동작하는 프로그램. 즉 프로그램의 한 라인씩 읽어 해석하고 실행하는 과정을 반복하도록 만들어진 프로그램. 쉘이라는 것은 운영체제에서 제공하는 커널 들에 접근할 수 있는 방법. 대화형 형태로 운영체제에서 제공하는 시스템 명령어들을 사용자가 사용할 수 있도록 한다. 쉘 명령어들을 일련의 순서대로 작성하면 쉘 스크립트가 되며. 인터프리터가 순서대로 해석하고 실행한다. 쉘 프로그램도 여러 종류가 있는데 /bin/sh/bin/bash (bourne-again shell)/bin/csh/bin/ksh/bin/tcsh 여기서 bash 가 현재 리눅스의 표준 쉘이다. 윈도우에서 사용하는 cmd의 명령어와 리눅스에서의 명령어가 다른 것은 알고 있을 텐데 각 운영체제에 구현된 커널이 다른 것이 영향이 있겠지만 쉘(명령어 해석기, 대화형 프로그램)이 다르기 때문이다. 컴파일러와 인터프리터bash프로그램 카운터 (PC)마이크로프로세서 내부에 있는 레지스터 중 하나로서, 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정한다. 프로그램 카운터는 각 명령 주기에 따라서 자동으로 증가되며, 메모리에 있는 명령어들이 순차적으로 실행될 수 있도록 한다. 단 분기 또는 서브루틴 호출/복귀 등의 명령어는 프로그램 카운터에 실행해야할 위치가 바로 다음 코드가 아니라 새로운 기계어 코드의 위치 값이 들어간다. 배치 프로그램일괄처리(batch processing)란 컴퓨터 프로그램 흐름에 따라 순차적으로 자료를 처리하는 방식. 개별적으로 어떤 요청이 있을 때마다 실시간으로 통신하는 것이 아니고. 한꺼번에 일괄적으로 대량 건을 처리하는 방법. 특히 배치는 보통 정해진 특정한 시간에 실행된다. 대량 건의 데이터를 처리. 틀정 시간에 실행. 일괄적으로 처리. OSI 7 계층TCP handshake 시 SYN, ACK 여기의 숫자들의 의미.TLSSSL HandshakeCORS프로세스와 스레드의 차이블로킹 논블로킹프로세스의 메모리 영역프로세스 동기화세마포어 뮤텍스데이터베이스 인덱스ACID정규화List vs Set정렬 vs 탐색단방향 암호화JWT vs OAuth인터페이스와 추상클래스 차이SOLID 원칙POJO DTO VO DAO Entity DomainJPA 장점 (1) 보다 객체중심적인 코딩이 가능 (1) 생산성 : CRUD용 SQL을 개발자가 직접 작성하지 않아도 추상화된 메소드를 통해 확인 가능 (2) 패러다임 불일치 해결 : 객체가 가지고 있는 특성을 엔티티와 호환을 맞추는 것에서 미묘한 차이가 발생했었는데 이를 해결 가능 (3) 성능 : 1차 캐시를 이용해서 한번 접근했던 데이터에 대해 데이터베이스에 추가적으로 접근하는 것이 아닌, 1차 캐시에서 데이터 확인 가능 데이터베이스 벤더를 고려하지 않아도 됨. JPA 즉시로딩 지연로딩FetchType.EAGER FetchType.LAZY JPA N+1 문제이렇게 하위 엔티티들을 첫 쿼리 실행시 한번에 가져오지 않고, Lazy Loading으로 필요한 곳에서 사용되어 쿼리가 실행될때 발생하는 문제가 N+1 쿼리 문제입니다. @OneToMany 관계에서 Lazy Loading을 하고 Loop 참조를 하게 되면. N+1 문제 발생. 이유는 이미 호스트에 해당하는 객체 정보를 가져왔기 때문에 JOIN으로 쿼리가 생성이 안되기 때문. 해결방법 1. fetchJoin JPQL 에서 제공하는 fetchJoin을 활용. PreparedStatment와 Statement의 차이는 무엇JDBC가 쿼리를 보내는 과정은. 쿼리를 해석하고 컴파일하고 실행하는데. Statement는 매번 이 작업을 반복하지만 PreparedStatement는 이를 캐싱해서 처리한다. 무중단 배포nginx의 로드밸런싱 과정클린코드Checked Exception동등성 vs 동일성동일하다 는 두 개의 오브젝트가 완전히 같을 경우를 의미하고, 동등하다 는 두 오브젝트가 같은 정보를 같고 있을 경우를 의미합니다. 동일하다 의 경우 == 연산자로 표시되고, 동등하다 의 경우 equals 연산자로 표시됩니다. 오브젝트 간 == 연산자는 주소값의 비교, equals는 내용의 비교가 됩니다 서블릿클라이언트 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 Servlet 클래스의 구현 규칙을 지킨 자바 프로그램” (클라이언트의 HTTP 요청에 대해 특정 기능을 수행, HTML문서를 생성등의 응답을 하는 인터넷 서버 프로그램) 서블릿 생명주기 (servlet Life Cycle) 서블릿 생성 -&gt; init() -&gt; { service() -&gt; doXxx() } -&gt; destory() -&gt; 서블릿 종료 ( {} 반복 ) 서블릿 컨테이너서블릿 컨테이너는 서블릿의 생명주기를 관리하고 요청에 따른 스레드를 생성해준다. 또, 클라이언트의 Request 를 받아주고 Response 를 보낼 수 있게 웹 서버와 소켓을 만들어서 통신을 해준다 왜 전 회사 그만두고 개발하러 오셨나요?-&gt; 더 뛰어난 개발자들이 있고, 더 높은 수준의 기술을 배우기 위해서. 지원한 이유는 무엇인지?-&gt; 우선 네이버이고, 금융권이기 때문. 테크핀회사가 가지는 기술력이 높을거라고 판단했음. 개발이 왜 좋은가?-&gt; 무언가를 끊임없이 고민하게 하게 하고, 이 고민한 내용이 실제로 현실에 반영될 수 있기 때문. 개발을 왜 시작했는지.-&gt; 예전에 컴퓨터 게임을 좋아했고, NIC를 교체해서 인터넷을 고친 경험 등을 본 형이 추천을 해서 들어오게되었고 지금까지도 이 직업을 좋아함. 어떤 점에서 개발자가 되고 싶은지?-&gt; 무언가를 끊임없이 고민하게 하게 하고, 이 고민한 내용이 실제로 현실에 반영될 수 있기 때문. 미래에 어떤 개발자가 되고 싶은지?-&gt; 계속 끊임없이 공부하고 고민하는 개발자. 전공 과목중에 좋아하는 과목이랑 싫어하는 과목 각각-&gt; 좋아하는 과목 : 네트워크-&gt; 싫어하는 과목 : 소프트웨어 공학. (그 당시에 어떤 서비스를 하고 싶은지?-&gt; 기술을 목적으로 생각하는 서비스보다는 하나의 도구로 생각하는게 맞다고 생각함. REST서버의 리소스 도메인을 중심적으로 개발을 한다. RESTful API라면 API 설계시 리소스 중심적으로 API를 구현한다. HTTP URI 로 자원을 표현하고 HTTP Method로 자원을 처리한다. Open API 가 Restful API 대표적 예시 장/단점 동등성 동일성동일성 완전 같은 인스턴스. 가리키는 메모리 주소가 같다. 동등성은 다른 인스턴스이나 완전히 똑같은 경우. 세션HTTP가 stateless 하기 때문에 이전 연결에 대한 정보를 서버쪽에 남기기 위한 기술. 서버가 여러 대라면 이런 세션 정보를 세션 저장소를 만들어서 관리. 서블릿클라이언트 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 Servlet 클래스의 구현 규칙을 지킨 자바 프로그램” (클라이언트의 HTTP 요청에 대해 특정 기능을 수행, HTML문서를 생성등의 응답을 하는 인터넷 서버 프로그램) 데이터베이스 인덱스 동작 과정 *자주사용되는 칼럼들의 값을 해당 주소값과 같이 보관하는것을 인덱스라 합니다. 인덱스는 값을 정렬하여 저장하기 떄문에 새로운 데이터를 삽입, 삭제 하는것은 오래걸리나 검색은 빠르다. 인덱스 저장 구조 : B-TREE 연결리스트 : O(n) Binary Search Tree : O(logn) -&gt; 한쪽으로 쏠릴 수 있음. B-Tree : 단말노드에 데이터들이 들어가 있음. 캐시가 무엇인가요? redis 같은 걸 캐싱 서버로 사용해보신적 있으신가요?항공사에서 상품정보를 가져오는 것을 레디스에 넣어두고 캐싱한 적이 있다. Call by value와 Call by reference 차이값을 복사해서 전달. 원래 값이 보존이 된다. 값을 가리킬는 주소를 복사해서 전달. 원래 값도 수정된다. TDD가 무엇인가요?테스트를 먼저 만들고 테스트를 통과하기 위한 소스 코드를 작성하는 방법. TDD의 장, 단점?단점 : TDD를 하면 개발 시간이 늘어난다. 장점 : TDD를 하면 결함이 줄어든다. 지속적으로 테스트를 하면서 코드를 작성하기 때문. TDD를 하면 소스코드의 의존성을 감소시킬 수 있다. PreparedStatment와 Statement의 차이는 무엇인가요?PreparedStatement 와 Statement의 가장 큰 차이점은 캐시(cache) 사용여부이다. Statement 단일로 사용될 때 빠른 속도를 지닙니다. 쿼리에 인자를 부여할 수 없습니다. 매번 컴파일을 수행해야 합니다. PreparedStatement 쿼리에 인자를 부여할 수 있습니다. 처음 프리컴파일 된 후, 이후에는 컴파일을 수행하지 않습니다. 여러번 수행될 때 빠른 속도를 지닙니다. 전 프로젝트에서 배포 구조 설명해주세요gitlab에서 머지를 함 -&gt; jenkins 로 빌드를 함. -&gt; 이미지가 빌드됨 -&gt; 서버에 작성된 쉘스크립트 실행 -&gt; 이미지 다운받고 해당 이미지 실행 nginx가 어떤 방식으로 로드밸런싱을 할 지 설명해주세요 *클린코드클린코드의 가장 중요한 요소 중 하나는 가독성이라고 볼 수 있습니다. 즉, 모든 팀원이 이해(understandability)하기 쉽도록 작성된 코드 Deep Copy와 Shallow Copy에 대해 설명해주세요.OAuth 의 흐름에 대해 설명해주세요.특정 서비스에서 네이버 로그인 / 카카오 로그인을 클릭 -&gt; 해당 사이트의 로그인 페이지로 넘어감 -&gt; 여기서 인증이 되면 Access Token을 발급해줌 -&gt; redirect_uri 페이지로 리다이렉트 객체를 나누는 기준이 무엇인가? *커밋 컨벤션에서 feat, chore, refactor 등. 각각 어떤 기준으로 나누어 사용했는지? *OOP가 무엇인가요?객체지향 프로그래밍. 객체들을 설계하고 이를 기준으로 프로그램을 작성 즉 어떤 개념에 대해서 추상화한 (속성과 행위를 가진) 객체로 만들어, 그들 사이에서 상호작용을 하며 프로그래밍하는 것을 말한다. OOP를 썼을 때 어떤 점이 좋았고 안좋았는지? *FP에 비해서 상대적으로 처리가 무겁다.?? OOP를 잘하기 위해 어떤 노력을 했는지?SOLID - Single Responsibility Principle 하나의 객체는 하나의 기능, 책임을 가지며 집중되어야 한다는 원칙. - Open Close Principle 확장의 방법에 대해서는 열려있고 변경에 대해서는 닫혀있어야 한다는 원칙 (코드를 수정하는 것에는 닫혀있고 이를 확장하여 재사용할 수 있어야 한다는 의미) 추상화와 다형성을 활용하여 적용 가능. - Liskov Substitution Principle 서브 클래스가 상위 클래스, 인터페이스의 표준 규격을 준수해야한다는 의미. - Interface Segregation Principle AOP 적용 클린 코드는 무엇인가요?가독성이 좋은 코드 왜 코드는 클린해야 하죠?가독성이 좋아야 나중에 코드의 수정이 필요할 때 코드를 분석하는 시간이 감소된다. Test코드는 왜 짜야 합니까?모든 비즈니스는 예외 케이스들을 가지고 있고. 이런 것들에 대해서 많이 알고 있는 사람들을 사실 상 베테랑이라고 한다. 근데 이 베테랑들은 이런 지식을 시스템에 녹이는게 아니고 사람이 가지고 있는것.이런 노하우들을 테스트코드, 테스트케이스로 만들어서 남겨두면 시스템 자체가 노하우를 많이 가진 시스템이 된다. 훨씬 튼튼해진다.이것들이 누적되면 많은 예외케이스들에 대해서 미리미리 확인이 가능하다. Mock을 사용한 이유는?테스트를 하려고하는 것에 집중을 하려고 하다 보면 어떤 대상의 코드가 의존성을 가지고 있는 경우가 있따. 그 영역은 우리 테스트 커버리지가 아니기 떄문에 가짜 객체 목 객체를 심어준다.또 다른 관점에서 데이터베이스에서 값ㅇ르 가져온느 경우 해당 값은 항상 동일하다고 할 수 없기 때문에 테스트코드가 100% 성공한다고 보기 어렵다.이런 외부에 의존된 코드들은 모킹해야한다. 트리 구조에 대해 설명 해주세요.트리는 계층 모델이다. 그 자식 노드 또한 0개 이상의 자식 노드를 갖고 있고, 이는 반복적으로 정의된다. 이진 트리에 대해 설명 해주세요.기존 트리 구조에서 자식 노드의 개수를 2개로 제한한 것. Binary Search Tree에 대해 설명해주세요 *노드의 왼쪽 서브트리에는 그 노드의 값보다 작은 값들을 지닌 노드들로 이루어져 있다.노드의 오른쪽 서브트리에는 그 노드의 값보다 큰 값들을 지닌 노드들로 이루어져 있다. 힙 *모든 레벨에서 노드들이 꽉 채워진 완전이진트리(complete binary tree)를 기본으로 합니다. 브라우저에서 서버 응답까지의 흐름브라우저에서 URL 입력 -&gt; 로컬 hosts 파일과 DNS 서버를 탐색해서 IP를 얻음 -&gt; ARP 프로토콜로 IP -&gt; 맥주소 변경 -&gt; TCP 3 ways handshake로 가상회선 구축 -&gt; HTTP 요청 정보 전달 -&gt; 웹서버에서 수신 후 정적 컨텐츠이면 바로 반환 -&gt; 동적 컨텐츠이면 서블릿 컨테이너에서 서블릿 구현체를 생성 -&gt; 서블릿이 서버의 비즈니스 로직 수행 후 응답 결과 반환 -&gt; 클라이언트에게 응답 정보 전달 -&gt; TCP 4 ways handshake로 가상회선 해제 CI/CD 에 대해 각각 설명해주세요.CI/CD는 약어로, 몇 가지의 다른 의미를 가지고 있습니다. CI/CD의 “CI”는 개발자를 위한 자동화 프로세스인 지속적인 통합(Continuous Integration)을 의미합니다. CI를 성공적으로 구현할 경우 애플리케이션에 대한 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트되어 공유 리포지토리에 통합되므로 여러 명의 개발자가 동시에 애플리케이션 개발과 관련된 코드 작업을 할 경우 서로 충돌할 수 있는 문제를 해결할 수 있습니다. CI/CD의 “CD”는 지속적인 서비스 제공(Continuous Delivery) 및/또는 지속적인 배포(Continuous Deployment)를 의미하며 이 두 용어는 상호 교환적으로 사용됩니다. 두 가지 의미 모두 파이프라인의 추가 단계에 대한 자동화를 뜻하지만 때로는 얼마나 많은 자동화가 이루어지고 있는지를 설명하기 위해 별도로 사용되기도 합니다. DTO가 무엇이죠?계층 간에 데이터를 전달해주기 위해 만들어지는 객체. ManyToOne 쓴 이유는? 반대쪽에서 OneToMany 쓸수도 있지 않나요?relation에서는 참조 관계가 외래키를 한곳에 두고 동일하지만. 객체의 관점에서는 A, B가 있을 때 A가 B를 참조할 수도 있고 반대로 B가 A를 참조할 수도 있습니다.ManyToOne 사용한 이유는 분명하게 OneToMany 사용처가 다르기때문이죠. JPA를 왜 쓰나요?(ORM이 나오게 된 이유) 어떤 장점이 있죠?벤더사 독립적이다. persistent context 라는 캐싱 영역이 존재한다. 트랜잭션 관리가 용이하다. CRUD 쿼리를 직접 짜지않기 때문에 생산성이 좋아진다. Hibernate는 뭘까요?JPA는 인터페이스로써 ORM를 사용하기 위해서 규격화해둔 추상체입니다. 이를 실제로 구현한 것중 하나가 Hibernate입니다. OpneJPA도 있는데. 사용해본 경험은 없습니다. @transactional 동작 과정 *Spring Configuration에 @EnableTransactionManagement 애노테이션을 붙입니다. (스프링 부트에서는 자동으로 해줍니다.)Spring Configuration에 트랜잭션 매니저를 지정합니다.그러면 스프링은 @Transactional 애노테이션이 달린 public 메서드에 대해서 내부적으로 데이터베이스 트랜잭션 코드를 실행해줍니다. JPA FetchTypeN+1 문제엔티티 매핑을 할 때 ManyToOne을 lazy로 설정해주지 않았던 이유JPA FetchTypeTransient, Persistent, Removed, DetachedController, RestController는 뭐가 다른가요? 응답이 어떻게 다른가요?@Controller의 주용도는 view를 리턴하는 것이고, @RestController는 데이터를 리턴하는 것이 주용도라고 할 수 있다.물론 @Controller의 경우 메서드에 @ResponseBody를 사용하여 객체를 리턴할 수 있다. Spring에서 Service, Controller, Repository annotation의 차이점@ComponentSpring에서 관리되는 객체임을 표시하기 위해 사용하는 가장 기본적인 annotation이다. 즉, scan-auto-detection과 dependency injection을 사용하기 위해서 사용되는 가장 기본 어노테이션이다. @ControllerWeb MVC 코드에 사용되는 어노테이션이다. @RequestMapping 어노테이션을 해당 어노테이션 밑에서만 사용할 수 있다. @Repository다 알고 있듯이 data repository를 나타내는 어노테이션이다. @Repository는 플랫폼 특정 exception을 잡아 Spring의 unchecked exception으로 뱉어내준다. ( PersistenceExceptionTranslationPostProcessor ) @Service비즈니스 로직이나 respository layer 호출하는 함수에 사용된다. 다른 어노테이션과 다르게 @Component에 추가된 기능은 없다. 하지만 나중에 Spring 측에서 추가적인 exception handling을 해줄 수도 있으니 비즈니스 로직에는 해당 어노테이션을 사용하자. Spring MVC 설명웹 요청이 들어옴 -&gt; Servlet 컨테이너에서 Dispatcher Servlet을 실행 -&gt; 이 서블릿이 HandlerMapping 에서 사상되는 컨트롤러를 찾음 -&gt; 비지니스 로직 수행 -&gt; 뷰 리졸버를 확인 -&gt; 뷰 반환 ControllerAdvice가 무엇인가요?컨트롤러에 공통적으로 적용할 수있는 코드 AOP의 일종으로 보임. AOP에 대해 설명해주세요Aspect : 위에서 설명한 흩어진 관심사를 모듈화 한 것. 주로 부가기능을 모듈화함. Target : Aspect를 적용하는 곳 (클래스, 메서드 .. ) Unchecked, Checked Exception 차이가 뭔가요?RuntimeException을 상속하지 않는 클래스는 Checked Exception, 반대로 상속한 클래스는 Unchecked Exception으로 분류할 수 있다. Checked Exception : 컴파일 시점에 확인되는 Exception Unchecked Exception : 실행 중 확인이 되는 Exception 그렇기 때문에 RuntimeException 이라고 부름 프로세스와 쓰레드의 차이점프로세스는 커널에 의해 직접 관리되는데 커널 메모리 안에는 각 프로세스마다 관리하고 있는 프로세스에 대한 데이터들이 있다. 이 정보는 Process Control Block(이하 “PCB”)이라고 하는 자료구조 안에 있는데 커널 스케쥴러가 프로세스를 제어하는 데 필요한 정보들이 담겨 있다 프로세스에는 코드, 데이터, 힙, 스택 메모리 영역 존재. 먼저 프로세스는 보다 독립적이다. 서로 구분되는 자원을 할당 받아 정말 필요한 경우가 아니면 다른 프로세스에 영향을 미치지 않고 실행된다. 반면 스레드는 프로세스의 하위 집합으로 여러 스레드가 같은 프로세스 자원을 공유하기 때문에 독립적이지 않다. 같은 의미로 프로세스는 보유한 자원에 대한 별개의 주소 공간을 갖지만 스레드는 이 주소 공간을 공유한다. PCB에 들어가는 정보PID : 프로세스의 고유 번호상태 : 준비, 대기, 실행포인터 : 다음에 실행될 프로세스의 포인터메모리 : 코드, 데이터, 힙, 스택 IO/NIO 개념","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"interview","slug":"interview","permalink":"http://kidongyun.github.io/tags/interview/"}]},{"title":"Computer Science Basic","slug":"2021-02-27-computer-science-basic","date":"2021-02-26T15:54:00.000Z","updated":"2022-05-31T07:34:23.000Z","comments":true,"path":"2021/02/27/","link":"","permalink":"http://kidongyun.github.io/2021/02/27/","excerpt":"","text":"1. 전기 신호를 기억하자.플립플롭플립플로은 순서 논리 회로를 구성하는 기본 기억 소자로 1비트를 기억할 수 있다. JK 플립플롭J K 상태 0 0 상태 변화 없음 0 1 무조건 0인 상태로 변화 1 0 무조건 1인 상태로 변화 1 1 내부 상태의 반전 D 플립플롭JK플립플롭에서 아래 두가지 속성만 구현한 플립플롭 J K 설명 0 1 무조건 0인 상태로 변화 1 0 무조건 1인 상태로 변화 레지스터플립플롭은 1비트만 표현하는 기억소자인데 이들을 병합시켜서 여러비트를 저장할 수 있는 레지스터를 만든다.여기서 D플립플롭을 주로 사용 2. 전기 신호가 문자가 되다.위 플립플롭, 레지스터를 활용해서 저장되어진 전기적 신호들을 문자로 표현하기 위해 테이블을 구성. BCD 코드EBCDIC 코드ASCII 코드유니코드패리티 코드7비트를 실제 데이터로 사용하고 1비트를 에러검출용 데이터로 사용. 짝수 패리티 코드라면 8비트 내부에 1의 개수가 짝수개가 되도록 에러검출 비트의 데이터를 넣는다. 만약 실제 사용시 이 8비트의 1의 개수가 홀수개가 들어왔다면 오류가 생겼다는 의미. 오류가 2개나는 케이스는 실제 드물기 때문에 활용도가 높다. 3. 전기 신호 전문가 등장 배경.명령어operand 개수에 따라서 명령어 구조의 형태를 분류할 수 있다. 세부적으로 CPU 마다 이 명령어의 매핑 테이블은 다르기 때문에 개념적으로만 언급. 0-주소 명령어, 1-주소 명령어, 2-주소 명령어 주소 지정간접주소, 직접주소 4. 전문가 프로세서의 등장.프로세서CISC (Complex Instruction Set Computer) 명령어의 개수가 120 ~ 350개로 많다. 명령어의 길이가 16 ~ 64 비트로 가변적. 메모리 참조 연산을 주로 사용 마이크로프로그램 제어방식을 주로 사용 RISC (Reduced Instruction Set Computer) 명령어의 길이가 32비트로 고정 명령어의 개수도 100개 미만으로 적다. 레지스터 참조 연산을 많이 한다. 레지스터PC : Program Counter다음 명령어의 주소 값을 기억하고 있는 레지스터이다. MAR : Memory Address Register메모리에 접근하려고 할 때 접근하고자 하는 곳의 주고 값을 기억하고 있는 레지스터이다. MBR : Memory Buffer Register주기억 장치에서 정보를 읽을 때 읽은 정보를 기억시키거나 주기억 장치에 정보를 기억시키는 레지스터. IR : Instruction Register현재 수행하고 있는 명령어를 기억하는 레지스터. ACC : Accumulator연산기능 수행 시 중심이 되는 데이터 레지스터로서 연산 장치에 연결되어 있다. PSWR : Program Status Word Register = Flag Register 프로그램의 수행이 진행되고 있을 때 매 순간마다 프로그램으 ㅣ수행 상태를 포함하는 중앙 처리 장치으 ㅣ상태를 나타내느 레지스터 (메이저 사이클의 F,R 플래그도 여기에 소속될 듯) …. 프로세서 사이클 (메이저 사이클)명령어 인출 -&gt; 명령어 해독 -&gt; 오퍼랜드 인출 -&gt; 실행 -&gt; 인터럽트 조사 5. 폰노이만 구조의 등장 (메모리의 필요성)현대의 CPU는 데이터를 처리하는 동작으로 모듈화되어있다. 데이터를 저장하는 것은 필수적인 레지스터만 가지고 있다. 데이터들은 시대가 흘러가면서 점점 커지고 많아지는데 이런 것들을 저장해야하는 필요성이 있음메모리와 프로세서의 구조가 구분됨 폰노이만 구조 실제는 앨런튜링이 이 구조를 고안함. 메모리 계층위로갈수록 빠르고, 비쌈, 용량이 작음 아래로 갈수록 느리고 쌈, 용량이 큼 레지스터 캐시 주 기억 장치 보조 기억 장치 캐시 기억장치CPU와 메인 메모리 사이에 사용되며 가격이 비싼편메인 메모리와 CPU 속도 차이를 개선하기 위해 사용두 객체 사이의 일종의 버퍼 기능을 수행기억잧치의 접근 시간을 줄여 컴퓨터 처리 속도 향상CPU에서 실행 중인 프로그램과 데이터를 기억 가상 메모리소프트웨어 적으로 구현됨주소 공간의 확대가 목적가상 주소를 실제 주소로 매핑하는 과정이 필요. 사상 : 가상 기억 장치에 있는 내용을 어떤 일정 단위로 분류하여 이 단위의 내용이 실기억 장치의 어느 위치에 있는지를 알아내는 방법.페이징 : 가상 기억 장치에 있는 내용을 어떤 일정한 단위로 분류할 때 분류 단위가 똑같은 크기일 떄를 페이징기법이라고 함페이지 폴트 : 주 기억장치에 없는 페이지가 참조될 때 생기는 인터럽트로, 페이티 폴트가 발생하면 CPU가 하던 일을 중단하고 해당 페이지를 주기억 장치로 옮겨놓는 인터럽트 작업을 먼저 수행하게 된다.스래싱 : 보조 기억 장치의 페이지 접근 횟수가 많아서 작업 수행 시간 보다 페이징 교체 시간이 많아지는 경우. 적중률이 떨어진다는 의미지 6. 입출력 (외부 장치들)CPU-메모리의 영역과 입출력 영역의 차이점동작 속도 : 가장 중요한 차이점으로 입출력 장치는 기계적인 동작이 필요하기 때문에 전자적으로 동작하는 CPU-메인 메모리 영역에 비해서 속도가 상당히 느리다. -&gt; 이를 개선하기 위해서 여러 입출력 인터페이스를 사용. 그 중 하나가 DMA정보 단위, 에러 발생률 DMA (Direct Memory Access)기본적인 컴퓨터 구조는 메모리에서 데이터를 CPU로 Fetching 하고 처리한 다음 결과를 외부 장치에 출력하거나 입력시키는 구조로 중앙처리장치가 항상 끼어있는데CPU의 작업량을 줄이기 위해서 외부 장치들이 CPU를 거치지 않고 바로 메인메모리와 통신하는 구조를 의미. CPU를 경유하지 않는다.직접 기억장치와 입출력 장치 사이에서 전송이 이루어진다. 인터럽트인터럽트의 필요성은 중앙 처리 장치와 주변 장치의 차이에 따른 효율적인 시스템 자원의 활용과 기계적 장애로 인하여 실행하던 프로그램을 완료하지 못하였을 때, 처음부터 다시 하지 않고 중단된 위치로 복귀되어 이상 없이 계속해서 프로그램이 진행되도록 하는데에 있다. 인터럽트의 원인정전, 데이터 전달 과정의 오류, 기계 장치의 장애타이머, 외부 프로세스 등의 요청컴퓨터 조작원의 의도적인 동작보호된 기억 공간의 접근, 블법적인 명령어의 수행0으로 나누기, Overflow/Underflow 발생페이지 폴트, 캐시미스 발생입출력 장치에서 CU에게 기능 요청시SVC 인터럽트 7. CPU, 메인메모리, 입출력의 총 관리 프로그램 운영체제의 등장.정의하드웨어를 제어하는 소프록 하는 프로그램컴퓨터를 편리하게 사용하고 하드웨어를 효율적으로 사용할 수 있도록 하는 프트웨어.하드웨어를 활용할 수 있도록 펌웨어나 소프트웨어로 만들어진 프로그램컴퓨터 본체 및 각 주변 장치를 가장 능률적이고, 경제적으로 사용할 수 있도로그램. 목적컴퓨터 시스템의 처리량, 신뢰성을 최대화사용자와 컴퓨터 시스템과의 인터페이스 제공.주변 장치를 관리CPU, 메모리 사용을 효율적으로 하기 위해서 스케줄링 (라운드로빈 같은거) 운영체제의 세부 구조마이크로프로그램 : ROM, PROM에 영구히 기록되는 프로그램을 말하는 것으로 보통 펌웨어를 말한다.기계어 : 기계어는 0과 1로 표시되며 실행할 명령, 데이터, 기억장치 주소드을 포함한다. 하드웨어를 직접 실행시킬 수 있는 형태로 구성되며 컴퓨터의 모든 하드웨어를 제어하기 위한 다양한 비트 형식의 명령어가 존재.제어 프로그램(커널) : 하드웨어를 제어하는 프로그램을 ㅗ메모리, CPU, 단마리, 프린터 등 시스템의 자원 활용도를 높이기 위해 스케줄링과 자료 관리를 하는 핵심 요소.명령어 해석기(쉘) : 사용자 명령을 입력받아 시스템 기능을 수행하는 명령 해석기로서 사용자와 시스템 간의 인터페이스를 담당하는 프로그램.어셈블러 : 어셈블리어로 작성된 원시 프로그램을 목적 프로그램으로 변환컴파일러 : 고급 언어로 작성된 원시 프로그램을 목적 프로그램으로 변환인터프리터 : 고급 언어로 작성도니 원시 프로그램을 실행하되 목적 프로그램은 만들지 않고 대화식으로 처리 (바로 해석하고 결과를 반환함. 목적 프로그램을 만들지는 않음)로더 : 프로그램을 실행하기 위해서 보조 기억장치에 있는 데이터를 주기억장치로 가져온다. 프로세스 개념파일로 작성된 프로그램은 로더에 의해 주기억 장치에 상주되어 CPU에 의해서 처리된다.이떄 주기억 장치에 상주된 프로그램이 CPU에 의해서 처리되는 상태를 프로세스라고 한다. CPU에 의해서 현재 실행되고 있는 프로그램이다.PCB의 존재로서 명시되는 것.프로세서가 할당되는 개체로서 디스패치가 가능한 단위.CPU가 할당되는 실체운영체제가 관리하는 최소 단위의 작업이다. 프로세스 상태실행, 준비, 대기 스풀링, 버퍼링스풀링 : 프로그램과 이를 이용하는 I/O 장치와의 속도 차를 극복하기 위한 장치로 대부분 하드 디스크가 중재한다.버퍼링 : CPU와 입출력 장치와의 속도 차이를 줄이기 위해 메모리가 중재한다. 버퍼링은 한 레코드를 읽어서 CU가 그것에 대한 작업을 시작함과 동시에 입출력 장치가 필요한 레코드를 미리 읽어 CPU에 저장해 두고 CU가 필요한 레코드를 읽기 위해 기다리는 일이 없도록 한다. 문맥 교환(Context Switching) 다중 프로그래밍 시스템에서 CPU가 할당되는 프로세스를 변경하기 위하여 현재 CPU를 사용하여 실행되고 있는 프로세서의 상태 정보를 저장하고 제어권을 인터럽트 서비스 루틴에게 넘기는 작업을 문맥 교환이라고 한다. 프로그램 실행 : 인터럽트 발생프로그램 중단 : 현재 처리 중인 프로그램 잠시 중단.문맥 교환 : 두 개의 프로그램 정보 교환인터럽트 처리 : 새롭게 실행된 프로그램 처리인터럽트 서비스 루틴 : 새롭게 실행된 프로그램의 부가적인 서비스 루틴 수행프로그램 중단 부분 재실행 : 중단되었던 기존에 프로그램 실행 오버헤드프로세스의 실행을 위한 부가적인 활동을 오버헤드라고 하는데 이 또한 문맥 교환 수와 같이 늘어나게 된다. 정리하면 다음과 같다.시간 할당량이 적어지면 : 문맥 교환수 , 인터럽트 횟수, 오버헤드가 증가하지만 여ㅑ러 개의 프로세스가 동시헤 수행되는 느낌을 가진다.시간 할당량이 커지면 : 문맥 교환수, 인터럽트 횟수, 오버헤드가 감소하지만 여러 개의 프로세스가 동시에 수행되는 느낌을 가지지 못한다. PCB (프로세스 제어 블록)프로세스 식별자 : 프로세스들을 구분할 수 있는 태그, 명칭, 고유 이름이다.프로세스 현재 상태 : 프로세스의 현재 상태 (준비, 실행, 대기 상태)를 기억프로그램 카운터(계수기) : 다음에 실행되는 명령어의 주소를 기억…. CPU 스케줄링CPU 성능 평가 기준 처리 능력 (Throughput) : 단위 시간당 처리할 수 있는 CPU의 작업량이다. 처리 능력은 최대한 늘린다.대기 시간 (Waiting Time) : 준비 상태에서 대기하는 시간. 대기 시간은 최소화 해야한다.응답 시간 (Response Time) : 입력에 대해 처음 반응하는 시간이다. 응답 시간은 최소화해야 한다.반환 시간 (Tur-around Time) : 작업을 지시하고 그 결과가 되돌아오는 시간이다. 반환시간은 최소화해야한다. 비선점형프로세스가 CPU에 할당되면 권한을 뺴앗을 수 없다.일괄 처리 방식에 적당.FIFO, SJF, HRN, 우선순위, 기한부 방식이 비선점형 방식에 속한다.문맥 교환이 적어 오버헤드가 적다. 선점형프로세스가 CPU에 할당되면 우선순위가 높으면 빼앗을 수 있다.일괄 처리 방식에 부적당하다.대화형, 시간 분할 ,실시간 시스템에 적당하다.RR, SRT, MFQ 방식이 선점형에 속한다.문맥 교환이 많아서 오버헤드가 많다. FIFO (First In First Out) : 먼저 입력된 작업을 먼저 처리하는 방식.SJF (Shortest Job First) : 작업이 끝나기까지의 실행 시간 추정치가 가장 작은 작업을 먼저 실행시키는 방식으로 비선점 방식. - 에이징 기법 : 무한 연기 문제를 해결하기 위해서 오랜 기간 기다린 프로세스에게 상대적으로 높은 우선순위를 부여한다. RR (Round-Robin) : 프로세스 스케줄링 방법 중 시분할 시스템을 위해 고안되었으며 여러 개의 프로세스가 10 ~ 100msec 정도의 시간 할당량이라는 작은 단위 시간이 정의되어 시간 할당량만큼씩 CPU를 사용하는 방법. 만약 할당 시간을 점점 적게 한담ㄴ 문맥 교환 횟수가 증가하므로 그만큼 전체적인 스셑ㅁ 실행 속도가 늦어지기 때문에 시스템의 특성에 맞는 적절한 할당 시간의 배정이 중여하다. 병행 프로세스와 교착상태임계구역 여러 개의 프로세스가 공동으로 사용하는 CPU, 메모리, 디스크, 입출력 장치들을 임계 구역이라고 할 수 있다. 여러 프로세스들이 접근할 수 있고 그에 따른 충돌, 불일치 문제가 발생할 수 있기 때문. 임계 구역의 원칙두 개 이상의 프로세스가 동시에 사용할 수 없다.순서를 지키면서 신속하게 사용한다.하나의 프로세스가 독점해서는 안된다.사용 중에 중단, 무한 반복되어서도 안된다.인터럽트가 불가능한 상태로 만들어져야 한다. 프로세스 간 데이터 전달 (프로세스 통신)프로세스 끼리 데이터를 공유할 떄 Shared memory 방법을 활용할 수 있는데. 이 때 하나 이상의 기억 장소를 공유하게 되면서 순차적으로 사용한다면 프로세스 간에 공유 기억 장솔르 통해 통신 할 수 있게 된다. 이렇나 공유 기억 장솔르 임계 구역이라 할 수있다. 상호 배제임 계 구역을 어느 시점에서 단지 한 개의 프로세스 만이 사용할 수 있도록 하는 것.알고리즘은 인터럽트 불능 처리, 잠금, 엄격한 교대, TSL, 세마포어 등이 존재. 교착상태 (Dead-lock) 스래싱보조기억장치에서 주기억장치를 데이터를 가져올 때 데이터가 없어서 지속 페이지 폴트 발생하는 경우 시스템 성능이 저하되는데 이러한 경우를 스래싱이라고 표현한다. 구역성프로그램이 실행할 때 기억 장치 내의 모든 정보를 균일하게 참조하는 것이 아니라 어느 한 순간에 특정 부문으로 집중적으로 참조하는 프로그램의 순차적인 성질이다. 한번 호출된 자료나 명령은 곧바로 다시 사용될 가능성을 말한다. 페이지 교체 전략메인메모리의 공간이 가득 찾을 때 새로운 페이지가 들어오면 이를 교체시키고 사용해야한다. 이 때 어떤 데이터를 교체시킬지에 대한 정책들이다. FIFO (First In First Out)LRU(Least Recently Used)LFU(Least Frequesntly Used) 비밀키암호화 키와 복호화 키가 같다.해독키의 비밀성이 보호되어야 한다.DES 알고리즘이 대표적 공개키암호화 키와 복호화 키가 다른 키를 사용한다.RSA 알고리즘이 대표적. 스레드프로세스 내부에 있는 개념. 단일 프로세스를 다수의 스레드로 생성하여 병행성을 증진시킬 수 있다.싱행환경을 공유시켜서 기억 장소의 낭비가 줄어든다.프로세스의 생성이나 문맥 교환의 비용을 줄여서 다중처리시 성능을 보다 향상시킬 수 있다.프로세스 내부에 포함되는 스레드는 공통적으로 접근 가능한 기억 장치를 통해 효율적으로 통신한다.하나의 프로세스에 여러 개의 스레드가 존재할 수 있다. DFD (Data Flow Diagram)자료가 소프트웨어 내의 각 절차를 따라 흐르면서 변하는 과정을 도형화시키는 방법이다.사용자 요구를 넓은 시각에서 분석하는 도구로 설계 단계에서 기본적으로 사용된다는 점에서 가장 많이 사용하는 방법. 외부 입출력 직사각형처리 과정 원자료 흐름 화살표자료 저장소 두 줄 객체지향 기술의 용어클래스하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 데이터 추상화를 의미. 객체들이 갖는 속성과 적용 연산을 정의하는 툴이다. 인스턴스어떤 클래스에 속하는 구체적이 객체를 의미하며 클래스로 정의된 객체의 요소로 객체의 복사본이라고 할 수 있다. 어트리뷰트객체에 존재하는 함수들이 동작하게 될 경우 같은 객체에 존재하는 자료구조의 값을 변경하게 되는데, 자료 구조의 변경된 값을 통해 객체의 상태를 파악하게 된다. 메서드객체지향의 기본 개념 중 객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산을 정의한 것 상속성상속은 상위클래스가 가지는 속성과 연산을 그대로 물려받는 것을 의미. 상속을 통한 가장 중요한 이점은 클래스와 객체를 재사용할 수 있는 능력이 생긴다는 것. 다형성같은 상위 객체에서 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 가지는 객체로 이용될 수 있는 성질. 화이트박스 검사 VS 블랙박스 검사화이트 박스 모듈 안의 작동을 직접 관찰.프로그램 모듈의 논리적 구조를 체계적으로 점검하는 구조 검사.원시 코드의 모든 문장을 한번 이상 수행함으로써 진행되는 검사이다.프로그램 원시 코드의 논리적인 구조를 커버하도록 테스트 케이스를 설계한다.… 블랙박스 검사.저품의 각 기능이 완전히 작동되는 것을 입증하는 검사.설계된 모든 기능들이 정상적으로 수행되는지 확인하는 검사.입력 대비 출력이 정확하게 생성되는지를 보여주는데에 사용. DTE (Data Terminal Equipment)사용자 인터페이스 장비로 터미널이라고 한다. 정보 통신 시스템을 사람이 접근하여 사용하는 장비로전화기, 컴퓨터, 팩시밀리, 휴대폰 등이 있다. 모뎀 (Modulator-Demodulater)디지털 데이터 -&gt; 아날로그 신호로 변환시키는 장비.인터넷 보급이 덜 되었을 때 데이터를 공중 전화망(PSTN) 으로 주고 받기 위해서 이 장비를 많이 사용했따.무선통신은 아날로그 통신이기 때문에 모뎀 부분이 존재함.모뎀의 신호 변환 방식ASK (Amplitude Shift Keying )진폭을 다르게 하여 특정 진폭은 1로 보고 특정 진폭은 0으로 보고 변환. 평균 300bps FSK (Frequency Shift Keying)디지털 데이터의 1과 0을 주파수의 주기 수를 다르게 하여 전송하는 방식. 평균 1,200bps PSK (Phase Shift Keying)디지털 데이터의 1과 0을 다른 위상으로 보내어 전송하는 방식 4,800bps 4위상 PSK -&gt; 00, 01, 10, 11을 4가지의 다른 위상으로 보냄(0도, 90도, 180도, 27도)한번에 2비트의 데이터를 보내기 때문에 PSK의 2배 속도 8위상 PSK -&gt; 000, 001 … 111을 8가지의 다른 위상으로 보냄.한번에 3비트의 데이터를 보내기 때문에 PSK의 3배 속도. 16위상 PSK -&gt; … M위상 PSK -&gt; … QAM (Quadrature Amplitude Modulation)ASK + PSK DSU (Digital Service Unit)네트워크 간에 서로 다른 디지털 신호를 사용하기 때문에 신호 변환을 위해 사용하는 네트워크 연결 장비.디지털 데이터를 디지털 통신망을 이용하여 전송되도록 디지털 신호로 변환하는 장비. 종류 : RZ, NRZ, 바이폴라 CODEC (Coder-Docoder)아날로그 데이터를 디지털 신호로 변환아날로그 데이터는 디지털 신호와 다르게 연속적인 데이터이기 때문에 쪼개질 수 없고, 무한하다.이를 디지털로 표현하가 위해서 PCM 변조를 한다. PCM표본화(Sampling) -&gt; 양자화(Quantization) -&gt; 부호화(Encoding) -&gt; 복호화(Decoding) -&gt; 필터링보통 최대 주파수의 2배 기준으로 표본화를 한다.표본화된 하나의 PAM 신호를 부호화 할 때 표본당 전송 비트가 4비트이면 양자화 스텝은 16개가 필요, 8비트면 256 스텝이 필요하다.양자화된 표본 펄스의 진폭 값을 디지털 신호 1, 0으로 조합하는 변환단계.부호화 과정에서는 인접한 부호간 1비트만 변화하는 Gray Code를 가장 많이 사용. 전송 방향단방향 전송 (Simplex)한쪽 방향으로만 데이터 전송이 이루어지는 방식으로 TV, 라디오, 델렉스, 원격 측정등이 예이다. 양방향 전송 (Duplex)양쪽 방향에서 데이터 전송이 이루어지는 방식. 반이중 전송 (Half-Duplex)한쪽에서 데이터 전송이 되면 다른 한쪽에서는 전송이 끝나기를 기다리는 방식을 무전기가 여기에 속한다. 전이중 전송 (Full-Duplex)양쪽에서 동시에 데이터 전송이 되는 방식으로 전화나 비디오텍스(Videotex) 등이 있다.또한 전이중 전송이 가능하다면 단방향, 반이중 전송도 가능하다. HDLCFLAG + ADDRESS + CONTROL + INFORMATION + FCS + FLAG FLAG프레임 구조의 앞과 뒤를 구분하는 비트 열로서 ‘01111110’으로 구성 ADDRESS상대국이나 복합국의 주소를 지정할 때 사용하는 블록으로 기본적으로 8비트를 사용하며 8바이트까지 확장 가능. CONTROLI-프레임, S-프레임, U-프레임 비트 위주 프레임이다.전송 방향 단방향, 반이중, 전이중 모두 사용 가능회선 연결은 점 대 점, 멀티포인트, 루프 모두 사용 가능오류 제어 방식은 연속적 ARQ동기식 전송. 오류 검출 방식패리티 방식, Checksum, 해밍코드 공유 회선 점유 방식CSMA/CD, 토큰링 이더넷라우팅 프로토콜RIP(Routing Information Protocol)OSPF LAN동일 빌딩 내 또는 한정된 지역 내 등 비교적 좁은 지역에 분산 배치된 컴퓨터와 프린터 등의 단말기를 통신 회선으로 연결하여 각종 정보를 교환할 수 있는 통신 네트워크이다. LAN 전송 매체UTP, STP 케이블한 케이블에는 8가닥의 전선이 들어있는데 이 전기적 간섭 현상을 줄이기 위해서 전선들이 꼬여있다.가격이 저렴하고 설치가 간편한 이점을 가진 반면, 내구성이 약하다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Process","slug":"Process","permalink":"http://kidongyun.github.io/tags/Process/"},{"name":"Computer Architecture","slug":"Computer-Architecture","permalink":"http://kidongyun.github.io/tags/Computer-Architecture/"},{"name":"Operating System","slug":"Operating-System","permalink":"http://kidongyun.github.io/tags/Operating-System/"}]},{"title":"Coding Test","slug":"2021-02-21-coding_test","date":"2021-02-20T15:54:00.000Z","updated":"2022-05-31T07:33:21.000Z","comments":true,"path":"2021/02/21/","link":"","permalink":"http://kidongyun.github.io/2021/02/21/","excerpt":"","text":"int[] -&gt; List1Arrays.stream(new int[] &#123;0, 1, 2, 3&#125;).boxed().collect(Collectors.toList()) List -&gt; int[]1List.of(0, 1, 2, 3).stream().mapToInt(Integer::intValue).toArray() Swap을 활용한 Permutation1234567891011121314151617181920212223242526public perm(int[] arr, int depth) &#123; if(depth == arr.length) &#123; print(arr, arr.length); return; &#125; for(int i=depth; i&lt;arr.length; i++) &#123; swap(arr, i, depth); perm(arr, depth + 1); &#125;&#125;public void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;public void print(int[] arr, int k) &#123; for(int i=0; i&lt;k; i++) &#123; System.out.print(arr[i] + &quot;, &quot;); &#125; System.out.println(&quot;&quot;);&#125; Prefix를 활용한 Permutation1234567public void perm(String pre, String src) &#123; System.out.println(pre); for(int i=0; i&lt;src.length(); i++) &#123; perm(pre + src.charAt(i), src.substring(0, i) + src.substring(i+1)); &#125;&#125; String -&gt; char[]1char[] chars = str.toCharArray(); isPrime12345678910111213public boolean isPrime(int num) &#123; if(num == 1) return false; if(num == 2) return true; if(num % 2 == 0) return false; for(int i=3; i&lt;=(int)Math.sqrt(num); i+=2)&#123; if(num%i==0) return false; &#125; return true;&#125; Math.max(triangle[i][j], triangle[i][j + 1]);배열 자를때 문자열로 변환해서 하면 쉽다 배열 변환시 String.valueOf 사용 혹은 Arrays.toStringint[] -&gt; String[]1Arrays.stream(numbers).boxed().map(String::valueOf).collect(toList()) String[] -&gt; String1Collectors.joining() java 배열을 뒤집어주는 기능1Collections.reverse(list); 테스트 셋의 종류 null을 넣는다던지, 엄청 큰값을 넣는다던지..원소가 하나만 있다던지, 음수값, 오버플로우값, 비어있는 배열에 접근, 초기값이나 마지막 값이 이벤트인 경우 Dynamic Programming - 카데인 알고리즘 (부분 배열의 최대 합 구하기)유클리드 알고리즘 123456789 /* a가 더 큰값 */private int gcd(int a, int b) &#123; if(a % b == 0) &#123; return b; &#125; return gcd(b, a%b);&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Design Pattern","slug":"2021-02-15-design-pattern","date":"2021-02-14T15:54:00.000Z","updated":"2022-05-31T07:33:13.000Z","comments":true,"path":"2021/02/15/","link":"","permalink":"http://kidongyun.github.io/2021/02/15/","excerpt":"","text":"디자인패턴 vs 알고리즘알고리즘은 문제 해결을 위한 처리 절차. ex 1) 서울에서 부산으로 가는 방법 걸어서 간다 자전거를 타고 간다. 버스를 타고 간다. KTX를 타고 간다. 비행기를 타고 간다. ex 2) 여러 개의 데이터가 있을 때 순서에 맞게 정렬하는 방법 단순 정렬 버블 정렬 삽입 정렬 쉘 정렬 퀵 정렬 디자인 패턴 효율적인 프로그래밍을 하고 있다는 판단하는 기준 중복된 코드가 없다. 변경된 요구사항을 순조롭게 받아들일 수 있어야 한다.(이 둘중에 어떤게 더 우선이 될까??) 디자인 패턴을 적용하여 프로그램을 만드는 중요한 이유는 다양한 추가 요구사항에 대해 좀 더 쉽게 대응하기 위해서이다.= 과거에 이런 상황에 이렇게 하니 요구사항 변경에 따라 코드 수정을 하기 좋았다. 디자인패턴도 같은 상황에 하나의 패턴만이 정답은 아니다. 디자인패턴도 만드는 서비스의 종류에 따라서 다양하게 나뉜다. 오리지널 파운데이션 패턴(GoF 패턴) 썬의 J2EE 패턴 JSP 패턴 아키텍쳐 패턴 게임 디자인 패턴 GoF 패턴에는 아래와 같은 패턴들이 있음. 싱글턴 패턴 플라이웨이트 패턴 빌더 패턴 옵저버 패턴 어댑터 패턴 파사드 패턴 데코레이션 패턴 브릿지 패턴 스트래티지 패턴 디자인 패턴과 클래스의 다형성 참조타입 사이에서의 형변환클래스 사이에서도 형변환이 일어나는데, 클래스 사이의 형변환은 상위클래스와 하위클래스 사이에서 일어나게 된다.-&gt; 하위클래스의 객체는 상위클래스의 객체에 대입할 수 있다.-&gt; 상위클래스 객체를 하위클래스 객체에 대입할 수 없다.: 다형성의 특징. 객체지향 프로그래밍을 하는데 굉장히 큰 근간이 되는 특징이 다형성이다. 클래스의 약한 결합, 강한 결합의 이해DI(Dependency Injection) 의존성 주입 : 객체지향 프로그래밍에서 다른 객체를 사용하는 것을 다른 객체에 의존한다고 표현.다른 객체를 사용하기 위해서는 다른 객체를 생성해야 하는데. 직접 생성도 가능하고, 미리 생성되어있는 다른 객체를 받아올수도 있다.이런 것들이 모두 의존성 주입의 방법들 123456789101112131415class A &#123; B b; C c; public A(C c) &#123; this.c = c; &#125; // Setter 주입 public setB(B b) &#123; this.b = b; &#125;&#125; 생성자 주입이나, Setter 주입은 기존에 있는 객체를 가져와 주입하기 때문에 결합도가 낮아지지만, A 에서 직접 생성하게 되면 의존성 관리도 A 객체가 직접 해야하기 때문에결합도가 높아진다. 강한 결합의 예시. 123456789101112131415161718192021222324252627282930313233343536public class UnderstandDI &#123; public static void main(String[] args) &#123; &#125; // 강한 결합 public static void getDate() &#123; Date date = new Date(); System.out.println(date); &#125; // 약한 결합 public static void getDate(Date d) &#123; Date date = d; System.out.println(date); &#125; // 강한 결합 : Member를 직접 생성 public static void memberUse1() &#123; Member m1 = new Member(); &#125; //약한 결합 : 생성된 것을 주입 받음 public static void memberUse2(Member m) &#123; Member m2 = m; &#125;&#125;class Member &#123; String name; String nickname; public Member() &#123; &#125;&#125; Utility 클래스는 보통 싱글톤 방식으로 사용하기 때문에 내부적으로 private 생성자를 사용. 싱글턴 패턴 : 최대 N개의 객체 생성을 제한하는 패턴예시) 데이터베이스 커넥션 풀 로그 라이터 사운드 매니저 스코어 매니저 싱글톤이 아닌경우의 예시 -&gt; Database 객체가 계속 생성된다. 1234567891011121314151617181920212223242526public class Database &#123; private String name; public Datebase(String name) &#123; super(); this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;public class TestPattern1 &#123; public static void main(String[] args) &#123; Database d1 = new Database(&quot;1&quot;); Database d2 = new Database(&quot;2&quot;); Database d3 = new Database(&quot;3&quot;); Database d4 = new Database(&quot;4&quot;); Database d5 = new Database(&quot;5&quot;); Database d6 = new Database(&quot;6&quot;); System.out.println(&quot;database use&quot;); &#125;&#125; 싱글톤인 경우 1234567891011121314151617181920212223242526272829303132333435public class Database &#123; private static Database singleton; private String name; public Database(String name) &#123; super(); this.name = name; &#125; public static Database getInstance(String name) &#123; if(singleton == null) &#123; singleton = new Database(name); &#125; return singleton; &#125; public String getName() &#123; return name; &#125;&#125;public class TestPattern1 &#123; public static void main(String[] args) &#123; Database database; database = Database.getInstance(&quot;첫 번째 Database&quot;); System.out.println(&quot;This is the &quot; + database.getname() + &quot; !!!&quot;); database = Database.getInstance(&quot;두 번째 Database&quot;); System.out.println(&quot;This is the &quot; + database.getname() + &quot; !!!&quot;); &#125;&#125; 위 예시의 문제점은 생성자 생성 방식을 제한하지 못한다. getInstance() 이 함수 말고 생성자로 호출하게 되면 싱글톤이 적용이 안된다.그래서 생성자의 접근제어지시자를 private 으로 변경한다. 1234567891011121314151617181920212223public class Database &#123; private static Database singleton; private String name; private Database(String name) &#123; super(); this.name = name; &#125; public static Database getInstance(String name) &#123; if(singleton == null) &#123; singleton = new Database(name); &#125; return singleton; &#125; public String getName() &#123; return name; &#125;&#125; 멀티쓰레드 환경의 경우 문제점 : 각 쓰레드가 Database 객체에 접근하려고 하면 모두 새롭게 생성.왜 그럴까 for문은 엄청 빠르다. 다른 쓰레드가 도는 시점에 singleton 객체는 모두 null임.그래서 모두 새롭게 생성하는 것임. 1234567891011121314151617181920public class TestPattern2 &#123; static int nNum = 0; public static void main(String[] args) &#123; Runnable task = () =&gt; &#123; try &#123; nNum++; database database = Database.getInstance(nNum + &quot;번째 Database&quot;); System.out.println(&quot;This is the &quot; + database.getName() + &quot; !!!&quot;); &#125; catch (Exception e) &#123; &#125; &#125;; &#125; for(int i=0; i&lt;10; i++) &#123; Thread t = new Thread(task); t.start(); &#125;&#125; 멀티스레드환경에서도 안정적인 싱글톤 구현하기 : 객체 생성시에 synchonized 선언 -&gt; 비동기 프로그래밍시 중요한 사항! setter에 해당하는 코드들은synchronized를 붙여야한다. 그러면 이부분은 블로킹되고 순서대로 처리된다. -&gt; 비용이 비쌈 / 병목현상이 일어남 / 블로킹됨 1234567891011121314151617181920212223public class Database &#123; private static Database singleton; private String name; private Database(String name) &#123; super(); this.name = name; &#125; public synchronized static Database getInstance(String name) &#123; if(singleton == null) &#123; singleton = new Database(name); &#125; return singleton; &#125; public String getName() &#123; return name; &#125;&#125; 싱글톤 코드의 비용을 줄여보자. 123if(singleton == null) &#123; singleton = new Database(name);&#125; 이 코드가 처음에 싱글톤 객체가 생성될때에만 유효하고 그 이후부터는 쓸데없는 코드. 생각보다 낭비가 많은 코드이다. 이거 수정해보자. 123456789101112131415161718192021public class Database &#123; private static database singleton = new Datebase(&quot;products&quot;); private String name; private Database(String name) &#123; try &#123; Thread.sleep(100); this.name = name; &#125; catch (Exception e) &#123; &#125; &#125; public static Database getInstance(String name) &#123; return singleton; &#125; public String getName() &#123; return name; &#125;&#125; synchronized 개선, if(singleton == null) 코드 개선 실전 : 로그 라이터 만들기싱글톤 패턴을 적용해보기 위해서 로깅하는 객체를 만들어 보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class LogWriter &#123; private static LogWriter singleton = new LogWriter(); private static BufferedWriter bw; private LogWriter() &#123; try &#123; bw = new BufferedWriter(new FileWriter(&quot;log.txt&quot;)); &#125; catch (Exception e) &#123; &#125; &#125; public static LogWriter getInstance() &#123; return singleton; &#125; public synchronized void log(String str) &#123; try &#123; bw.write(str + &quot;\\n&quot;); bw.flush();+ &#125; catch(Exception e) &#123; &#125; &#125; @Override protected void finalize() &#123; try &#123; &#125; catch (Throwable ex) &#123; &#125; &#125;&#125;public class TestPattern1 &#123; public static void main(String[] args) &#123; LogWriter logger; logger = LogWriter.getInstance(); logger.log(&quot;홍길동&quot;); logger = LogWriter.getInstance(); logger.log(&quot;전우치&quot;); &#125;&#125; 플라이웨이트 패턴 이해하기싱글턴 패턴과 마찬가지로 오브젝트의 생성을 제한하는 패턴 플라이웨이트 패턴은 비용이 큰 자원을 공통으로 사용할 수 있도록 만드는 패턴자원에 대한 비용은 크게 두가지로 나눠 볼 수 있다. 중복 생성될 가능성이 높은 경우.-&gt; 자주 사용될 가능성이 높다는 의미 자원 생성 비용은 큰데 사용 빈도가 낮은 경우-&gt; 요청시에 생성하며, 마무리되면 정리한다. 나무를 생성한다고 치면 나무의 필요한 요소는 잎사귀, 뿌리, 가지 등이 있다.잎사귀, 뿌리, 가지에 대한 정보가 고유하게 가져아할 정보가 있는 객체가 아니라면 이 객체들을 싱글톤으로 생성하고이 객체들을 참조 형식으로 나무가 바라보도록 할 수 있다. 이렇게 하면 나무를 위해서 잎사귀, 뿌리, 가지등의 객체가 매번 새롭게 생성되지 않으며, 각각 하나의 객체만을 가지고많은 나무들을 구현할 수 있다.나무는 단지 각 객체를 참조할 수 있는 값만 가지면 된다. 실제로 쓰기 위해서는. 나무도 고유한 값을 가지는 데이터들이 잇을 거시다. 이런 값들은 어쩔수 없고고유하지 않아도 되는 데이터들만 묶어서 그거를 참조하게끔 구현한다. ** 한 객체 내에서 싱글톤으로 쓸수 있는 객체를 새로운 객체로 표현하고 이를 참조하는 구조를 가짐. 장점-&gt; 많은 객체를 만들 때 성능을 향상시킬 수 있다.-&gt; 많은 객체를 만들 때 메모리를 줄일 수 있다.-&gt; state pattern과 쉽게 결합될 수 있다. 단점-&gt; 특정 인스턴스 공유 컴포넌트를 다르게 설정할 수 없다. 기존 자바에서 코드에서 볼 수 있는 플라이웨이트 패턴123456789public class TestPattern &#123; public static void main(String[] args) &#123; String str1 = new String(&quot;홍길동&quot;); String str2 = new String(&quot;홍길동&quot;); String str3 = &quot;홍길동&quot;; String str4 = &quot;홍길동&quot;; &#125;&#125; str1, str2 은 별도의 인스턴스str3, str4 은 같은 인스턴스 String 객체가 싱글톤 패턴을 사용하고 있음을 알 수 있다. 123456789101112131415161718192021222324252627public class TestPattern &#123; public static void main(String[] args) &#123; Mydata md1 = new Mydata(); md1.xpos = 10; md1.ypos = 11; md1.name = &quot;홍길동&quot;; MyData md2 = new MyData(); md2 = md1; MyData md3 = new MyData(); md3.xpos = 20; md3.ypos = 21; md3.name = &quot;손오공&quot; md2.name = &quot;전우치&quot; md2.xpos = 5; &#125;&#125;class MyData &#123; int xpos; int ypos; String name;&#125; 플라이웨이트 패턴 구현하기.1234567891011121314151617181920212223242526272829303132333435363738public class Subject &#123; private String name; public Subject(String name) &#123; this.name = name; &#125;&#125;public class FlyweightFactory &#123; private static Map&lt;String, Subject&gt; map = new HashMap&lt;String, Subject&gt;(); public Subject getSubject(String key) &#123; Subject subject = map.get(key); if(subject == null) &#123; subject = new Subject(key); map.put(key, subject); System.out.println(&quot;새로 생성 &quot; + key); &#125; else &#123; System.out.println(&quot;재사용 &quot; + key); &#125; return subject; &#125;&#125;public class TestPattern &#123; public static void main(String[] args) &#123; FlyweightFactory flyweight = new Flyweightfactory(); flyweight.getSubject(&quot;a&quot;); flyweight.getSubject(&quot;a&quot;); flyweight.getSubject(&quot;b&quot;); flyweight.getSubject(&quot;b&quot;); &#125;&#125; 빌더 패턴빌더패턴은 객체를 생성할 때 흔하게 사용하는 패턴이다.자바로 코딩할 때 다음과 같은 스타일로 객체를 생성하는 코드가 있다면, 빌더 패턴을 사용했다고 살 수 있다.체이닝 기법을 활용한다. 객체 일관성, 변경 불가능성의 특징을 가지고 있기 때문에 빌더패턴을 사용.코드의 가독성과 유지보수하기 쉬워진다 생성자 인자가 많을 때는 빌더패턴을 사용하라. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899@Getter@Setterpublic class Person &#123; private String firstName; private String lastName; private LocalDate birthDate; private String addressOne; private String addressTwo; private String sex; private boolean driverLicence; private boolean married; public static PersonBuilder builder() &#123; return new PersonBuilder(); &#125;&#125;public class PersonBuilder &#123; private String firstName; private String lastName; private LocalDate birthDate; private String addressOne; private String addressTwo; private String sex; private boolean driverLicence; private boolean married; public PersonBuilder firstName(String firstName) &#123; this.firstName = firstName; return this; &#125; public PersonBuilder lastName(String lastName) &#123; this.lastName = lastName; return this; &#125; public PersonBuilder birthDate(LocalDate birthDate) &#123; this.birthDate = birthDate; return this; &#125; public PersonBuilder addressOne(String addressOne) &#123; this.addressOne = addressOne; return this; &#125; public PersonBuilder addressTwo(String addressTwo) &#123; this.addressTwo = addressTwo; return this; &#125; public PersonBuilder sex(String sex) &#123; this.sex = sex; return this; &#125; public PersonBuilder driverLicence(boolean driverLicence) &#123; this.driverLicence = driverLicence; return this; &#125; public PersonBuilder married(boolean married) &#123; this.married = married; return this; &#125; public Person build() &#123; Person person = new Person(); person.setFirstName(firstName); person.setLastName(lastName); person.setAddressOne(addressOne); person.setAddressTwo(addressTwo); person.setBirthDate(birthDate); person.setSex(sex); person.setDriverLicence(driverLicence); person.setMarried(married); return person; &#125;&#125;public class TestPatterm &#123; public static void main(String[] args) &#123; Person p1 = Person.builder() .firstName(&quot;FirstName&quot;) .lastName(&quot;LastName&quot;) .addressOne(&quot;금천구 가산동 월드메르비앙2차 KOSMO&quot;) .addressTwo(&quot;AddressTwo&quot;) .birthDate(LocalDate.of(1995, Month.APRIL, 13)) .sex(&quot;male&quot;) .driverLicence(true) .married(true) .build(); System.out.println(p1.getAddressOne()); &#125;&#125; 빌더안에 Person 필드들을 주는거보다 Person 객체를 그냥 주는게 훨씬 나음 보일러플레이트 코드 개쩜그리고 빌더의 목적 중 하나는 값이 중간에 변경이 불가능하도록 하는 건데 저렇게하면 변경이 결국 가능setter를 제거하고 buider 내부에서는 한번에 생성 되도록 final 키워드 선언해야됨 static 선언하는거 저거 하나 건졌다. 옵저버 패턴한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동을 ㅗ내용이 갱신되는 방식으로일대다 의존성을 정의. Subject 객체가 있음. 이 객체는 bCheck 값을 가짐Observer 객체 1,2,3 Subject의 bCheck 값을 감시한다.bCheck 값이 변경되면 등록되어있는 필요한 동작 수행 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class PlayController extends Observable &#123; private boolean bPlay; public PlayController() &#123; &#125; public void setFlag(boolean bPlay) &#123; this.bPlay = bPlay; setChanged(); notifyObservers(); &#125; public boolean getFlag() &#123; return bPlay; &#125;&#125;/** Observer 객체 */public class MyClassA implements Observer &#123; Observable observable; private boolean bPlay;public MyClassA(Observable o) &#123; this.observable = o; observable.addObserver(this);&#125; @Override public void update(Observable o, Object arg) &#123; if(o instanceof PlayController) &#123; PlayController myControl = (PlayController) o; this.bPlay = myControl.getFlag(); myActControl(); &#125; &#125; public void myActControl() &#123; if(bPlay) &#123; System.out.println(&quot;MyClassA : 동작을 시작합니다.&quot;); &#125; else &#123; System.out.println(&quot;MyClassA : 동작을 정지합니다.&quot;); &#125; &#125;&#125;/** Observer 객체 */public class MyClassB implements Observer &#123; Observable observable; private boolean bPlay;public MyClassB(Observable o) &#123; this.observable = o; observable.addObserver(this);&#125; @Override public void update(Observable o, Object arg) &#123; if(o instanceof PlayController) &#123; PlayController myControl = (PlayController) o; this.bPlay = myControl.getFlag(); myActControl(); &#125; &#125; public void myActControl() &#123; if(bPlay) &#123; System.out.println(&quot;MyClassB : 동작을 시작합니다.&quot;); &#125; else &#123; System.out.println(&quot;MyClassB : 동작을 정지합니다.&quot;); &#125; &#125;&#125;public class TestPattern &#123; public static void main(String[] args) &#123; PlayController controller = new PlayController(); MyClassA classA = new MyClassA(Controller); MyClassB classB = new MyClassB(controller); &#125;&#125; 자바 내장 옵저버 패턴의 단점과 한계(1) Observable은 클래스다.Observable이 클래스기 때문에 서브클래스를 만들어야 한다는 점이 문제다. 이미 다른 수퍼클래스를 확장하고 있느 클래스에 Observable의 기느을 추가할 수 없기 때문이다.그래서 재사용성에 제약이 생긴다. (2) Observable 클래스의 핵심 메서드를 외부에서 호출할 수 없다.Observable API를 살펴보면 setChanged() 메서드가 protected로 선언되어 있다.Observable의 서브클래스에서만 setChanged()를 호출할 수 있다. 결국 직접 어떤 클래스를 만들고 , Observable 서브클래스를 인스턴스 변수로 사용하는 방법도 쓸 수 없다. 이런 디자인은 상속보다는 구성을 사용한다는 디자인 원칙도 위배된다. 1234public interface Pulisher &#123; public void addObserver()&#125; 어댑터 패턴의 이해와 구현하기이미 제공되어 있는것 과 필요한 것의 차이를 없애주는 것이 Adapter 패턴. 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환.Adapter 패턴은 Wrapper 패턴으로 불리기도 한다. 두가지 종류가 있음클래스에 의한 Adapter 패턴인스턴스에 의한 Adapter 패턴 어떤 경우에 사용하는가.-&gt; 기존에 존재하는 클래스를 활용하여 코드를 작서ㅇ할 떄.-&gt; 기존 클래스를 개조해서 필요한 클래스를 만든다.-&gt; 이 패턴으로 필요한 메서드를 발 빠르게 만들 수 있따.-&gt; 만약 버그가 발생해도 기존의 클래스에는 버그가 없으므로 Adapter 역할의 클래스를 중점적으로 조사하면 되고, 프로그램 검사도 상당히 쉬워진다. 어댑터 패턴이란 기존에 존재하는 클래스를 커스터마이징 해서 새로운 클래스를 만드는거 이미 만들어진 클래스를 새로운 인터페이스에 맞게 개조시킬 떄는 당연히 Adapter 패턴을 사용해야 한다.그러나 실제 우리가 새로운 인터페이스에 맞게 개조시킬 때는 기존 클래스의 소스를 바꾸어서 ‘수정’ 하려고 한다.이것을 조금 바꿈녀 분명 작업은 끝이나 라고 생각하기 쉽다.그러나 그렇게 하면 동작 테스트가 이미 끝난 기존의 클래스를 수정한 후에 다시 한번 테스트 해야한다.-&gt; 기존 클래스를 변경하게 되면 그에 대한 테스트를 다시 시행해야하기 때문에 작업 범위가 넓어진다는 의미 adapter 패턴은 기존의 클래스를 전혀 수정하지 않고 목적한 인터페이스에 맞추려는 것.adapter 패턴은 기존 클래스의 소스를 반드시 가질 필요가 없으며 기존 클래스의 사양(Interface) 만 알면 새로운 클래스를 만들 수있다 Adapter 패턴과 유사한 두가지 패턴 Bridge, Decorator 인스턴스에 의한 Adapter 패턴123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public interface APlayer &#123; void play(String fileName); void stop();&#125;public class APlayerImpl implements Aplayer &#123; @Override public void play(String fileName) &#123; System.out.println(&quot;(A) &quot; + fileName); &#125; @Override public void stop() &#123; &#125;&#125;public interface BPlayer &#123; void playFile(String fileName); void stopFile();&#125;public class BPlayerImpl implements BPlayer &#123; @Override public void playFile(String fileName) &#123; System.out.println(&quot;(B) &quot; + fileName); &#125; @Override public void stopFile() &#123; &#125;&#125;public class BToAAdapter implements APlayer &#123; private BPlayer media; public BToAAdapter(BPlayer media) &#123; this.media = media; &#125; @Override public void play(String fileName) &#123; System.out.print(&quot;Using Adapter : &quot;); media.playFile(fileName); &#125; @Override public void stop() &#123; &#125;&#125; APlayer , BPlayer 간의 어댑터.기존에 잘 동작하다가 BPlayer로 변경시 문제가 발생한다면BToAAdapter 이쪽 부분만 테스트하면 된다. 클래스에 의한 어댑터1234567891011121314151617181920212223242526public interface APlayer &#123; void play(String fileName); void stop();&#125;public class APlayerImpl implements Aplayer &#123; @Override public void play(String fileName) &#123; System.out.println(&quot;(A) &quot; + fileName); &#125; @Override public void stop() &#123; &#125;&#125;public abstract class BPlayer &#123; public abstract void playFile(String fileName); public abstract void stopFile();&#125;public class BPlayerImpl extends BPlayer &#123; &#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://kidongyun.github.io/tags/Design-Pattern/"},{"name":"Singleton Pattern","slug":"Singleton-Pattern","permalink":"http://kidongyun.github.io/tags/Singleton-Pattern/"},{"name":"Flyweight Pattern","slug":"Flyweight-Pattern","permalink":"http://kidongyun.github.io/tags/Flyweight-Pattern/"},{"name":"Builder Pattern","slug":"Builder-Pattern","permalink":"http://kidongyun.github.io/tags/Builder-Pattern/"},{"name":"Observer Pattern","slug":"Observer-Pattern","permalink":"http://kidongyun.github.io/tags/Observer-Pattern/"},{"name":"Adapter Pattern","slug":"Adapter-Pattern","permalink":"http://kidongyun.github.io/tags/Adapter-Pattern/"}]},{"title":"Call back when build() is occured in lombok","slug":"2021-02-07-callback_build_lombok","date":"2021-02-06T15:54:00.000Z","updated":"2022-05-31T07:31:48.000Z","comments":true,"path":"2021/02/07/","link":"","permalink":"http://kidongyun.github.io/2021/02/07/","excerpt":"","text":"AllArgs 을 위한 builder는 만들지마라 -&gt; 클래스단위로 Builder를 만들지 마라그러면 모든 매개변수를 변경할 수 있는 기회를 가지게 된다. 접근제어가 필요한 매개변수들은 제어를 해주는게 좋다는 의미.이를 해결하기 위해서는 클래스단위로 빌더를 선언하는 거보다는 메소드 별로 빌더를 선언하는 것이 좋다. build() 이후에 callback 처리하기.아직 lombok builder 패턴에서는 이를 @postbuild 어노테이션 같은걸 지원하지 않는다.그래서 callback 처리 하려면 커스텀하게 Builder 클래스를 구현해야한다.어떤 원리인지 모르겠으나 동일한 클래스명으로 정의하면 해당 클래스가 상속되어서 구현된다.아래같이 구현하면 된다. 123456789101112131415161718192021222324@Slf4j@Getter@ToStringpublic class Note &#123; private final Key key; private final Integer octave; private Integer pitch; @Builder(buildMethodName = &quot;buildInternal&quot;) private Note(Key key, Integer octave) &#123; this.key = key; this.octave = octave; &#125; public static class NoteBuilder &#123; public Note build() &#123; Note note = this.buildInternal(); // 여기서 콜백 처리 return note; &#125; &#125;&#125; buildMethodName 옵션에 값을 적용하면 default로 build() 함수의 역할의 이름이 바뀐다. 기본적으로 제공하는 build() 함수의 이름을 buildInternal() 로 변경하고새로 Builder 클래스를 만들었다. 그리고 먼저 buildInternal() 이 함수를 호출한다음에 그다음 콜백처리할 내용을 작업하고 Note 객체를 리턴한다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Lombok","slug":"Lombok","permalink":"http://kidongyun.github.io/tags/Lombok/"}]},{"title":"Intellij jdk re-set","slug":"2021-02-07-intellij-jdk-set","date":"2021-02-06T15:54:00.000Z","updated":"2022-05-31T07:31:47.000Z","comments":true,"path":"2021/02/07/","link":"","permalink":"http://kidongyun.github.io/2021/02/07/","excerpt":"","text":"When you have a problem associated with jdk in intellij, you can re-set it in Project Structure menu. 1File &gt; Project Structure &gt; Project SDK if it doesn’t work good although you re-set it, then remove .idea folder and re-start intellij remove .idea folder re-start intellij","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Intellij","slug":"Intellij","permalink":"http://kidongyun.github.io/tags/Intellij/"}]},{"title":"코딩테스트 - 위장","slug":"2021-02-02-camouflage","date":"2021-02-01T15:54:00.000Z","updated":"2022-05-31T07:29:48.000Z","comments":true,"path":"2021/02/02/","link":"","permalink":"http://kidongyun.github.io/2021/02/02/","excerpt":"","text":"문제스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다. 예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다. 종류 이름얼굴 동그란 안경, 검정 선글라스상의 파란색 티셔츠하의 청바지겉옷 긴 코트스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다.스파이가 가진 의상의 수는 1개 이상 30개 이하입니다.같은 이름을 가진 의상은 존재하지 않습니다.clothes의 모든 원소는 문자열로 이루어져 있습니다.모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 ‘_’ 로만 이루어져 있습니다.스파이는 하루에 최소 한 개의 의상은 입습니다.입출력 예clothes return[[yellow_hat, headgear], [blue_sunglasses, eyewear], [green_turban, headgear]] 5[[crow_mask, face], [blue_sunglasses, face], [smoky_makeup, face]] 3입출력 예 설명예제 #1headgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다. yellow_hat blue_sunglasses green_turban yellow_hat + blue_sunglasses green_turban + blue_sunglasses예제 #2face에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다. crow_mask blue_sunglasses smoky_makeup 솔루션123456789101112131415161718192021import java.util.HashMap;import java.util.Map;class Solution &#123; public int solution(String[][] clothes) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (String[] clothe : clothes) &#123; map.put(clothe[1], map.getOrDefault(clothe[1], 0) + 1); &#125; int result = 1; for(String key : map.keySet()) &#123; result *= map.get(key) + 1; &#125; return result - 1; &#125;&#125; 포인트첫번쨰 포인트는 배열로 되어있는 자료구조를 Map 구조로 변경하는 것그리고 조합을 계산할 때 수식을 알고 있는 것 두가지 인데.코딩 관점에서 봤을 떄에는 Map 구조로 변경하는 거가 좀더 중요하지 않았나 싶음.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"코딩테스트 - 완주하지 못한 선수","slug":"2021-02-02-not-finished-player","date":"2021-02-01T15:54:00.000Z","updated":"2022-05-31T07:29:56.000Z","comments":true,"path":"2021/02/02/","link":"","permalink":"http://kidongyun.github.io/2021/02/02/","excerpt":"","text":"문제수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 제한사항마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.completion의 길이는 participant의 길이보다 1 작습니다.참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.참가자 중에는 동명이인이 있을 수 있습니다.입출력 예participant completion return[leo, kiki, eden] [eden, kiki] leo[marina, josipa, nikola, vinko, filipa] [josipa, filipa, marina, nikola] vinko[mislav, stanko, mislav, ana] [stanko, ana, mislav] mislav입출력 예 설명예제 #1leo는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #2vinko는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #3mislav는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. 솔루션1234567891011121314151617181920212223242526import java.util.HashMap;import java.util.Map;class Solution &#123; public String solution(String[] participant, String[] completion) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0; i&lt;participant.length; i++) &#123; map.put(participant[i], map.getOrDefault(participant[i], 0) + 1); if(i != participant.length - 1) &#123; map.put(completion[i], map.getOrDefault(completion[i], 0) - 1); &#125; &#125; String result = null; for(String key : map.keySet()) &#123; if(map.get(key) != 0) &#123; result = key; &#125; &#125; return result; &#125;&#125; 포인트이 문제를 추상화 시키면 두 배열을 비교하는데 이 중에 서로 맞지 않는 값을 찾아내는 문제다.추가적으로 중복이 가능하다는 조건이 있다. 이를 해결하기 위한 포인트는 그 값들을 세서 해쉬에 저장하는 방법. 이였다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Spring data redis","slug":"2021-02-02-spring-data-redis","date":"2021-02-01T15:54:00.000Z","updated":"2022-05-31T07:30:01.000Z","comments":true,"path":"2021/02/02/","link":"","permalink":"http://kidongyun.github.io/2021/02/02/","excerpt":"","text":"adding dependency 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; Installing Redis based on Docker 1docker run -p 6379:6379 --name redis_boot -d redis Executing Redis 1docker exec -i -t redis_boot redis-cli 아래 명령어로 키 기반 조회 가능 1key * 각 키에 해당하는 값을 알고 싶으면 아래 명령어 사용 가능 1get keesun 기존에는 Redis에서 제공하는 client 라이브러리가 있었는데. 스프링 데이터에서 이 Redis를 감싸고 그 구현체를 제공한다. 그 구현체가 StringRedisTemplate, RedisTemplate 이다. 12345678910111213@Componentpublic class RedisRunner implements ApplicationRunner &#123; @Autowired StringRedisTemplate redisTemplate; @Override public void run(ApplicationArguments args) throws Exception &#123; ValueOperations&lt;String, String&gt; values = redisTemplate.opsForValue(); values.set(&quot;keesun&quot;, &quot;whiteship&quot;); values.set(&quot;springboot&quot;, &quot;2.0&quot;); values.set(&quot;hello&quot;, &quot;world&quot;); &#125;&#125; Redis 커스터마이징 하기 위해서는 application.properties 여기에서 spring.redis.* 관련된 속성들을 변경해주면 된다.Redis는 기본적으로 6379 포트를 사용한다. 그렇기 때문에 docker와 Spring 모두 6379 포트가 기본값이 되어있다. Repository를 만들어서 사용하는 방법 1234567891011121314151617181920212223242526272829303132@RedisHash(&quot;accounts&quot;)public class Account &#123; @Id private String id; private String username; private String email; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; 123public interface AccountRepository extends CrudRepository&lt;Account, String&gt; &#123;&#125; 123456789101112131415161718192021@Componentpublic class RedisRunner implements ApplicationRunner &#123; @Autowired StringRedisTemplate redisTemplate; @Autowired AccountRepository accountRepository; @Override public void run(ApplicationArguments args) throws Exception &#123; Account account = new Account(); account.setEmail(&quot;whiteship@email.com&quot;); account.setUsername(&quot;keesun&quot;); accountRepository.save(account); Optional&lt;Account&gt; byId = accountRepository.findById(account.getId()); System.out.println(byId.get().getUsername()); System.out.println(byId.get().getEmail()); &#125;&#125; hash들은 get hello 이런식으로 못가져 온다. hash get 으로 가져와야 한다. 12hget accounts:1b27ba23-e840-4a6a-b6c4-41b036dabfbd emailhgetall accounts:1b27ba23-e840-4a6a-b6c4-41b036dabfbd","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Redis","slug":"Redis","permalink":"http://kidongyun.github.io/tags/Redis/"}]},{"title":"코딩테스트 - 전화번호 목록","slug":"2021-02-02-tel-list","date":"2021-02-01T15:54:00.000Z","updated":"2022-05-31T07:30:09.000Z","comments":true,"path":"2021/02/02/","link":"","permalink":"http://kidongyun.github.io/2021/02/02/","excerpt":"","text":"문제전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다. 구조대 : 119박준영 : 97 674 223지영석 : 11 9552 4421전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요. 제한 사항phone_book의 길이는 1 이상 1,000,000 이하입니다.각 전화번호의 길이는 1 이상 20 이하입니다.입출력 예제phone_book return[119, 97674223, 1195524421] false[123,456,789] true[12,123,1235,567,88] false입출력 예 설명입출력 예 #1앞에서 설명한 예와 같습니다. 입출력 예 #2한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다. 입출력 예 #3첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다. 솔루션123456789101112131415161718192021import java.util.Arrays;import java.util.List;import static java.util.stream.Collectors.toList;class Solution &#123; public boolean solution(String[] phone_book) &#123; Arrays.sort(phone_book); for(int i=0; i&lt;phone_book.length - 1; i++) &#123; System.out.println(phone_book[i] + &quot;, &quot; + phone_book[i + 1]); if(phone_book[i + 1].startsWith(phone_book[i])) &#123; return false; &#125; &#125; return true; &#125;&#125; 포인트.문자열 내부에 유사 문자열이 있는지를 확인하는 문제로 공통화 시킬수 있을 것 같다.이런 문제는 우선 정렬을 하고. 그다음에 바로 앞이나 뒤만 체크하도록 하면 이중포문으로 다 체크하는 것 보다 훨씬 효율적이다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Jackson을 사용해서 배열로 시작하는 Json 문자열을 객체로 변경","slug":"2021-01-31-jackson-read-value-start-array","date":"2021-01-30T15:54:00.000Z","updated":"2022-05-31T07:29:27.000Z","comments":true,"path":"2021/01/31/","link":"","permalink":"http://kidongyun.github.io/2021/01/31/","excerpt":"","text":"단순하게 원하는 객체의 배열형으로 타입을 선언해서 readValue() 함수의 두번째 인수로 주면, 배열 타입으로 json 문자열이 객체화 되어서 반환되는데. 이 값을 Arrays.asList() 함수를 사용해서List 타입으로 변환할 수 있다. 123List&lt;Plan&gt; plans = Arrays.asList(objectMapper.readValue(response, Plan[].class));","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Jackson","slug":"Jackson","permalink":"http://kidongyun.github.io/tags/Jackson/"}]},{"title":"Spring Security + JWT 연동에 대한 고찰","slug":"2021-01-20-spring-security-jwt","date":"2021-01-20T02:38:54.000Z","updated":"2022-05-31T07:28:52.000Z","comments":true,"path":"2021/01/20/","link":"","permalink":"http://kidongyun.github.io/2021/01/20/","excerpt":"","text":"의존성 추가 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Configuration@RequiredArgsConstructorpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; private final TokenProvider jwtTokenProvider; private final MemberService memberService; private final PasswordEncoder passwordEncoder; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .csrf().disable() .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() .requestMatchers(CorsUtils::isPreFlightRequest).permitAll() .antMatchers(&quot;/api/v1/sign/up&quot;, &quot;/api/v1/sign/in&quot;).permitAll() .anyRequest().authenticated() .and().cors() .and().addFilterBefore(new JwtFilter(jwtTokenProvider), UsernamePasswordAuthenticationFilter.class); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(memberService).passwordEncoder(passwordEncoder); &#125; @Bean public CorsConfigurationSource corsConfigurationSource() &#123; CorsConfiguration configuration = new CorsConfiguration(); configuration.addAllowedOrigin(&quot;http://localhost:3000&quot;); configuration.addAllowedHeader(&quot;*&quot;); configuration.addAllowedMethod(&quot;*&quot;); configuration.setAllowCredentials(true); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;, configuration); return source; &#125;&#125; 123456789101112131415public interface TokenProvider &#123; String createToken(String email, List&lt;String&gt; roles); Authentication getAuthentication(String token); String getUsername(String token); Claims getClaims(String token); String resolveToken(HttpServletRequest request); boolean isValid(String token);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Slf4j@Component@RequiredArgsConstructorpublic class JwtTokenProvider implements TokenProvider &#123; @Value(&quot;$&#123;security.jwt.secret.key&#125;&quot;) private String secretKey; @Value(&quot;$&#123;security.jwt.token.time&#125;&quot;) private long tokenValidTime; private Key key; @PostConstruct protected void init() &#123; byte[] keyBytes = Decoders.BASE64.decode(secretKey); this.key = Keys.hmacShaKeyFor(keyBytes); &#125; @Override public String createToken(String email, List&lt;String&gt; roles) &#123; Claims claims = Jwts.claims().setSubject(email); claims.put(&quot;roles&quot;, roles); Date now = new Date(); return Jwts.builder() .setClaims(claims) .setIssuedAt(now) .setExpiration(new Date(now.getTime() + tokenValidTime)) .signWith(key, SignatureAlgorithm.HS256) .compact(); &#125; @Override public Authentication getAuthentication(String token) &#123; Claims claims = getClaims(token); Collection&lt;? extends GrantedAuthority&gt; authorities = Arrays.stream(new String[]&#123;claims.get(&quot;roles&quot;).toString()&#125;) .map(SimpleGrantedAuthority::new) .collect(toList()); User user = new User(claims.getSubject(), &quot;&quot;, authorities); return new UsernamePasswordAuthenticationToken(user, &quot;&quot;, user.getAuthorities()); &#125; @Override public String getUsername(String token) &#123; return this.getClaims(token).getSubject(); &#125; @Override public Claims getClaims(String token) &#123; return Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token).getBody(); &#125; @Override public String resolveToken(HttpServletRequest request) &#123; return request.getHeader(&quot;X-AUTH-TOKEN&quot;); &#125; @Override public boolean isValid(String token) &#123; try &#123; return !this.getClaims(token).getExpiration().before(new Date()); &#125; catch (Exception e) &#123; return false; &#125; &#125;&#125; 1234567891011121314151617181920@Slf4j@RequiredArgsConstructorpublic class JwtFilter extends GenericFilterBean &#123; private final TokenProvider tokenProvider; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; String token = tokenProvider.resolveToken((HttpServletRequest) request); if(Objects.nonNull(token) &amp;&amp; tokenProvider.isValid(token)) &#123; Authentication authentication = tokenProvider.getAuthentication(token); SecurityContextHolder.getContext().setAuthentication(authentication); &#125; chain.doFilter(request, response); &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://kidongyun.github.io/tags/Spring-Security/"},{"name":"JWT","slug":"JWT","permalink":"http://kidongyun.github.io/tags/JWT/"}]},{"title":"Swagger 커스터마이징","slug":"2021-01-20-swagger-custom","date":"2021-01-20T02:38:54.000Z","updated":"2022-05-31T07:29:12.000Z","comments":true,"path":"2021/01/20/","link":"","permalink":"http://kidongyun.github.io/2021/01/20/","excerpt":"","text":"Swagger 에 Authentication Header 추가12345678910111213141516171819202122232425262728293031323334353637@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket api() &#123; return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.ant(&quot;/api/**&quot;)) .build() .securityContexts(Collections.singletonList(securityContext())) .securitySchemes(Collections.singletonList(apiKey())); &#125; private ApiKey apiKey() &#123; return new ApiKey(&quot;JWT&quot;, &quot;x-auth-token&quot;, &quot;header&quot;); &#125; private SecurityContext securityContext() &#123; return springfox .documentation .spi.service .contexts .SecurityContext .builder() .securityReferences(defaultAuth()).forPaths(PathSelectors.any()).build(); &#125; List&lt;SecurityReference&gt; defaultAuth() &#123; AuthorizationScope authorizationScope = new AuthorizationScope(&quot;global&quot;, &quot;accessEverything&quot;); AuthorizationScope[] authorizationScopes = new AuthorizationScope[1]; authorizationScopes[0] = authorizationScope; return Collections.singletonList(new SecurityReference(&quot;JWT&quot;, authorizationScopes)); &#125;&#125; Swagger Model Naming 정책 변경하기.기본적으로 Swagger 는 리플렉션시 getSimpleName() 함수를 사용. 이렇게되면 Nested Class 가 만약 이름이 동일하다면 Swagger-ui 에서 모델을 구분하지 못한다. 이럴때 네이밍 정책을 바꿔준다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket api() &#123; return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.ant(&quot;/api/**&quot;)) .build() .securityContexts(Collections.singletonList(securityContext())) .securitySchemes(Collections.singletonList(apiKey())); &#125; private ApiKey apiKey() &#123; return new ApiKey(&quot;JWT&quot;, &quot;x-auth-token&quot;, &quot;header&quot;); &#125; private SecurityContext securityContext() &#123; return springfox .documentation .spi.service .contexts .SecurityContext .builder() .securityReferences(defaultAuth()).forPaths(PathSelectors.any()).build(); &#125; List&lt;SecurityReference&gt; defaultAuth() &#123; AuthorizationScope authorizationScope = new AuthorizationScope(&quot;global&quot;, &quot;accessEverything&quot;); AuthorizationScope[] authorizationScopes = new AuthorizationScope[1]; authorizationScopes[0] = authorizationScope; return Collections.singletonList(new SecurityReference(&quot;JWT&quot;, authorizationScopes)); &#125; @Component @Order(SwaggerPluginSupport.SWAGGER_PLUGIN_ORDER) public static class CustomTypeNameProvider implements TypeNameProviderPlugin &#123; @Override public String nameFor(Class&lt;?&gt; type) &#123; String fullName = type.getName(); return fullName.substring(fullName.lastIndexOf(&quot;.&quot;) + 1); &#125; @Override public boolean supports(DocumentationType documentationType) &#123; return true; &#125; &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Swagger","slug":"Swagger","permalink":"http://kidongyun.github.io/tags/Swagger/"}]},{"title":"Spring Security 의 기본 사용방법에 대한 고찰","slug":"2021-01-13-spring-security-basic","date":"2021-01-13T02:38:54.000Z","updated":"2022-05-31T07:28:37.000Z","comments":true,"path":"2021/01/13/","link":"","permalink":"http://kidongyun.github.io/2021/01/13/","excerpt":"","text":"스프링에서 제공해주는 인증, 권한의 기능을 활용하기 위해서 Spring Security 라이브러리를 적용했다. 처음으로 적용해본 경험으로는 다른 스프링 라이브러리와 다르게 조금은 침투적인 성향이 있는거 같다. 회원이라는 개념을 가진 객체를 다루기 위해서는 Spring Security 가 제공하는 추상 객체를 구현하여야 한다. 이부분이 처음에는 조금 어렵게 다가왔지만 조금만 이해하면 손쉽게 회원 관리를 할 수 있을 것 같다. 의존성 추가Spring Security 를 사용하기 위한 의존성을 추가한다. 스프링 부트에서 버전 관리를 해주는 의존성이기 때문에 버전설정을 하지 않아도 된다. 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; Config 파일 구현Spring Security 를 사용하기 위해서 기본적인 설정을 적용한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Configuration@RequiredArgsConstructorpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; private final MemberService memberService; /* 패스워드를 암호화시킬 인코더 객체를 생성하고 이를 빈으로 등록. */ @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; /* HTTP 통신에 대한 기본적인 설정을 한다. .csrf().disable() : CSRF(Cross Site Request Forgery) 공격에 대비하기 위한 설정. .authorizeRequests().anyRequest().authenticated() : 각 URL 별로 권한 설정이 가능한데 이 케이스는 모든 요청에 대해서 기본적인 권한처리를 한다는 의미. .httpBasic() : HTTP 통신 시 가장 기본이 되는 설정으로 등록. */ @Override protected void configure(HttpSecurity http) throws Exception &#123; http .csrf().disable() .and() .authorizeRequests() .antMatchers(&quot;/api/v1/sign/up&quot;, &quot;/api/v1/sign/in&quot;, &quot;/swagger-ui.html&quot;).permitAll() .anyRequest().authenticated() .and() .httpBasic(); &#125; /* 회원 객체를 위해 사용하는 Service와, 패스워드를 위한 인코더를 등록한다. */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(memberService).passwordEncoder(passwordEncoder()); &#125;&#125; 주의해서 봐야할 사항은 우선 WebSecurityConfigurerAdapter 인터페이스 객체를 구현해야한다. 그리고 이 객체가 가지고 있는 추상 메서드들을 필요조건에 따라서 맞추어 코드를 작성한다. 아래 코드는 http 설정을 하는 방법을 예시로 가져왔다. 1234567891011121314151617181920@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .antMatchers(&quot;/login&quot;, &quot;/signup&quot;, &quot;/user&quot;).permitAll() // 누구나 접근 허용 .antMatchers(&quot;/&quot;).hasRole(&quot;USER&quot;) // USER, ADMIN만 접근 가능 .antMatchers(&quot;/admin&quot;).hasRole(&quot;ADMIN&quot;) // ADMIN만 접근 가능 .anyRequest().authenticated() // 나머지 요청들은 권한의 종류에 상관 없이 권한이 있어야 접근 가능 .and() .formLogin() .loginPage(&quot;/login&quot;) // 로그인 페이지 링크 .defaultSuccessUrl(&quot;/&quot;) // 로그인 성공 후 리다이렉트 주소 .and() .logout() .logoutSuccessUrl(&quot;/login&quot;) // 로그아웃 성공시 리다이렉트 주소 .invalidateHttpSession(true) // 세션 날리기 ;&#125; 회원 도메인 객체 생성12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Slf4j@Getter@Setter@ToString(exclude = &quot;cells&quot;)@Builder@NoArgsConstructor@AllArgsConstructor@Entitypublic class Member implements UserDetails &#123; @Id private String email; private String password; private String auth; /* 이 함수에서 반환된 결과가 이 멤버가 가지고 있는 권한 정보이다. auth 값에 &quot;USER, ADMIN&quot; 이렇게 들어있다면 USER, ADMIN 두 권한을 가지는 것이다. */ @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; Set&lt;GrantedAuthority&gt; roles = new HashSet&lt;&gt;(); for(String role : auth.split(&quot;,&quot;)) &#123; roles.add(new SimpleGrantedAuthority(role)); &#125; return roles; &#125; /* 회원 객체에서 ID에 해당하는 값을 반환시킨다 */ @Override public String getUsername() &#123; return email; &#125; /* 계정의 만료 여부를 반환하는 함수 */ @Override public boolean isAccountNonExpired() &#123; return true; &#125; /* 계정의 잠금 여부를 반환하는 함수 */ @Override public boolean isAccountNonLocked() &#123; return true; &#125; /* 패스워드의 만료 여부를 반환하는 함수 */ @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; /* 계정 사용 가능 여부를 반환하는 함수 */ @Override public boolean isEnabled() &#123; return true; &#125;&#125; 여기서는 회원으로 사용할 도메인 객체에 Spring Security 에서 제공하는 추상 클래스 UserDetails 를 구현한다.이 객체는 꽤 많은 추상 메서드들을 구현해야 하는데 주석에 각 추상 메서드의 기능을 적어두었다. 구현해야하는 코드가 많아서 조금은 마음에 안들지만 이해하면 그렇게 어렵지 않다. Service 구현123456789101112131415161718@Slf4j@Servicepublic class MemberService implements UserDetailsService &#123; private MemberRepository memberRepository; @Autowired public MemberService(MemberRepository memberRepository) &#123; this.memberRepository = memberRepository; &#125; @Override public Member loadUserByUsername(String email) throws UsernameNotFoundException &#123; return memberRepository.findByEmail(email) .orElseThrow(() -&gt; new UsernameNotFoundException(email)); &#125;&#125; UserDetailsService 인터페이스를 구현하고, loadUserByUsername() 함수를 구현한다. 주의할 점은 반환형이 우리가 사용하는 회원 객체로 바꾸어 준다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://kidongyun.github.io/tags/Spring-Security/"}]},{"title":"비즈니스 중심 API vs 도메인 중심 API 설계에 대한 고찰","slug":"2021-01-12-domain-api-business-api","date":"2021-01-12T11:00:00.000Z","updated":"2022-05-31T07:28:12.000Z","comments":true,"path":"2021/01/12/","link":"","permalink":"http://kidongyun.github.io/2021/01/12/","excerpt":"","text":"API 개발자로 살면서 API를 어떻게 개발해야 좋은 구조를 가지는 것인가에 대한 생각은 정말 끊임이 없었다. 나는 글은 이러한 나의 고민에 대한 결과를 남겨두려고 쓴다. 말 그대로 이 글은 저자의 주관적인 생각이 포함되어 있기 때문에 맹목적인 신뢰는 지양한다. 비즈니스 중심의 API내가 회사에서 API를 만드는 경우는 기본적으로 API 제작 요청이 들어온 경우다. 즉 그말은 특정 API를 사용해야할 고객이 있다는 이야기이고 그 고객을 위한 맞춤 API를 제작한다. 이 고객은 우리 API를 사용하는 클라이언트 개발자일 것이다. 여기서 한가지 인지해야하는 점은 바로 고객이 있다는 점이다. 비즈니스 중심 API 라는 단어는 말 그대로 비즈니스에 맞추어 API를 만든다는 것이다. 만약에 비즈니스에서 API 개발자에게 A, B, C 라고 구분되는 기능을 요구할 경우, 비즈니스 중심의 API는 A, B, C를 함께 버무려서 요청한 클라이언트 개발자가 사용하기 쉽도록 해준다. 기본적으로 API를 비즈니스 기준으로 설계하는 방법은 조금은 오래된 기술로 볼 수 있다. 그 배경은 React, Vue 와 같은 프론트 쪽의 라이브러리, 프레임워크가 나타나기 전에는 Javascript의 영향력은 지극히 낮았다. Javascript를 사용하지 않고 프론트 화면을 구성하려면 기본적으로 jsp, Thymeleaf 와 같은 기술로 서버 사이드 렌더링을 해야하는데 서버 사이드 렌더링은 기본적으로 프론트 쪽으로 비즈니스 로직을 가져갈 수 없다. 그 자체로는 동적인 처리를 할 수 없기 때문이다. 그렇기 때문에 API를 설계할 때에도 A, B, C 세 기능을 요구한다면 이 클라이언트의 비즈니스에 맞게 모두 내려줄 수 밖에 없었다. 클라이언트 사이드 렌더링의 시작Javascript 기술의 활용도가 급격히 증가함에 따라서 React, Vue 와 같은 라이브러리의 사용이 급증하였고, 이로 인해 변한 것은 매우 많지만 그 중 하나는 클라이언트 쪽에서 비즈니스 로직을 처리할 능력을 가지게 된 것이다. 물론 그 전에도 순수 Javascript 만으로 처리는 할 수 있었지만, 그러한 개발 방식이 대중화 되어 있지는 않았다. 프론트 쪽 프레임워크의 사용과 함께 이런 개발 패턴이 변하게 된 것이다. 클라이언트 사이드 렌더링을 하게 되면 비즈니스 로직을 클라이언트 쪽에서 처리할 수 있음으로 API를 클라이언트의 비즈니스 요구에 맞게 맞추어서 내려보내지 않아도, 클라이언트에서 여러 API를 짜집어 사용할 수 있다. 예를 들어서 위의 경우 A, B, C의 기능을 제공하기 위해 이 세가지를 버무리고 한 API로 내려줬지만, 클라이언트 사이드 렌더링을 하는 고객이라면 A, B, C 기능을 독립적인 API로 두고 이를 클라이언트가 원하는대로 사용하게 할 수 있다. 이렇게 클라이언트의 요청에 맞추어 API 구조를 설계하는 것이 아니고, API 서비스르 하는 서버의 도메인을 기준으로 API 를 만들 수 있게 된 것 이다. 도메인 중심의 API기본적으로 OpenAPI 라는 것을 개발자라면 들어본 적이 있을 것이다. 위에서 우리가 만든 API와 OpenAPI의 가장 큰 차이점은 API를 만드는 시점에 고객이 있는가 없는가의 차이다. OpenAPI는 특정 고객을 위한 API가 아닌 말 그대로 열린 API를 만드는 것이기 때문에 어떠한 비즈니스에 종속적이지 않은 구조로 API를 설계하는 것이 중요하다. 보통 이러한 구조를 만들어 내개 위해 API 서비스 도메인 중심의 설계를 한다. API 설계 방식에 대한 결론그렇다면 도메인 중심의 API가 최근의 트렌드이기 때문에 옳은가? 라는 질문은 사실 적절하지 않다. 최근에도 서버 사이드 렌더링이 가지고 있는 장점을 다시 살리기 위해서 Next.js 등의 기술들이 등장하고 있다. 즉 API 설계를 할때 위 두가지 방식이 다른 특성을 가지고 있으며, 적재적소에 알맞은 형태의 API를 구현하는 것이 결국엔 정답이다. 하지만 한가지 명확하게 둘 수 있는 것은, API 서비스 코드를 작성할 때 도메인의 원자성을 살리지 않고 비즈니스에 맞춰진 코드를 선행하여 만들게 되면, 후에 도메인 중심의 API를 만드는 것은 사실 어렵다. 이미 코드들이 특정 비즈니스에 종속이 되어있기 때문이다. 하지만 반대로 도메인 중심으로 코드를 작성한 후에 비즈니스에 맞춘 API를 구현하는 것은 상대적으로 더 쉽다. 왜냐하면 독립적인 도메인 기반 코드들을 서로 버무려주기만 하면 되니까 말이다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"API","slug":"API","permalink":"http://kidongyun.github.io/tags/API/"}]},{"title":"어노테이션에 값 넘겨받는 방법에 대한 고찰","slug":"2021-01-06-aop-annotation-spel","date":"2021-01-06T11:00:00.000Z","updated":"2022-05-31T07:25:56.000Z","comments":true,"path":"2021/01/06/","link":"","permalink":"http://kidongyun.github.io/2021/01/06/","excerpt":"","text":"Aspect 객체에 동적으로 들어오는 데이터를 넘겨야하는 경우가 생길 때가 있다. 보통 이럴 때에 나는 커스텀 어노테이션을 만들고 이 어노테이션 값에 SpEL 문법을 활용하여 동적으로 들어온 데이터를 넘겨주는데 이 방법을 남겨둔다. Aspect 쪽에서 동적 데이터가 필요한 배경로깅 작업이 서버에 단순히 로그를 남겨둘 때에도 있지만 만약 좀 더 중요한 로그라면 별도의 데이터베이스 테이블을 구성하고 이 곳에 보통 저장해둔다. 이런 로그들은 비지니스 관련하여 중요도가 높은 로그일 경우가 많은데 보통 이런 로그는 후에 로그를 찾을 때 질의를 쉽게 하기 위해서 ID 값을 함께 넣어둔다. 이런 로깅을 AOP로 처리하기 위해서는 ID 값을 파라미터에서 가져와야 하는데 파라미터의 구조는 함수마다 다르기 떄문에 어떤 값이 ID에 해당하는지 Aspect 객체는 알 수가 없다. 그렇기 떄문에 이를 함수쪽에서 어떤 값이 ID인지를 매핑해주어야 하는데 이 때 SpEL 문법을 활용한다. 구현12345678@Documented@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface ExampleLog &#123; String id() default &quot;&quot;;&#125; 우선 어노테이션을 만든다. 이 어노테이션을 id 값을 가지고 있으며, 여기를 통해서 동적으로 데이터를 넘겨줄 것이다. 1234567891011@ExampleLog(id = &quot;#id&quot;)public String example1(String id) &#123; return id;&#125;@ExampleLog(id = &quot;#value&quot;)public String example2(String value) &#123; return value;&#125; 이 어노테이션을 활용해서 데이터를 넘겨주는 함수부분이다. 보면은 파라미터가 어떤 이름으로, 어떤 구조로 들어오는지 알 수 없기 때문에 위와 같이 SpEL 문법으로 매핑을 시켜주고 있다. 1234567891011121314151617181920212223242526272829303132@Slf4j@Aspect@Componentpublic class ExampleLogAspect &#123; @Around(value = &quot;@annotation(ExampleLog)&quot;) public Object log(ProceedingJoinPoint joinPoint) throws Throwable &#123; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); ExampleLog annotation = method.getAnnotation(ExampleLog.class); Object id = getDynamicValue(signature.getParameterNames(), joinPoint.getArgs(), annotation.id()); log.info(&quot;ID : &quot; + id); // 로그 테이블에 추가 return joinPoint.proceed(); &#125; public static Object getDynamicValue(String[] parameterNames, Object[] args, String key) &#123; ExpressionParser parser = new SpelExpressionParser(); StandardEvaluationContext context = new StandardEvaluationContext(); for (int i$ = 0; i$ &lt; parameterNames.length; i$++) &#123; context.setVariable(parameterNames[i$], args[i$]); &#125; return parser.parseExpression(key).getValue(context, Object.class); &#125;&#125; Aspect 쪽 코드이다. Around 에 ExampleLog 어노테이션을 주어서 해당 어노테이션이 설정되어 있는 함수들은 이 AOP 가 적용되도록 하였다, 후에는 리플렉션과 SpEL Parser 를 활용하여 ID에 해당하는 값을 찾아낸다. 그 다음엔 로깅 목적으로 사용하는 테이블에 데이터를 추가하면 된다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Annotation","slug":"Annotation","permalink":"http://kidongyun.github.io/tags/Annotation/"},{"name":"A.O.P","slug":"A-O-P","permalink":"http://kidongyun.github.io/tags/A-O-P/"}]},{"title":"테스트 코드 작성시 stub 객체 생성에 대한 고찰","slug":"2021-01-06-testcode-stubbing","date":"2021-01-06T11:00:00.000Z","updated":"2022-05-31T07:28:18.000Z","comments":true,"path":"2021/01/06/","link":"","permalink":"http://kidongyun.github.io/2021/01/06/","excerpt":"","text":"테스트 코드를 작성하다보면 서로 간에 의존성을 가지고 있어서 테스트를 하기 어려운 상황들을 직면하게 된다. 이를 해결했던 나의 경험들을 남겨두려고 한다. 이 글은 저자의 주관적인 생각이 포함되어 있음으로 맹목적인 신뢰는 지양하기 바란다. 외부 리소스 코드의 분리테스트하려는 코드가 의존성을 가지고 있어서 테스트하기가 어렵다면, 이를 개선하기 위한 첫번째 방법은 해당 코드의 의존성을 제거할 수 있는지를 확인해보는 것이다. 의존성을 가지고 있다는 것은 후에 비즈니스 변경이 일어났을 때에 코드를 변경하기가 쉽지 않음으로 가능하다면 의존성은 제거하는 것이 좋다. 예를 들어 아래와 같이 덧셈을 위한 코드가 있다고 하자. 1234567891011121314151617181920212223242526272829303132/* 데이터베이스에 접근하여 데이터를 가져오는 객체. */class Database &#123; public Integer getValue() &#123; return new Random().nextInt(); &#125;&#125;/* 외부 API 에 접근하여 데이터를 가져오는 객체. */class ExternalApi &#123; public Integer getValue() &#123; return new Random().nextInt(); &#125;&#125;class Example &#123; Database database; ExternalApi externalApi; public Example(Database database, ExternalApi externalApi) &#123; this.database = database; this.externalApi = externalApi; &#125; public Integer add() &#123; Integer value1 = database.getValue(); Integer value2 = externalApi.getValue(); return value1 + value2; &#125;&#125; 이 코드에서 ‘value1’ 값은 데이터베이스에서 가져오고 있고, ‘value2’ 값은 외부 API에서 가져오고 있다. 즉 데이터베이스와, 외부 API에 의존성을 가지고 있다는 것이다. 이렇게 되면 이 두 영역과 관련된 소스들 우리가 관리할 수 있는 부분이 아니기 때문에 이 의존성을 제거하는 것이 좋다. 테스트 코드는 항상 일관된 결과를 반환해야 한다. 하지만 위와 같이 의존성을 가진 코드가 테스트 커버리지 안에 존재하게 된다면 데이터베이스나, 외부 API의 변화에 따라서 코드는 동일하다 하더라도 일관된 결과를 얻지 못한다. 이렇듯 의존성을 가진 함수는 이 의존성 때문에 테스트하기가 어려워진다. 아래는 예시의 테스트 코드이다. 12345678910111213public class ExampleTest &#123; @Test public void add_test() &#123; Example example = new Example(new Database(), new ExternalApi()); /* add() 함수의 결과가 데이터베이스, 외부 API 결과에 의존됨으로 일관된 결과를 가질 수 없다. */ Integer result = example.add(); assertThat(result).isEqualTo(1); &#125;&#125;&#125; 이러한 문제를 개선하기 위해서 생각해야할 것은 바로 비즈니스 코드와, 외부 코드를 구분할 필요성이 있다. 일반적으로 테스트를 해야할 코드는 우리의 비즈니스 코드이다. 즉 우리 관할안에 있는 코드를 테스트하고 관리해야한다. 위에서 우리의 비즈니스 코드는 두 값을 더하는 부분이며, 외부 코드는 데이터베이스와, 외부 API를 호출하는 부분이다. 보통 이런 외부 코드는 함수의 인수로 받게 하여 비즈니스 코드와 구분을 짓고, 의존성을 관리할 수 있도록 한다. 아래는 의존성 문제를 개선한 add() 함수이다. 12345678910111213141516171819202122class Example &#123; Database database; ExternalApi externalApi; public Example(Database database, ExternalApi externalApi) &#123; this.database = database; this.externalApi = externalApi; &#125; public Integer callAdd() &#123; Integer value1 = database.getValue(); Integer value2 = externalApi.getValue(); return add(value1, value2); &#125; public Integer add(Integer value1, Integer value2) &#123; return value1 + value2; &#125;&#125; 이렇게 작성하게되면 add() 함수의 관점에서는 외부에 종속된 코드는 모두 파라미터로 받았기 때문에 그 내부에서는 항상 일관된 결과를 반환할 수 있다. 그리고 일관된 결과를 얻을 수 있기 때문에 테스트 코드도 작성이 가능하다. 추가적으로 이런 일관된 결과를 반환하도록 함수를 순수함수라고 한다. (정확히는 순수함수 특성 중 하나) 순수함수의 형태로 함수를 작성하는 것은 의존성을 제거하는데에 좋다. 1234567891011121314public class ExampleTest &#123; Example example; @Test public void add_test() &#123; Integer value1 = 3; Integer value2 = 5; Integer result = example.add(value1, value2); assertThat(result).isEqualTo(8); &#125;&#125; 이 테스트 코드의 목적은 우리의 비즈니스 코드인 add() 함수가 정상적으로 동작하는 것인지 확인하는 것이다. 여기에 외부에서(데이터베이스, API) 에서 값이 들어오는 과정은 중요하지 않다. 왜냐하면 이 값들은 외부에서 들어오기 때문에 우리가 테스트를 한다고 해서 우리가 수정할 수 있는 영역이 아니기 때문이다. 즉 이것 자체를 테스트하는 것은 무의미 하다. 의존성을 가진 코드를 테스트 하기그럼에도 뭔가 꺼림직함을 느끼는 사람들이 있을 것이다. 왜냐하면 결국 외부 의존성을 가진 코드는 call() 함수가 가져갔고, 우리는 이 함수는 테스트하지 않았기 때문이다. 코드를 작성하다보면 불가피하게 의존성을 불러오는 코드쪽에도 비즈니스 코드가 들어가야할 때가 있다. 예를 들면 null 처리이다. 12345678910111213141516171819202122232425262728293031 class Example &#123; Database database; ExternalApi externalApi; public Example(Database database, ExternalApi externalApi) &#123; this.database = database; this.externalApi = externalApi; &#125; public Integer callAdd() throws Exception &#123; Integer value1 = database.getValue(); if(Objects.isNull(value1)) &#123; throw new Exception(&quot;&#x27;value1&#x27; must not be null&quot;); &#125; Integer value2 = externalApi.getValue(); if(Objects.isNull(value2)) &#123; throw new Exception(&quot;&#x27;value2&#x27; must not be null&quot;); &#125; return add(value1, value2); &#125; public Integer add(Integer value1, Integer value2) &#123; return value1 + value2; &#125;&#125; 위와 같은 코드를 작성하려 한다면 비지니스 코드가 call() 함수에도 어느정도 내포되어 있기 때문에 테스트를 해야할 필요성이 생길수도 있다. 이렇게 call() 함수처럼 의존성을 가진 함수를 테스트하는 방법을 소개한다. 추상체의 구현위 call() 함수에서 테스트하기 어렵게 만드는 것은 외부에 의존성을 가진 ‘database.getValue()’, ‘externalApi.getValue()’ 이 두 함수인데, 이 둘을 대신할 가짜 객체를 생성해서 테스트할 수 있다. 가짜 객체를 만드는 첫번째 방법은 바로 추상체의 구현이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485interface Database &#123; Integer getValue();&#125;class DatabaseImpl implements Database &#123; public Integer getValue() &#123; return new Random().nextInt(); &#125;&#125;interface ExternalApi &#123; Integer getValue();&#125;class ExternalApiImpl implements ExternalApi &#123; public Integer getValue() &#123; return new Random().nextInt(); &#125;&#125;class Example &#123; Database database; ExternalApi externalApi; public Example(Database database, ExternalApi externalApi) &#123; this.database = database; this.externalApi = externalApi; &#125; public Integer callAdd() throws Exception &#123; Integer value1 = database.getValue(); if(Objects.isNull(value1)) &#123; throw new Exception(&quot;&#x27;value1&#x27; must not be null&quot;); &#125; Integer value2 = externalApi.getValue(); if(Objects.isNull(value2)) &#123; throw new Exception(&quot;&#x27;value2&#x27; must not be null&quot;); &#125; return add(value1, value2); &#125; public Integer add(Integer value1, Integer value2) &#123; return value1 + value2; &#125;&#125;class Main &#123; public static void main(String[] args) throws Exception &#123; /* 실제 소스에서는 추상체를 구현한 객체를 사용한다. */ Example example = new Example(new DatabaseImpl(), new ExternalApiImpl()); example.callAdd(); &#125;&#125;class ExampleTest &#123; @Test public void callAdd_test() throws Exception &#123; /* 테스트코드에서는 추상체를 직접 구현하여 원하는 값을 반환하도록 함. */ Database database = new Database() &#123; @Override public Integer getValue() &#123; return 3; &#125; &#125;; /* 테스트코드에서는 추상체를 직접 구현하여 원하는 값을 반환하도록 함. */ ExternalApi externalApi = new ExternalApi() &#123; @Override public Integer getValue() &#123; return 5; &#125; &#125;; Example example = new Example(database, externalApi); Integer result = example.callAdd(); assertThat(result).isEqualTo(8); &#125;&#125; 추상체 구현방법을 활용해서 의존성을 가진 함수를 테스트하기 위해서는 우선 의존성을 내포한 객체 여기서는 Database, ExternalApi 를 추상화 시킨 객체가 필요하다. 그래서 두 타입의 interface 를 만들고, 이 인터페이스를 구현받아서 실제 소스에서 사용하는 코드를 작성한다. 그 부분이 Impl 이 붙은 부분이다. 테스트 시에는 이 인터페이스를 구현한 Impl 객체를 사용하지 말고 직접 구현하여 가짜 객체를 생성한다. 한 인터페이스로 묶여있기 때문에 이 가짜 객체가 callAdd() 함수에 넘겨졌을 때 정상적으로 동작할 것이다. 위 방식은 익명클래스를 활용한 방법인데, 가독성이 현저히 떨어진다. 만약 java8 버전 이상 사용하고 있다면 람다 표현식을 사용할 수 있으므로 이로 대체하자. 그렇다면 보다 훨씬 읽기 쉬워질 것이다. 1234567891011121314151617181920212223@FunctionalInterfaceinterface Database &#123; Integer getValue();&#125;@FunctionalInterfaceinterface ExternalApi &#123; Integer getValue();&#125;class ExampleTest &#123; @Test public void callAdd_test() throws Exception &#123; Database database = () -&gt; 3; ExternalApi externalApi = () -&gt; 5; Example example = new Example(database, externalApi); Integer result = example.callAdd(); assertThat(result).isEqualTo(8); &#125;&#125; 추상체 구현방법은 사실상 한계가 명확하다. 그 첫번째는 익명클래스를 사용하는 방법은 굉장히 가독성이 떨어졌다. 그래서 람다표현식을 활용했는데, 람다표현식은 한 인터페이스에 한 함수가 존재할때만 사용이 가능한 문법이기 때문에 만약 Database 객체와, ExternalApi 객체가 두개 이상의 함수를 가지고 있다면 람다표현식 사용이 불가능하다. 두번째 문제가 더 중요한데 바로 테스트를 위해서 프로덕션 소스에 있는 객체의 추상체를 구현하면 안된다. 다시 말해서 단순히 테스트를 위해서 프로덕션 코드가 변경되면 안된다는 것이다. 이는 주객전도가 되는 일이며, 정말 그래야 하는 상황이 온다면 다시 생각해봐야한다. Mock 객체 활용이렇게 추상체를 구현해서 가짜 객체를 생성하는 방법은 제한사항이 많다. 이번에는 보다 널리 사용되는 Mock 라이브러리를 활용해보려고 한다. 이 라이브러리를 활용하면 추상체를 굳이 생성하지 않아도 가짜 객체를 생성하여 의존성을 대체할 수 있다. 세부적인 동작 원리는 잘 알지 못하지만, 기본적으로 Mock 라이브러리는 테스트시에 필요한 객체들이 생성되고 난 후 그 객체들에게 설정된 가짜 객체들을 대체 주입한다. 123456789101112131415161718192021222324public class ExampleTest &#123; @Mock Database databaseMock; @Mock ExternalApi externalApiMock; @InjectMocks Example exampleMock; public void setUp() &#123; MockitoAnnotations.openMocks(this); &#125; @Test public void callAdd_test() &#123; when(databaseMock.getValue()).thenReturn(3); when(externalApiMock.getValue()).thenReturn(5); Integer result = exampleMock.callAdd(); assertThat(result).isEqualTo(8); &#125;&#125; 위와 같이 작성하면 메인 소스를 수정하지 않고 Mock 객체를 생성할 수 있으며 이를 활용해 의존성을 제거하고 비지니스 코드만을 테스트할 수 있다. @Mock, @InjectMocks 어노테이션들은 생성되어진 리얼 객체를 기반으로 가짜 Mock 객체를 덮어씌운다. 그렇기 때문에 database, externalApi 와 같이 Mock 주입을 할 객체들은 final 로 생성하면 Mock 주입을 받을 수 없다. 테스트를 위해서 메인 소스 코드가 변경되는 것은 옳지 않지만 아직 위의 케이스를 해결할 방법은 공부하지 못했다. PowerMock 이나 TestNG 라이브러리를 사용하면 된다고 하는데 다음에 찾아보도록 하자. ArgumentMatchers 라이브러리 활용기본적으로 Mock 객체를 생성할 때 when() 절에 들어가는 파라미터도 모두 동일해야 실제로 가짜 객체 주입이 이루어진다.그러나 이 파라미터들을 실제로 모두 맞추는 작업이 굉장히 번거롭다. 이런 상황을 위해서 mockito 라이브러리에서는 ArgumentsMatchers 객체를 제공하는데, 이 객체를 사용하면 파라미터의 값을 정확히 맞추지 않고 타입만 맞추면 가짜 객체 주입을 시킬 수 있다. 1234567/* ArgumentMatchers 사용하지 않는 경우. findById() 함수에 들어가는 파라미터도 동일하게 맞추어야 한다 */when(objectiveService.findById(1L)).thenReturn(stub);/* ArgumentMatchers 사용한 경우. Long 타입만 맞으면 자동 Mocking 된다 */when(objectiveService.findById(anyLong())).thenReturn(stub); Mock 에서 Real 객체 사용@Mock 어노테이션을 붙여서 생성된 객체들은 기본적으로 실제 로직을 사용하지 않는다. 만약 사용하고 싶다면 아래 옵션을 주면 된다. 1234@Mock(answer = Answers.CALLS_REAL_METHODS)MypageMapper mypageMapper; WireMock (Stub Server)외부 서버도 일종의 가짜 서버를 두고싶을 때 사용하는 라이브러리이다. 위에서 언급한 Stub을 만드는 방법은 결국 소스코드 레벨에서 테스트하는 방법이기 떄문에. 스테이징 수준으로 테스트 레벨이 올라가게 되면 기획자나 다른 비개발자 직군은 테스트가 불가능하다. 이럴 때는 고정적인 가짜 데이터를 줄수 있는 Stub 서버를 하나 구축하는 방법도 있다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Test","slug":"Test","permalink":"http://kidongyun.github.io/tags/Test/"},{"name":"Stub","slug":"Stub","permalink":"http://kidongyun.github.io/tags/Stub/"}]},{"title":"예외 처리 방법에 대한 고찰","slug":"2021-01-05-exception-handling","date":"2021-01-05T11:00:00.000Z","updated":"2022-05-31T07:25:41.000Z","comments":true,"path":"2021/01/05/","link":"","permalink":"http://kidongyun.github.io/2021/01/05/","excerpt":"","text":"Java 프로그래밍 책을 맨 처음 펼치고 조금 읽다보면 ‘try-catch’ 키워드를 활용한 예외처리 문법이 소개된다. 프로그래밍을 얼마 접하지 않은 초급 개발자들도 이 ‘try-catch’ 키워드는 낯설지 않을 것이다. 그러나 정작 이 예외처리 문법을 보다 효율적으로 사용하는 할 수 있는 방법에 대해서는 쉽게 익혀지지 않는 것 같다. Java 프로그래밍 언어를 활용한 API 개발을 하면서 경험적으로 느낀 예외처리에 대한 나의 생각을 간단하게 적으려고 한다. 이 글은 저자의 주관적인 생각을 바탕으로 작성되었으므로 맹목적인 신뢰는 지양한다. ‘try-catch’ 키워드의 숨겨진 의미1234567try &#123; // 이 범위 안에서 무언가를 시도한다.&#125; catch(Exception e) &#123; // 호출한 함수가 오류를 반환할 경우 예외처리 한다.&#125; ‘무언가를 시도하고 뜻대로되지 않았을 때에는 오류를 잡아라.’ 이런 느낌에서 ‘try-catch’ 용어를 사용한 것 같다. 이 키워드는 결론적으로 이야기 하자면, 클라이언트 범주에 해당하는 코드에 사용된다. 클라이언트 코드라는 것은 어떤 특정 함수를 호출하는 함수이다. 그리고 이 반대의 개념으로 서비스 코드는 함수 호출 요청이 들어오면 특정 작업을 해주고 결과를 반환해준다. 이 개념은 우리가 흔히 아는 웹클라이언트, 웹서버의 개념과 동일하다. 사실 좀 더 폭넓게 생각해보면 우리가 작성하는 모든 코드는 이러한 클라이언트 코드와, 서비스 코드로 나눌수 있다. 12클라이언트 코드 : 서비스 코드의 함수를 호출하는 함수서비스 코드 : 클라이언트 코드의 요청을 받고 결과를 반환하는 함수 이 개념을 언급한 이유는 ‘try-catch’ 이 키워드는 클라이언트 코드쪽에서만 사용되는 문법이라는 점이다. 계산기 객체를 활용해 간단한 예시를 들어보자. 12345678910111213141516171819class Calculator &#123; public add(int value1, int value1) &#123; return value1 + value2; &#125;&#125;class User &#123; Calculator calculator = new Calculator(); public void calculate() &#123; try &#123; calculator.add(2, 5); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 위에서 Calculator 객체는 서비스 코드에 해당하고 User 객체는 클라이언트 코드에 해당한다. User 객체에서 Calculator 객체의 add() 함수를 호출하고 있으며, 이 함수가 어떤 결과를 반환할지 User 객체의 입장에서는 알 수 없기 때문에 ‘try-catch’ 키워드로 감싸고 있다. 위의 예제에서는 Calculator 객체의 add() 함수가 오류를 반환한다고 보기 어렵지만 이해를 위해 add() 함수가 int 타입이 아닌 String 타입을 받게 만들어보자. 1234567891011121314151617181920class Calculator &#123; public add(String value1, String value1) &#123; return Integer.parseInt(value1) + Integer.parseInt(value2); &#125;&#125;class User &#123; Calculator calculator = new Calculator(); public void calculate() &#123; try &#123; calculator.add(&quot;2&quot;, &quot;5&quot;); // 정상 케이스 calculator.add(&quot;2&quot;, &quot;글자&quot;); // 오류 반환 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 이런 경우를 보면 왜 클라이언트 코드인 User 객체가 ‘try-catch’ 키워드로 감싸져야 하는 지가 보다 명확히 이해가 된다. 현재 우리 눈에는 Calculator 객체가 바로 보이지만 실무에서 라이브러리를 활용하다보면 서비스 코드에 해당하는 객체를 쉽게 이해하기 어렵다. 위 add() 함수처럼 간단하지 않은 로직일 가능성이 높고, 또 라이브러리 안에 서비스 코드에 해당하는 함수를 찾는 것도 어렵기 때문에 알지 못하는 서비스 코드를 받는 클라이언트 코드 관점에서 ‘try-catch’ 키워드를 사용해서 예외에 대비해야 한다. 자 그러면 반대로 서비스 코드에서는 예외를 어떻게 다뤄야 할까? 위의 소스 코드를 다시 확인해보자. calculator.add() 함수의 두번째 호출은 숫자 타입이 아니기 때문에 오류가 반환됨을 알 수 있다. 그렇다면 이 오류는 누가 반환을 하는 것일까? 나도 정확하게는 파악하지 않았지만 Integer 객체의 parseInt() 함수 내부에서 오류를 반환하고 있을 것이다. 즉 Calculator 객체와, Integer 객체의 사이에서는 Calculator 객체가 클라이언트 코드가 되고, Integer 객체가 서비스 코드가 된다. 이렇 듯 개발을 하면서 내가 짜는 코드가 클라이언트 코드가 될 수도 있고, 서비스 코드가 될 수도 있다.즉 다시 말하면, add() 함수에서도 ‘try-catch’ 키워드를 활용해 Integer 객체가 던지는 오류를 잡을 수 있다. 12345678910111213141516171819202122232425class Calculator &#123; public int add(String value1, String value2) &#123; try &#123; return Integer.parseInt(value1) + Integer.parseInt(value2); &#125; catch(Exception e) &#123; return 0; &#125; &#125;&#125;class User &#123; Calculator calculator = new Calculator(); public void calculate() &#123; try &#123; calculator.add(&quot;2&quot;, &quot;5&quot;); // 정상 케이스 calculator.add(&quot;2&quot;, &quot;글자&quot;) // 오류 반환 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; ‘throws’ 키워드를 활용한 예외의 전파위의 코드에서 add() 함수에서도 ‘try-catch’ 키워드를 사용했고, calculate() 함수에서도 ‘try-catch’ 키워드를 사용했다. 그러면 오류는 어떻게 될까. 오류는 add() 함수에서만 잡히고 calculate() 함수에서는 잡히지 않는다. 이유는 add() 함수가 프로그램 순서상 먼저 예외에 접근하기 때문이며, 이 예외라는 것이 ‘try-catch’ 키워드로 잡히게 되면 전파되지 않는다. 그렇다면 만약 예외가 발생했을 경우 add() 함수에서 이 예외를 처리하지 않고 calculate() 함수에서 처리하고 싶다면 어떻게 해야할까? 이럴 때 ‘throws’ 키워드를 사용한다. 1234567891011121314151617181920class Calculator &#123; public int add(String value1, String value2) throws Exception &#123; return Integer.parseInt(value1) + Integer.parseInt(value2); &#125;&#125;class User &#123; Calculator calculator = new Calculator(); public void calculate() &#123; try &#123; calculator.add(&quot;2&quot;, &quot;5&quot;); // 정상 케이스 calculator.add(&quot;2&quot;, &quot;글자&quot;) // 오류 반환 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 이렇게 작성하면 이전과 동일하게 calculate() 함수에서 예외가 잡힌다. ‘throw’ 키워드를 활용한 예외의 시작‘try-catch’ 키워드를 활용해 예외를 잡아냈고, ‘throws’ 키워드를 활용해 예외를 전파했다. 그러나 이쯤되면 생각이 드는 것이 그러면 예외는 과연 어디서부터 시작하는 것일까? 라는 것이다. 예외의 시작은 ‘throw’ 키워드를 통해서 만들어낼 수 있다. 이 키워드는 ‘try-catch’ 키워드와는 반대로 서비스 코드에서만 사용이 된다. ‘throw’, ‘throws’, ‘try-catch’ 이 3가지의 키워드가 서로 조화를 이루어서 예외처리를 유연하게 처리할 수 있다. 123&#x27;throw&#x27; : 예외의 출발 지점&#x27;throws&#x27; : 예외의 중간 지점&#x27;try-catch&#x27; : 예외의 도착 지점 예외를 만들어내는 간단한 예제를 생각해보자. 123456789101112131415161718192021222324class Calculator &#123; public int add(String value1, String value2) throws Exception &#123; if(value1.replaceAll(&quot;[^0-9]&quot;, &quot;&quot;).isEmpty()) &#123; throw new Exception(); &#125; return Integer.parseInt(value1) + Integer.parseInt(value2); &#125;&#125;class User &#123; Calculator calculator = new Calculator(); public void calculate() &#123; try &#123; calculator.add(&quot;2&quot;, &quot;5&quot;); // 정상 케이스 calculator.add(&quot;2&quot;, &quot;글자&quot;) // 오류 반환 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; add() 함수에서 value1 값에 숫자가 아닌 값들은 지우고, 지우고 난 뒤에 숫자가 없다면 예외를 발생시켜 전파하는 예제이다. 이 전파된 예외는 calculate() 함수에서 잡아서 처리된다. 예외처리는 이렇게 이 3가지 키워드가 전부이며 기본적으로 이 규칙만 이해하면 된다. 그렇다면 언제 예외를 생성해야 할까? 클라이언크 코드 관점에서는 서비스 코드가 어떤 값을 반환할지 모르기 때문에 서비스 코드의 반환 값이 불안정 요소이다. 반대로 서비스 코드 관점에서는 클라이언트 코드의 입력 파라미터가 어떻게 들어올지 모르기 때문에 이 파라미터 값이 불안정 요소이다. 사실 대부분 코드에서 불안정 요소는 이 두가지에 해당한다. 12345678/* parameter 라는 값은 클라이언트 코드에서 받아오는 값이며, example() 이라는 서비스 코드에게는 알 수 없는 미지의 값이다.*/String example(String parameter) &#123; /* service.call() 함수는 반대로 서비스 코드에게서 반환되는 값이며, 이 또한 example() 이라는 클라이언트 코드에게는 알 수 없는 미지의 값이다. */ return service.call(parameter);&#125; 위와 같이 불안정 요소에 대해서 조치를 해야할 때 예외 처리를 해야하며, 처리 가능 여부에 따라서 조치 내용이 다르다. 1234567처리가 가능한 예외가 발생한 경우-&gt; 비지니스 적으로 보완이 가능한 로직을 수행하도록 분기한다.처리가 불가능한 예외가 발생한 경우-&gt; 상세 에러 메시지를 포함하여 예외를 던진다. 클라이언트 코드에서 예외처리를 하는 것이 보다 유연하다어쩌다보니 예외처리에 대한 기본적인 문법도 위에서 언급하게 되었는데, 예외처리를 위한 각 키워드들이 가지고 있는 목적을 좀 더 명확하게 하는데 도움이 되는거 같아 남겨두었다. 내가 쓰고싶었던 글은 지금부터의 글인데, 저자가 스프링 프레임워크 기반으로 API 개발을 할 때 예외처리를 어떻게 하는 것이 보다 유연하고 효율적일까를 고민한 것으로 API 개발에 종속적인 내용일 수 있다. 보통 스프링 프레임워크에서 클라이언트 코드라고 하면 Controller 영역을 이야기하고, 서비스 코드라고 하면 Service 영역을 이야기한다. 이러한 상황에서 예외처리는 Service 영역에서 하는 것 보다 Controller 영역에서 하는 것이 보다 더 유연하다. 한가지 예제 소스와 함께 이해해보자. 위와 동일하게 Calculator 객체가 있고, 이 객체를 User1, User2 객체가 사용하고 있다. 즉 User1, User2 두 객체가 클라이언트 코드가 되고, Calculator 객체가 서비스 코드가 된다. 현재 예제에는 Calculator 객체에서 ‘try-catch’ 키워드를 활용해 예외 처리를 끝냈으며, 이 예외는 User1, User2 두 객체에게 전달되지 않는다. 여기서 발생하는 문제점은 User1, User2 두 객체가 add() 함수에서 오류가 발생했을 때 그에 대한 조치를 각자 비지니스에 맞게 조절할 수 없다는 것이다. 만약 User1 객체에서는 calculate() 함수를 호출하고 오류가 났을 때, 기본 값으로 ‘0’을 주고 싶고, User2 객체에서는 기본 값으로 ‘-1’을 주고 싶어 한다면 User2 객체는 예외를 이미 Calculator 객체가 잡아 버렸기 때문에 이 ‘-1’ 값을 줄 타이밍을 알 수 없다. 123456789101112131415161718192021222324252627class Calculator &#123; public int add(String value1, String value2) throws Exception &#123; try &#123; return Integer.parseInt(value1) + Integer.parseInt(value2); &#125; catch (Exception e) &#123; return 0; &#125; &#125;&#125;class User1 &#123; Calculator calculator = new Calculator(); public void calculate() &#123; calculator.add(&quot;2&quot;, &quot;5&quot;); &#125;&#125;class User2 &#123; Calculator calculator = new Calculator(); public void calculate() &#123; calculator.add(&quot;2&quot;, &quot;5&quot;); &#125;&#125; 이처럼 예외에 대한 클라이언트 코드의 대처는 비지니스에 따라서 달라질 수 있기 때문에 예외처리는 최대한 클라이언트쪽에서 하는 것이 보다 유연해진다. 그래서 스프링 프레임워크를 사용하는 경우 대부분 서비스, 데이터 액세스 레벨, 외부 데이터 연동 등과 같은 구간에서는 예외를 ‘throws’ 키워드를 활용해 전파하기만 하고 예외를 직접 처리하지는 않는다. 예외를 실제 처리하는 부분은 가장 클라이언트 쪽 코드인 Controller 영역에서 예외처리를 담당한다. 그렇게 하는 것이 위와 같은 이유로 보다 유연하기 때문이다. 123456789101112131415161718192021public class Controller &#123; @GetMapping(&quot;/api1&quot;) public ResponseEntity&lt;?&gt; api1() &#123; try &#123; return ResponseEntity.status(HttpStatus.OK).body(HttpStatus.OK.getReasonPhrase); &#125; catch (Exception e) &#123; return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase()); &#125; &#125; @GetMapping(&quot;/api2&quot;) public ResponseEntity&lt;?&gt; api2() &#123; try &#123; return ResponseEntity.status(HttpStatus.OK).body(HttpStatus.OK.getReasonPhrase); &#125; catch (Exception e) &#123; return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase()); &#125; &#125;&#125; @Advice그러면 Contoller 보다 더 클라이언트에 쪽에 가까운 코드는 없을까? 사실은 없다. 왜냐면 비지니스 관점에서 Controller 다음 영역은 프론트 엔드 영역으로 넘어가기 때문이다. 하지만 스프링 프레임워크에서는 @Advice 어노테이션을 활용해 Controller 보다 더 클라이언트 코드인 영역을 제공한다. 사실 @Advice의 존재는 위에서 내가 설명한 것과 조금은 역설적이다. 왜냐하면 예외처리를 클라이언트 코드 쪽에서 해야한다고 한 이유는 보다 더 비지니스에 유연할 수 있기 때문이라고 했는데, @Advice 의 존재는 비지니스와는 관련이 없기 때문이다. 그렇다면 이 @Advice는 왜 나타났을까? 클라이언트 코드로 예외처리를 넘기게되면 생기는 단점은 유연성이 많이 생기는 만큼 클라이언트 코드 쪽에서 대처해야하는 코드가 많아진다. 만약 이 대처가 동일하다면 그만큼 코드의 중복이 생긴다고 볼수있다. 위에서 보여준 Controller 코드 예시도 예외처리 부분에서 INTERNAL_SERVER_ERROR 를 보내는 방식으로 동일한 대처를 하고있기 때문에 코드가 중복되고 있다. 즉 유연성이 늘어난 만큼 이를 활용하지 않고 모두 동일한 예외처리를 한다면 이는 모두 중복된 코드가 될 수 있다는 것이다. 이러한 중복을 개선시키기 위해서 @Advice 어노테이션이 등장했다. 123456789101112131415161718192021222324// Advice@RestControllerAdvicepublic class Advice &#123; @ExceptionHandler(Exception.class) public ResponseEntity&lt;?&gt; exception(Exception e) &#123; return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase()); &#125;&#125;// Controllerpublic class Controller &#123; @GetMapping(&quot;/api1&quot;) public ResponseEntity&lt;?&gt; api1() &#123; return ResponseEntity.status(HttpStatus.OK).body(HttpStatus.OK.getReasonPhrase); &#125; @GetMapping(&quot;/api2&quot;) public ResponseEntity&lt;?&gt; api2() &#123; return ResponseEntity.status(HttpStatus.OK).body(HttpStatus.OK.getReasonPhrase); &#125;&#125; Controller에서 ‘try-catch’ 키워드를 활용해 예외처리를 하지 않는다면 이 예외는 전파되어 Advice 객체에서 처리된다. @ExceptionHandler 어노테이션에 지정된 예외클래스와 @Advice 객체 내부에 구현된 함수와 매핑되어 예외처리 동작이 실행된다. Exception.class 의 한계기본적으로 모든 예외 클래스들은 Exception.class 를 상속받는다. 그래서 ‘try-catch’ 로 예외처리를 할 때에도 catch 영역에 Exception.class 를 주게되면 모든 예외 클래스들이 들어오게 됨으로 간편했다. 자 그러면 이렇게 널리 공용으로 사용되는 Exception.class 만으로는 해결할 수 없는 문제를 생각해보자. 공통으로 사용하는 예외 클래스들 같은 경우 범용적으로 사용해야 하기 때문에 오류를 반환하는 내용들이 굉장히 추상적이다. 그래서 내가 구현하려고 하는 API 서버에 예외가 발생했을 때 발생한 예외에 대해서 구체적인 로그를 남겨두려고 한다. 아래 예제 코드를 참고하여 이해해보자. 123456789101112131415161718192021222324class Calculator &#123; public int add(String value1, String value2) throws Exception &#123; if(value1.replaceAll(&quot;[^0-9]&quot;, &quot;&quot;).isEmpty()) &#123; throw new Exception(&quot;value1 변수에 적절하지 않은 값이 입력되었습니다.&quot;); &#125; return Integer.parseInt(value1) + Integer.parseInt(value2); &#125;&#125;class User &#123; Calculator calculator = new Calculator(); public void calculate() &#123; try &#123; calculator.add(&quot;2&quot;, &quot;5&quot;); // 정상 케이스 calculator.add(&quot;2&quot;, &quot;글자&quot;) // 오류 반환 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 위와 같이 작성하면 Exception 객체 생성시 같이 전달된 Message 정보가 StackTrace 에 남게 된다. StackTrace 를 남겨보면 알겠지만 함수의 콜백이 모두 나오기 때문에 내용이 많아 실무에서 이를 로그로 사용하기는 쉽지 않다. 그래서 이번에는 StackTrace 를 찍지 않고 Message 로그만 남기도록 하였다. 123456789101112131415161718192021222324class Calculator &#123; public int add(String value1, String value2) throws Exception &#123; if(value1.replaceAll(&quot;[^0-9]&quot;, &quot;&quot;).isEmpty()) &#123; throw new Exception(&quot;value1 변수에 적절하지 않은 값이 입력되었습니다.&quot;); &#125; return Integer.parseInt(value1) + Integer.parseInt(value2); &#125;&#125;class User &#123; Calculator calculator = new Calculator(); public void calculate() &#123; try &#123; calculator.add(&quot;2&quot;, &quot;5&quot;); // 정상 케이스 calculator.add(&quot;2&quot;, &quot;글자&quot;) // 오류 반환 &#125; catch (Exception e) &#123; log.info(e.getMessage()); &#125; &#125;&#125; 여기서 문제점은 발생한다. 만약 우리가 ‘throw’ 키워드를 활용해 서비스 코드에서 직접 던진 예외의 경우 어떤 케이스인지 알고 있기 때문에 로그만 남겨도 충분하지만 만약 그 외에 예상하지 못한 예외들이 던져졌을 경우 이 로그만을 보고 원인 파악을 하는 것은 쉽지 않다. 즉 다시말해서, 내가 언급하고 싶은 것은 내가 알고 직접 던진 예외와, 나도 모르게 던져진 예외는 처리가 달라야 함을 인지해야 한다는 것이다. 그러나 Exception.class 와 같이 공통적으로 사용하는 예외 클래스들을 사용하면 catch 영역에서 두 가지의 방법의 겹쳐지기 때문에 둘을 구분할 수 없다. 커스텀한 예외 클래스를 만들자.이 문제를 해결하기 위해서 새로운 예외 클래스를 만들자. 이 예외 클래스는 나의 API 서버에서만 사용할 것이기 때문에 다른 클래스와 겹쳐질 걱정은 안해도 된다. 1234567891011121314151617181920212223242526272829303132333435363738class CustomException extends Exception &#123; private final String message; public CustomException(String message) &#123; this.message = message; &#125; public String getMessage() &#123; return this.message; &#125;&#125;class Calculator &#123; public int add(String value1, String value2) throws Exception &#123; if(value1.replaceAll(&quot;[^0-9]&quot;, &quot;&quot;).isEmpty()) &#123; throw new CustomException(&quot;value1 변수에 적절하지 않은 값이 입력되었습니다.&quot;); &#125; return Integer.parseInt(value1) + Integer.parseInt(value2); &#125;&#125;class User &#123; Calculator calculator = new Calculator(); public void calculate() &#123; try &#123; calculator.add(&quot;2&quot;, &quot;5&quot;); // 정상 케이스 calculator.add(&quot;2&quot;, &quot;글자&quot;); // 오류 반환 &#125; catch(CustomException e) &#123; log.info(e.getMessage()); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 내가 인지하지 못하는 예외 클래스들은 Exception.class 를 받는 catch 영역에서 stackTrace() 를 남기도록 하고 있고, 내가 직접 던진 예외의 경우 CustomException.class 를 받는 catch 영역에서 로그만 남기도록 되어 있다. 이렇게 내가 직접 던진 예외와, 내가 모르는 예외를 구분하여 작업함으로써 내 비지니스에 연관된 예외들을 구체화시킬 수 있다. 잘 생각해보면 우리가 쓰는 라이브러리들도 각각 개인적으로 정의하고 있는 예외 클래스들이 있다. 이처럼 각자의 프로젝트에 맞게 예외 내용들을 구체화 시켜야 한다면 이렇게 커스텀한 예외 클래스를 만들어서 사용하여야 한다. API 서버에서 사용하는 커스텀 예외 클래스이제는 API 서버에 종속적으로 예외 클래스를 활용하는 방법을 언급하려고 한다. 전통적인 API 서버는 API의 응답 코드를 프로젝트마다 정의하고 있다. 예를 들면 에러코드 ‘1000’ 이면 ‘연동 오류’ 이런식으로 말이다. API 서버에 맞는 커스텀 예외 클래스를 사용하려면 우선적으로 프로젝트 전반에 걸쳐서 공통적으로 사용하는 응답코드가 있어야 한다. 그리고 이 응답코드를 포함해 커스텀 예외 클래스를 만들어 낸다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152enum ApiCode &#123; SUCCESS(0, &quot;성공&quot;), PAYMENT_FAIL(1000, &quot;결제 오류&quot;), RESERVATION_FAIL(2000, &quot;예약 오류&quot;); ApiCode(int code, String desc) &#123; this.code = code; this.desc = desc; &#125; private final int code; private final String desc; public int code() &#123; return code; &#125; public String desc() &#123; return desc; &#125;&#125;class ApiException extends Exception &#123; private final ApiCode apiCode; public ApiException(ApiCode apiCode) &#123; this.apiCode = apiCode; &#125; public ApiCode apiCode() &#123; return this.apiCode; &#125;&#125;public class Controller &#123; @GetMapping(&quot;/api1&quot;) public ResponseEntity&lt;?&gt; api1() &#123; try &#123; return ResponseEntity.status(HttpStatus.OK).body(HttpStatus.OK.getReasonPhrase); &#125; catch (ApiException e) &#123; return ResponseEntity.status(e.apiCode().code()).body(e.apiCode().desc()); &#125; catch (Exception e) &#123; return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase()); &#125; &#125; @GetMapping(&quot;/api2&quot;) public ResponseEntity&lt;?&gt; api2() &#123; try &#123; return ResponseEntity.status(HttpStatus.OK).body(HttpStatus.OK.getReasonPhrase); &#125; catch (ApiException e) &#123; return ResponseEntity.status(e.apiCode().code()).body(e.apiCode().desc()); &#125; catch (Exception e) &#123; return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase()); &#125; &#125;&#125; 이러한 커스텀 예외 클래스도 @Advice 객체에 전파시킬 수 있다. 1234567891011121314151617181920212223242526272829// Advice@RestControllerAdvicepublic class Advice &#123; @ExceptionHandler(Exception.class) public ResponseEntity&lt;?&gt; exception(Exception e) &#123; return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase()); &#125; @ExceptionHandler(ApiException.class) public ResponseEntity&lt;?&gt; apiException(ApiException e) &#123; return ResponseEntity.status(e.apiCode().code()).body(e.apiCode().desc()); &#125;&#125;// Controllerpublic class Controller &#123; @GetMapping(&quot;/api1&quot;) public ResponseEntity&lt;?&gt; api1() &#123; return ResponseEntity.status(HttpStatus.OK).body(HttpStatus.OK.getReasonPhrase); &#125; @GetMapping(&quot;/api2&quot;) public ResponseEntity&lt;?&gt; api2() &#123; return ResponseEntity.status(HttpStatus.OK).body(HttpStatus.OK.getReasonPhrase); &#125;&#125; REST API 서버에서 사용하는 커스텀 예외 클래스드디어 이 글의 마지막 단계에 도달했다. 전통적인 API 서버들은 위에서 언급한 것처럼 각 프로젝트마다 errorCode, errorDesc 를 개별적으로 정의하고 사용한다. 그러나 REST API 방법론으로 넘어오면서 HttpStatus 코드를 활용하여 errorCode를 대체하는 분위기가 생겨났다. 이 HttpStatus 코드는 모두가 아는 코드이기 때문에 새로운 학습비용이 들지 않는다는 장점이 있다. 반대로 온전히 비지니스에 맞는 에러코드를 정의할 수 없다는 점이 단점이다. 그렇기 때문에 비지니스의 성향에 따라서 위와 같은 커스텀 응답코드를 만들어서 구현해도 되며, HttpStatus Code 규칙을 따르겠다고 한다면 아래와 같은 예제로 작성할 수있다. 이미 응답코드가 HttpStatus 객체에 정의되어 있고 이에 맞는 예외 클래스도 HttpStatusCodeException 객체에 커스텀 예외 클래스가 이미 이 응답코드에 맞게 정의되어 있다. 이를 활용하면 훨씬 간편하다. 123456789101112131415161718192021222324252627282930// Advice@RestControllerAdvicepublic class Advice &#123; /** Common Exception Handler */ @ExceptionHandler(Exception.class) public ResponseEntity&lt;?&gt; exception(Exception e) &#123; return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase()); &#125; /** Custom Exception Handler */ @ExceptionHandler(HttpStatusCodeException.class) public ResponseEntity&lt;?&gt; httpStatusCodeException(HttpStatusCodeException e) &#123; return ResponseEntity.status(e.getStatusCode()).body(e.getStatusCode().getReasonPhrase()); &#125;&#125;// Controllerpublic class Controller &#123; @GetMapping(&quot;/api1&quot;) public ResponseEntity&lt;?&gt; api1() &#123; return ResponseEntity.status(HttpStatus.OK).body(HttpStatus.OK.getReasonPhrase); &#125; @GetMapping(&quot;/api2&quot;) public ResponseEntity&lt;?&gt; api2() &#123; return ResponseEntity.status(HttpStatus.OK).body(HttpStatus.OK.getReasonPhrase); &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"ExceptionHandling","slug":"ExceptionHandling","permalink":"http://kidongyun.github.io/tags/ExceptionHandling/"}]},{"title":"Gitlab Api 사용하기","slug":"2020-12-30-gitlab-api","date":"2020-12-30T11:00:00.000Z","updated":"2022-05-31T07:25:10.000Z","comments":true,"path":"2020/12/30/","link":"","permalink":"http://kidongyun.github.io/2020/12/30/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.air.interpark.controller;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;import com.fasterxml.jackson.annotation.JsonProperty;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.Getter;import lombok.Setter;import lombok.ToString;import lombok.extern.slf4j.Slf4j;import net.rcarz.jiraclient.*;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.utils.URIBuilder;import org.apache.http.impl.client.HttpClientBuilder;import org.apache.http.util.EntityUtils;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import java.io.IOException;import java.net.InetAddress;import java.net.URI;import java.net.URISyntaxException;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.List;@Slf4j@Controllerpublic class AutoDeployController &#123; @RequestMapping(value = &quot;/deploy&quot;, method = &#123;RequestMethod.POST, RequestMethod.GET&#125;, produces = &#123;&quot;text/html;charset=UTF-8&quot;, &quot;application/xml;charset=UTF-8&quot;, &quot;application/json;charset=UTF-8&quot;&#125;) public ResponseEntity&lt;?&gt; deploy(@RequestParam String pmsNo) throws URISyntaxException, IOException, JiraException &#123; URI mergeRequestUri = new URIBuilder(new URI(&quot;http://gitlab.interpark.com/api/v4/projects/1090/merge_requests&quot;)) .addParameter(&quot;search&quot;, &quot;ITSERVICE-39158&quot;).addParameter(&quot;state&quot;, &quot;opened&quot;).build(); List&lt;MergeRequest&gt; mergeRequests = new ObjectMapper().readValue(EntityUtils.toString(call(mergeRequestUri)), new TypeReference&lt;List&lt;MergeRequest&gt;&gt;() &#123;&#125;); URI versionUri = new URIBuilder(new URI(&quot;http://gitlab.interpark.com/api/v4/projects/1090/merge_requests/&quot; + mergeRequests.get(0).getIid() + &quot;/versions&quot;)).build(); List&lt;Version&gt; versions = new ObjectMapper().readValue(EntityUtils.toString(call(versionUri)), new TypeReference&lt;List&lt;Version&gt;&gt;() &#123;&#125;); URI versionDetaionUri = new URIBuilder(new URI(&quot;http://gitlab.interpark.com/api/v4/projects/1090/merge_requests/&quot; + mergeRequests.get(0).getIid() + &quot;/versions/&quot; + versions.get(0).getId())).build(); VersionDetail versionDetail = new ObjectMapper().readValue(EntityUtils.toString(call(versionDetaionUri)), VersionDetail.class); List&lt;Diff&gt; diffs = versionDetail.getDiffs(); /* JIRA 계정 로그인 및 연동 */ BasicCredentials creds = new BasicCredentials(&quot;[ID]&quot;, &quot;[PASSWORD]&quot;); JiraClient jira = new JiraClient(&quot;https://pms.interpark.com/&quot;, creds); /* JIRA ISSUE 생성 */ Issue issue = jira.createIssue(&quot;DEP&quot;, &quot;수시반영 형상관리&quot;) .field(&quot;customfield_10544&quot;, &quot;정규반영&quot;) .field(Field.SUMMARY, &quot;summary&quot;) .field(Field.DESCRIPTION, &quot;description&quot;) .execute(); return ResponseEntity.status(HttpStatus.OK).body(HttpStatus.OK.getReasonPhrase()); &#125; private HttpEntity call(URI uri) throws IOException &#123; HttpGet httpGet = new HttpGet(uri); httpGet.addHeader(&quot;PRIVATE-TOKEN&quot;, &quot;[PRIVATE TOKEN]&quot;); HttpResponse response = HttpClientBuilder.create().build().execute(httpGet); return response.getEntity(); &#125; @Getter @Setter @ToString @JsonIgnoreProperties(ignoreUnknown = true) public static class MergeRequest &#123; @JsonProperty(value = &quot;iid&quot;) private String iid; &#125; @Getter @Setter @ToString @JsonIgnoreProperties(ignoreUnknown = true) public static class Version &#123; @JsonProperty(value = &quot;id&quot;) private String id; &#125; @Getter @Setter @ToString @JsonIgnoreProperties(ignoreUnknown = true) public static class VersionDetail &#123; @JsonProperty(value = &quot;diffs&quot;) private List&lt;Diff&gt; diffs; &#125; @Getter @Setter @ToString @JsonIgnoreProperties(ignoreUnknown = true) public static class Diff &#123; @JsonProperty(value = &quot;new_path&quot;) private String newPath; &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Gitlab","slug":"Gitlab","permalink":"http://kidongyun.github.io/tags/Gitlab/"}]},{"title":"오픈소스 Jar 파일 커스터마이징 과정에 대한 고찰","slug":"2020-12-29-maven-jar-export","date":"2020-12-29T11:00:00.000Z","updated":"2022-05-31T07:24:47.000Z","comments":true,"path":"2020/12/29/","link":"","permalink":"http://kidongyun.github.io/2020/12/29/","excerpt":"","text":"일반적인 상황은 아니지만 유명하지 않거나, 크게 지원되지 않는 라이브러리를 사용할 때 라이브러리 자체에 결함이 존재할 수도 있다. 이렇게 되면 이러한 에러를 해결하기 위한 방법을 모색해야 하는데, 이 중에 권장되는 방법은 아니지만 우리 프로젝트에 맞추기 위해서 오류가 있는 부분의 소스를 수정하고 재 빌드하는 방법이 있다. 저작권과 관련된 이슈는 저자는 크게 잘 모르기 때문에 이부분에 대해서는 생략하며, 단지 필요하다면 오픈소스로 공개된 라이브러리에 대해서만 이러한 작업을 하길 바란다. jad를 활용해 직접 소스파일을 구하자내가 오류를 발견한 라이브러리 파일에 대해서 jar 파일만 가지고 있고, 실제 소스 파일을 구할 수 없는 경우에는 jad 라는 프로그램을 활용해서 .class 파일을 .java 파일로 디컴파일 시켜야 한다. Jad Download Jad 프로그램은 패키지 단위로 .class 파일을 디컴파일 시킬수 있고 파일 단위로도 디컴파일이 가능하다. 디컴파일된 .java 파일을 원하는 방식으로 수정을 하고 난 후에 javac 명령어를 실행해서 다시 컴파일을 하자. 여기서 문제점은 현대 대부분의 프로젝트들은 gradle, maven과 같은 빌드 툴을 사용하고 있는데 여기에는 의존성 관리 기능이 포함된다. javac를 활용해서 빌드를 하게 될 경우 의존성들이 로컬에 존재하지 않기 때문에 라이브러리가 아니기 때문에 컴파일 오류가 나는 객체들이 많을 것이다. 이런 경우에는 gradle, maven 빌드 툴을 활용하여 빌드하여야 한다. 그러나 만약 라이브러리 사이즈가 크다면 이 빌드 툴을 설정하는 것 자체가 굉장히 큰 작업이 된다. 그래서 직접 소스파일을 디컴파일하여 소스를 수정하는 것은 현실적으로는 한계가 있다. 그래서 대안으로는 github 과 같은 사이트에서 실제로 운영되고 있는 해당 소스를 구하는 것이다. 대부분의 라이브러리들이 오픈소스로서 공개되어 있기 떄문에 사이트를 검색하다 보면 공식 소스들을 쉽게 구할 수 있다. 외부에서 공식 소스를 구해서 프로젝트를 만들자.대부분 git으로 형상관리를 하기 때문에 github를 찾아보면 공식 소스를 찾을 수 있다. 여기서는 예제로 jira-client을 활용해보겠다. 내가 이 글을 써야겠다라고 마음 먹게된 계기의 라이브러리이다. https://github.com/rcarz/jira-client 위 사이트가 소스 공식 사이트이다. 여기서 클론을 하던 각자가 원하는 방식으로 해서 로컬에 프로젝트를 구축하자. 나와 같은 경우 intellij 에서 github 소스를 바로 import하는 기능이 있어 이를 활용해서 로컬에 구축하였다. 그리고 나서 수정을 원하는 부분에 가서 소스를 변경하면 된다. 빌드 툴을 활용하여 빌드하자.intellj는 오른쪽 창들 중에 maven 관련 창이 있다 이 곳에서 Lifecycle -&gt; install 을 클릭하면 자동으로 jar 파일을 떨군다. 콘솔을 확인하면 어느 경로에 jar 파일이 떨어지는 지 확인이 가능하다. 빌드 설정이 어떻게 되어 있느냐에 따라서 바로 jar 파일이 성공적으로 만들어질 수도 있고 아닐수도 있다. 어떤 오류를 던지는지 잘 확인하고 오류에 맞추어서 빌드 설정을 바꿔주어야 하는 작업이 필요할 수도 있다. 나의 경험으로는 테스트 코드를 통과하지 못하는 경우가 있어서 이를 skip 하는 설정을 추가한 상황도 있고, parent 에 해당하는 의존성을 가져오지 못해 parent 부분을 제거해본 적도 있다. 모든 방법이 다 상황에 따라서 답이 아닐 수 있음으로 오류를 잘 읽어서 빌드 설정을 적절히 변경시켜주는게 중요하다. 각 빌드 툴 저장소에 올리기각 빌드 툴은 로컬 저장소나, 원격 저장소에 해당 의존성을 올릴 수 있는 기능을 제공한다. 이 기능을 활용하여 업로드 시키고, 본인 작업 프로젝트에서 의존성을 불러와서 사용하면 된다. 보다 옛스럽지만 간편한 방법으로는 해당 라이브러리를 로컬로 가지고 불러와도 된다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Jira","slug":"Jira","permalink":"http://kidongyun.github.io/tags/Jira/"},{"name":"Maven","slug":"Maven","permalink":"http://kidongyun.github.io/tags/Maven/"},{"name":"Jad","slug":"Jad","permalink":"http://kidongyun.github.io/tags/Jad/"},{"name":"Decompile","slug":"Decompile","permalink":"http://kidongyun.github.io/tags/Decompile/"}]},{"title":"함수형 인터페이스 정리해두기","slug":"2020-12-29-sort-of-functional-interface","date":"2020-12-29T11:00:00.000Z","updated":"2022-05-31T07:24:58.000Z","comments":true,"path":"2020/12/29/","link":"","permalink":"http://kidongyun.github.io/2020/12/29/","excerpt":"","text":"12345678910@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125;```java@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t)&#125; 1234@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; T get()&#125; 1234@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t)&#125; 1234@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t)&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"FunctionalInterface","slug":"FunctionalInterface","permalink":"http://kidongyun.github.io/tags/FunctionalInterface/"}]},{"title":"JPA Entity 관련 annotation 에 대한 고찰","slug":"2020-12-28-entity-annotations","date":"2020-12-28T02:38:54.000Z","updated":"2022-05-31T07:23:52.000Z","comments":true,"path":"2020/12/28/","link":"","permalink":"http://kidongyun.github.io/2020/12/28/","excerpt":"","text":"기본 어노테이션이 글은 백기선 개발자님의 Spring Data JPA 강의를 듣고 JPA 관련 내용들을 정리한 글이다. 기본적으로 해당 강좌에서 언급되는 개념으로 진행되지만, 저자의 JPA 경험을 토대로 이해한 바가 함께 녹아있으므로 그 부분은 참고하고 글을 읽어주시기 바란다. JPA에서 객체와 릴레이션간에 매핑을 위해 메타데이터를 생성하는 방법은 어노테이션 방법과 xml방법 두 가지가 있다. 그런데 요즘은 거의 어노테이션 방법만 사용하고 있다. 파일이 구분되지 않고 가독성이 높아지기 떄문인데 이는 스프링 설정 방법이 어노테이션 방식으로 바뀌어 가는 것과 동일하다고 본다. @Entity 어노테이션에 설정한 이름은 객체 세상에서만 사용되어지는 거고 테이블의 이름을 바꾸고 싶으면 @Table 어노테이션을 사용해야 한다. @Table 어노테이션은 릴레이션 관련 정보를 설정하는 어노테이션이다. 테이블의 이름을 변경하고 싶다면 이 어노테이션에 옵션으로 주면 된다. 그런데 이 어노테이션은 @Entity 어노테이션과 옵션을 바라보고 있기 때문에 @Entity 어노테이션의 옵션으로 이름을 변경하게 되면, @Table 어노테이션의 이름도 마찬가지로 변경된다. @Id 는 주키를 설정하는 어노테이션. 문서 상에는 모든 타입을 제공한다. 여기서 논쟁거리 하나가 int, long과 같은 원시타입을 써야하는지 혹은 객체타입을 써야하는지에 대한 이슈이다. 백기선 강사님은 객체타입을 사용하는 걸 추천하는데 숫자를 원시타입으로 사용할 경우 초기 값에 0이 들어가게 되고, 이 0 값이 특정 비지니스에서는 필요한 값일 수도 있기 때문에 초기 값을 null을 넣는 걸 권장하기 때문이다. 123456789/* primitive type */@Idprivate long id;/* reference type */@Idprivate Long id; @GeneratedValue 어노테이션은 자동 생성된 값을 사용하겠다는 어노테이션이다. 자동 생성 규칙은 각 데이터베이스의 규칙에 따라서 생성이 되며, SEQ를 쓸건지, Identity 객체를 쓸건지.. 명시적으로 옵션을 통해 설정할 수 있디. 예를 들면 @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = ‘’) 이런 식이다. @Column 도메인 객체 각 필드에 사용하는 어노테이션이다. 옵션으로 nullable, unique, name 등을 줄수 있다. @Temporal 날짜와 시간에 관련된 필드에 매핑이 가능하다. 3가지 속성이 있으며 상황에 맞춰서 쓰면 된다. LocalDate는 자바 1.8 이후에 생겨난 객체이기 떄문에 JPA 2.1 이전 버전에는 이 타입에 대한 매핑이 지원이 안된다. 따라서 Calendar와 Date 객체를 사용해야 한다. 그렇기 떄문에 LocalDate 객체를 사용해야 한다면 JPA 2.1 이상 버전을 추천한다. @Transient 이 어노테이션을 사용하면 사용된 필드는 릴레이션의 컬럼으로 매핑을 하지 안겠다는 의미이다. 이 용어는 JPA에서 관리하는 엔티티 상태 4가지 중 하나와 동일하다. 참조타입 필드를 위한 어노테이션만약 필드에 기본 타입이 아니고 객체타입을 사용하고 싶은 경우에는 @Embeddable, @Embedded 어노테이션을 활용해야 한다.예를 들어 주소 관련 정보를 가지고 있는 엔티티를 만든다고 하자. 이 주소 정보는 도로명을 가지고 있는 street 필드, 도시명을 가지고 있는 city 필드, 주명을 가지고 있는 state, 우편번호를 가지고 있는 zipCode 이렇게 4개가 필요하다.이 정보들을 한 엔티티에 바로 추가할 수 있지만. 관련된 필드들을 묶고싶어서 Address라는 객체를 만들고 이 객체 타입으로 필드에 넣었다. 이렇게하면 실제 엔티티에는 이 4개의 필드 정보가 직접적으로 생성된다. 객체관점에서는 구분되어있지만 릴레이션 관점에서는 구분되어있지 않는다는 것이다. 엔티티로서 사용해야할 만큼 큰 객체라면 @Entity 어노테이션을 써서 기존처럼 새로운 릴레이션을 만들면 된다. 그러나 지금처럼 Address의 경우 그정도의 사이즈는 아니고 단순하게 값을 묶어서 가지고 있는 정도이기 때문에 이 녀석을 @Embeddable, @Embedded 어노테이션을 활용하면 객체에서는 묶여있지만 릴레이션에서는 모두 포함된 구조로 구현이 가능하다. 1234567891011121314151617181920212223242526272829@Getter@Setter@Embeddablepublic class Address &#123; private String street; private String city; private String state; private String zipCode;&#125;@Getter@Setter@Entitypublic class Account &#123; @Id @GeneratedValue private Long id; private String username; private String password; @Embedded private Address address;&#125; 같은 Embeddable 객체를 한 엔티티 내에 여러번 사용할 경우에는 @AttributeOverrides, @AttributeOverride 어노테이션을 활용해 이름을 변경할 수 있다. 예를 들면 집주소, 직장주소 등이 있다. 관계 어노테이션엔티티끼리의 관계가 있을 때 릴레이션에게 이 관계를 설명하기 위한 메타데이터를 설정해야 한다. 관계가 있다는 것은 객체관점에서는 의존성을 가지고 있다는 것이고 릴레이션 관점에서는 한쪽 방향에서는 FK를 가지고 있다는 의미이다. 1:N 관계에 대한 매핑을 하기 위해서는 @ManyToOne 어노테이션을 사용해야한다. Account 객체와 Study 객체로 예를 들어 생각해보자. 아래 예시를 보면 Study 객체에 Account 필드를 생성하고 여기에 @ManyToOne 어노테이션을 붙였다. 이렇게 하면 데이터베이스에서는 Account 릴레이션의 PK를 참조하는 FK 값이 Study 릴레이션에 생성된다. Study가 Account를 의존하고 있기 때문에 Study는 이 FK를 활용해서 Account에 접근이 가능하다. 12345678910111213141516171819import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.ManyToOne;@Getter@Setter@Entitypublic class Study &#123; @Id @GeneratedValue private Long id; private String name; @ManyToOne private Account ownwer;&#125; 이번엔 Account 객체 기준으로 Study에 접근한다고 생각해 보자. Account 한 개가 여러 개의 Study를 가질 수 있으므로 아래와 같이 컬렉션 타입으로 Study 필드를 생성하고 @OneToMany 어노테이션을 붙인다. @ManyToOne 방식은 FK를 주는 것으로 구현이 되었다면 @OneToMany 어노테이션이 릴레이션에 매핑될 때에는 기본적으로 조인테이블이 생성된다. 123456789101112131415161718192021import javax.persistence.*;import java.util.HashSet;import java.util.Set;@Getter@Setter@ToString@Entitypublic class Account &#123; @Id @GeneratedValue private Long id; private String username; private String password; @OneToMany private Set&lt;Study&gt; studies = new HashSet&lt;&gt;();&#125; 양방향 참조를 하려면 어떻게 해야할까? 즉 Studt 객체도 Account 객체를 의존하고 있고 Account 객체도 Study 객체를 의존하고 있는 구조다. 사실 이 구조는 디자인 패턴 관점에서는 권장하지 않는 구조인데. 이렇게 되면 Account 객체와 Study 객체간 결합성이 너무 높아지기 때문이다. 여하튼 그럼에도 이런 구조를 가지고 있을 때 양방향성을 릴레이션에 매핑하려면 우선 위 처럼 @OneToMany, @ManyToOne 어노테이션을 붙인다. 그리고 Account 객체에서 @OneToMany 속성 중 mappedBy에 Study 객체가 Account 객체를 참조하기 위해 사용한 필드의 이름을 넣어준다. 12345678910111213141516171819202122232425262728293031@Getter@Setter@ToString@Entitypublic class Account &#123; @Id @GeneratedValue private Long id; private String username; private String password; @OneToMany(mappedBy = &quot;owner&quot;) private Set&lt;Study&gt; studies = new HashSet&lt;&gt;();&#125;@Getter@Setter@ToString@Entitypublic class Study &#123; @Id @GeneratedValue private Long id; private String name; @ManyToOne private Account owner;&#125; 이렇게 양방향성을 가진 두 객체에 실제로 데이터를 넣을때에는 양 객체에 모두 쿼리를 날려야 한다.12345678910111213141516171819202122232425262728293031323334353637import org.hibernate.Session;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.stereotype.Component;import javax.persistence.EntityManager;import javax.persistence.PersistenceContext;import javax.transaction.Transactional;@Component@Transactionalpublic class JpaRunner implements ApplicationRunner &#123; @PersistenceContext EntityManager entityManager; @Override public void run(ApplicationArguments args) throws Exception &#123; Account account = new Account(); account.setUsername(&quot;kidongyun&quot;); account.setPassword(&quot;hibernate&quot;); Study study = new Study(); study.setName(&quot;Spring Data JPA&quot;); account.getStudies().add(study); study.setOwner(account); Session session = entityManager.unwrap(Session.class); /* Account 관련 데이터 INSERT */ session.save(account); /* Study 관련 데이터 INSERT */ session.save(study); &#125;&#125; 양방향성을 가진 객체끼리는 항상 쿼리를 날릴 때 위와 같이 두 객체를 위한 쿼리를 따로 날려야 하기 때문에 보통 아래 addStudy(), removeStudy() 함수와 같이 이들을 함께 호출한다. 12345678910111213141516171819202122232425262728293031import javax.persistence.*;import java.util.HashSet;import java.util.Set;@Getter@Setter@ToString@Entitypublic class Account &#123; @Id @GeneratedValue private Long id; private String username; private String password; @OneToMany(mappedBy = &quot;owner&quot;) private Set&lt;Study&gt; studies = new HashSet&lt;&gt;(); public void addStudy(Study study) &#123; this.getStudies().add(study); study.setOwner(this); &#125; public void removeStudy(Study study) &#123; this.getStudies().remove(study); study.setOwner(null); &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"JPA","slug":"JPA","permalink":"http://kidongyun.github.io/tags/JPA/"}]},{"title":"JPA 프로젝트 기본 설정에 대한 고찰","slug":"2020-12-27-jpa-project-setting","date":"2020-12-27T02:38:54.000Z","updated":"2022-05-31T07:23:50.000Z","comments":true,"path":"2020/12/27/","link":"","permalink":"http://kidongyun.github.io/2020/12/27/","excerpt":"","text":"이 글은 백기선 개발자님의 Spring Data JPA 강의를 듣고 JPA 관련 내용들을 정리한 글이다. 기본적으로 해당 강좌에서 언급되는 개념으로 진행되지만, 저자의 JPA 경험을 토대로 이해한 바가 함께 녹아있으므로 그 부분은 참고하고 글을 읽어주시기 바란다. JPA 프로그래밍 프로젝트 세팅Maven 프로젝트를 활용해서 간단하게 JPA 프로그래밍이 가능한 환경을 구축해보자. 우선 의존성을 추가한다. JPA 관련 기능이 담겨져 있는 ‘spring-boot-starter-data-jpa’ 라이브러리와 당신이 사용할 데이터베이스의 JDBC 드라이버를 가져오자 여기서는 postgresql 데이터베이스를 사용하기 때문에 이 의존성을 가져왔다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;me.whiteship&lt;/groupId&gt; &lt;artifactId&gt;demospringdata&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demospringdata&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; postgresql 데이터베이스에 접속하기 위해 필요한 정보 url, username, password 를 입력하자. 그리고 개발의 편의를 위해 추가적인 설정들도 넣었는데 이는 주석으로 내용을 설명해 두었다. 지금과 같이 application.properties에 설정한 정보들은 HibernameJpaAutoConfiguration 이 자동 설정을 해준다. 123456789101112131415spring.datasource.url=jdbc:postgresql://localhost:5432/springdataspring.datasource.username=keesunspring.datasource.password=pass// 스프링 서버 재시작시 DDL을 항상 새로만들지, 업데이트할지, 검증만할지를 결정한다.spring.jpa.hibernate.ddl-auto=createspring.jpa.properties.hibername.jdbc.lob.non_contextual_creation=true// 우리가 만든 JPA 쿼리가 기존 SQL 쿼리로 어떻게 변환되어 날라가는지 보여준다.spring.jpa.show-sql=true// 이 쿼리를 개행 등을 하여 좀 더 보기 쉽게 보여준다spring.jpa.properties.hibernate.format_sql=true spring.jpa.hibernate.ddl-auto=create 이 속성은 DDL을 서버 재시작 할 때마다 새로 생성하기 때문에 개발할 때 유용하며,실제 운영 단계에서는 ‘validate’ 값을 주는 게 좋다. ‘update’ 값은 기존 스키마와 데이터들을 유지하고 새로운 값이 들어오면 생성한다. ‘update’ 값의 주의사항은 기존 값들을 유지하기 때문에 편하긴 하지만 무조건 좋은건 아니다. 왜냐하면 특정 컬럼을 지우는 DDL을 ‘update’ 값으로 날렸을 경우 기존 스키마를 유지해야 하기 때문에 지우고 싶었던 필드가 실제로 릴레이션에서 보면 남아있다. 또 ‘update’ 값으로 기존 스키마의 이름을 바꾸면 변경이 안된다. 단지 기존 것을 남기고 새로운 걸 추가한다. 이렇게 이전에 작업하던 것들이 지속 남아있게 됨으로 ‘update’ 값을 사용하면 스키마가 지저분해질 수 있으므로 주의해서 사용해야 한다. 그 다음은 도메인 객체를 생성한다. 이 객체가 자바에서 사용하는 도메인 객체이면서 데이터베이스의 릴레이션 즉 테이블이 된다. 12345678910111213@Getter@Setter@Entitypublic class Account &#123; @Id @GeneratedValue private Long id; private String username; private String password;&#125; lombok 어노테이션은 제외하고 JPA와 관련된 어노테이션에 대해서만 간략히 알아보도록 하자. 12345678910@Entity : JPA에서 사용하는 도메인 객체임을 선언하는 어노테이션이며, 선언된 객체는 릴레이션으로 매핑된다.@Id : 해당 필드가 PK 값으로 쓰인다고 명시한다.@GeneratedValue : mysql에서 auto_increment 같은 것으로 생각하면 되며 값을 자동으로 생성시켜준다. 생성 방식은 옵션으로 추가할 수 있으며 데이터베이스에 따라 SEQUENCE를 생성할지, Identity 테이블을 사용할지를 결정한다.@Column : 위 예제 코드에는 이 어노테이션이 안보이지만 @Entity 어노테이션을 사용한 도메인 객체의 필드들은 이 어노테이션이 자동으로 붙는다.이 어노테이션을 통해서 실제 릴레이션에 매핑되는 컬럼의 이름등을 변경할 수 있다. 빙금 만든 Account 도메인 객체가 릴레이션에 잘 매핑되고 있는지 확인하기 위해서 Runner 클래스 하나를 생성하자. 1234567891011121314151617181920212223242526import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.stereotype.Component;import javax.persistence.EntityManager;import javax.persistence.PersistenceContext;import javax.transaction.Transactional;@Component@Transactionalpublic class JpaRunner implements ApplicationRunner &#123; @PersistenceContext EntityManager entityManager; @Override public void run(ApplicationArguments args) throws Exception &#123; Account account = new Account(); account.setUsername(&quot;keesun&quot;); account.setPassword(&quot;jpa&quot;); entityManager.persist(account); &#125;&#125; Spring Framework에서 핵심 객체라고 하면 ApplicationContext가 있듯이 JPA에서는 EntityManager가 가장 핵심 객체라고 할 수 있다. 이 객체를 활용하여 영속화가 가능하다. 즉 데이터베이스에 실제 쿼리를 날릴 수 있다. JPA에서 제공하는 이 EntityManger 객체를 살펴보면 하이버네이트 기반으로 구현되어 있는 Session 객체에 접근할 수 있다. 영속화를 위해서 이 두 객체 모두 사용이 가능하다. 그렇기 때문에 JPA를 사용한다고 하면 하이버네이트 기반의 코딩도 실제로는 가능하다. 아래 예제는 하이버네이트 방식으로 영속화를 하는 코드이다. 추가적으로 이 Runner 클래스는 @Transactional 어노테이션을 사용하고 있는데 이 어노테이션은 JPA에서 제공하는 어노테이션이 아니다. Entity와 관련된 작업은 트랜잭션 범주를 설정하고 그 안에서 쿼리들이 이뤄져야 한다. 대표적인 예시로 은행 ATM 입/출금 기능을 들 수 있겠다.나의 계좌에서 만원을 출금하는 경우 출금하는 돈 항목에는 만원이 추가되고, 나의 계좌에는 만원이 빠져나가야 한다. 그러나 만약 출금하는 돈에 만원이 추가된 이후에 오류가 나서 나의 계좌에서 만원이 빠져나가지 않는 경우 고객은 만원을 벌게되는 치명적 오류가 발생한다. (나에게 이런 오류가 발생했으면 좋겠다..) 이렇듯 데이터베이스 관련 업무는 한 트랜잭션의 범주를 설정하고 한 세트로 동작하도록 하는 것이 중요한데 이를 위해 @Transactional 어노테이션을 붙인다. @Transactional 어노테이션은 클래스 기준으로 사용하게되면 해당 클래스가 가지고 있는 모든 메서드에 트랜잭션 관리가 적용이 되고 한 메서드에만 적용하면 해당 메서드에만 적용이 된다. 1234567891011121314151617181920212223242526272829import org.hibernate.Session;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.stereotype.Component;import javax.persistence.EntityManager;import javax.persistence.PersistenceContext;import javax.transaction.Transactional;@Component@Transactionalpublic class JpaRunner implements ApplicationRunner &#123; @PersistenceContext EntityManager entityManager; @Override public void run(ApplicationArguments args) throws Exception &#123; Account account = new Account(); account.setUsername(&quot;keesun&quot;); account.setPassword(&quot;hibernate&quot;); /* JPA 객체인 EntityManager에서 하이버네이트 객체인 Session을 꺼내온다 */ Session session = entityManager.unwrap(Session.class); session.save(account); &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"JPA","slug":"JPA","permalink":"http://kidongyun.github.io/tags/JPA/"}]},{"title":"JDBC와 ORM의 필요성과 배경에 대한 고찰","slug":"2020-12-27-jdbc-orm","date":"2020-12-27T02:38:54.000Z","updated":"2022-05-31T07:23:32.000Z","comments":true,"path":"2020/12/27/","link":"","permalink":"http://kidongyun.github.io/2020/12/27/","excerpt":"","text":"이 글은 백기선 개발자님의 Spring Data JPA 강의를 듣고 JPA 관련 내용들을 정리한 글이다. 기본적으로 해당 강좌에서 언급되는 개념으로 진행되지만, 저자의 JPA 경험을 토대로 이해한 바가 함께 녹아있으므로 그 부분은 참고하고 글을 읽어주시기 바란다. JDBC를 활용해 자바에서 관계형 데이터베이스 연동하기자바와 같은 호스트 언어와 오라클과 같은 관계형 데이터베이스들은 실제로는 독립적이며 별도로 동작된다. 실무의 많은 곳에서 이 둘을 버무려서 사용하고 있지만 근본적으로 이 둘은 역할이 다름을 먼저 이해하고 들어가야 한다. 자바에서 데이터베이스와 연동을 하기 위해서 JPA, Mybatis 등 많은 오픈소스들이 존재하지만 이들의 근본에는 JDBC가 있다. JDBC는 자바 언어에서 데이터베이스에 접근하기 위해서 사용하는 모듈이라고 생각하면 되고, 이를 기반으로 DDL, DML 같은 쿼리들을 데이터베이스에 요청할 수 있다. 우선 간략하게 전통적인 방법으로 JDBC를 활용해 어떻게 자바가 데이터베이스와 연동이 되는지를 살펴보자. 여기서는 Postgresql 데이터베이스를 사용하며 도커기반으로 이 데이터베이스를 설치한다. 123456&gt; docker run -p 5432:5432 -e POSTGRES_PASSWORD=pass -e POSTGRES_USER=keesun -e POSTGRES_DB=springdata --name postgres_boot -d postgres&gt; docker exec -i -t postgres_boot bash&gt; psql --username keesun --dbname springdata 위의 명령어를 통해서 postgresql 데이터베이스를 설치하고, 내부로 접속이 가능하다. 그 다음에는 Maven 프로젝트를 만들고 pom.xml 파일에 postgresql 데이터베이스에 접속하기 위한 드라이버 의존성을 주입한다. JDBC는 각 데이터베이스마다 다른 드라이버를 가지고 있으며 이에 맞게 의존성을 주입해야한다. 예를 들어 오라클 데이터베이스를 사용한다고 하면 오라클 데이터베이스에 맞는 JDBC 드라이버를 설치해야한다. 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;me.whiteship&lt;/groupId&gt; &lt;artifactId&gt;jdbcsample&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/artifactId&gt; &lt;version&gt;42.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; JDBC를 통해서 postgresql 데이터배이스에 연동하는 소스를 작성해보자. JDBC를 통해 데이터베이스에 연동을 할때 필요한 정보는 url, usename, password 인데 각각의 의미는 아래와 같다. 12345url - 어떤 데이터베이스를 바라보는지를 알려주기 위한 데이터베이스 경로.username - url에 해당하는 데이터베이스에 접근할 때 사용할 계정.password - 계정에 해당하는 비밀번호. 1234567891011121314151617import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class Application &#123; public static void main(String[] args) throws SQLException &#123; String url = &quot;jdbc:postgresql://localhost:5432/springdata&quot;; String username = &quot;keesun&quot;; String password = &quot;pass&quot;; try(Connection connection = DriverManager.getConnection(url, username, password)) &#123; System.out.println(&quot;Connection created: &quot; + connection); &#125; &#125;&#125; 추가적으로 위 연동 소스에는 try-with-resource 문법을 사용하고 있는데 이 문법은 자원 연동과 관련된 소스를 감싸주면 해당 소스의 작업이 끝났을 때 연결 해제의 작업을 자동으로 진행해준다. 이전에는 try-catch-finally 문법으로 작성해서 finally 부분에 자원해제를 위한 코드를 항상 작성해야 했었는데 이 부분이 더 간편해진 버전이다. Java 7 이후 부터 제공하고 있는 문법임으로 참고하도록 하자. 아래는 JDBC를 활용해서 테이블을 생성하는 예제이다. 우리 글의 목표는 JPA를 아는 것 임으로 이 소스에 대한 상세 설명은 생략한다. 다만 데이터베이스에 연동을 하기 위해 어떤 과정을 거치고 있는지 확인하고 어떤 부분에서 개선되면 좋을지를 생각해보자. 123456789101112131415161718192021222324import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;public class Application &#123; public static void main(String[] args) throws SQLException &#123; String url = &quot;jdbc:postgresql://localhost:5432/springdata&quot;; String username = &quot;keesun&quot;; String password = &quot;pass&quot;; try(Connection connection = DriverManager.getConnection(url, username, password)) &#123; System.out.println(&quot;Connection created: &quot; + connection); String sql = &quot;CREATE TABLE ACCOUNT (id int, username varchar(255), password varchar(255));&quot;; try(PreparedStatement statement = connection.prepareStatement(sql)) &#123; statement.execute(); &#125; &#125; &#125;&#125; 아래는 JDBC를 활용해서 데이터를 삽입하는 예제이다. 1234567891011121314151617181920212223import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;public class Application &#123; public static void main(String[] args) throws SQLException &#123; String url = &quot;jdbc:postgresql://localhost:5432/springdata&quot;; String username = &quot;keesun&quot;; String password = &quot;pass&quot;; try(Connection connection = DriverManager.getConnection(url, username, password)) &#123; System.out.println(&quot;Connection created: &quot; + connection); String sql = &quot;INSERT INTO ACCOUNT VALUES(1, &#x27;keesun&#x27;, &#x27;pass&#x27;);&quot;; try(PreparedStatement statement = connection.prepareStatement(sql)) &#123; statement.execute(); &#125; &#125; &#125;&#125; 이렇게 JDBC를 활용해서 데이터베이스에 연동을 했을 때 문제가 되는 부분은 무엇이 있을까? 1. 테이블에 있는 데이터를 가져와서 자바 도메인 객체로 바꿔야 하는 작업을 해야한다.위의 예시에서는 SELECT 하는 부분이 없었지만. SELECT를 하게되면 보통 ResultSet 이라는 JDBC에서 사용하는 특유의 객체로 반환된다. 해당 객체는 리스트 타입의 객체들을 cursor 라는 요소로 접근해야 한다. 이러한 방식은 조금은 전통적인 방법이 되어버렸고 더 중요하게는 이러한 ResultSet 객체를 Java 표준 Collection 객체로 변환해야 한다. 그렇지 않고 ResultSet 을 그대로 Java 도메인 영역에서도 사용하게 되면 그 프로젝트의 소스는 JDBC 에 의존적인 소스를 작성하게 되는 것이다. 2. 데이터베이스 커넥션을 만드는 작업은 굉장히 비싼 작업이다. (JPA를 사용하면 상대적으로 커넥션을 덜 생성할 수 있다.)JDBC를 통해 데이터베이스에 연결을 하는 작업 자체가 굉장히 시간이 오래 걸리는 작업이다. 그렇기 때문에 실무에서는 보통 DBCP 라는 것을 활용해 데이터베이스 연결을 위한 풀을 만들어 둔다. 시간이 오래 걸리는 작업을 매번 새로 만드는 것은 비효율적이기 때문이다. 이 부분은 JPA를 활용하면 데이터베이스 커넥션하는 횟수를 JDBC를 그냥 사용하는 것 보다 덜 생성할 수 있다. (물론 JDBC로도 가능하지만 이를 다 구현해야한다.) 예를 들어 어떤 필드의 값을 100번 업데이트하는 쿼리가 있다고 하자. 근데 100번째의 쿼리가 1번째의 쿼리와 동일한 값을 넣는다면. 사실 1번째 쿼리를 제외하고는 모두 무의미하다. 결국 값이 1번째 쿼리의 값과 같아졌기 때문이다. 이럴때 JDBC를 순수하게 사용한다면 100번의 커넥션 연결 작업을 하지만 JPA는 내부의 상태관리를 통해서 이러한 쿼리들을 검증하고 1번의 쿼리를 날린다. 3. SQL이 어느정도는 표준이지만 DB마다 다르다. 그래서 DB 종류를 바꾸면 쿼리도 바껴야한다.이 개념은 JVM과 유사하다. Java가 처음 등장했을 때 강력했던 이유는 운영체제에 종속적이지 않고 프로그래밍이 가능하다는 것이였다. JVM 에서 운영체제에 맞게 코드를 컴파일, 빌딩 해준다. SQL를 바로 사용하는 것은 데이터베이스마다 SQL 문법이 조금씩 다르기 때문에 데이터베이스를 바꾸게되면 SQL 부분을 모두 바꾸어야 하는 이슈가 발생한다. 하지만 JPA에서 사용하는 JPQL은 DB를 바라보고 쿼리를 짜는 것이 아니기 때문에 데이터베이스에 독립적이게 된다. 4. 모든데이터를 가져오는게 아니고 필요한 데이터만을 가져오기가 어렵다.한 도메인에 해당하는 데이터들을 쿼리를 날려서 가져왔다고 생각해보자. 이 중에 유독 양이 많은 한 필드가 있어서 쿼리의 속도가 느려진다고 하면, 우리는 성능 향상을 위해 이 필드는 필요할때만 가져오도록 다르게 쿼리를 작성할 것이다. Lazy-Loading의 개념인데 쿼리로는 이러한 것들을 모두 직접 구현해야 하지만 JPA에서는 이미 구현되어 있어서 어노테이션 하나를 붙이면 이러한 방식으로 동작하도록 할 수 있다. 여기에서 나오는 대부분의 단점은 사실 JDBC로도 구현이 가능하다. 왜냐하면 결국 JPA도 JDBC로 구현되어 있기 때문이다. 그러나 위와 같은 단점을 모두 극복한 쿼리, 코드를 작성하는 것은 훨씬 많은 고민을 해야하고, 많은 코드를 작성해야한다. JPA는 이러한 고민과 코드들을 오픈소스화 시켜둔 하나의 라이브러리라고 생각하면 보다 이질감 덜할 것 같다. 필수는 아니지만 권장이다. 여기서는 JDBC를 기준으로 JPA를 사용해야하는 이유를 언급하고 있지만 사실 Mybatis와 비교해도 이와 거의 다르지 않다고 본다. ORM 개요ORM의 기본적인 개념은 애플리케이션의 클래스와 SQL 데이터베이스의 테이블 사이의 매핑 정보를 기술한 메타데이터를 사용하여, 자바 애플리케이션의 객체를 SQL 데이터베이스의 테이블에 자동으로 또 꺠끗하게 영속화 해주는 기술입니다. 보다 쉽게 말하자면 Objct와 Relation을 적절하게 Mapping하는 기술이다. 현존하는 대부분의 웹서비스는 관계형 데이터베이스에서 데이터를 가져오고 이를 자바와 같은 호스트 언어로 비즈니스 로직을 다룬 후 화면으로 전달하게 된다. 여기서 관계형 데이터베이스는 데이터들을 테이블이라고 보통 부르는 Relation 기준으로 생성, 관리하고 호스트 언어에서는 도메인 객체 기준으로 데이터를 생성, 관리한다. 이 둘을 매핑시켜주는 역할을 하는 것이 ORM 이다. 12345ORM : Object Relation MappingObject : 자바에서의 도메인 모델Relation : 데이터베이스의 테이블 그러면 왜 도메인 모델을 사용해서 데이터베이스 작업을 할 수 있는게 왜 좋을까? 여기서 말하는 도메인은 DTO, DAO 등은 제외하고 순수히 해당 자바 프로젝트가 O.O.P 방식으로 비지니스를 표현하고 구햔히기 위한 POJO 객체를 일컫는다. 1. 자바에서 비지니스 로직을 구현하려면 결국 SQL로 데이터를 가져와도 결국 자바 객체로 매핑을 해야 한다.결국 최종적으로 그것이 도메인이 아니여도 이와 유사한 자바의 객체로 변환을 해야하는 것은 필수적이다. 2. 디자인패턴을 적용하기 수월하다.현존하는 대부분 디자인패턴의 가이드는 O.O.P 기반임으로 적용하기가 쉬워진다. 3. 우리의 비지니스 로직에 집중이 가능해진다.오직 비지니스 도메인기준으로 기능들을 만들어 낼 수 있음으로 실제 사업에 중요한 비지니스 로직에 보다 더 집중할 수 있다. 이번에는 왜 JPA, 하이버네이트를 사용하게되면 얻게되는 장점을 생각해보자 1. 생산성도메인 데이터와 릴레이션 간 변환 작업이 굉장히 간단하다. 실제 컴퓨터가 하는 작업량이 줄어든다는 의미가 아니고 소스코드 레벨에서 간단해진다는 의미이다. 2. 유지보수성SQL관련 코드가 적어지고 운영에 필요한 비지니스 로직코드만 남기 떄문에 테스트 코드 작성도 편리해지고 가독성이 높아진다. 3. 성능이 이슈는 JPA 에서 가장 두드러지게 언급되는 이슈인데. SQL과 JPA의 성능 비교는 C와 Java의 성능 비교하는 것과 유사하다. C에서는 객체를 사용하고 난 이후에 개발자가 메모리 확보를 위해 연결 해제 작업을 직접 해야하지만 자바는 가비지 컬렉터가 객체의 연결을 해제시키는 역할을 해주기 때문에 연결 해제 작업에 대해서 직접 코딩할 필요는 없다. 물론 필요한 상황들이 있을 떄에는 직접 접근이 가능하다. 이처럼 SQL과 JPA의 관계도 SQL은 많은 것을 개발자가 하도록 되어 있기 때문에 상당 부분 쿼리를 직접 조정하지만 JPA는 독자적인 객체들의 상태를 관리하고 캐싱을한다. 이 캐싱되어 있는 데이터들이 쿼리를 날려야하는 상황인지 아닌지를 판단한다. GC처럼 JPA에게 개발자가 해야할 일을 조금은 넘겨준 것이다. 그렇기에 JPA를 잘 알지 못하고 사용한다면 성능은 SQL 보다 느릴 수 밖에 없지만. 잘 알고 사용한다면 오히려 SQL 보다 더 쉬운 코드로 좋은 쿼리를 작성해낼 수 있다. 4. 벤더 독립성여기서 벤더는 데이터베이스를 말하며, 데이터베이스의 종류에 상관없이 자바에서 쿼리를 동일한 형태로 작성할 수 있다. JPQL, 메서드 쿼리, Querydsl 모두 릴레이션이 아닌 엔티티 기준으로 쿼리를 작성하기 떄문에 일관된 쿼리 작성이 가능하다. 즉 실무에서 데이터베이스를 바꿔야하는 이슈가 생긴 경우, 쿼리의 수정 작업 없이 데이터베이스만 변경할 수 있다. JPA의 가장 치명적인 단점은 바로 학습비용이 너무 크다는 것이다. 1. 학습비용JPA를 쓴다고 해서 기존의 SQL 쿼리를 몰라도 되는 것은 아니다. 내가 JPA 로 작성한 쿼리가 SQL 쿼리 변경되었을 떄 정상적인지를 판단할 수 있어야 성능 튜닝이 가능하다 알아야함.즉 둘다 알아야 ORM을 잘 쓸수 있으며, 잘 모르고 쓴다면 SQL 쿼리로 작업하는 것 보다 못하다. 결국 JPA도 SQL 쿼리 처럼 JDBC 근본에서 동작하기 때문에 성능 이슈가 있는 상황이라면, SQL 쿼리처럼 작성하여 해결 가능하다. ORM: 패러다임 불일치자바는 기본적으로 O.O.P를 하기 위해서 설계된 언어이다. 즉 객체를 기준으로 데이터를 설계하고 관리한다. 그리고 현재 대부분 사용하는 관계형 데이터베이스는 릴레이션을 기준으로 데이터를 표현하고 관리한다. 이 둘이 서로 데이터를 표현하는 기준이 다르기 때문에 생기는 불일치가 있다. 그것이 어떤 것들이 있는지 살펴보고 이를 해결하기 위해 ORM을 어떻게 동작시켜야 하는지 알아보자. 1. 밀도의 문제1234567891011121314151617class Account &#123; Long id; Address address; List&lt;Study&gt; studies; &#125;class Account &#123; Long id; String address; List&lt;Study&gt; studies;&#125; 자바 객체에서는 클래스를 하나 추가함으로써 커스텀한 타입을 만들어 낼수 있지만 릴레이션은 그렇지 않다. 릴레이션의 경우 테이블 타입, 기본 데이터 타입이 전부이며 이 타입들로 자바 객체의 모든 타입을 표현해야 할때 어려움이 있다. 위와 같이 ‘주소’로 예를 들면 자바 객체로 Address 라는 객체를 만들었다고 해서 릴레이션에서 동일하게 이를 표현해줄 방법이 적절한 것이 없다. Address 테이블을 만들어 볼 수는 있지만 조금은 거창한 것 같다. 이런 경우 @Embeddable, @Embbded 어노테이션을 사용하면 Address 같은 객체를 다른 테이블에 하나로 포함 시켜서 표현할 수 있다. 2. 상속관계의 표현 객체는 클래스간의 상속 구조를 만들기가 쉽다. 그게 사실 기본인데 릴레이션에는 상속이라는 개념이 없다. 그렇기에 JPA에서는 @Inheritanced 어노테이션을 제공하며 약 3가지의 방법으로 상속을 릴레이션에 표현할 수 있도록 정의하고 있다. 물론 완벽하게 표현할 수 있는 것은 아니고 모두 대체 방법이다. 3. 관계 문제123456789public class User &#123; List&lt;Study&gt; myStudy;&#125;public class Study &#123; List&lt;User&gt;&#125; 위와 같이 객체는 필드를 가지고 어떤 객체를 참조하고 있는지 그 관계를 표현할 수 있다. 위처럼 User가 메인 클래스고 Study가 필드로써 참조되고 있는 것처럼 그 방향성에 대한 부분도 위 객체 생성시 명시가 가능하다. 그리고 다대다 관계도 표현이 가능하다. 그러나 릴레이션에는외래키로 관계를 표현하며 여기에는 방향성이 사실 없다. 태생적으로 다대다 관계를 만들지 못하며 조인테이블, 링크 테이블을 활용해서 묶어서 관계를 표현한다. 조인테이블을 예를 들면 Study 테이블에서 User 테이블의 FK 를 가지고 있다고 하자. 두 테이블을 조인하고 이 FK 값을 비교해서 결국 두 테이블의 원하는 방향성으로 데이터를 가져올 수 있다. @ManyToOne, @OneToMany 어노테이션들을 활용하여 이러한 문제를 개선할 수 있다. 4. 데이터 네비게이션 문제.1234class A &#123; B b; &#125;class B &#123; C c;&#125; class C &#123; &#125; 객체 내부에서의 네비게이션은 위 예시처럼 A.B.C 형태로 계속 순회가 편리하다. 다 돌아다닐 수 있음. 릴레이션에서 이렇게 동작시키면 가능은 하지만 한번의 조회가 매번 쿼리를 보내야하기 때문에 성능이 안 좋다. SQL은 커넥션 생성 작업이 비싸기때문에 성능을 올리려면 한번의 쿼리로 날리는게 좋다.그런데 한번의 쿼리로 날린다는 것은 테이블들을 모두 조인한다는 건데. 이 많은 데이터를 한번에 모두 사용하는지도 검토해봐야 한다.즉 한번에 필요한 데이터만을 모두 가져와야한다. 여기서 발생하는 성능 이슈 해결을 위해 Lazy Loading 기법이 적용되는 등 JPA 내부적으로 다양한 해결책을 제시한다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"}]},{"title":"JPA 기본 내용에 대한 고찰","slug":"2020-12-24-spring-data-jpa","date":"2020-12-24T02:38:54.000Z","updated":"2022-05-31T07:23:25.000Z","comments":true,"path":"2020/12/24/","link":"","permalink":"http://kidongyun.github.io/2020/12/24/","excerpt":"","text":"JPA 프로그래밍 5. 엔티티 상태와 CascadeCascade 속성은 @ManyToOne, @OneToMany 어노테이션 옵션으로 가지고 있는데 이 어노테이션의 의미는 해당 엔티티 상태의 변화를 어노테이션이 설정된 필드에도 전파하겠다라는 의미이다.용어 자체의 의미는 사전적 의미와 데이터베이스에서 사용되던 의미랑 유사한것 같다. 123456789101112@Entitypublic class Study &#123; @Id @GeneratedValue private Long id; private String name; @ManyToOne(cascade = Cascade.PERSIST) private Account owner;&#125; 예를 들어서 위 코드에서 Study Entity가 A 상태에서 B 상태로 전이될때 Account 객체에도 이 전이를 전파하고 싶다면, 위와 같이 cascade 옵션으로 제공하면 된다. 그러면 전파되는 Entity의 상태라는 것이 어떤 것들이 있는지 알아보자. Entity에는 Transient, Persistent, Detached, Removed 로 총 4가지의 상태가 있다. 이에 대해여 간략하게 알아보도록 하자. 1. Transient1234567public void run() &#123; Account account = new Account(); account.setUserName(&quot;keesun&quot;); account.setPassword(&quot;jpa&quot;);&#125; 위 코드에서는 Account 타입의 객체를 생성하고 필드에 값을 주입하고 있다. 순수하게 Account 객체를 만들고 이를 데이터베이스에 반영하기 위해 JPA에 전달하는 업무가 없다. 이런 작업처럼 릴레이션쪽에 반영이 되는 것이 없고 오직 자바 객체 수준에서만 변화가 있는 상태를 Transient 라고 한다. JPA는 이러한 작업들이 데이터베이스에 영향을 주지 않기 때문에 자신의 관리포인트 안에 두지 않는다. Entity 클래스에서 필드 내에 Transient 어노테이션을 넣는 것과 개념면에서 유사하다. Persistent 123session.save(account); 위에서 만든 account 인스턴스를 하이버네이트 세션을 통해 영속화를 한 이후에는 Persistent 상태로 바뀐다. save를 했다고 해서 바로 데이터베이스에 들어가는 것은 아니다 우선 JPA의 Persistent Contenxt 라는 곳에서 캐싱을 하고 있다가. JPA 스스로 데이터베이스에 들어가야 한다고 판단하는 시점에 들어간다. 이 Persistent Context 영역은 JPA는 데이터베이스에 들어가거나 나와야할 데이터들을 관리하며 쿼리 요청시 해당 데이터가 질의가 필요한지 아닌지도 검증하는데 사용한다. 12345678910111213141516171819202122232425262728293031323334353637import org.hibernate.Session;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.stereotype.Component;import org.springframework.transaction.annotation.Transactional;import javax.persistence.EntityManager;import javax.persistence.PersistenceContext;@Component@Transactionalpublic class JpaRunner implements ApplicationRunner &#123; @PersistenceContext EntityManager entityManager; @Override public void run(ApplicationArguments args) throws Exception &#123; Account account = new Account(); account.setUsername(&quot;kidongyun&quot;); account.setPassword(&quot;hibernate&quot;); Study study = new Study(); study.setName(&quot;Spring Data JPA&quot;); account.addStudy(study); Session session = entityManager.unwrap(Session.class); session.save(account); session.save(study); Account keesun = session.load(Account.class, account.getId()); System.out.println(&quot;============================&quot;); System.out.println(keesun.getUsername()); &#125;&#125; 위의 예제를 보면서 Persistent Context 어떤식으로 동작하는지 살펴보자. Study, Account 타입의 새 객체를 만들고 이를 save() 함수를 통해 데이터베이스에 저장했다. 그 이후에 저장된 데이터를 load() 함수를 통해서 다시 꺼내고 이 데이터 내용을 표준 콘솔로 출력하고 있다. 이런 경우 save() 함수를 호출 했을 때 들어간 데이터들을 JPA는 Persistent Context 영역에 캐싱을 해둔다. 그렇기 때문에 만약 동일한 데이터를 load() 함수로 호출하게 되면 데이터베이스에 접근해서 해당 데이터들을 가져오는 것이 아니고 캐싱된 Persistent Context에서 가져온다.이를 활용하게 되면 실제 필요한 질의의 수가 줄어들기 때문에 성능 향상을 기대해볼 수 있다. 추가적으로 save() 함수 호출했을 때 데이터를 바로 INSERT 하는 것은 아니다. 보통 한 트랜잭션이 끝난 경우에 INSERT 쿼리가 발생하고 실제 데이터베이스에 반영이 된다. 이번에는 Persistent 상태가 가지는 특성 중 하나인 Dirty Checking을 알아보자 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import org.hibernate.Session;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.stereotype.Component;import org.springframework.transaction.annotation.Transactional;import javax.persistence.EntityManager;import javax.persistence.PersistenceContext;@Component@Transactionalpublic class JpaRunner implements ApplicationRunner &#123; @PersistenceContext EntityManager entityManager; @Override public void run(ApplicationArguments args) throws Exception &#123; Account account = new Account(); account.setUsername(&quot;kidongyun&quot;); account.setPassword(&quot;hibernate&quot;); Study study = new Study(); study.setName(&quot;Spring Data JPA&quot;); account.addStudy(study); Session session = entityManager.unwrap(Session.class); session.save(account); session.save(study); Account keesun = session.load(Account.class, account.getId()); keesun.setUsername(&quot;whiteship&quot;); System.out.println(&quot;============================&quot;); System.out.println(keesun.getUsername()); &#125;&#125;import org.hibernate.Session;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.stereotype.Component;import org.springframework.transaction.annotation.Transactional;import javax.persistence.EntityManager;import javax.persistence.PersistenceContext;@Component@Transactionalpublic class JpaRunner implements ApplicationRunner &#123; @PersistenceContext EntityManager entityManager; @Override public void run(ApplicationArguments args) throws Exception &#123; Account account = new Account(); account.setUsername(&quot;kidongyun&quot;); account.setPassword(&quot;hibernate&quot;); Study study = new Study(); study.setName(&quot;Spring Data JPA&quot;); account.addStudy(study); Session session = entityManager.unwrap(Session.class); session.save(account); session.save(study); Account keesun = session.load(Account.class, account.getId()); keesun.setUsername(&quot;whiteship&quot;); keesun.setUsername(&quot;helloworld&quot;); keesun.setUsername(&quot;kidongyun&quot;); System.out.println(&quot;============================&quot;); System.out.println(keesun.getUsername()); &#125;&#125; 위의 코드는 keesun.setUsername(“whiteship”) 이 부분만 추가한 것인데. 요 코드드 사실 상 쿼리와는 연관이 없음에도 하이버네이트가 알아서 인지하고 업데이트 쿼리르 날려줬다. 무슨 뜻이냐면 엔티티 상태가 Persistent 이면 해당 객체를 하이버네이트나 JPA 가 지속 관리를 하고 있다는 것이다. 한 트랜잭션 스코프가 끝났을 때 해당 객체 값이 변경이 이루어 졌다면 변경을 시켜주고, 새로 생성이된 객체가 있다면 INSERT 쿼리를 날려준다. 중요한 사항은 만약 특정 값이 변경이 100번 이루어 졌고 마지막에 결국 초기의 값과 같아졌다면 이 변경 내역 쿼리는 날라가지 않는다. 이는 쿼리 수정내용을 Persistent Context 검증하는 절차를 가진다는 의미이다. Dirty Checking 이라는 것은 이렇게 트랜잭션이 끝날떄마다 변경내용을 지속확인하는 것을 의미. Write Behind 라는것은 Lazy 기법이랑 비슷한 개념인 것 같다. 마지막에 수정한다는 의미. Detached Session 이 종료가 되면 Persistent 상태에서 Detached 상태로 넘어간다. 이 상태가 되면 Persistent 상태에서 관리되어지는 다양한 기능들은 동작하지 않는다.보통 한 Repository 에서 한 트랜잭션이 끝나면 Detached 상태로 전이된다. 1234567891011/* Detached 상태로 가는 함수들 */Session.evict();Session.clear();Session.close();/* Re-attached 해사 다시 Persistent 상태가 되는 함수들 */Session.update();Session.merge();Session.saveOrUpdate(); Removed Cascading 은 엔티티가 Parent 와 Child 관계인 경우에 주로 사용된다. 부모의 것이 삭제가 되면 자식의 것들도 연쇄적으로 삭제가 되어야 한다. Convenience method = 양방향으로 두 객체가 서로 참조하고 있는 경우에 어떤 행위가 일어나면 그거에 대한 작업을 두 방향 모두 해주도록 하는 함수. 내가 직접 만들어야함 위에서 addStudy(), removeStudy() 함수가 이러한 메서드 이다. Cascading 사용 예시를 위해 부모, 자식 구조를 가지는 Entity Post, Comment 를 구현하자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import javax.persistence.*;import java.util.HashSet;import java.util.Set;@Entitypublic class Post &#123; @Id @GeneratedValue private Long id; private String title; @OneToMany(mappedBy = &quot;post&quot;, cascade = CascadeType.PERSIST) private Set&lt;Comment&gt; comments = new HashSet&lt;&gt;(); public void addComment(Comment comment) &#123; this.getComments().add(comment); comment.setPost(this); &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public Set&lt;Comment&gt; getComments() &#123; return comments; &#125; public void setComments(Set&lt;Comment&gt; comments) &#123; this.comments = comments; &#125;&#125;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.ManyToOne;@Entitypublic class Comment &#123; @Id @GeneratedValue private Long id; private String comment; @ManyToOne private Post post; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getComment() &#123; return comment; &#125; public void setComment(String comment) &#123; this.comment = comment; &#125; public Post getPost() &#123; return post; &#125; public void setPost(Post post) &#123; this.post = post; &#125;&#125;import org.hibernate.Session;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.stereotype.Component;import org.springframework.transaction.annotation.Transactional;import javax.persistence.EntityManager;import javax.persistence.PersistenceContext;@Component@Transactionalpublic class JpaRunner implements ApplicationRunner &#123; @PersistenceContext EntityManager entityManager; @Override public void run(ApplicationArguments args) throws Exception &#123; Post post = new Post(); post.setTitle(&quot;Spring Data JPA 언제 보나...&quot;); Comment comment = new Comment(); comment.setComment(&quot;빨리 보고 싶어요.&quot;); post.addComment(comment); Comment comment1 = new Comment(); comment1.setComment(&quot;곧 보여드릴게요.&quot;); post.addComment(comment1); Session session = entityManager.unwrap(Session.class); session.save(post); Post post = session.get(Post.class, 1L); session.delete(post); &#125;&#125; 위처럼 돌리면 comment를 save 하는 함수가 없지만. post가 자기가 하위로 가지고있는 comment 엔티티가 있고. 이를 Cascading 시켰기 때문에. post save 시에 comment에 관련된 내용이. 전파되어 추가된다. delete 되는 부분도 마찬가지로 post를 삭제하면 plan이 cascading 되어 삭제된다. 위 예제는 한 트랜잭션에서 발생했기 때문에 실제로는 save() 함수가 동작하지 않는 것은 참고. 따로따로 두번의 트랜잭션으로 작업해봐야 예제가 정상적으로 돌거다. JPA 프로그래밍 6. Fetch연관관계의 엔티티를 어떻게 가져올 것이냐… 지금가져온다면 (Eager) 나중에 가져온다면 (Lazy) 기본적으로 @OneToMany 어노테이션은 Lazy 방법으로 가져온다. 예를 들어 위에서 구현한 Post 객체와 Comment 객체로 참고해보면.Post 객체를 가져오는 것은 단일 건인데 Comment 건은 복수개로 얼마나 많은지를 알수가 없다. 이러한 상황에서 Post 만가져와도 되는 비지니스 로직이라면 많은 수를 가지고 있는 Comment 객체를 가져오는 것은 비효율적이기 때문에 Lazy loading 방법으로 가져온다. 반대로 @ManyToOne 은 EAGER 방식이다. 12345678910111213@OneToMany(fetch = FetchType.LAZY)@ManyToOne(fetch = FetchType.EAGER)Post post = session.get(Post.class, 1L);System.out.println(post.getTitle());Comment comment = session.get(Comment.class, 2L);System.out.println(comment.getComment());System.out.println(comment.getPost().getTitle()); session.get() 함수는 해당하는 값이 없는 경우 NULL 리턴, session.load() 는 없는 경우 예외를 반환, 프록시로도 가져올 수 있따. 이걸 잘 조절해야 성능 이슈를 해결할 수 있다. 가장 흔한 N+1 의 문제. JPA 프로그래밍 7. 쿼리지금까지는 HIBERNATE API 에서 제공하는 Session 객체를 활용해서 구현을 했음.JPA가 하이버네이트를 감싸고 있다. 내부적으로 사용하고 있따. JPQL (HQL)Java Persistencec Query Language / Hibernate Query Language 쿼리 모양이 우리가 기존에 알고 있는 SQL과 굉장히 유사하다. 다만 다른 점은 데이터베이스 테이블 기준이 아니고. 엔티티 객체 모델 기반으로 쿼리를 작성한다. 12345678910111213141516171819202122import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.stereotype.Component;import org.springframework.transaction.annotation.Transactional;import javax.persistence.EntityManager;import javax.persistence.PersistenceContext;@Component@Transactionalpublic class JpaRunner implements ApplicationRunner &#123; @PersistenceContext EntityManager entityManager; @Override public void run(ApplicationArguments args) throws Exception &#123; entityManager.createQuery(&quot;SELECT p FROM Post AS p&quot;); &#125;&#125; JPQL / HQL 은 기존 SQL이 아니기 때문에 데이터베이스 벤더에 독립적이다. 사용되어지는 데이터베이스 쿼리로 변환되어 질의가 실행된다. 쿼리를 어노테이션으로 지정해두고 불러와서도 사용이 가능하다. toString에 @ManyToOne 타입으로 있는 필드를 찍어놓으면. 필요없이 단순히 습관적으로 한거겠지만. toString 호출시 Comment 관련 쿼리도 날라간다. toString 때문에. JPA, 하이버네이트 쓸때는 항상 무슨 쿼리를 발생시키는지, 내가 성능이슈를 점검해야하니 의도한건지를 항상 파악해야한다. 학습비용이 드는거지만 어쩔수 없다. JPQL 의 단점은 TypeSafe 하지 않다. 문자열로 전달되기 때문. -&gt; 타입세이프한 방법이 있따 Criteria 사용해보자 1234567891011121314151617181920212223242526272829303132import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.stereotype.Component;import org.springframework.transaction.annotation.Transactional;import javax.persistence.EntityManager;import javax.persistence.PersistenceContext;import javax.persistence.criteria.CriteriaBuilder;import javax.persistence.criteria.CriteriaQuery;import javax.persistence.criteria.Root;import java.util.List;@Component@Transactionalpublic class JpaRunner implements ApplicationRunner &#123; @PersistenceContext EntityManager entityManager; @Override public void run(ApplicationArguments args) throws Exception &#123; CriteriaBuilder builder = entityManager.getCriteriaBuilder(); CriteriaQuery&lt;Post&gt; query = builder.createQuery(Post.class); Root&lt;Post&gt; root = query.from(Post.class); query.select(root); List&lt;Post&gt; posts = entityManager.createQuery(query).getResultList(); posts.forEach(System.out::println); &#125;&#125; native Query 를 사용하는 방법도 있따. 1234567891011121314151617181920212223242526import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.stereotype.Component;import org.springframework.transaction.annotation.Transactional;import javax.persistence.EntityManager;import javax.persistence.PersistenceContext;import java.util.List;@Component@Transactionalpublic class JpaRunner implements ApplicationRunner &#123; @PersistenceContext EntityManager entityManager; @Override public void run(ApplicationArguments args) throws Exception &#123; List&lt;Post&gt; posts = entityManager.createNativeQuery(&quot;Select * from Post&quot;, Post.class) .getResultList(); posts.forEach(System.out::println); &#125;&#125; 스프링 데이터 JPA 원리EntityManager 를 직접 쓰던 상황에서 이제 Repository 라는 DAO 유사한 녀석을 만들고 여기 안에서 이 EntityManager 활용한 디비 작업을 모으기 시작함. 이걸 또 제네릭화 시키고 최종적으로 JpaRepository 형태로 공통화시켜 이걸 상속받기만 하면 되는 구조가 되어있음. @EnableJpaRepositories 어노테이션은 Repository 관련 빈들을 자동 등록해주는 어노테이션인데 스프링 부트에는 자동설정을 해주기 때문에(Auto Configuration 방법으로 ). 이 어노테이션을 붙이지 않아도 되고. 또 각 Repository에 @Repository 어노테이션을 붙이지 않아도 됨. 기존에 EntityManager 을 활용해서 사요하는 방식보다 이 Spring Data JPA는 결국 Repository 부분을 보면 기본적인 CRUD 쿼리들은 제공이 되기 때문에 이를 사용하고 되면 이 말은 즉은 내가 만든 코드가 아니기때문에 테스트 영역 줄어둔다. 코드가 적으니 생산성이 살아나고, 유지보수도 좋아진다. @EnableJpaRepositories 어노테이션 안을 살펴보면 JpaRepositoriesRegistrar 클래스를 임포트 하고 있는데 이녀석이 바로 JPA Repository 들을 주입해주는 역할을 한다. 요 녀석은 JpaRepository 를 상속받는 Repository 들을 찾아서 빈으로 등록해준다. 이를 예제로 코딩해보면 아래와 같다. 12345678910111213141516171819202122232425262728293031323334353637383940public class Keesun &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.beans.factory.support.BeanNameGenerator;import org.springframework.beans.factory.support.GenericBeanDefinition;import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;import org.springframework.core.type.AnnotationMetadata;public class KeesunRegistrar implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator) &#123; GenericBeanDefinition beanDefinition = new GenericBeanDefinition(); beanDefinition.setBeanClass(Keesun.class); beanDefinition.getPropertyValues().add(&quot;name&quot;, &quot;whiteship&quot;); registry.registerBeanDefinition(&quot;keesun&quot;, beanDefinition); &#125;&#125;@SpringBootApplication@Import(KeesunRegistrar.class)public class Demojpaspringdata2Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Demojpaspringdata2Application.class, args); &#125;&#125; 보면 Keesun 클래스가 빈 등록을 위한 어노테이션이 없음에도 KeesunRegistrar 객체에서 Keesun 객체를 프로그래밍적으로 빈 등록을 해주고 있따.내가 만든 Repository 클래스들도 위와 같은 방식으로 JpaRepositoriesRegistrar 요 객체가 등록을 해준다. 물음표로 나오는 값을 실제 값이 나오게끔 로깅하는 방법. 1logging.level.org.hibernate.type.descriptor.sql=trace 스프링 데이터 JPA 활용Spring Data 라는 것은 여러 개의 프로젝트를 범주잡아 일컫는 말임. 여기에 JPA, REDIS, REST, MONGODB 등 많은 것들이 포함되어 있음.그중 공통적인 작업들을 Spring Data Common 이라는 프로젝트에 넣어뒀는데 여기에 리포지토리를 생성하고, 메소드 쿼리를 구현하는 작업들이 있음. Spring Data Common 1. 리포지토리Spring Data Common 프로젝트에 있는 3개의 상위 리포지토리 - Repository, CrudRepository, PagingAndSortingRepositorySpring Data Jpa 프로젝트에 있는 리포지토리 - JpaRepository. @NoRepositoryBean 어노테이션이 붙는 이유 - 이게 붙어있는 리포지토리는 빈으로 등록하는 걸 방지 즉 서브 클래스를 만들어서 상속받아서 사용하라는 이야기. @DataJpaTest DAO 레벨을 테스트할 떄 이 어노테이션을 스프링부트에서 제공해준다. -&gt; Repository 만 등록이 된다.리포지토리만 빈등록 스코프가 잡히기 때문에 빈이 많은 프로젝트의 경우 보다 빈등록하는데에 가볍다. h2 디비는 메모리 디비를 사용해서 테스트를 하면 실제 어플리케이션에서 사용하는 포스트그레스큐엘 디비에는 영향이 가지 않는다.또 H2 디비는 메모리 디비 이기 떄문에 실제 디비를 사용하는것보다 더 빠르다. 123456&lt;dependency&gt; &lt;groupId&gt;org.postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/artifactId&gt;&lt;/dependency&gt; import static org.assertj.core.api.Assertions.assertThat 이 라이브러리르 사용하면 아래처럼 코드를 짤 수 있다.assertThat(post.getId()).isNull(); 기본적으로 @Test 테스트 코드는 테스트 이후에 롤백이 된다. 이 트랜잭션 처리하는 롤백기능은 스프링 프레임워큭에서 제공하는 기능.롤백을 하고싶지 않다고 하면 어노테이션 추가. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.junit4.SpringRunner;import java.util.List;import static org.assertj.core.api.Assertions.assertThat;@RunWith(SpringRunner.class)@DataJpaTestpublic class PostRepositoryTest &#123; @Autowired PostRepository postRepository; @Test @Rollback(false) public void crudReposiroy() &#123; // Given Post post = new Post(); post.setTitle(&quot;hello spring boot common&quot;); assertThat(post.getId()).isNull(); // When Post newPost = postRepository.save(post); // Then assertThat(newPost.getId()).isNotNull(); // When List&lt;Post&gt; posts = postRepository.findAll(); // Then assertThat(posts.size()).isEqualTo(1); assertThat(posts).contains(newPost); // When Page&lt;Post&gt; page = postRepository.findAll(PageRequest.of(0, 10)); // Then assertThat(page.getTotalElements()).isEqualTo(1); assertThat(page.getNumber()).isEqualTo(0); assertThat(page.getSize()).isEqualTo(10); assertThat(page.getNumberOfElements()).isEqualTo(1); // When postRepository.findByTitleContains(&quot;spring&quot;, PageRequest.of(0, 10)); // Then assertThat(page.getTotalElements()).isEqualTo(1); assertThat(page.getNumber()).isEqualTo(0); assertThat(page.getSize()).isEqualTo(10); assertThat(page.getNumberOfElements()).isEqualTo(1); // When long spring = postRepository.countByTitleContains(&quot;spring&quot;); // Then assertThat(spring).isEqualTo(1); &#125;&#125;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.jpa.repository.JpaRepository;public interface PostRepository extends JpaRepository&lt;Post, Long&gt; &#123; Page&lt;Post&gt; findByTitleContains(String title, Pageable pageable); long countByTitleContains(String title);&#125; 위 코드는 기존에 만들어져 있는 CrudRepository 와 PagingAndSortingRepository 기능들을 테스트 코드 짜본 것. 의미는 없는데 내가 보기엔 Repository 테스트코드를 이런식으로 작성해야 한다를 보여주는 것 같음. 쿼리 메소드 H2 DB를 사용하고 있는지는 스프링 부트가 뜰때 로그를 보면 알수 있다. 단 @DataJpaTest 어노테이션을 붙여야함. 그리고 의존성을 추가했을 떄. 12020-12-25 22:26:27.671 INFO 3476 --- [ main] org.hibernate.dialect.Dialect : HHH000400: Using dialect: org.hibernate.dialect.H2Dialect Spring Data Common 2. 인터페이스 정의하기지금까지는 스프링데이타 Common 이나 스프링 데이터 JPA 에서 제공하는 리포지토리의 기능이 들어오는게 싫다. 내가 다 정의하고 싶은 경우. 123456789101112import org.springframework.data.repository.RepositoryDefinition;import java.util.List;@RepositoryDefinition(domainClass = Comment.class, idClass = Long.class)public interface CommentRepository &#123; Comment save(Comment comment); List&lt;Comment&gt; findAll();&#125; 이렇게 @RepositoryDefinition 어노테이션을 활용해서 직접 정의가 가능하다. 이런식으로 정의했을 때 공통적으로 쓰이는 기능들을 묶고싶다면. Repository 객체의 최상위 인터페이스인 Repository를 상속받고 이를 통해 구현하도록 하자. 12345678910111213141516171819import org.springframework.data.repository.NoRepositoryBean;import org.springframework.data.repository.Repository;import java.io.Serializable;import java.util.List;@NoRepositoryBeanpublic interface MyRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; &#123; &lt;E extends T&gt; E save(E Comment); List&lt;T&gt; findAll();&#125;public interface CommentRepository extends MyRepository&lt;Comment, Long&gt; &#123;&#125; JpaRepository 같은걸 커스텀하게 만들었다고 생각하면 되겠다. Spring Data Common 3. Null 처리단일 값을 받을때 Optional 로 받는것을 권장. List로 받는것은 Null이 안나온다. 아마 갯수는 없는 List의 형태의 객체가 나올듯(비어있는 콜렉션). 그렇기때문에 List 로 받는 것은 Optional 로 받을 필요가 없음. 이건 Spring Data JPA 특징. 이걸 통해서 컬렉션 구조를 반환하는 함수는 결코 NULL이 되지 않음. @NonNull, @Nullable 1234567891011121314151617181920212223242526272829303132333435363738394041import org.springframework.data.repository.NoRepositoryBean;import org.springframework.data.repository.Repository;import org.springframework.lang.NonNull;import org.springframework.lang.Nullable;import java.io.Serializable;import java.util.List;import java.util.Optional;@NoRepositoryBeanpublic interface MyRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; &#123; &lt;E extends T&gt; E save(@NonNull E Comment); List&lt;T&gt; findAll(); long count(); @Nullable &lt;E extends T&gt; Optional&lt;E&gt; findById(ID id);&#125;import org.junit.jupiter.api.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@DataJpaTestclass CommentRepositoryTest &#123; @Autowired CommentRepository commentRepository; @Test public void crud() &#123; commentRepository.save(null); &#125;&#125; 파라미터에 Null이 들어가면 안될 때 해당 파라미터에 @NonNull 어노테이션을 붙이면 IDE에서 점검이 가능하고 런타임시에 Null이 들어갔다고 exception이 발생한다. Spring Data Common 4. 쿼리 만들기쿼리 만드는 방법은 2가지가 있다. @EnableJpaRepositories(queryLookupStrategy = QueryLookupStrategy.Key.CREATE) 쿼리 메서드 (메소드 이름을 분석해서 쿼리 만들기) @EnableJpaRepositories(queryLookupStrategy = QueryLookupStrategy.Key.USE_DECLARED_QUERY) @Query 어노테이션 활용 (미리 정의해 둔 쿼리 찾아 사용하기.) 기본값은 JPQL 이며 SQL 을 사용하고 싶다면 옵션중에 nativeQuery를 true로 적용. 이거가 디폴트 맞네 미리 정의한 쿼리를 찾아보고(메서드 쿼리를 찾아보고) 없으면 만들기. -&gt; 이거를 사용하고 싶으면 @EnableJpaRepositories 이 어노테이션에@EnableJpaRepositories(queryLookupStrategy = QueryLookupStrategy.Key.CREATE_IF_NOT_FOUND) 이렇게 옵션을 주면 됨. 쿼리 찾는 방법. @Query @Procedure @NamedQuery 123456789메서드 쿼리 사용시 규칙접두어 : Find, Get, Query, Count도입부 : Distinct, First(N), Top(N) /* 생략 가능* /프로퍼티 표현식 : 보통 리포지토리는 한 엔티티를 위한 리포지토리로 구현이 되어야함. 그렇기 때문에 내가 생각했던 그 JpaBeanRepository를 만드는 것은 모두를 위한 리포지토리를 만드는 것이기 때문에 내가 볼때는 Spring Data jpa의 정책에 조금 어긋난 방법이지 않았나. 그래서 서비스단에서 Repository를 기본 CRUD에 대해서 하나로 묶고 싶다면 JpaService 하나에 Repository를 여러개 넣는 방법이 최선일것 같고. Pageable 객체에 Paging 관련 기능과 sorting 관련 기능이 같이 있다 이걸 활용하면되고, sorting만 해야할 경우에는 Sort 객체 활용. 보통 쿼리를 만들때에는 Pageable를 권장. (1) 메서드 쿼리로 구현이 가능한지 확인 확인하는방법 -&gt; 테스트를 만들어서 확인하면됨 (2) 메서드 쿼리를 잘 만든건지 확인 -&gt; 그냥 돌려보면 된다ㅏ. 비어있는 테스트 함수 하나 만들고 돌리면 됨. (3) 쿼리DSL 사용 Spring Data Common 5. 쿼리 만들기 실습ignoreCase 를 쓰면 upper() 쿼리가 추가되어 대소문자 구분이 사라진다. Stream&lt;&gt; 타입으로 받으면 try-with-resouce 문법을 사용할 것 Stream을 다쓴다음에 close() 해야함. 123456789101112131415161718192021import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import java.util.List;public interface CommentRepository extends MyRepository&lt;Comment, Long&gt; &#123; List&lt;Comment&gt; findByCommentContains(String keyword); List&lt;Comment&gt; findByCommentContainsIgnoreCase(String keyword); List&lt;Comment&gt; findByCommentContainsIgnoreCaseAndLikeCountGreaterThan(String keyword, Integer likeCount); List&lt;Comment&gt; findByCommentContainsIgnoreCaseOrderByLikeCountDesc(String keyword); List&lt;Comment&gt; findByCommentContainsIgnoreCaseOrderByLikeCountAsc(String keyword); Page&lt;Comment&gt; findByCommentContainsIgnoreCase(String keyword, Pageable pageable);&#125; Spring Data Common 7. 커스텀 리포지토리 만들기255자 이상의 컬럼은 @Lob 어노테이션을 넣어주면 됨. 스프링 데이터 리포지토리 인터페이스 기능에 추가커스텀 리포지토리는 JPA, SPRING 에 침투받지 않음. 순수한 POJO 객체임 이거를 구현하는 Impl 클래스를 만들고 여기에서 EntityManager 를 통해 직접 데이터 액세스하는 부분을 구현한다.그리고 커스텀 리포지토리를 JpaRepository를 상속하고 있는 비지니스별 Repository에 같이 상속시켜준다. 123456789import java.util.List;public interface PostCustomRepository&lt;T&gt; &#123; List&lt;Post&gt; findMyPost(); void delete(T entity);&#125; 123456789101112131415161718192021222324252627import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import javax.persistence.EntityManager;import javax.transaction.Transactional;import java.util.List;@Repository@Transactionalpublic class PostCustomRepositoryImpl implements PostCustomRepository&lt;Post&gt; &#123; @Autowired EntityManager entityManager; @Override public List&lt;Post&gt; findMyPost() &#123; System.out.println(&quot;custom findMyPost&quot;); return entityManager.createQuery(&quot;SELECT p FROM Post AS p&quot;, Post.class).getResultList(); &#125; @Override public void delete(Post entity) &#123; System.out.println(&quot;custom delete&quot;); entityManager.detach(entity); &#125;&#125; 12345678import org.springframework.data.jpa.repository.JpaRepository;public interface PostRepository extends JpaRepository&lt;Post, Long&gt;, PostCustomRepository&lt;Post&gt; &#123;&#125; Impl 이라는 용어가 싫으면 @EnableJpaRepositories 요 어노테이션에 repositoryImplementationPostfix 옵션에 원하는 문구로 바꾸면 됨. 스프링 데이터 Common 8. 기본 리포지토리 커스터마이징모든 리포지토리에 공통적으로 추가하고 싶은 기능이 있거나 덮어쓰고 싶은 기본 기능이 있다면. 이렇게하자 우선 내가 했던대로 JpaRepository 요걸 상속하는 Repository를 하나 만든다. 다른점은 구현체를 하나더 만들고 이 구현체는 SImpleJpaRepository를 상속 entityManager.contains -&gt; persistent context에 해당 객체가 있는지 없는지를 확인해주는 함수 JpaRepository 를 상속한 리포지토리는 @NoRepositoryBean 등록 바로 빈등록 하면 안된다고 얘기하는 것임 1234567891011import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.repository.NoRepositoryBean;import java.io.Serializable;@NoRepositoryBeanpublic interface MyRepository&lt;T, ID extends Serializable&gt; extends JpaRepository&lt;T, ID&gt; &#123; boolean contains(T entity);&#125; 12345678910111213141516171819202122import org.springframework.data.jpa.repository.support.JpaEntityInformation;import org.springframework.data.jpa.repository.support.SimpleJpaRepository;import javax.persistence.EntityManager;import java.io.Serializable;public class SimpleMyRepository&lt;T, ID extends Serializable&gt; extends SimpleJpaRepository&lt;T, ID&gt; implements MyRepository&lt;T, ID&gt; &#123; private EntityManager entityManager; public SimpleMyRepository(JpaEntityInformation&lt;T, ?&gt; entityInformation, EntityManager entityManager) &#123; super(entityInformation, entityManager); this.entityManager = entityManager; &#125; @Override public boolean contains(T entity) &#123; return entityManager.contains(entity); &#125;&#125; 123456789101112131415import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;@SpringBootApplication@EnableJpaRepositories(repositoryBaseClass = SimpleMyRepository.class)public class Demojpa3Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Demojpa3Application.class, args); &#125;&#125; 12345678910111213141516171819202122232425262728293031import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;import org.springframework.test.context.junit4.SpringRunner;import static org.assertj.core.api.Assertions.assertThat;@RunWith(SpringRunner.class)@DataJpaTestpublic class PostRepositoryTest &#123; @Autowired PostRepository postRepository; @Test public void crud() &#123; Post post = new Post(); post.setTitle(&quot;hibernate&quot;); assertThat(postRepository.contains(post)).isFalse(); postRepository.save(post); assertThat(postRepository.contains(post)).isTrue(); postRepository.delete(post); postRepository.flush(); &#125;&#125; 이방법은 내가 생각한게 아니고. JpaRepository 가 기본적으로 제공하지ㅇ 않는 어떤 기능을 모든 Repository 들이 공통적으로 사용하게끔 하고 싶을때 사용하는 방법. Spring Data Common 9. 도메인 이벤트 퍼블리싱 기능도메인 엔티티의 변화를 이벤트로써 발생시키고, 이벤트리스너가 이러한 변화를 감지하고, 이벤트 기반의 프로그래밍이 가능하게끔 하는 것. ApplicationContext 는 우리가 아는 IoC의 기능을 하는 BeanFactory 를 상속을 받았고 또 ApplicationEventPublisher 도 상속을 받았다. 모든 스프링에는 이벤트 기반 코딩이 가능하다. 이를 지원한다. 우선 먼저 스프링에서 제공하는 이벤트기반 코딩 예시를 살펴보자. 테스트 코드에서 빈관련 설정 코드 넣을 때에는 필요로하는 객체 + TestConfig 라고 이름짓고 클래스르 만든다음.주입받으려고하는 객체 빈 등록해주고, 이 설정 파일을 테스트할때 사용하려면 테스트 클래스에 @Import(객체 + TestConfig.class) 넣어주면 된다. 12345678910111213141516import org.springframework.context.ApplicationEvent;public class PostPublishedEvent extends ApplicationEvent &#123; private final Post post; public PostPublishedEvent(Object source) &#123; super(source); this.post = (Post) source; &#125; public Post getPost() &#123; return post; &#125;&#125; 12345678910111213141516171819202122232425262728293031import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Import;import org.springframework.test.context.junit4.SpringRunner;import static org.assertj.core.api.Assertions.assertThat;@RunWith(SpringRunner.class)@DataJpaTest@Import(PostRepositoryTestConfig.class)public class PostRepositoryTest &#123; @Autowired PostRepository postRepository; @Autowired ApplicationContext applicationContext; @Test public void event() &#123; Post post = new Post(); post.setTitle(&quot;event&quot;); PostPublishedEvent event = new PostPublishedEvent(post); applicationContext.publishEvent(event); &#125;&#125; 123456789101112import org.springframework.context.ApplicationListener;public class PostListener implements ApplicationListener&lt;PostPublishedEvent&gt; &#123; @Override public void onApplicationEvent(PostPublishedEvent event) &#123; System.out.println(&quot;-------------------------&quot;); System.out.println(event.getPost() + &quot; is published!&quot;); System.out.println(&quot;-------------------------&quot;); &#125;&#125; 12345678910111213import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class PostRepositoryTestConfig &#123; @Bean public PostListener postListener() &#123; return new PostListener(); &#125;&#125; 이러한 구조의 이벤트 코딩을 할수 있또록 스프링 데이터에서도 제공한다. 스프링 데이터 Common 10. QueryDSL 연동 사용 이유. 조건문을 표현하는 방법이 굉장히 타입세이프 하다. 조건문들을 조합할 수 있다. 쿼리 메서드의 단점은 함수의 이름이 굉장히 길어지는 단점이 있다. 가독성 감소. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;me.whiteship&lt;/groupId&gt; &lt;artifactId&gt;querydsldemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;querydsldemo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-apt&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt; &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;process&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;target/generated-sources/java&lt;/outputDirectory&gt; &lt;processor&gt;com.querydsl.apt.jpa.JPAAnnotationProcessor&lt;/processor&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package me.whiteship.querydsldemo.account;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;@Entitypublic class Account &#123; @Id @GeneratedValue private Long id; private String username; private String firstName; private String lastName; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getFirstName() &#123; return firstName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125;&#125; 123456789import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.querydsl.QuerydslPredicateExecutor;public interface AccountRepository extends JpaRepository&lt;Account, Long&gt;, QuerydslPredicateExecutor&lt;Account&gt; &#123;&#125; QuerydslPredicateExecutor 이 클래스에는 findOne, findAll 두가지 함수가 존재. findOne은 단일 건으로 Optional로 결과를 반환하고 findAll은 컬렉션으로 반환.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"JPA","slug":"JPA","permalink":"http://kidongyun.github.io/tags/JPA/"}]},{"title":"API 서버에서 응답 객체에 대한 고찰","slug":"2020-12-14-response","date":"2020-12-14T02:38:54.000Z","updated":"2022-05-31T07:22:54.000Z","comments":true,"path":"2020/12/14/","link":"","permalink":"http://kidongyun.github.io/2020/12/14/","excerpt":"","text":"API 개발 작업을 처음 의뢰 받게 되면 가장 먼저 눈에 들어오는 것은 일반적으로 요청과 응답에 대한 API SPEC 일 것이다 . 클라이언트에서 어떤 데이터를 요구하는지, 서버에서는 클라이언트의 요구에 어떻게 응답해줘야 하는지 고민 해야 한다.이 글에 주된 내용은 API 응답 구조를 어떠한 형태로 그리는 것이 보다 나은지 에 대한 이야기이다. 특히 응답 객체 내에서 비즈니스 데이터가 아닌 필연적으로 가지게 되는 에러 코드, 에러 상태 등에 대한 것을 다룬다.이 글은 저자의 경험에 비롯된 주관적인 글임으로 단순히 하나의 참고 글로써 읽어주시길 바란다. 에러 코드, 에러 설명 필드 명123456789101112131415161718&#123; &quot;errorCode&quot;: 0, &quot;errorDesc&quot;: &quot;정상입니다&quot;, ...&#125;&#123; &quot;errorNo&quot;: 1003, &quot;errorDescription&quot;: &quot;카드번호 불일치 오류&quot;, ...&#125;&#123; &quot;status&quot;: 1003, &quot;description&quot;: &quot;카드번호 불일치 오류&quot;, ...&#125; 내가 개발 초기에 자주 접했던 API 응답 구조는 보통 위와 같은 구조였다. 에러 코드와 에러 설명을 위한 두 값이 필연적으로 존재하고, 그 필드 명은 각 API 마다 상이했다.여기서 내가 느낀 한 가지 문제점을 언급해보려고 한다.API 서버를 바라보고 있는 클라이언트 개발자가 있다고 생각하자. API 마다 에러 코드, 에러 설명에 대한 필드 명이 모두 다르기 때문에 각 API 들을 쓸 때 서버 쪽에서 제공하는 API 공식 문서를 확인 해야 하고, 문서가 제대로 준비되어 있지 않다면 API 서버 개발자와 연락을 해서 정보를 얻어야 한다. 1에러 코드, 에러 설명에 대한 필드 명을 각 API 마다 확인 해야 한다. 통일된 Response 응답 객체그렇다면 에러 코드, 에러 설명에 해당하는 필드 명을 모든 API 에서 항상 동일하게 내려주는 것이 어떨까? 그렇게 된다면 API 사용자의 입장에서는 에러 코드, 에러 설명 필드 명을 바로 인지 할 수 있으며 이를 찾기 위한 시간을 줄일 수 있을 것이다.그렇다면 이를 어떻게 구현할 수 있을까? 물론 파트너들과 개발 가이드 문서를 만들고 특정 필드 명을 사용하도록 규정을 정할 수도 있지만, 아래와 같이 공통의 Response 객체를 만들어 사용할 수도 있다. 1234567class Response &#123; private int errorCode; private String errorDesc; private Object data;&#125; 대부분의 응답 객체가 가져야 하는 에러 코드, 에러 설명 정보를 ‘errorCode’, ‘errorDesc’ 필드 명으로 통일하여 API 사용자가 보다 알아보기 쉬운 획일적인 API 구조로 내려줄 수 있게 되었다. 서버 개발자 마음대로의 에러 코드이제 다음 문제점을 생각해보자. 현재 API 사용자들은 이 ‘errorrCode’ 에 들어가는 각 숫자들의 의미를 API 가이드 공식 문서를 통해 이해해야 한다. ‘errorCode’ 값이 ‘1003’ 일 때 ‘카드 번호 불일치 오류’ 라고 한다면 API 사용자들은 단순히 받아들여야 한다. 즉 에러 코드에 대한 결정이 순전히 서버 개발자의 마음대로 이기 때문에 API 사용자는 새로운 API 를 접할 때마다 매번 새로운 에러 코드 규칙을 익혀야 한다.에러 코드에 대한 설명을 보통은 API 문서를 통해 제공 받지만 경험적으로 API 문서가 잘 관리되는 것은 쉽지 않다. 항상 시간에 쫓겨 야근까지 하는 개발자에게 문서 작업도 완벽하게 하는 것은 쉽지 않다고 생각한다.API 공식 문서가 잘 관리되지 않는다면 특정 ‘errorCode’ 가 반환 되었을 때 해당 오류에 대한 자세한 정보를 문서에서 확인하기 어려우며 오로지 ‘errorDesc’ 에서 내려오는 설명을 가지고 이해해야 한다.물론 Swagger 등의 API 문서화를 자동화 해주는 다른 접근으로의 해결 방법들이 존재하지만 지금은 보다 근본적인 문제점을 생각하자. 표준화 되어있는 에러 코드API 통신은 여러가지 형태로 존재할 수 있지만, 현대에 와서는 많은 서비스들이 HTTP 프로토콜을 기반으로 하여 통신을 한다. 그렇다면 이미 표준으로 지정되어 있는 HTTP STATUS 코드를 기반으로 ‘errorCode’ 값을 만들면 어떨까?그렇다면 API 사용자들도 받아들이기 쉬울 것이다.HTTP STATUS 의 특성에 따라 ‘200’ 이면 성공,‘400’ 대역의 에러 코드가 나타났다면 API 사용자가 날린 요청에 오류가 있고, ‘500’ 대역의 에러 코드가 나타났다면 서버에 오류가 있음을 API 사용자들이 바로 인지할 수 있게 된다. 1234567891011&#123; &quot;errorCode&quot;: 200, &quot;errorDesc&quot;: &quot;OK&quot;, ...&#125;&#123; &quot;errorCode&quot;: 500, &quot;errorDesc&quot;: &quot;INTERNAL_SERVER_ERROR&quot;, ...&#125; HTTP STATUS 에 대한 공식 문서를 찾아보면 이미 다양한 케이스에 대해서 미리 정의를 해두고 있다. 대부분의 경우에는 이를 활용해서 ‘errorCode’, ‘errorDesc’ 값을 내릴 수 있다고 생각한다.그러나 특정 비즈니스에 맞춰져 있는 오류를 반환 해야 할 경우도 있다. 그런 경우에는 기존의 방식대로 서버 개발자가 임의의 에러 코드를 만들고 이를 사용해야 한다. 다만 이런 경우에는 클라이언트의 이해를 위해 ‘errorDesc’ 정보를 보다 자세하게 적거나, API 문서를 명확히 하는 것이 좋다. 동적타입의 활용1234567class Response &#123; private int errorCode; private String errorDesc; private Object data;&#125; 이전에 만든 Response 객체에서 data 필드 부분을 좀 더 살펴보자.이 필드는 특정 비즈니스에 맞춰진 모든 데이터들을 받아야 하기 때문에 Object 타입으로 받고 있다. Response의 관점에서는 알 수 없는 구조를 받아야 하기 때문에 Object 타입을 사용하는 것은 불가피하다. 그러나 Object 타입의 근본적인 문제는 타입 세이프 하지 않아서 컴파일 시점에 오류를 찾아내지 못한다. 1234567891011121314151617181920@Getter@Setter@Builderclass Response &#123; private int errorCode; private String errorDesc; private Object data;&#125;@RequestMappingpublic Response goodExample() &#123; return Response.builder().errorCode(200).errorDesc(&quot;OK&quot;).data(150).build();&#125;@RequestMappingpublic Response badExample() &#123; return Response.builder().errorCode(200).errorDesc(&quot;OK&quot;).data(&quot;150&quot;).build();&#125; ‘data’ 필드에 들어갈 데이터의 형식이 ‘int’ 이기를 기대했지만 실제로는 ‘Object’ 타입이기 때문에 ‘String’, ‘int’ 모두를 고려하지 않고 받게 되어. 컴파일 시점에 오류를 검출하지 못한다. 이를 개선하기 위해 제네릭 문법을 활용해서 동적으로 타입을 지정할 수 있도록 하자. 1234567891011121314151617181920@Getter@Setter@Builderclass Response&lt;T&gt; &#123; private int errorCode; private String errorDesc; private T data;&#125;@RequestMappingpublic Response&lt;Integer&gt; goodExample() &#123; return Response.&lt;Integer&gt;builder().errorCode(200).errorDesc(&quot;OK&quot;).data(150).build();&#125;@RequestMappingpublic Response&lt;Integer&gt; badExample() &#123; return Response.&lt;Integer&gt;builder().errorCode(200).errorDesc(&quot;OK&quot;).data(&quot;150&quot;).build();&#125; ‘badExample()’ 의 경우에는 ‘Integer’ 타입을 원하지만 ‘data’ 필드에 ‘String’ 객체를 넣었음으로 컴파일 시점에 오류가 나타날 것이다. ErrorDesc 필드의 필요성우리는 습관적으로 ‘errorCode’, ‘errorDesc’ 두 값을 마치 형제처럼 종종 함께 선언하고 사용했다. 이 구조에 대해서 좀 더 면밀히 생각해보자.‘errorDesc’ 값은 API 통신에 문제가 없는 경우 사용될 일이 없다. 왜냐하면 필드 명에서 말해주듯이 에러가 발생했을 때 에러에 대한 설명을 넣기 위한 필드이기 때문이다. 반대로 data 필드를 생각해보자. 이 값은 일반적으로 API 통신이 성공적일 경우에만 사용이 될 수 있다.그러면 ‘errorDesc’ 필드와 ‘data’ 필드를 하나의 필드로 묶어보는 것은 어떨까? API 통신이 성공했을 때는 해당 필드를 data 필드로서 사용하고 오류가 발생했을 때에는 ‘errorDesc’ 필드로 사용하는 것이다. 123456789101112131415161718192021222324252627282930313233343536373839404142@Getter@Setter@Builderclass Response&lt;T&gt; &#123; private int status; /* errorCode와 동일하며, 필드 이름만 바꾸었다. */ private T body; /* errorDesc, data 성격을 모두 가지고 있는 필드이다. */&#125;/* 예시를 위한 샘플 데이터 객체이다. */@Getter@Setter@Builderclass Person &#123; private String name; private int age;&#125;/** 성공인 경우 예시 */@RequestMappingpublic Response&lt;Person&gt; goodExample() &#123; Person person = Person.builder().name(&quot;홍길동&quot;).age(30).build(); return Response.&lt;Person&gt;builder().status(200).body(person).build();&#125;/** 실패인 경우 예시 */@RequestMappingpublic Response&lt;String&gt; badExample() &#123; return Response.&lt;String&gt;builder().status(500).body(&quot;INTERNAL_SERVER_ERROR&quot;).build();&#125;/** 한 컨트롤러에서 실제 사용되는 예시 */@RequestMappingpublic Response&lt;?&gt; example() &#123; try &#123; Person person = Person.builder().name(&quot;홍길동&quot;).age(30).build(); return Response.&lt;Person&gt;builder().status(200).body(person).build(); &#125; catch (Exception e) &#123; return Response.&lt;String&gt;builder().status(500).body(&quot;INTERNAL_SERVER_ERROR&quot;).build(); &#125;&#125; 에러 코드를 표현하는 필드 명이 ‘errorCode’ 이였지만 ‘status’ 필드 명으로 변경 하였고 ‘errorDesc’, ‘data’ 두 필드 명을 합쳐서 ‘body’ 필드 명으로 변경하였다.‘한 컨트롤러에서 실제 사용되는 예시’ 이 곳을 보면 컨트롤러의 반환 형에 타입에 Response&lt;?&gt; 형태를 사용하고 있다. 위와 같이 ‘body’ 필드 명을 사용하게 되면 성공했을 때와, 실패했을 때의 ‘body’ 필드 타입이 다르기 때문에 모두 수용할 수 있도록 와일드카드 문법을 사용하고 있다. ResponseEntity지금까지 응답 객체에 대한 고찰을 하면서 ‘Response’ 객체를 다듬어 왔다. 이 객체를 항상 직접 만들어서 사용할 수도 있지만 Spring Framework 에서 제공하는 ‘ResponseEntity’ 객체가 ‘Response’ 객체와 거의 유사함으로 이를 사용하는 것을 권장한다. 123456789101112131415161718192021222324import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;/* 예시를 위한 샘플 데이터 구조이다. */@Getter@Setter@Builderclass Person &#123; private String name; private int age;&#125;@RequestMappingpublic ResponseEntity&lt;?&gt; example() &#123; try &#123; Person person = Person.builder().name(&quot;홍길동&quot;).age(30).build(); return ResponseEntity.status(HttpStatus.OK).body(person); &#125; catch (Exception e) &#123; return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase()); &#125;&#125; ‘ResponseEntity’ 객체는 지금까지 우리가 만든 Response 객체와 굉장히 유사하나, 가장 결정적인 차이가 있고 이 차이 때문에 사실 이 객체를 사용해야 한다. HTTP Header현대의 대부분 API 통신은 HTTP 통신 기반 하에 이루어진다. HTTP 구조는 Header, Body 두 부분으로 나누어지는데 Header 에는 통신을 원활히 하기 위해 필요한 제반 정보들이 존재하고, Body 에는 실제 데이터가 들어간다. 여기서 HTTP STATUS 코드는 본래 Header 영역에 들어가는 정보이고, 우리가 만든 API 응답 객체는 Body 안에 들어간다.즉 다시 말하자면 Response 객체 내부에 있는 status 필드 값을 ‘200’, ‘500’ 같이 특정 코드로 변경한다고 해서 Header 에 있는 HTTP STATUS 코드가 변경되는 것은 아니라는 거다. Response 객체는 우리가 만든 API 응답 객체 이기 때문에 Body 안에서만 영향을 미친다.위처럼 status 필드를 HTTP STATUS 코드를 사용할 때 발생하는 한 가지 문제점은 Header 안에 있는 HTTP STATUS 값과 Body 안에 있는 status 필드 값이 서로 안 맞는 경우가 생길 수 있다.‘ResponseEntity’ 객체가 우리가 만든 ‘Response’ 객체와 가장 다른 점은 status 필드 값이 이 Header의 HTTP STATUS 값이랑 연계가 되어 있다는 것이다. 이 객체를 활용하면 API 안에 status 필드 값에 맞추어 Header 도 변경이 가능하다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring - API - Response","slug":"Spring-API-Response","permalink":"http://kidongyun.github.io/tags/Spring-API-Response/"}]},{"title":"Redux 패턴에 대한 고찰","slug":"2020-12-04-redux-pattern","date":"2020-12-04T11:00:00.000Z","updated":"2022-05-31T07:22:05.000Z","comments":true,"path":"2020/12/04/","link":"","permalink":"http://kidongyun.github.io/2020/12/04/","excerpt":"","text":"예전에 Vanila.JS 로 위지윅 같이 한 화면에서 변화가 많은 프로그램을 만들어 본 경험이 있다. 이 때 내가 느꼈던 불편했던 점 하나는 데이터가 수정되었을 떄 모델 객체에 이 수정된 내용을 반영하는 것과 수정된 내용이 실제 화면에 렌더링 시키는 동작이 상이하다는 것이 였다. 이를 명확히 하지 못했었고 프로젝트를 진행하면서 이 이유로 혼란이 왔었던 적이 있다. 기존의 MVC 패턴은 고객이 Controller 쪽에 특정 요청을 할 경우 데이터가 변경되야 한다면 Model을 변경하고, 화면이 변경되야 한다면 View 가 변경된다. 사실 이 Controller, Model, View 셋 컴포넌트 간에 데이터가 어느쪽으로 흘러야 한다라는 제약이 강하지 않아서 개발자의 성향에 따라 방식이 달라진다. 이러한 단점으로 인해서 Flux 패턴이 고안되었고, 이 방식이 React 라이브러리에서도 채택이 되어서 Redux 라는 상태 관리 라이브러리가 생겼는데. 그렇다면 이 Flux, Redux 의 패턴이 기존의 MVC 와 무엇이 다른지 살펴보자. 구성요소MVC 패턴은 Model, View, Contoller 가 핵심 요소 였다면, Redux 패턴은 Action, Dispatcher, Reducer, Store 이 4가지가 중요한 구성 요소이다. 1. Action고객이 우리 웹 어플리케이션에 접속해서 하는 행위가 Redux가 관리하는 데이터에 변화가 생긴다면 이는 Action 으로 관리해야한다. 이 Action 의 개념은 사전적 정의와 굉장히 유사하다. 단순히 웹 어플리케이션 사용자가 하는 행위들을 말한다.예를 들어서 카카오톡이 웹 어플리케이션으로 동작하고 있다고 해보자. 하단에 메뉴 4개가 존재하고 각각 친구목록, 대화방 목록, 설정 등을 보여준다. 만약 사용자가 친구 목록을 보고 있는 상태에서 대화방 목록을 보기위해 메뉴 버튼을 눌렀다면. 이 대화방 버튼을 눌렀다는 것 자체가 하나의 Action 이다. Action 은 Redux 패턴에서 다른 구성요소들이 동작하기 위한 시발점이 된다. 1234567891011121314export const SET_OBJECTIVE_ACTION = &#x27;SET_OBJECTIVE_ACTION&#x27; as constexport const SET_PLAN_ACTION = &#x27;SET_PLAN_ACTION&#x27; as constexport const setObjectiveAction = (objective: Objective) =&gt; (&#123; type: SET_OBJECTIVE_ACTION, payload: objective&#125;)export const setPlanAction = (plan: Plan) =&gt; (&#123; type: SET_PLAN_ACTION, payload: plan&#125;) 2. DispatcherDispatcher는 용어 그대로 보내다, 분배하다는 느낌이 강하다. Action이 왔다면 그 Action에 맞는 Reducer를 찾아서 보내준다. 예를 들어 대화방 메뉴를 눌렀다면 이 Dispatcher에게 Action이 다가와서 물어본다. 12Action : &quot;대화방 버튼을 클릭해서 왔어요&quot;Dispatcher : &quot;대화방 버튼 기능은 이 Reducer에게 가시면 됩니다.&quot; 위와 같이 모든 Action과 Reducer 사이에서 연결관계를 이어준다. 3. ReducerAction이 발생했을 때 실제 어떠한 처리를 하는 곳이 Reducer이다 대화방 버튼을 눌렀을 때 대화방 목록이 보이도록 이 Reducer 영역에서 처리를 해야 한다. Reducer 는 입력으로 기존의 상태값과, 변경된 상태값을 가지는데 이 둘을 비교해서 필요한 작업을 처리한다. 123456789101112export default function cell(state: Cell = new Cell(&quot;CELL&quot;), action: CellAction) &#123; switch(action.type) &#123; case SET_OBJECTIVE_ACTION : return action.payload; case SET_PLAN_ACTION : return action.payload; default : return state; &#125;&#125; 4. StoreReducer는 기존의 상태값과 새롭게 들어온 상태값을 비교하여 비지니스 로직을 구현한다고 위에서 언급했다. 그러면 기존의 상태값은 어디에서 저장되고 있을까? 이 Store 영역에서 상태값들을 모두 가지고 있으며 이들을 관리한다. 그렇기 때문에 Redux 가 상태관리 라이브러리라고 불리는 것이다. 123456789101112131415const rootReducer = combineReducers(&#123; objectives, plans, todos, cell, page, noti, sign&#125;)export default rootReducer;export type RootState = ReturnType&lt;typeof rootReducer&gt;;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"React","slug":"React","permalink":"http://kidongyun.github.io/tags/React/"}]},{"title":"로깅을 활용한 Proxy, AOP 에 대한 고찰","slug":"2020-12-04-aop-proxy-with-logging","date":"2020-12-04T02:38:54.000Z","updated":"2022-05-31T07:22:00.000Z","comments":true,"path":"2020/12/04/","link":"","permalink":"http://kidongyun.github.io/2020/12/04/","excerpt":"","text":"실무에서 코드를 작성하게 되면 로그를 남기는 행위는 굉장히 범용적으로 필요한 일이다. 어느 특정 비지니스에 해당하지 않고 모든 곳에 사용이 되기 때문이다. 가독성의 관점이나 중복제거의 관점이나 이 로깅을 하는 코드들은 비지니스 코드에 의존에 의존되지 않도록 작성하는 것이 중요하다. 이 글에서 이를 해결하기 위한 고민해보록 하자. 가장 간편한 로깅 방법123456789101112131415@Slf4jclass Calculator &#123; public int add(int value1, int value2) &#123; long startTime = System.currentTimeMillis(); int result = value1 + value2; long endTime = System.currentTimeMillis(); log.info(&quot;value1 : &quot; + value1 + &quot;, value2 : &quot; + value2); log.info(&quot;result : &quot; + result); log.info(&quot;execute time : &quot; + (endTime - startTime) + &quot; ms&quot;); return result; &#125;&#125; 이 글에서 구현하려고하는 로깅의 기능은 한 함수의 범위에서 들어오는 입력 파라미터의 값들과, 리턴되는 결과 값을 보여주고 해당 함수의 실행시간을 보여주는 기능이다. 위에서 제시한 로깅 방법은 이를 가장 간단하게 구현한 방법이다. 이번에는 덧셈의 기능을 하는 add() 뿐만 아니라 뺄셈과 곱셈의 기능을 하는 sub(), mul() 도 구현하고, 로깅 기능도 넣어보도록 하자. 12345678910111213141516171819202122232425262728293031323334353637@Slf4jclass Calculator &#123; public int add(int value1, int value2) &#123; long startTime = System.currentTimeMillis(); int result = value1 + value2; long endTime = System.currentTimeMillis(); log.info(&quot;value1 : &quot; + value1 + &quot;, value2 : &quot; + value2); log.info(&quot;result : &quot; + result); log.info(&quot;execute time : &quot; + (endTime - startTime) + &quot; ms&quot;); return result; &#125; public int sub(int value1, int value2) &#123; long startTime = System.currentTimeMillis(); int result = value1 + value2; long endTime = System.currentTimeMillis(); log.info(&quot;value1 : &quot; + value1 + &quot;, value2 : &quot; + value2); log.info(&quot;result : &quot; + result); log.info(&quot;execute time : &quot; + (endTime - startTime) + &quot; ms&quot;); return result; &#125; public int mul(int value1, int value2) &#123; long startTime = System.currentTimeMillis(); int result = value1 * value2; long endTime = System.currentTimeMillis(); log.info(&quot;value1 : &quot; + value1 + &quot;, value2 : &quot; + value2); log.info(&quot;result : &quot; + result); log.info(&quot;execute time : &quot; + (endTime - startTime) + &quot; ms&quot;); return result; &#125;&#125; 로깅을 전담해서 하는 객체 생성함수가 여러 개가 되니까 간편하게 구현한 로깅기능에 문제점 하나가 보이는 것 같다. 모두 동일하게 입력되는 파라미터와, 반환되는 결과 값을 보여주는 로그인데 같은 기능을 함에도 소스가 중복이 되고 있다. 이를 개선하기 위해 첫번째로 생각해 볼수 있는 방법은 로깅을 위한 객체를 별도로 두고 이 객체를 호출하도록 하는 것이다. 여기서 로깅 작업의 목표는 파라미터, 리턴값, 실행시간을 보여주는 것이기 때문에 이를 위한 값들을 파라미터로 받는다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Slf4jclass Logger&lt;T, U&gt; &#123; public void execute(T params, U returnValue, long startTime, long endTime, String methodName) &#123; log.info(&quot;Params : &quot; + params.toString()); log.info(&quot;Method Name : &quot; + methodName); log.info(&quot;Return Value : &quot; + returnValue.toString()); log.info(&quot;Execute Time : &quot; + (endTime - startTime) + &quot; ms&quot;); &#125;&#125;@Slf4jclass Calculator &#123; private final Logger&lt;List&lt;Integer&gt;, Integer&gt; logger; public Calculator() &#123; logger = new Logger&lt;&gt;(); &#125; public int add(int value1, int value2) &#123; long startTime = System.currentTimeMillis(); int result = value1 + value2; logger.execute(List.of(value1, value2), result, startTime, System.currentTimeMillis(), Thread.currentThread().getStackTrace()[1].getMethodName()); return result; &#125; public int sub(int value1, int value2) &#123; long startTime = System.currentTimeMillis(); int result = value1 + value2; logger.execute(List.of(value1, value2), result, startTime, System.currentTimeMillis(), Thread.currentThread().getStackTrace()[1].getMethodName()); return result; &#125; public int mul(int value1, int value2) &#123; long startTime = System.currentTimeMillis(); int result = value1 * value2; logger.execute(List.of(value1, value2), result, startTime, System.currentTimeMillis(), Thread.currentThread().getStackTrace()[1].getMethodName()); return result; &#125;&#125; 로깅을 위해서 Logger라는 객체를 생성했고 파라미터, 리턴값, 시작시간, 종료시간, 메소드명을 받도록 했다. Logger 객체를 활용해서 로깅을 어떤 객체에서 이 로깅을 하는 것인지 알 수 없기 때문에 메서드 명 항목을 추가했다. 위 소스를 보면서도 느끼지만 로깅을 비지니스 영역과 구분하기 위해서 굉장히 난잡해진 코드를 작성했다. 소스의 중복은 사라졌다고 하지만 비즈니스 영역에서 로깅 작업을 제외하는 이유는 가독성을 향상시키기 위함이 큰데, 사실 가독성이 그렇게 증가한 것 같지도 않다. 또 보시면 알겠지만 startTime 값은 비즈니스 영역의 함수를 호출하기 전 생성이 되어야 하기 때문에 logger 객체에 바로 넣지 못하고 결국 변수를 하나 생성했다. 로깅을 전담하는 객체를 만들어서 이 객체를 활용해 로깅을 하는 위와같은 방식은 근본적으로 비즈니스 소스에서 로깅 객체를 호출하는 구조를 가지고 있다. 즉 로깅 작업을 없애려고 노력했지만 결국 한줄이라도 이 로깅 객체를 호출하는 부분이 남아 있다. 우리는 비즈니스 영역의 코드와 로깅을 위한 코드의 완벽한 분리를 원한다. 이러려먼 어떻게 해야할까? 프록시 패턴의 활용이번에 도전해볼 방법은 프로그래밍 디자인 패턴 중 프록시 패턴을 활용할 것이다. 이 패턴은 우리가 원하는 작업처럼 비즈니스 소스와 그 외의 소스를 구분시킬 때 사용한다. Calculator 객체를 감싸는 새로운 객체를 하나 더 만들고, 그 객체에서 Calculator 객체의 비즈니스 코드를 호출하는 것이다. 이렇게 하였을 때, 다른 클라이언트 소스에서 Calculator 객체를 직접 호출하지 않고 이 프록시 객체를 호출하게 되면 로깅 작업도 정상 작동할 것이다. 위에서 적용한 Logger 객체를 만드는 방법과 프록시 객체를 생성하는 방법은 서로 겹치는 작업이 아니다. Logger 객체를 만드는 방법의 호출 관계는 비즈니스 코드가 더 범위가 넓고 이 안에서 로깅 코드를 호출하는 것이였다면, 프록시 객체를 만드는 방법은 반대로 비즈니스 코드를 감쌀 수 있는 더 넓은 범위의 객체를 생성하는 것이다. 이 관점에서 로깅 객체를 만드는 것과는 다른 관점에서의 해결 방법이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@Slf4jclass Logger&lt;T, U&gt; &#123; public void execute(T params, U returnValue, long startTime, long endTime, String methodName) &#123; log.info(&quot;Params : &quot; + params.toString()); log.info(&quot;Method Name : &quot; + methodName); log.info(&quot;Return Value : &quot; + returnValue.toString()); log.info(&quot;Execute Time : &quot; + (endTime - startTime) + &quot; ms&quot;); &#125;&#125;@Slf4jclass Calculator &#123; private final Logger&lt;List&lt;Integer&gt;, Integer&gt; logger; public Calculator() &#123; logger = new Logger&lt;&gt;(); &#125; public int add(int value1, int value2) &#123; return value1 + value2; &#125; public int sub(int value1, int value2) &#123; return value1 + value2; &#125; public int mul(int value1, int value2) &#123; return value1 * value2; &#125;&#125;class CalculatorProxy &#123; private final Calculator calculator; private final Logger&lt;List&lt;Integer&gt;, Integer&gt; logger; public CalculatorProxy() &#123; this.calculator = new Calculator(); this.logger = new Logger&lt;&gt;(); &#125; public int add(int value1, int value2) &#123; long startTime = System.currentTimeMillis(); int result = calculator.add(value1, value2); long endTime = System.currentTimeMillis(); logger.execute(List.of(value1, value2), result, startTime, endTime, Thread.currentThread().getStackTrace()[1].getMethodName()); return result; &#125; public int sub(int value1, int value2) &#123; long startTime = System.currentTimeMillis(); int result = calculator.sub(value1, value2); long endTime = System.currentTimeMillis(); logger.execute(List.of(value1, value2), result, startTime, endTime, Thread.currentThread().getStackTrace()[1].getMethodName()); return result; &#125; public int mul(int value1, int value2) &#123; long startTime = System.currentTimeMillis(); int result = calculator.mul(value1, value2); long endTime = System.currentTimeMillis(); logger.execute(List.of(value1, value2), result, startTime, endTime, Thread.currentThread().getStackTrace()[1].getMethodName()); return result; &#125;&#125; Calculator 객체 괸점에서는 비즈니스 영역의 코드만 남았고, CalculatorProxy 객체에서 로그를 남기는 코드를 작성하고 있다. 우리가 원하는 목표는 이루었지만 무언가 깔끔하지 않다. 바로 CalculatorProxy 객체의 문제이다. 이 객체는 Calculator 객체에 다른 함수가 생길 때 마다 CalculatorProxy 객체에도 그 함수를 위한 함수를 생성해줘야하는 문제가 발생한다. 보일러플레이트 코드가 많아진 것 같다. AOP 개념의 필요성 대두AOP와 OOP 개념은 서로 적대적인 개념이 아니며 상호 보완적인 개념이다. 현재 위 소스들은 Calculator 라는 객체 중심의 사고를 하면서 만들어지고 있다. add(), sub(), mul() 이러한 함수들도 Calculator 객체가 가지는 동작들 중 일원이며, 함수들의 정의가 Calculator 객체 중심으로 이루어지고 있다. 객체를 중심으로 코드를 작성하게 되면 공통 기능들은 위처럼 중복으로 구현되어진다. 로깅 작업은 실무에서 대부분의 동작에 필연적으로 들어가야하는 공통 기능이다. 그렇기 때문에 이를 OOP 방식으로 소화하려고 하면 모든 함수들이 이 기능을 가져야 하기 때문에 로깅 관련 소스의 중복이 생겨난다. 여기서 AOP 방식을 활용하면 이를 보다 심플하게 개선할 수 있다. AOP는 이런 로깅 작업처럼 객체 관점의 코딩으로 보았을 때 중복이 많아지거나 하는 문제점이 생기는 코드들을 해결하기 위한 방법이다. AOP 방식은 위에서 우리가 만들었던 Proxy 객체와 유사하게 동작한다. 객체들의 비즈니스 코드가 동작되기 이전, 이후에 호출되어 로깅등과 같은 작업을 한다. 하지만 좀 더 부가적인 것은 위처럼 우리가 직접 Proxy 객체들을 만드는 것이 아니고 AOP 기능을 제공해주는 라이브러리에서 이런 Proxy 객체들을 자동으로 구현해준다. 또 위에서 우리가 예제로 만든 것처럼 Calculator.add() - CalculatorProxy.add() 이런 1:1 관계가 아니고 1:N 관계 매핑이 가능하도록 구현이 되어있다. (내부적으로 리플렉션을 활용하는 것 같다.) 실제 내부적으로 어떻게 돌아가는지는 사실 나도 잘 모르겠다, 하지만 스프링 AOP를 사용하면 런타임시에 프록시 객체를 만들어내는데 그 구조는 위에서 우리가 만든 프록시 패턴과 유사할 것이다. 1234567891011121314151617181920212223242526272829@Documented@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface ExecuteLog &#123;&#125;@Slf4j@Component@Aspectpublic class ExecuteLogAspect &#123; @Around(value = &quot;@annotation(ExecuteLog)&quot;) public Object log(ProceedingJoinPoint joinPoint) throws Throwable &#123; long start = System.currentTimeMillis(); Object result = joinPoint.proceed(); long end = System.currentTimeMillis(); MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); log.info(&quot;Method Name : &quot; + method.getName()); log.info(&quot;Input : &quot; + Arrays.toString(signature.getParameterNames())); log.info(&quot;Output : &quot; + result.toString()); log.info(&quot;Execute Time : &quot; + (end - start) + &quot; ms&quot;); return result; &#125;&#125; 이 코드는 Spring 에서 제공하는 AOP 구현 방식이다. 위와 같이 코드를 작성하면 @ExecuteLog 어노테이션을 붙인 함수들이 동작하기 전, 후에 위에 작성한 함수가 실행이 된다. AOP 방식을 사용할 떄 주의할 점은. 비지니스 코드 외부에서 공통 소스 작업을 하는 것이기 때문에. 비지니스 코드가 돌아하는 함수의 범위에서 만약 지역변수로 생성되고 없어지는 변수가 있다면, 이러한 변수는 AOP 방식으로는 접근할 수 없다는점을 인지해야 한다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"}]},{"title":"HttpClient","slug":"2020-12-10-httpClient","date":"2020-12-04T02:38:54.000Z","updated":"2022-05-31T07:22:40.000Z","comments":true,"path":"2020/12/04/","link":"","permalink":"http://kidongyun.github.io/2020/12/04/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.interpark.tour.air.api.product.service.domestic;import com.fasterxml.jackson.databind.ObjectMapper;import com.interpark.tour.air.api.product.common.Utility;import com.interpark.tour.air.api.product.model.domestic.dto.AirlineControlTimer;import lombok.extern.slf4j.Slf4j;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.client.HttpClient;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.utils.URIBuilder;import org.apache.http.impl.client.BasicCookieStore;import org.apache.http.impl.client.HttpClientBuilder;import org.apache.http.impl.cookie.BasicClientCookie;import org.apache.http.util.EntityUtils;import org.springframework.stereotype.Service;import java.io.IOException;import java.net.URI;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;@Slf4j@Service(value = &quot;AirlineControlTimerService&quot;)public class AirlineControlTimerService &#123; /** DOM_AIRLINE_CONTROL_HISTROY 테이블에 스케줄, 마이페이지 ON/OFF 내역 등록 */ public AirlineControlTimer.Res registerHistory(AirlineControlTimer.Req req) throws Exception &#123; URI uri = new URIBuilder(new URI(&quot;http://batchadmin.interparktour.com/admin/airControlTimerAdd.do&quot;)) .addParameter(&quot;searchAirline&quot;, &quot;AL&quot;) .addParameter(&quot;airline&quot;, req.getAirline()) .addParameter(&quot;startDateTime&quot;, req.getStartDateTime().format(DateTimeFormatter.ofPattern(&quot;yyyyMMddHHmm&quot;))) .addParameter(&quot;endDateTime&quot;, req.getEndDateTime().format(DateTimeFormatter.ofPattern(&quot;yyyyMMddHHmm&quot;))) .addParameter(&quot;inputDate&quot;, LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyyMMddHHmm&quot;))) .addParameter(&quot;inputId&quot;,&quot;SYSTEM&quot;) .addParameter(&quot;scheduleOff&quot;, req.getScheduleOff()) .addParameter(&quot;mypageOff&quot;, req.getMypageOff()) .build(); AirlineControlTimer.Res res = call(uri); int HISTORY_ADD_SUCCESS = 101; if(HISTORY_ADD_SUCCESS != res.getErrorCode()) &#123; throw new Exception(&quot;히스토리 테이블에 새 내역을 추가하는 중 오류가 발생했습니다&quot;); &#125; return res; &#125; /** 배치 스케줄러에 스케줄, 마이페이지 ON/OFF 등록 */ public AirlineControlTimer.Res registerBatch(AirlineControlTimer.Req req) throws Exception &#123; URI uri = new URIBuilder(new URI(&quot;http://batchadmin.interparktour.com/admin/airControlTimerUpdateBatch.do&quot;)) .addParameter(&quot;no&quot;, null) .addParameter(&quot;airline&quot;, req.getAirline()) .addParameter(&quot;startDateTime&quot;, req.getStartDateTime().format(DateTimeFormatter.ofPattern(&quot;yyyyMMddHHmm&quot;))) .addParameter(&quot;endDateTime&quot;, req.getEndDateTime().format(DateTimeFormatter.ofPattern(&quot;yyyyMMddHHmm&quot;))) .addParameter(&quot;scheduleOff&quot;, req.getScheduleOff()) .addParameter(&quot;mypageOff&quot;, req.getMypageOff()) .addParameter(&quot;type&quot;, &quot;add&quot;) .build(); AirlineControlTimer.Res res = call(uri); int BATCH_ADD_SUCCESS = 104; if(BATCH_ADD_SUCCESS != res.getErrorCode()) &#123; throw new Exception(&quot;배치 테이블에 새 내역을 추가하는 중 오류가 발생했습니다&quot;); &#125; return res; &#125; public AirlineControlTimer.Res register(AirlineControlTimer.Req req) throws Exception &#123; registerHistory(req); return registerBatch(req); &#125; private AirlineControlTimer.Res call(URI uri) throws IOException &#123; HttpClient httpClient = HttpClientBuilder.create().setDefaultCookieStore(cookieConfig(&quot;N19147&quot;)).build(); HttpGet httpGet = new HttpGet(uri); HttpResponse response = httpClient.execute(httpGet); HttpEntity entity = response.getEntity(); return new ObjectMapper().readValue(EntityUtils.toString(entity), AirlineControlTimer.Res.class); &#125; private BasicCookieStore cookieConfig(String adminId) &#123; BasicClientCookie adminIdCookie = new BasicClientCookie(&quot;ADMIN_ID&quot;, adminId); adminIdCookie.setDomain(&quot;batchadmin.interparktour.com&quot;); adminIdCookie.setPath(&quot;/&quot;); BasicClientCookie awpKeyCookie = new BasicClientCookie(&quot;AWP_KEY&quot;, Utility.getEncSHA256(&quot;interpark_&quot; + adminId + &quot;_airadmin12#$&quot;)); awpKeyCookie.setDomain(&quot;batchadmin.interparktour.com&quot;); awpKeyCookie.setPath(&quot;/&quot;); BasicCookieStore cookieStore = new BasicCookieStore(); cookieStore.addCookie(adminIdCookie); cookieStore.addCookie(awpKeyCookie); return cookieStore; &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring - HttpClient","slug":"Spring-HttpClient","permalink":"http://kidongyun.github.io/tags/Spring-HttpClient/"}]},{"title":"Spring Boot","slug":"2020-12-02-spring-boot","date":"2020-12-02T02:38:54.000Z","updated":"2022-05-31T07:21:54.000Z","comments":true,"path":"2020/12/02/","link":"","permalink":"http://kidongyun.github.io/2020/12/02/","excerpt":"","text":"스프링부트 소개제품 수준의 스프링 프레임워크 기반의 제품을 만들때 빠르게 만들수 있다. 스프링에서 가장 널리 쓰이는 설정을 기본적으로 설정한 것. (convention of configuration)-&gt; 원한다면 보다 더 쉽게 커스터마이징도 가능. third-party 라이브러리에 대한 처리도 어느정도 제공 -&gt; ex) 톰캣이 내부적으로 뜬다. 스프링 부트는 자바 8 이상부터 사용이 가능. 스프링부트 프로젝트 생성1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;SpringBootLecture&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!-- 스프링 부트 프레임워크가 부모 의존성 임을 명시--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus-central&lt;/id&gt; &lt;name&gt;Interpark Nexus Central Maven Repository&lt;/name&gt; &lt;url&gt;http://nexus.interpark.com:8888/nexus/content/repositories/central/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; dependencies 항목들은 repositories 에서 의존성을 가져오고 plugin 들은 pluginRepositories에서 가져온다. Spring-boot maven 활용 직접 세팅하는 방법pom.xml 설정 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;SpringBootAutoConfigure&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus-central&lt;/id&gt; &lt;name&gt;Interpark Nexus Central Maven Repository&lt;/name&gt; &lt;url&gt;http://nexus.interpark.com:8888/nexus/content/repositories/central/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus-central&lt;/id&gt; &lt;name&gt;Interpark Nexus Central Maven Repository&lt;/name&gt; &lt;url&gt;http://nexus.interpark.com:8888/nexus/content/repositories/central/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 원하는 패키지 생성하고 거기에 Application.java 파일 생성 Application.java 12345678910111213package com.example;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 스프링 부트 프로젝트 구조.1234567src main java resource test java resource main application의 추천하고 있는 위치는 사용하고 있는 최상위 default package 에 넣는걸 추천.-&gt; @ComponentScan 이 붙어있기 때문에 그렇다. 이 파일이 들어있는 패키지 기준으로 컴포넌트를 스캔하기 때문. 하나 주의해야할 점은. 이 메인 어플리케이션이 하위에 있는 자바 파일들만 빈등록이 되는것. 그 외 패키지에 있는것은 등록이 안됩니다.!!! @SpringBootApplication 이 붙은걸 메인 어플리케이션이라고 부름. 스프링 부트 의존성 원리pom.xml 안에 태그에 우리는 아래처럼 ‘spring-boot-starter-parent’ 을 받고있다. 여기 안에 들어가 보면 또 부모가 있는걸 볼수 있는데 그 녀석 이름이 ‘spring-boot-dependencies’ 이다. 여기에 또 들어가보면 기본적으로 Spring 을 사용하는데 필요한 의존성들을 모두 주입해둔것을 볼 수 있다. dependencyManagement 라는 태그로 되어있음. 12345678&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 이렇게 의존성을 스프링 부트 내부적으로 관리해주고 우리는 spring-boot-starter-web 이런식으로 한두개만 의존성 관리할게 될때의 장점은. 버전을 올리거나 내려야 할 상황이 올때모든 라이브러리들이 호환이 잘되는지 않되는지를 명확히 알기 어렵기도 하기 때문에 이런 버전 관리가 어렵다. 그래서 이렇게 관리해주고 있는 이러한 스프링 부트만을 의존성을 받게 되면.이미 관리되어진 의존성만을 가져오는 거기때문에 버전 문제에 대한것을 쉽게 처리할 수 있다. 태그를 사용하지 않고 의존성을 관리하는 방법도 있다. 가 만약 다른 걸로 고정이되어서 수정할 수 없느경우 이 태그를 사용해서 보다 더 커스터마이징된 의존성을 넣을 수 있다. 여기에 spring-boot-dependencies를 넣으면 됨. 단점 -&gt; parent 쪽에서 들어오는거가 dependency 만 들어오는게 아니고 다른 속성들 (인코딩, 자바 버전, 플러그인 설정, yml 파일 사용) 도 설정을 해주는 거기 때문에 이런것들을 모두 관리해야 한다.parent에서 의존성 말고 관리해주느 것들을 이 태그로 못가져 오기 때문에. 이 부분들을 모두 나의 프로젝트에서 관리해주어야 한다. 스프링 부트 의존성 관리 응용mvnrepository -&gt; maven 의존성의 허브사이트. 의존성을 추가하는 방법 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; modelMapper -&gt; domain을 가지고 flatDesign을 만들어준다 12345&lt;dependency&gt; &lt;groupId&gt;org.modelmapper&lt;/groupId&gt; &lt;artifactId&gt;modelmapper&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt; version은 항상 명시해줘야한다. Spring Boot가 지원해주는 애들은 version이 자동 관리가 되긴 함 이거는 intellij 소스창 옆에 보면 동그랗게 뜸 123&lt;properties&gt; &lt;spring.version&gt;5.0.6.RELEASE&lt;/spring.version&gt;&lt;/properties&gt; 스프링 버전을 바꾸고싶다면 properties 태그에 위와같이 추가한다. 이는 Spring-boot parent 에 dependencies parent 에 가보면 동일한 형태로 정의가 되고 있음을 볼수 있다.자바 버전을 바꾸고싶다면 properties 태그에 똑같이 아래와 같이 수정하면된다. 123&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt; 자동 설정 이해 (EnableAutoConfiguration)@SpringBootApplication 는 중요한 3개의 어노테이션을 합친것 @SpringBootConfiguration@ComponentScan@EnableAutoConfiguration 스프링 부트는 2단계로 의존성을 가져온다?ComponentScan + EnableAutoConfiguration @EnableAutoConfiguration 이 없어도 어플리케이션을 실행할 수는 있다. 그러나 이것은 웹서버는 없다. 웹어플리케이션에 대한 초기 자동 설정을 버리고 그냥 스프링 프레임워크만 띄웠다는 의미인듯. 12345678910111213141516import org.springframework.boot.SpringApplication;import org.springframework.boot.WebApplicationType;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication application = new SpringApplication(Application.class); application.setWebApplicationType(WebApplicationType.NONE); application.run(args); &#125;&#125; @ComponentScan 으로 빈을 먼저 등록한 다음에@EnableAutoConfiguration 이걸로 추가적인 빈 등록을 한다 2단계로 나누어진다. @ComponentScan -&gt; 스프링의 기본적인 내용 @Component, @Configuration @Repository, @Service @Controller @RestController 등등의 어노테이션이 되어있는 인스턴스를 리플렉션으로 생성해서 스프링 컨테이너에 빈으로서 넣어두는거 같음. 기본적인 내용. 자기 어노테이션 기준으로 하위 패키지에 저 어노테이션들이 박혀있는 클래스들을 인스턴스화 후 빈 등록. @EnableAutoConfiguration -&gt; Spring meta 파일을 보고 가져온다.org.springframework.boot:spring-boot-autoconfigure 프로젝트 안에META-INF 폴더가 있고 이안에 spring.factories 라는 파일이 있다.거기 안에 org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ 라는 경로로 키가 설정 되어있오 그밑으로 Configuration value 값들이 들어있는데 이걸 다 가져오는거 같아.여하튼 이 파일을 보고 여기에 설정되어있는 값들을 모두 빈등록. WebMvcAutoConfiguration 이 클래스도 EnableAutoConfiguration 으로 빈 등록되는 객체인데그 안에보면 @Conditional…. 조건에 따라서 등록되고 안되는것도 볼수있다. 모두 빈 등록을 하지만 조건에 따라 안되는것도 있음을 참고해야함. 자동 설정 만들기 1부: Starter와 AutoConfigureXxx-Spring-Boot-Autoconfigure =&gt; 자동설정 등을 설정할때 이런식으로 이름을 만들고 프로젝트를 만든다.Xxx-Spring-Boot-Starter =&gt; 필요한 의존성등을 정의할때 보통 이런식으로 이름을 만든다.그냥 하나로 하고싶을 때에는 Starter 이름을 사용하자. 12345678910111213141516171819202122232425262728293031323334/* Holoman.java */package me.whiteship;public class Holoman &#123; String name; int howLong; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getHowLong() &#123; return howLong; &#125; public void setHowLong(int howLong) &#123; this.howLong = howLong; &#125; @Override public String toString() &#123; return &quot;Holoman&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, howLong=&quot; + howLong + &#x27;&#125;&#x27;; &#125;&#125; 12345678910111213141516171819/* HolimanConfiguration.java */package me.whiteship;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class HolomanConfiguration &#123; @Bean public Holoman holoman() &#123; Holoman holoman = new Holoman(); holoman.setHowLong(5); holoman.setName(&quot;Keesun&quot;); return holoman; &#125;&#125; src/main/resource/META-INF에 spring.factories 파일 생성 이 파일은 스프링부트가 아니고 스프링에서 원래 제공해주는 형식의 파일이다 여기서 라이프사이클도 조절이 가능하다. 1234org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ me.whiteship.HolomanConfiguration 그 다음에 다른 프로젝트에서 이 프로젝트를 사용할 수 있도록 mvn install 해서 빌드해서 jar 파일로 만들고 이걸 로컬 메이븐 저장소에다가 등록 다른 lib에 등록해준다. 사용하려고하는 프로젝트를 열고 의존성 추가 의존성 groupId 와 artifactId, version 등은 Holoman 프로젝트 pom.xml 에서 확인할 수 있다. 123456789&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;me.whiteship&lt;/groupId&gt; &lt;artifactId&gt;kidong-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ApplicationRunner 는 스프링 프레임워크가 시작되었을 때 자동으로 실행되는 빈을 만들고 싶을때 사용하면 된다. 인터페이스 객체임으로 implements 받아서 사용가능 12345678910111213141516171819202122package com.example;import me.whiteship.Holoman;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.stereotype.Component;@Componentpublic class HolomanRunner implements ApplicationRunner &#123; /* 이 프로젝트에서는 어디에서도 Holoman 객체를 빈으로 등록하지 않았다 */ @Autowired Holoman holoman; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(holoman); &#125;&#125; 이 방법의 문제는 내가 직업 위처럼 자동설정한 빈을 아래처럼 직접 다시 생성하면 생성한 빈이 무시가 된다. 1234567891011121314151617181920212223242526package com.example;import me.whiteship.Holoman;import org.springframework.boot.SpringApplication;import org.springframework.boot.WebApplicationType;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication application = new SpringApplication(Application.class); application.setWebApplicationType(WebApplicationType.NONE); application.run(args); &#125; @Bean public Holoman holoman() &#123; Holoman holoman = new Holoman(); holoman.setName(&quot;whiteship&quot;); holoman.setHowLong(60); return holoman; &#125;&#125; 왜냐하면 빈 등록을 하는 단계가 2개라고 이전에 언급했는데@ComponentScan 방법이 먼저이고 @EnableAutoConfiguration 인데 직접 생성한 빈 설정은 @ComponentScan 방법에서 만들어졌다가 2단계에서 묻히는것.@EnableAutoConfiguration 요거에 특정 케이스에는 빈 등록을 안하게끔 하는 설정들이 있엇다 그걸 활용하면 이 문제를 개선 가능하다.내 설정보다 자동설정이 더 우선된다. 최근 버전으로 살펴보니 아예 오류가 떨어진다. 1The bean &#x27;holoman&#x27;, defined in class path resource [me/whiteship/HolomanConfiguration.class], could not be registered. A bean with that name has already been defined in com.example.Application and overriding is disabled. 자동 설정 만들기 2부: @ConfigurationProperties@ConditionalOnMissingBean -&gt; 이 타입의 빈이 없을 때만 자동설정 해라. 위에서 본것처럼 자동설정으로 빈을 등록하고, 또 실제 프로젝트에서 빈을 등록하게 되면 오류가 반환된다. 실제 프로젝트에서 빈을 등록하고 싶다면 이 어노테이션을 붙여서 실제 프로젝트에서 빈 등록을 안할 때에만 자동 설정이 되도록 할 수 있다. 스프링 부트가 여러가지 설정들을 커스터마이징 할수 있도록 하는 기능들 중 하나이다. 위에서 한 방법은 빈 자체를 새롭게 등록했다. 그런데 만약 빈의 사이즈가 커서 빈 자체를 새롭게 등록하는 것이 아니고 빈의 일부 데이터만 변경하고 싶을때에는 Properties를 활용해서 값을 넘겨준다. 빈 자체는 자동설정에서 만들고 빈을 만들 때 필요한 Properties 값을 메인 프로젝트에서 가져온다. ConfigurationProperties 어노테이션을 사용하기 위해서는 의존성을 추가해줘야 한다. 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 아래는 Properties 구조에 맞는 POJO 객체이다 1234567891011121314151617181920212223242526 import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(&quot;holoman&quot;)public class HolomanProperties &#123; private String name; private int howLong; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getHowLong() &#123; return howLong; &#125; public void setHowLong(int howLong) &#123; this.howLong = howLong; &#125;&#125; @EnableConfigurationProperties 어노테이션을 적용해야 동작한다. 하나 더 달라진 점은 Bean 등록시 holoman 함수에서 파라미터를 받고 있는데 저 값을 메인 프로젝트의 spring.properties 에서 가져올 것이다. 1234567891011121314151617181920import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@EnableConfigurationProperties(HolomanProperties.class)public class HolomanConfiguration &#123; @Bean @ConditionalOnMissingBean public Holoman holoman(HolomanProperties properties) &#123; Holoman holoman = new Holoman(); holoman.setHowLong(properties.getHowLong()); holoman.setName(properties.getName()); return holoman; &#125;&#125; 메인 프로젝트의 application.properties 에 아래처럼 설정해준다.12holoman.name = keesunholoman.how-long = 6 내장 웹서버 이해스프링 부트는 서버가 아니다. 스프링 프레임워크를 쉽게 사용할 수 있도록 하는 툴이지 특히나 웹서버가 아니다. 스프링부트가 제공하는 자동설정을 활용하지 않고 내장 톰캣을 사용하는 방법 1234567891011121314151617181920212223242526272829public class Application &#123; public static void main(String[] args) throws LifecycleException &#123; Tomcat tomcat = new Tomcat(); tomcat.setPort(8080); Context context = tomcat.addContext(&quot;/&quot;, &quot;/&quot;); HttpServlet servlet = new HttpServlet() &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; PrintWriter writer = resp.getWriter(); writer.println(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot;); writer.println(&quot;Hey, Tomcat&quot;); writer.println(&quot;&lt;/title&gt;&lt;/head&gt;&quot;); writer.println(&quot;&lt;body&gt;&lt;h1&gt;Hello Tomcat&lt;/h1&gt;&lt;/body&quot;); writer.println(&quot;&lt;/html&quot;); &#125; &#125;; String servletName = &quot;helloServlet&quot;; tomcat.addServlet(&quot;/&quot;, servletName, servlet); context.addServletMappingDecoded(&quot;/hello&quot;, servletName); tomcat.getConnector(); tomcat.start(); &#125;&#125; 톰캣을 먼저 띄우고, 서블릿을 만들고 이 서블릿을 톰캣에 할당하고 /hello 경로로 들어올 때 이 서블릿으로 들어가도록 매핑 스프링 부트의 자동설정을 활용해 위와 같은 톰캣 설정을 구현한다. 웹서버의 경우 spring-boot-autoconfigure 프로젝트에 ServletWebServerfactoryAutoConfiguration 객체를 참조해 자동설정이 구현된다 내부를 보면 톰캣, 제티, 네티, 언더토우 등등 존재한다. 여기서 Import 하는 부분에 EmbeddedTomcat을 들어가보면 TomcatServletWebServerFactory 이객체가 있는데 여기서 위 예시처럼 톰캣을 구현하고 있다.TomcatServletWebServerFactoryCustomizer 여기세어 커스터마이징도 가능하다. DispatcherServletAutoConfiguration -&gt;Spring에서는 DispatcherServlet이 서블릿 개념으로 돈다. 이 녀석은 스프링에서 HttpServlet을 상속받아 만든 놈 스프링 MVC의 핵심 클래스. 여기에서 자동설정을 한다. Servlet 컨테이너들은 바뀔수 있지만 Servlet은 변하지 않는다. 다시 말하자면 톰캣 위에 띄울수 있고, 언더토우 위에 띄울 수 있고 이런말. 내장 서블릿 컨테이너 응용 1부 : 컨테이너와 서버 포트Spring boot의 기본 설정은 tomcat. 자동설정에서 그렇게 만듬. 다른 서블린 컨테이너로 변경하기 위해서는 spring-boot-starter-web 여기 의존성에서 기본적으로 tomcat을 가져옴 이걸 빼야함. 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 다른 서블릿 컨테이너의 의존성을 추가 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt; application.properies 여기에 아래 코드를 넣으면 서버가 웹서버로 뜨지 않는다. spring.main.web-application-type=none 서버포트 변경하려면 application.properties 여기에 아래 코드 입력server.port=7070 아래 방법으로 포트 번호를 알수 있다. 웹서블릿이 생성될때 아래 리스너가 실행되고 여기서 값을 얻어온다.12345678910@Componentpublic class PortListener implements ApplicationListener&lt;ServletWebServerInitializedEvent&gt; &#123; @Override public void onApplicationEvent(ServletWebServerInitializedEvent servletWebServerInitializedEvent) &#123; ServletWebServerApplicationContext applicationContext = servletWebServerInitializedEvent.getApplicationContext(); System.out.println(applicationContext.getWebServer().getPort()); &#125;&#125; 내장 서블릿 컨테이너에 HTTPS, HTTP2 적용하기HTTPS 를 사용하려면 먼저 인증서 작업을 해야함 키를 만들어야함 keytool 명령어를 활용해 인증서를 만든다. jdk/bin 폴더에가면 keytool.exe 프로그램이 있다. 이를 실행 1keytool -genkey -alias spring -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 4000 생성된 키를 프로젝트의 루트에 두는 경우 1server.ssl.key-store= keystore.p12 이렇게 application.properties 에 설정해주시고, resources 폴더에 넣고싶다면 넣고 1server.ssl.key-store= classpath:keystore.p12 해주면 된다. HTTPS 를 적용하면 HTTP로 받을 수없다 커넥터가 한개고 이거를 HTTPS가 덮어씌웠기 때문. 아래처럼 커넥터를 새로 만들어서 적용하면 두 프로토콜을 모두 쓸 수 있다. 12345678910111213141516171819202122232425262728@SpringBootApplication@RestControllerpublic class Springbootdemo4Application &#123; @GetMapping(&quot;/hello&quot;) public String hello() &#123; return &quot;Hello Spring&quot;; &#125; public static void main(String[] args) &#123; SpringApplication.run(Springbootdemo4Application.class, args); &#125; @Bean public ServletWebServerFactory serverFactory() &#123; TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory(); tomcat.addAdditionalTomcatConnectors(createStandardConnector()); return tomcat; &#125; private Connector createStandardConnector() &#123; Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;); connector.setPort(8080); return connector; &#125;&#125; 12345server.ssl.key-store= keystore.p12server.ssl.key-store-type= PKCS12server.ssl.key-store-password=123456server.ssl.key-alias=springserver.port=8443 HTTP2 쓰기 독립적으로 실행 가능한 JAR (Spring-boot-maven-plugin)mvn clean package를 실행 하면 모든 의존성을 가지고 있는 실행 가능한 JAR 파일 하나가 생성됨.이안에 의존성 jar 파일들이 모두 들어있음. 스프링 부트는 내장 JAR로 해서 JAR안에 JAR로 묶어둔다. target.app.BOOT-INF.lib 여기에 의존성들이 들어간다. JarLauncher 이 파일이 SpringBoot 어플리케이션을 기본적으로 실행한다. SpringApplication 객체의 기능 Edit configuration 에서 jvm option에 -Ddebug 옵션을 주거나 program argument 에 —debug 옵션을 주면 어플리케이션을 디버그 모드로 실행할 수 있다. 이 객체에서 banner를 조작가능. ApplicationEvent. 스프링 생명주기 같은거 같다. 이벤트 처리를 할때 중요한점은 어플리케이션 컨텍스트가 발생하기 이전에 발생하는 이벤트들은 빈이 없기때문에 빈주입하더라도 리스너 동작하지 않는다. 빈이 없기 때문이다. 123456789@Componentpublic class SampleListener implements ApplicationListener&lt;ApplicationStartingEvent&gt; &#123; @Override public void onApplicationEvent(ApplicationStartingEvent applicationStartingEvent) &#123; System.out.println(&quot;Application is starting&quot;); &#125;&#125; 그래서 위와같이 applicationContext가 생성되지 않는 라이프 사이클에 이벤트 처리를 하고 싶으면 직접 객체 생성을 해줘야 한다. 123456public static void main(String[] args) &#123; SpringApplication app = new SpringApplication(Springbootdemo4Application.class); app.addListeners(new SampleListener()); app.run(args);&#125; 아래 케이스는 applicationContext가 생성되고 난 뒤의 이벤트이기 때문에 정상 실행이 되야 한다. 123456789@Componentpublic class SampleListener implements ApplicationListener&lt;ApplicationStartedEvent&gt; &#123; @Override public void onApplicationEvent(ApplicationStartedEvent applicationStartedEvent) &#123; System.out.println(&quot;Started&quot;); &#125;&#125; WebApplicationTypeSpring MVC, SPRING WebFlux 둘을 구분하기 위함 둘 다 구현되어 있다면 기본적으로 MVC를 선택한다. 만약 이 상황에서 WebFlux 를 적용하고 싶다면 1234567public static void main(String[] args) &#123; SpringApplication app = new SpringApplication(Springbootdemo4Application.class); app.setWebApplicationType(WebApplicationType.REACTIVE); app.run(args); &#125; 이렇게 적용하면 된다. WebApplicationType.SERVLET 가 MVC 를 실행하는 설정. -D 로들어오는 것은 jvm option, — 로 들어오는것은 application arguments. 123456public Contructor(ApplicationArguments arguments) &#123; System.out.println(&quot;foo: &quot; + arguments.containsOption(&quot;foo&quot;)); System.out.println(&quot;bar: &quot; + arguments.containsOption(&quot;bar&quot;));&#125; ApplicationArguments 객체로 Program Arguments를 받을 수 있다 (— 옵션으로 들어오는 값들) 애플리케이션 아규먼트 사용하기 - ApplicationArguments를 빈으로 등록해 주니까 가져다 쓰면 된다. 애플리케이션 실행한 뒤 뭔가 실행하고 싶을 때 - ApplicationRunner (추천) 또는 CommandLineRunner - 순서 지정 가능 @Order ApplicationRunner, CommandRunner 둘다 jvm options 은 못받음, program arguments 만 받음 외부설정application.properties 이런 파일들을 말함. 이런데서 설정한 값들을 외부 설정값이라고 생각하면된다 스프링부트가 이런 값들을 참고한다. application.properties1keesun.name = keesun 123456789101112131415@Componentpublic class SampleRunner implements ApplicationRunner &#123; @Value(&quot;$&#123;keesun.name&#125;&quot;) private String name; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(&quot;=========================&quot;); System.out.println(name); System.out.println(&quot;=========================&quot;); &#125;&#125; name 필드에 application.properties 안에 있는 값을 주입한다. 우선순위 커맨드라인 argument로 주는게 application.properties 보다 높다. 이방법으로 주면 덮어씌워진다. 테스트해보려면 mvn clean package 해서 jar로 패키징하고해당 jar 파일을 java -jar … 로 실행할때 —keesun.name=whiteship 이런식으로 준다. @SpringBootTest 어노테이션에 properties 속성으로 외부설정 값을 주눈게 커맨드라인보다 더 높다. 이런 외부값들을 가져오는 다른방법 Environment 객체 활용 1234567891011121314151617@Componentpublic class SampleRunner implements ApplicationRunner &#123; @Value(&quot;$&#123;keesun.name&#125;&quot;) private String name; @Autowired Environment environment; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(&quot;=========================&quot;); System.out.println(environment.getProperty(&quot;keesun.name&quot;)); System.out.println(&quot;=========================&quot;); &#125;&#125; 테스트용 외부 설정이 따로 필요할때는 application.properties 이파일을 테스트쪽 같은 패키지에 동일하게 생성한다.그러면 테스트 외부설정의 값을 사용한다. 서버포트에 랜덤값을 주고싶을때에는 application.properties 에서 ${random.int} 이걸 사용하면 안되고 단순히 0 값을 줘야한다.0은 가용한 범위내애서 포트번호를 주지만 ${random.int} 이 값은 무작위로 값을 주기때문. -가 나올수도 있고, 루트권한이 필요한 포트일수도 있고.. 위 방법의 단점은 테스트용 application.properties 값들의 존재여부가, 리얼 application.properties 와다르다면, 주입시 실패할 수도 있다는점 참고해야한다. 이 문제를 해결하기 위해서는 src 쪽의 application.properties 와는 다른 이름을 가진 properties 파일을 테스트 패키지 쪽에 넣고, 이를 테스트 클래스에서 추가해주면 된다. 외부설정 값들을 하나의 빈으로도 받을 수 있다. 123keesun.name = keesunkeesun.age = $&#123;random.int(100)&#125;keesun.fullnName = $&#123;keesun.name&#125; Baik 123456789101112131415161718192021222324252627282930313233@Component@ConfigurationProperties(&quot;keesun&quot;)public class KeesunProperties &#123; private String name; private int age; private String fullName; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getFullName() &#123; return fullName; &#125; public void setFullName(String fullName) &#123; this.fullName = fullName; &#125;&#125; 1234567891011121314151617@Componentpublic class SampleRunner implements ApplicationRunner &#123; @Autowired KeesunProperties keesunProperties; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(&quot;=========================&quot;); System.out.println(keesunProperties.getName()); System.out.println(keesunProperties.getAge()); System.out.println(&quot;=========================&quot;); &#125;&#125; 프로파일특정한 프로파일에서만 특정한 빈을 등록하고 싶다. 이런 케이스에서 사용함 빈생성을 특정 상황(스테이징인지, 로컬인지, 운영인지) 에 맞게 할수 있음 123456789@Profile(&quot;prod&quot;)@Configurationpublic class BaseConfiguration &#123; @Bean public String hello() &#123; return &quot;hello&quot;; &#125;&#125; 12345678@Profile(&quot;test&quot;)@Configurationpublic class TestConfiguration &#123; @Bean public String hello() &#123; return &quot;test&quot;; &#125;&#125; 12// application.propertiesspring.profiles.active=test 혹은 커맨드라인 아규먼트로 위 값을 제공해도 된다. 이방법이 실제적으로 더 많이 쓰일듯. 왜냐하면 어느 환경에서 프로젝트가 실행하는지는 외부에서 설정값을 가져와야 하기 떄문에. 스프링부트 로깅로깅 퍼사드 vs 로깅 로거 API 들을 추상화 해놓은 인터페이스들주로 프레임워크들은 로깅 퍼사드들을 활용해서 개발.로깅퍼사드를 안써도되는데 장점은 로거들을 바꿔낄수 있다.로깅퍼사드 -&gt; 그냥 로거들의 추상화된 객체인가보네. 구현체를 바꿔낄수 있게 하려고. 프레임워크에서는 로깅퍼사드를 쓰는 이유는 어플리케이션 개발자가 쓰는 로거가 여러개 이기 때문에 이를 모두 수용하려고 추상체를 사용. 인터페이스의 사용 개념과 동일. Commons Logging -&gt; 스프링에서 기본적으로 제공하지만 지금은 안쓰는 추세, 뭔가 불안정했던게 많아다고함. 최종적으로 Logback을 쓰는거임. 이게 구현체인가보다. 로거 Slf4j, commons logging 이것들은 로깅 퍼사드. 로깅한 내용을 파일로 떨구고싶으면 application.properties 여기에 logging.path=logs 이런식으로 디렉토리, 파일을 설정해주면 된다. 1logging.path=logs 로깅 레벨도 패키지마다 설정가능. 1logging.level.[패키지경로]=DEBUG 12logging.file.path=logslogging.level.com.example.springdemo=DEBUG 1234567891011121314151617@Componentpublic class SampleRunner implements ApplicationRunner &#123; private Logger logger = LoggerFactory.getLogger(SampleRunner.class); @Autowired private String hello; @Override public void run(ApplicationArguments args) throws Exception &#123; logger.info(&quot;==============================&quot;); logger.info(hello); logger.info(&quot;==============================&quot;); &#125;&#125; Spring boot Http Message Converter-&gt; Http 요청 전문을 객체로 변경하거나, 객체를 Http 응답 전문으로 변경할때 사용되는 객체.요 객체를 호출하는 어노테이션이 @ResponseBody, @RequestBody 이다. 이건 익숙하지. 우리가 객체를 반환하게끔 코드를 짰지만 이거를 Http 전문으로 변경해주는 것이 기본적으로 jackson을 사용. String, int 같은 원시타입도 메세지 컨버터가 사용된다.@Controller 어노테이션을 쓰고 @ResponseBody 어노테이션을 안넣으면 REST 형태가 아니기때문에 return 값에 해당하는 view resolver 를 찾게된다. 123456789101112131415@RestControllerpublic class UserController &#123; @GetMapping(&quot;/hello&quot;) public String hello() &#123; return &quot;hello&quot;; &#125; @PostMapping(&quot;/users/create&quot;) public User create(@RequestBody User user) &#123; return user; &#125;&#125; 12345678910111213141516171819202122232425262728@RunWith(SpringRunner.class)@WebMvcTest(UserController.class)public class UserControllerTest &#123; @Autowired MockMvc mockMvc; @Test public void hello() throws Exception &#123; mockMvc.perform(get(&quot;/hello&quot;)) .andExpect(status().isOk()) .andExpect(content().string(&quot;hello&quot;)); &#125; @Test public void createUser_JSON() throws Exception &#123; String userJson = &quot;&#123;\\&quot;username\\&quot;:\\&quot;keesun\\&quot;, \\&quot;password\\&quot;:\\&quot;123\\&quot;&#125;&quot;; mockMvc.perform(post(&quot;/users/create&quot;) .contentType(MediaType.APPLICATION_JSON_UTF8) .accept(MediaType.APPLICATION_JSON_UTF8) .content(userJson)) .andExpect(status().isOk()) .andExpect(jsonPath(&quot;$.username&quot;, is(equalTo(&quot;keesun&quot;)))) .andExpect(jsonPath(&quot;$.password&quot;, is(equalTo(&quot;123&quot;)))); &#125;&#125; 12345678910111213141516171819202122232425262728293031public class User &#123; private Long id; private String username; private String password; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; Spring boot ViewResolverContentNegotiationViewResolver - 들어오는 요청의 accept Header 에 따라서 응답을 다르게 해주는 resolver 12345@PostMapping(&quot;/users/create&quot;)public User create(@RequestBody User user) &#123; return user;&#125; 메인에 해당하는 위 소스를 수정하지 않아도 accept 에따라서 xml 객체가 내려갈수도 json 객체가 내려갈수도 있다. 위에 있는 contentNegotialtionViewResolver 이녀석 덕분에. HttpMediaTypeNotAcceptableException 406 에러가 뜬다면 객체를 accept에 원하는 전문의 형태로 변환해줄 객체가 없다는 의미. spring boot 자동설정에 messageConvert 쪽을 보면 Xml을 매핑해주는 객체가 기본적으로 없다. 그래서 아래 의존성을 추가해야한다. 1234567&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt;&lt;/dependency&gt; Spring boot 정적리소스 지원이미 만들어져있는 리소스를 정적리소스. 이거를 바로 반환할수 있도록 지원함 Spring boot 웹JAR클라이언트에서 사용하는 자바스크립트 라이브러리 react, vue, bootstrap, jquery 이것들을 jar 파일로 dependency를 추가할 수 있다. jquery를 추가해보자. 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars.bower&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello Static Resource AHHHA&lt;script src=&quot;/webjars/jquery/3.3.1/dist/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function() &#123; alert(&quot;ready&quot;); &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webjars-locator-core 의존성을 추가하면 버저닝도 생략가능 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;webjars-locator-core&lt;/artifactId&gt; &lt;version&gt;0.35&lt;/version&gt;&lt;/dependency&gt; favicon, index 페이지static 디렉토리에 favicon.ico 파일을 넣는다. 그리고 빌드하면 끝. 안바뀌면 파비콘을 직접 호출한 후에, 브라우저 새로고침하면 됨. 브라우저 캐시때문에 발생하는 문제. Thymeleaf템플릿엔진이라는 것은 뷰를 만드는데 주로쓰고, 코드 제너레이션, 이메일 템플릿 이런거 사용 jsp를 권장하지 않는이유.-&gt; jar 패키징 할때는 동작하지 않고 war 패키징을 해야함.-&gt; 독립적으로 임베디드 톰캣으로 구현하기가 맞지 않음.-&gt; undertow는 jsp를 지원하지 않음.-&gt; 의존성 문제도 꽤 있다고 함. Thymeleaf-&gt; 비교적 최근에 만들어진 템플릿 엔진-&gt; 웹서버를 띄우지않고도 프론트쪽 작업이 가능하다. 데이터를 임시로 placeholder 처럼 처리가 가능. view쪽 테스트코드 작성하기 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text=&quot;$&#123;name&#125;&quot;&gt;Name&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 123456789@Controllerpublic class SampleController &#123; @GetMapping(&quot;/hello&quot;) public String hello(Model model) &#123; model.addAttribute(&quot;name&quot;, &quot;keesun&quot;); return &quot;hello&quot;; &#125;&#125; 12345678910111213141516@RunWith(SpringRunner.class)@WebMvcTest(SampleController.class)public class SampleControllerTest &#123; @Autowired MockMvc mockMvc; @Test public void hello() throws Exception &#123; mockMvc.perform(get(&quot;/hello&quot;)) .andExpect(status().isOk()) .andDo(print()) .andExpect(view().name(&quot;hello&quot;)) .andExpect(model().attribute(&quot;name&quot;, is(&quot;keesun&quot;))) .andExpect(content().string(containsString(&quot;keesun&quot;))); &#125;&#125; HtmlUnithtml을 단위테스트하기 위한 툴 form의 submit 행위를 모킹도 가능특정 브라우저인척 할수도 있다.dom tree element 탐색 가능 Spring HATEOASREST API 를 만들 때 연관된 링크정보들을 클라이언트에게 함께 제공 1234567891011121314151617@RestControllerpublic class SampleController &#123; @GetMapping(&quot;/hello&quot;) public Resource&lt;Hello&gt; hello() &#123; Hello hello = new Hello(); hello.setPrefix(&quot;Hey,&quot;); hello.setName(&quot;Keesun&quot;); Resource&lt;Hello&gt; helloResource = new Resource&lt;&gt;(hello); helloResource.add(linkTo(methodOn(SampleController.class).hello()).withSelfRel()); return helloResource; &#125;&#125; 12345678910111213141516@RunWith(SpringRunner.class)@WebMvcTest(SampleController.class)public class SampleControllerTest &#123; @Autowired MockMvc mockMvc; @Test public void hello() throws Exception &#123; mockMvc.perform(get(&quot;/hello&quot;)) .andDo(print()) .andExpect(status().isOk()) .andExpect(jsonPath(&quot;$._links.self&quot;).exists()); &#125;&#125; 스프링 데이터 7부 : 데이터베이스 초기화ddl이 실행될때 hibernate가 자동실행하는 것 말고 우리가 sql 을 스크립트로 작성할 수 있다. application.properties123spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true# spring.jpa.hibernate.ddl-auto=validate# spring.jpa.generate-ddl=false이렇게 해두고 schema.sql 파일을 만들어서 여기에 스크립트를 넣는다. resource/schema.sql 그다음에 data.sql 이걸 정의에서 여기에 초기 데이터를 넣을 수 있다. 스프링 데이터 8부 : 데이터베이스 마이그레이션Flyway, Liquibase 이 두가지가 대표적인 데이터베이스 마이그레이션 툴 스프링 데이터 9부 : 레디스도커로 레디스 실행 12docker run -p 6379:6379 --name redis_boot -d redisdocker exec -i -t redis_boot redis-cli","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"}]},{"title":"GIT 머지 충돌에 대한 고찰","slug":"2020-12-21-git-merge-conflict","date":"2020-12-01T02:38:54.000Z","updated":"2022-05-31T07:23:15.000Z","comments":true,"path":"2020/12/01/","link":"","permalink":"http://kidongyun.github.io/2020/12/01/","excerpt":"","text":"git 으로 형상 관리를 할 때 동일한 파일의 같은 행을 같이 서로 다른 브랜치에서 작업을 하게 되면 충돌 이슈가 발생한다. 어떤 수정된 내용이 맞는 것인지 git 은 알수 없기 때문이다. 머지 충돌 문제는 혼자 개발을 할 때에는 주요 문제가 아니지만 실무에서 협업을 하다보면 한번씩 발생하게 되는데 이러한 머지 충돌 문제를 어떻게 해결하는게 효율적인지에 대해 적어둔다. 이 글은 지극히 주관적인 글임으로 맹목적인 신뢰를 지양하며, 하나의 참고 글로만 읽어주시기 바란다. 머지 충돌이 일어나기 전으로 돌아가자머지 충돌이 발생하고 나서 머지된 브랜치를 지속 사용해야 한다면, 머지하기 이전의 커밋으로 돌아가야 한다. 이럴때는 ‘git reset, revert’ 등의 명령어를 사용하면 돌아갈 수 있으며 여기서는 가장 위험하지만 강력한 방법인 git reset 방법을 소개한다. 1git reset --head [COMMIT ID] 각 commit 에는 고유의 ID 값이 존재하는데 해당 값을 활용하여 위의 명령어를 실행하면 프로젝트는 저 커밋이 실행된 직후 상황으로 복원된다. 주의해야할 점은 그 이후에 커밋했던 내역들이 모두 사라짐을 유의하자. (이를 살려야한다면 git revert 명령어를 참고하라) 이제 복원시킨 이 내용을 원격 저장소에도 동기화 시켜주기 위해 ‘git push’ 명령어를 실행하자 1git push origin +master Commit 이력등 도 변경이 되기 때문에 원격저장소 브랜치 명 앞에 ‘+’ 키워드를 붙여 줘야 한다 충돌난 내용이 서로 연관이 없다면? ( A + B = AB, BA )머지 충돌이 발생했을 경우 이 이슈는 두 가지의 경우로 나뉜다. 첫번째는 서로 다른 두 브랜치에서 작업한 이 내용이 서로 관련이 없는 경우이다. 이런 경우에는 머지할 브랜치에 충돌된 두 브랜치의 작업 내용을 모두 포함시켜주면 된다. 두 브랜치 A, B 가 있다고 하자. 이 두 브랜치가 작업한 내용이 같은 파일의 같은 행에서 수정이 되었다. 이런 경우에 머지 충돌을 해결하기 위해서는 단순히 이 두 작업 A의 작업, B의 작업 를 연달아 호출하거나 반대로 B의 작업, A의 작업 호출하면 된다. 물론 연달아서 호출 시에 실제 비지니스에 문제가 있는지 없는지는 직접 보고 확인하여야 한다. 아래는 예시이다. 123456789101112131415/* A 브랜치의 작업 */AService aService = new AService();aService.doSomething();/* B 브랜치의 작업 */BService bService = new BService();bService.doSomething();/* 머지되어야할 브랜치 */AService aService = new AService();aService.doSomething();BService bService = new BService();bService.doSomething(); 머지 충돌을 위와 같이 수정하고 난 이후에 다시 A, B 브랜치에서 재 수정을 하게 되면 git은 알아서 서로 다른 행으로 인지하기 때문에 다시 머지 충돌이 일어나지 않는다. 지금 알아본 형태는 머지 충돌 이슈에서 다행히도 서로 연관된 값들을 사용하지 않기 때문에 간단하게 해결할 수 있는 방법이지만 다음에 볼 경우는 조금 더 복잡해진다. 충돌난 내용이 서로 연관이 있다면? ( A + B = C )머지충돌이 골치가 아파오는 경우는 사실 대부분 이 경우이다. A 브랜치에서 작업한 내용, B 브랜치에서 작업한 내용이 서로 공유가 되는 부분이 있어서 실제 머지되는 브랜치에서는 A, B 두 브랜치에서 작업한 코드가 아닌 새로운 코드가 필요한 경우이다. 이와 같은 경우 C의 작업으로 머지되어야 할 브랜치에 수정을 하게 되면, A, B 브랜치에서 새로운 수정 작업이 생겨서 다시 머지를 하게되면 A, B 브랜치에는 새로운 C의 작업을 가지고 있지 않기 때문에 매번 충돌이 일어난다. 이를 해결하기 위해서는 어쩔 수 없이 지금 가지고 있는 브랜치로는 활용이 불가능하다. 그렇기 때문에 새로운 브랜치들을 모두 만들것이며 여기에 기존의 작업 내용들을 머지하면서 개선해야 한다.추가적으로 우리는 PARENT 브랜치를 하나 더 만들 것인데 충돌이 나는 이 A, B 두 브랜치들은 이 PARENT 브랜치의 하위 브랜치로 생성을 한다. 이 하위 브랜치들은 PARENT 브랜치를 기준으로 작업내용을 서로 공유하며 진행한다. 즉 충돌난 내용이 서로 연관이 있다는 이야기는 즉 A, B 두 브랜치는 완전히 서로 독립적인 브랜치가 아니기 때문에 PARENT 라는 징검다리 브랜치를 만들어 머지가 되어야할 공용 브랜치를 보호하고 A, B 두 브랜치 간에 코드 공유도 가능하게 만든다. 아래는 이러한 머지 충돌이 났을 때 브랜치를 생성하는 예시이다. 123456789101112131415git checkout master : master 브랜치로 이동git branch parent : master 브랜치에서 parent 하위 브랜치 생성git checkout parent : parent 브랜치로 이동git branch new_A : parent 브랜치에서 new_A 하위 브랜치 생성git checkout new_A : new_A 브랜치로 이동git merge old_A : new_A 브랜치에 old_A 브랜치를 병합git checkout parent : parent 브랜치로 이동git merge new_A : parent 브랜치에 new_A 브랜치를 병합git branch new_B : parent 브랜치에서 new_B 하위 브랜치를 생성 (new_B 브랜치는 A의 작업을 포함하고 생성이 됨)git checkout new_B : new_B 브랜치로 이동git merge old_B : new_B 브랜치에 old_B 브랜치를 병합 (new_B 브랜치는 A작업을 가지고 있기 때문에 여기서 머지충돌이 일어남. 수동으로 개선 필요)git checkout parent : parent 브랜치로 이동git merge new_B : parent 브랜치에 new_B 브랜치를 병합","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Git - Merge","slug":"Git-Merge","permalink":"http://kidongyun.github.io/tags/Git-Merge/"}]},{"title":"The study about Value Object based on 'enum'","slug":"2020-11-27-enum","date":"2020-11-27T02:38:54.000Z","updated":"2022-05-31T07:21:14.000Z","comments":true,"path":"2020/11/27/","link":"","permalink":"http://kidongyun.github.io/2020/11/27/","excerpt":"","text":"It’s really useful to describe the enum syntax in Java when you want to express Value Object. This article just show how we could describe value object better using enum syntax. and You should know this article is included my personal opinions that might be not true. so I want to you who become more strictly than before when you are reading this. What is the Value Object ?Firstly, Let’s try to get the concept of Value Object briefly. Value Object is usually mentioned in Programming language (especially Java).It means the object what only has ‘status’ without behavior. and We usually abbreviate it as VO. so I will mentions it as VO at now. in other words, VO would be usually just data class that has only value(= variables) without any doing something(= function). if you should use enum syntax, then the Enum object will be the one to describe some data like Database. but The difference between Enum and Database is Enum data object is only stored in memory located programming language regions. Value Object The thing only has variables without function. expressing data object in programming language. Let’s try to express VO without enum syntax.You can express VO using class keyword. because Enum is implemented from class. Let’s try to describe ‘Season’ object simply using class. 123456789101112class Season &#123; String SPRING = &quot;SPRING&quot;; String SUMMER = &quot;SUMMER&quot;; String FALL = &quot;FALL&quot;; String WINTER = &quot;WINTER&quot;;&#125;class Main &#123; public static void main(String[] args) &#123; String season = Season.SPRING; &#125;&#125; This Season class only has data without any function as you learned the above. but You could see the disadvantage of the above source code. String type can take any word that you don’t want. it means this season class can take the string value that doesn’t associated with Season. If we can make it more strictly, then the source code is better. 1234567891011121314class Season &#123; public static final Season SPRING = new Season(); public static final Season SUMMER = new Season(); public static final Season FALL = new Season(); public static final Season WINTER = new Season();&#125;class Main &#123; public static void main(String[] args) &#123; Season season = Season.SPRING; &#125;&#125; Let’s do refactoring.You can change this code better using enum keyword. 1234567891011enum Season &#123; SPRING, SUMMER, FALL, WINTER&#125;class Main &#123; public static void main(String[] args) &#123; Season season = Season.SPRING; &#125;&#125; The source code using enum is more simple than the class one and the readability is also better. and one of the features of enum is that same data object is become same instance. so if you need to express like this data type then it’s really good choice that using enum for that. The advantage that you express VO with enum Improving readability Only input the data you want same data is same instance (singleton) enum with multiple fieldsyou also add new fields in enum object if you want. Let’s suppose for understanding this case. we need two fields that one is the korean word and the other is english code that represent the season. let’s follow up the below code. 123456789101112131415161718192021222324252627enum Season &#123; SPRING(&quot;S&quot;, &quot;봄&quot;), SUMMER(&quot;M&quot;, &quot;여름&quot;), FALL(&quot;F&quot;, &quot;가을&quot;), WINTER(&quot;W&quot;, &quot;겨울&quot;); Season(String code, String value) &#123; this.code = code; this.value = value; &#125; private final String code; private final String value; public String code() &#123; return code; &#125; public String value() &#123; return value; &#125;&#125;class Main &#123; public static void main(String[] args) &#123; Season season = Season.SPRING; System.out.println(season.toString()); System.out.println(season.code()); System.out.println(season.value()); &#125;&#125; lastly, i would like to say the advantage of enum keyword one more. let’s think the situation that some concepts could express various ways. sometimes we should it parse to another type one. but this coding style is not good. because you should add new function to parse whenever you add new variables that are same concepts. and You could not keep the consistency. 12345678910111213141516171819class Parser &#123; public static boolean parse(String str) throws Exception &#123; if(&quot;YES&quot;.equals(str) || &quot;Y&quot;.equals(str)) &#123; return true; &#125; if(&quot;NO&quot;.equals(str) || &quot;N&quot;.equals(str)) &#123; return true; &#125; throw new Exception(&quot;Cannot parse &quot; + str); &#125;&#125;class Main &#123; public static void main(String[] args) throws Exception &#123; boolean flag = Parser.parse(&quot;YES&quot;); &#125;&#125; if you use enum, it will be better. 12345678910@AllArgsConstructorenum Flag &#123; YES(true, &quot;Y&quot;, &quot;YES&quot;), NO(false, &quot;N&quot;, &quot;NO&quot;) ; private final boolean bool; private final String yn; private final String yesNo;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"Notepad","slug":"2020-11-23-notepad","date":"2020-11-23T02:38:54.000Z","updated":"2022-05-31T07:21:08.000Z","comments":true,"path":"2020/11/23/","link":"","permalink":"http://kidongyun.github.io/2020/11/23/","excerpt":"","text":"주제 DTO, Domain, VO 에 대한 글 요청(파라미터)는 DTO의 필요성을 명확히 알겠음. 그러면 반환해줄때의 객체의 형태는 DTO여야 하는가 아니면 VO여야 하는가… DTO, VO, Domain 객체 구분해서 사용하기를 원함. DTO가 비지니스 종속적여야 하는 이유.-&gt; 공통된 기능을 가졌다고 해서 다른 비즈니스를 공통된 DTO 사용했을 경우에 추후 다른 속성을 사용하는 비즈니스가 들어왔을경우이 DTO를 분리시켜야함. 단순히 DTO를 분리시킨다는 관점에서는 큰 문제는 아니지만. 그 기능이 인터페이스로 규격화 되어있을 경우DTO가 특정항공사는 다른 이슈가 생기기 때문에 이는 인터페이스화 시킬수 없는 문제가 발생. DTO와 Domain이 구분되어져야 하는 이유.-&gt; 해당 객체가 생성되는 근본적인 이유가 다르기 때문이다. DTO가 가져야할 특성이 있는데 그 중 주된것들은.fS첫번째 validation 체크이다. DTO는 데이터를 주고받을 때 사용하는 목적으로 만들어진 객체이기 때문에. validation 체크가 기본적으로 통상 들어간다.Domain 객체와 이러한 DTO를 같이 사용하게 되면 validation 체크를 DTO 자체적으로 구현하지 못하고 별도 서비스단 등에서 제어해야하는 문제가 발생한다. 두번째. 마샬링, 파싱 등의 작업을 할때 조건을 걸어야 하기때문. 조건은 결국 비지니스 종속적일 수밖에 없고 이를 domain 객체에 넣어둘수는 없다.domain은 모두 공통적으로 사용해야하는 객체이기 때문에 어떤 한 특정 비지스에 종속적인 객체를 만드는 것은 좋지 않은 패턴이다. 세번쨰. DTO 를 디자인하는 것과 도메인 객체를 디자인하는 근본적인 목적이 다르다. DTO 는 딱 주고 받아야할 데이터만 최대한 간단하게 주고받고록만들어야하지만 도메인 개체는 객체 모델링 관점에서 실세상을 투영되도록 각 도메인 객체들끼리 관계를 맺어주며 구현해야하기 때문에설계되는 모양이 근본적으로 다를수 밖에 없다. Map&lt;&gt; 은 언제 사용되어야 할까.-&gt; Map은 type safe 하지 않기 때문에 일반적으로는 DTO를 생성하고 해당 객체를 Map을 대신 사용하는 것을 추천한다. 그러나 만약 Map을 사용하는 곳의 Scope가한 함수의 내부적으로만 사용하고 해당 함수를 사용하는 다른 클라이언트들에게 이 Map 객체를 전달할 일이 없다면 해당 타입을 다른 클라이언트가 지속 사용하는현상이 일어나지 않음으로 구조가 심플하고, 스코프가 한 함수 내부라면 사용하는것이 좋을듯 하다. Java POJO 객체를 계속 만들어 나가는것도 결국에는 양이 엄청나기 때문이정도로 사이즈가 작고 클라이언트에게 큰 영향이 없다면 그냥 Collection Framework를 사용하는 것도 좋을 것 같다. innerClass 를 활용한 DTO, Domain 구분 무엇이 DTO이고 무엇이 Domain 일까 다른패키지에서 같은 이름으로 만들수는있어도 이를 한 클래스에서 같이 사용할 수는 없다. Domain.DTO -&gt; 이미 장점을 알고있는 구조. 각 비지니스에 맞추어서 POJO 객체를 쓸 수 있다. Spring Validation 가능 위에서도 이미 언급되고 있음. Flat Design Boundary.DTO, Package.DTO -&gt; innerClass 로 구현 -&gt; 영역의 구분에 대한 장점 패키지로 하는것 보다 더 제한적 -&gt; 이름이 중복될수 없음. -&gt; 특정 비지니스에 종속되어 있는 DTO 임을 명시 가능. DTO.Domain -&gt; 불가능한 구조 Domain 이라함은 공용으로 사용하는 POJO 객체 인데. 이것이 특정 비지니스에 맞추어져 있는 DTO 안에 들어갈 수 없음. Domain.DTO.DTO -&gt; 가능은 함 그러나 권장하지 않는 구조, Domain.DTO 에 들어가는 조건 중 하나는 Domain과 관련된 DTO가 들어가야함. Domain.DTO 구조로 설계했는데 Domain에 마땅히 들어갈 데이터가 없다면 Boundary.DTO 형태로 변경을 고려해야함. Domain이 될수있는 조건은 프로젝트 모든 곳에서 사용할 수 있는 구조인가를 고려해야함. 그리고 그런 데이터인지. 그렇기때문에 일반적으로 데이터베이스 엔티티 구조를 따른다 DAO는 결국 DB와 DOMAIN을 연결하는 DTO의 일종이다. 보통 DTO는 뷰와 DOMAIN을 연결하는 요소로 언급함. 내가볼때는 둘다 DTO로 봐도되지 않나.. 용어의 정의를 내가 내리지 않았으니이 둘을 구분은 해야할듯 DTO는 View - Domain, DAO는 Domain - DB jpa를 활용하지 않고 최대한 의존성이 적은 쿼리를 짜는 방법 -&gt; 결국 동적쿼리를 써야함으로 DB 캐싱은 사용할 수 없다 성능은 떨어짐 이슈. 그리고 쿼리가 최대한 의존적이지 않ㄱ ㅔ짜기 때문에대부분 분리된 방식으로 짬 -&gt; 트랜잭션 관리 가 더커짐. 테이블이 3개를 기준으로 쿼리를 가져와야 한다면. 해당 테이블 기준으로 Domain 객체 3개를 우선 만들고 이들을 합쳐 DAO를 만든다 그래서 파라미터로 들어가야할 부분에는 이 값들을 넣어준다.쿼리는 가능한 한도 내에서 동적쿼리로 작성 내가아까 푸쉬를 했나?? set하는 코드보다 builder 하는 코드가 좋은이유 가독성 측면에서 10000줄짜리 한 스코프의 코드가 있다고 하자. 이거 자체가 굉장히 억지스러운 일이지만.만약 1번째 줄에 선언된 변수가 10000째에서 사용된다고 하면. 그 사이의 작업이 어떤것이 있었는지 다 확인해야한다.그런데 만약 10000번째에 반환시키는 변수를 빌더로 사용한다면. 거기안에 들어가있는 변수들만 쫓아가면 된다변수를 좀더 사용하기 때문에 공간복잡도는 조금더 올라가겠지만. 가독성은 향상된다.그러나 변수명을 모두 지정해줘야하는 문제가 있다. 주제 . 인터페이스 설계의 이점주제. null 체크 (with optional)한 함수 스코프로 잡고 그 안에서의 null 처리를 하라.무의미한 null 처리라면 로깅의 목적으로로 쓸수 있다.객체에서 객체를 계속 참조하는 구조가 nullpointerexception의 취약점이다.set 할때보다 get 할때를 유의하라. 주제. 리플렉션 기본 문법.- 필드 가져오기 - 메소드 가져오기 - private 접근하기 - getter/setter 접근하기 주제. 리플렉션 과 스프링 생성자로 만들어진 객체는 바로 빈주입이 되지 않는다 생성자주입 사용시 NoArgs 생성자 사용을 어떻게 하는가 with reflection생성자 주입을 사용하면 해당 객체를 생성할때 해당 의존성을 반드시 전달해야하는 문제.리플렉션, new 로 객체생성시 빈등록이 안되는 문제에대해서 해결방법 스프링 빈 컨테이너를 가지고있는 ApplicationContext 객체를 Static 메모리에 올리고 접근할 수 있도록 함. 리플렉션시 생성자에 ApplicationContext 객체를 파라미터로 주입받고 이 객체를 통해 내부적으로 빈 주입을 진행. 주제. FLUXRedux사용방법 Redux 비동기 통신비동기 Action에 대해서Redux 로깅Redux Thunktypesafe-actionsMobx사용방법 주제. HttpClient 를 활용한 HTTP 통신 방법URI 생성쿠키 생성Header 주입GET, POST12345678910111213public static String get(String url) throws URISyntaxException, IOException &#123; URI uri = new URI(&quot;http://batchadmin.interparktour.com/admin/airControlTimerGet.do?searchAirline=AL&quot;); uri = new URIBuilder(uri).addParameter(&quot;searchAirline&quot;, &quot;AL&quot;).build(); HttpClient httpClient = HttpClientBuilder.create().build(); HttpGet httpGet = new HttpGet(uri); httpGet.setHeader(&quot;Content-Type&quot;, &quot;application/json&quot;); HttpResponse response = httpClient.execute(httpGet); HttpEntity entity = response.getEntity(); return EntityUtils.toString(entity);&#125; 123456789101112131415161718192021222324252627public static String get(String url) throws URISyntaxException, IOException &#123; URI uri = new URI(url); uri = new URIBuilder(uri).addParameter(&quot;searchAirline&quot;, &quot;AL&quot;).build(); /** 쿠키 처리 */ BasicCookieStore cookieStore = new BasicCookieStore(); BasicClientCookie cookie = new BasicClientCookie(&quot;ADMIN_ID&quot;, &quot;N19147&quot;); cookie.setDomain(&quot;batchadmin.interparktour.com&quot;); cookie.setPath(&quot;/&quot;); cookieStore.addCookie(cookie); BasicClientCookie cookie2 = new BasicClientCookie(&quot;AWP_KEY&quot;, Utility.getEncSHA256(&quot;interpark_N19147_airadmin12#$&quot;)); cookie2.setDomain(&quot;batchadmin.interparktour.com&quot;); cookie2.setPath(&quot;/&quot;); cookieStore.addCookie(cookie2); HttpClient httpClient = HttpClientBuilder.create().setDefaultCookieStore(cookieStore).build(); /** Get 혹은 Post */ HttpGet httpGet = new HttpGet(uri); httpGet.setHeader(&quot;Content-Type&quot;, &quot;application/json&quot;); HttpResponse response = httpClient.execute(httpGet); HttpEntity entity = response.getEntity(); return EntityUtils.toString(entity);&#125; 주제. async, await, promise, then주제 React에서 Component 와 DataComponent 설계할때 데이터에 영향이 있는것은 주입받도록 만들고 나머지는 해당 컨테이너에서 처리하면된다.추상화 기법은 Component 작업할때 별로 좋지 않은것 같다.styled 와 관련된 Component 를 두고 예를 추상화 시켜서 쓰려고 했는데. 결국 css 문법을 계속 한번씩 확인하게 되고. width, height 등과 관련된 Layout Component 하나 두고 이걸로 저런 값들을 조절하고 button, label 등의 글자나 특색이있는 UI 요소들은 다른 component로 둬서 둘을 결합해서 사용하는게 좋은듯. 이런식으로 기본적으로 내가 만든 모든 컴포넌트는 레이아웃에 특별함이 필요하다하면 저걸로 감싸는거지. 레이아웃적인 요소와 특정 컴포넌트만 가지는 요소를 구분시키고 이 레이아웃적인 요소를 감싸게끔 만드는게 진짜 조은듯 Data는 State를 기준으로 Store, Action, Reducer를 설계한다. State를 표현하기 위한 Store, State를 조작하기 위한 Action 들 인것이다. 주제. 제네릭 메서드 빌더123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.awb.domair.adminAwp.vo;public class Response&lt;T&gt; &#123; private int status; private T body; public int getStatus() &#123; return status; &#125; public void setStatus(int status) &#123; this.status = status; &#125; public T getBody() &#123; return body; &#125; public void setBody(T body) &#123; this.body = body; &#125; @Override public String toString() &#123; return &quot;Response&#123;&quot; + &quot;status=&quot; + status + &quot;, body=&quot; + body + &#x27;&#125;&#x27;; &#125; public static class Builder&lt;T&gt; &#123; private final Response&lt;T&gt; response; public Builder() &#123; this.response = new Response&lt;&gt;(); &#125; public Builder&lt;T&gt; status(int val) &#123; this.response.status = val; return this; &#125; public Builder&lt;T&gt; body(T val) &#123; this.response.body = val; return this; &#125; public Response&lt;T&gt; build() &#123; return response; &#125; &#125;&#125; O.O.P 와 F.P 문제 해결 접근 방법 비교DBResultSet &lt;-&gt; Map, T123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import com.fasterxml.jackson.databind.ObjectMapper;import java.sql.SQLException;import java.util.*;public class ResultSetUtil &#123; /** DBResultSet -&gt; List&lt;Map&lt;String, Object&gt;&gt; */ public static List&lt;Map&lt;String, Object&gt;&gt; toMap(DBResultSet rset) throws SQLException &#123; List&lt;Map&lt;String, Object&gt;&gt; rows = new ArrayList&lt;&gt;(); rset.initRow(); while (rset.next()) &#123; Map&lt;String, Object&gt; column = new HashMap&lt;&gt;(); for(int i$ = 1; i$ &lt;= rset.columnCount; i$++) &#123; column.put(rset.getColumnName(i$), rset.getObject(i$)); &#125; rows.add(column); &#125; return rows; &#125; /** List&lt;Map&lt;String, String&gt;&gt; -&gt; List&lt;T&gt; */ public static &lt;T&gt; List&lt;T&gt; toDomain(List&lt;Map&lt;String, Object&gt;&gt; maps, Class&lt;T&gt; clazz) &#123; List&lt;T&gt; objects = new ArrayList&lt;&gt;(); for(Map&lt;String, Object&gt; map : maps) &#123; objects.add(new ObjectMapper().convertValue(map, clazz)); &#125; return objects; &#125; /** DBResultSet -&gt; List&lt;T&gt; */ public static &lt;T&gt; List&lt;T&gt; toDomain(DBResultSet rset, Class&lt;T&gt; clazz) throws SQLException &#123; return toDomain(toMap(rset), clazz); &#125; /** List&lt;Map&lt;String, String&gt;&gt; -&gt; DBResultSet */ public static DBResultSet toResultSet(List&lt;Map&lt;String, Object&gt;&gt; rows) throws SQLException &#123; Set&lt;String&gt; columnNames = rows.get(0).keySet(); EditableResultSet ers = new EditableResultSet(columnNames.toArray(new String[0])); for(Map&lt;String, Object&gt; row : rows) &#123; ers.absolute(ers.addRow()); for(String columnName : columnNames) &#123; ers.setValue(columnName, row.get(columnName)); &#125; &#125; return ers; &#125; /** List&lt;T&gt; -&gt; DBResultSet */ public static &lt;T&gt; DBResultSet parseResultSet(List&lt;T&gt; rows) throws SQLException &#123; return toResultSet(toMap(rows)); &#125; /** List&lt;T&gt; -&gt; List&lt;Map&lt;String, String&gt;&gt; */ @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; List&lt;Map&lt;String, Object&gt;&gt; toMap(List&lt;T&gt; rows) &#123; List&lt;Map&lt;String, Object&gt;&gt; maps = new ArrayList&lt;&gt;(); for(T row : rows) &#123; maps.add(new ObjectMapper().convertValue(row, Map.class)); &#125; return maps; &#125;&#125; 주제. 리플렉션12345678910111213141516171819public static &lt;T extends AirLine&gt; AirLine create(String airline) throws Exception &#123; Class&lt;T&gt; clazz = (Class&lt;T&gt;) Class.forName(&quot;com.air.interpark.ariLine.AirLine&quot; + airline); Class[] classArgs = &#123;&#125;; Constructor&lt;T&gt; constructor = clazz.getDeclaredConstructor(classArgs); return constructor.newInstance();&#125;public static AirLine createRaw(String airline) throws Exception &#123; Class clazz = Class.forName(&quot;com.air.interpark.ariLine.AirLine&quot; + airline); Class[] classArgs = &#123;&#125;; Constructor constructor = clazz.getDeclaredConstructor(classArgs); return (AirLine) constructor.newInstance();&#125; 주제 Spring AOPSpring boot 안쓰고 Spring 으로 할경우 Dependencies 추가해줘야함. 12compile group: &#x27;org.aspectj&#x27;, name: &#x27;aspectjrt&#x27;, version: &#x27;1.9.2&#x27;compile group: &#x27;org.aspectj&#x27;, name: &#x27;aspectjweaver&#x27;, version: &#x27;1.9.2&#x27; 아래와 같이 Aspect 소스를 짰음 123456789101112131415161718import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.springframework.stereotype.Component;@Slf4j@Component@Aspectpublic class AirlineLog &#123; @Around(&quot;within(com.air.interpark.ariLine.common.*)&quot;) public Object loggerAop(ProceedingJoinPoint joinPoint) throws Throwable &#123; log.info(&quot;It&#x27;s loggerAop&quot;); return joinPoint.proceed(); &#125;&#125; 어드바이스 종류는 대따 많음 Around 어드바이스 타겟의 메서드가 호출되기 이전(before) 시점과 이후 (after) 시점에 모두 처리해야 할 필요가 잇는 부가기능을 정의한다. -&gt; Joinpoint 앞과 뒤에서 실행되는 Advice Before 어드바이스 타겟의 메서드가 실행되기 이전(before) 시점에 처리해야 할 필요가 있는 부가기능을 정의한다. -&gt; Jointpoint 앞에서 실행되는 Advice After Returning 어드바이스 타겟의 메서드가 정상적으로 실행된 이후(after) 시점에 처리해야 할 필요가 있는 부가기능을 정의한다. -&gt; Jointpoint 메서드 호출이 정상적으로 종료된 뒤에 실행되는 Advice After Throwing 어드바이스 타겟의 메서드가 예외를 발생된 이후(after) 시점에 처리해야 할 필요가 있는 부가기능을 정의한다. -&gt; 예외가 던져 질때 실행되는 Advice 조인포인트를 어노테이션으로도 줄수 있음 @EnableAspectJAutoProxy-&gt; ProxyTargetClass-&gt; joinPoint.getArgs() 이걸로 타켓 메소드에 들어가는 parameter 정보를 가져올 수 있다. pointjoint 할때 쓰는 expression 들도 알아야 할듯 리플렉션하는 소스를 스테이틱이 아닌 스프링 빈을 활용한 싱글톤 형태로 구현하면.리플렉션시 빈을 주입받지 못하는 오류를 해결할 수 있다. 주제. AOP 기본적인 로깅 중복되는 로깅 소스 발견 -&gt; 새로운 로깅 객체 생성 하여 콜 비지니스 로직에 새로운 로깅 객체를 계속 콜하는 소스가 발견 -&gt; 메인 비지니스 소스에는 로깅 같은 소스를 안넣었으면 좋겟음. -&gt; proxy 패턴 사용 인터페이스를 활용한 proxy 패턴 확장 Spring AOP 활용. Annotation 활용한 AOP Spring AOP + custom annotation + SpEL 주제. Annotation12345678910111213package reflection;import java.lang.annotation.Retention;import static java.lang.annotation.RetentionPolicy.RUNTIME;/** * 어노테이션 정의 */@Retention(RUNTIME)public @interface Check &#123; String value();&#125; 123456789101112131415package reflection;/** * 조작 대상 클래스 */@Check(&quot;클래스에 부여&quot;)public class AnnotationSample &#123; @Check(&quot;메소드에 부여&quot;) public void print(@Check(&quot;인수에 부여&quot;) String message) &#123; System.out.println(message); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package reflection;import java.lang.annotation.Annotation;import java.lang.reflect.Method;public class AnnotationMainSample &#123; public static void main(String[] args) throws NoSuchMethodException &#123; Class&lt;AnnotationSample&gt; clazz = AnnotationSample.class; ///////////////////////////////////////////////////////////////////////////// // 클래스에 부여한 @Check를 얻기 ///////////////////////////////////////////////////////////////////////////// &#123; Check check = clazz.getAnnotation(Check.class); System.out.println(check); System.out.println(check.value()); &#125; ///////////////////////////////////////////////////////////////////////////// // 메소드에 부여한 @Check를 얻기 ///////////////////////////////////////////////////////////////////////////// Method method = clazz.getMethod(&quot;print&quot;, String.class); // @Check가 부여되어 있는 경우 if (method.isAnnotationPresent(Check.class)) &#123; Check check = method.getAnnotation(Check.class); System.out.println(check); System.out.println(check.value()); &#125; ///////////////////////////////////////////////////////////////////////////// // 인수에 부여한 @Check를 얻기 ///////////////////////////////////////////////////////////////////////////// for (Annotation[] params : method.getParameterAnnotations()) &#123; for (Annotation annotation : params) &#123; Check check = (Check) annotation; System.out.println(check); System.out.println(check.value()); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031import java.lang.annotation.*;@Inherited@Documented@Retention(RetentionPolicy.RUNTIME) // 컴파일 이후에도 JVM에 의해서 참조가 가능합니다.//@Retention(RetentionPolicy.CLASS) // 컴파일러가 클래스를 참조할 때까지 유효합니다.//@Retention(RetentionPolicy.SOURCE) // 어노테이션 정보는 컴파일 이후 없어집니다.@Target(&#123; ElementType.PACKAGE, // 패키지 선언시 ElementType.TYPE, // 타입 선언시 ElementType.CONSTRUCTOR, // 생성자 선언시 ElementType.FIELD, // 멤버 변수 선언시 ElementType.METHOD, // 메소드 선언시 ElementType.ANNOTATION_TYPE, // 어노테이션 타입 선언시 ElementType.LOCAL_VARIABLE, // 지역 변수 선언시 ElementType.PARAMETER, // 매개 변수 선언시 ElementType.TYPE_PARAMETER, // 매개 변수 타입 선언시 ElementType.TYPE_USE // 타입 사용시&#125;)public @interface MyAnnotation &#123; /* enum 타입을 선언할 수 있습니다. */ public enum Quality &#123;BAD, GOOD, VERYGOOD&#125; /* String은 기본 자료형은 아니지만 사용 가능합니다. */ String value(); /* 배열 형태로도 사용할 수 있습니다. */ int[] values(); /* enum 형태를 사용하는 방법입니다. */ Quality quality() default Quality.GOOD;&#125; 위와같이 다양한 형태의 값을 넣을 수 있음 12345678910111213141516171819202122232425262728@Around(value = &quot;@annotation(domActionLog)&quot;) public Object domActionLogging(ProceedingJoinPoint joinPoint, DomActionLog domActionLog) throws Throwable &#123; log.info(domActionLog.toString()); log.info(&quot;REQ : &quot; + Arrays.toString(joinPoint.getArgs())); Class&lt;AirlineRS&gt; clazz = AirlineRS.class; Method method = clazz.getMethod(&quot;pnrStatus&quot;, PnrStatus.Req.class); if(method.isAnnotationPresent(DomActionLog.class)) &#123; DomActionLog annotation = method.getAnnotation(DomActionLog.class); System.out.println(annotation); System.out.println(annotation.prId()); System.out.println(annotation.pnr1()); &#125; Object obj = null; try &#123; obj = joinPoint.proceed(); log.info(&quot;RES : &quot; + obj.toString()); &#125; catch (Exception e) &#123; log.info(&quot;RES : &quot; + e.toString()); &#125; return obj; &#125; DomActionLog 부분을 Around annotation 이름과 맞추면 파라미터로 받을 수 있다. 내가 만들어둔 소스 dependencies 12compile group: &#x27;org.aspectj&#x27;, name: &#x27;aspectjrt&#x27;, version: &#x27;1.9.2&#x27;compile group: &#x27;org.aspectj&#x27;, name: &#x27;aspectjweaver&#x27;, version: &#x27;1.9.2&#x27; config (It should be turned on @EnableAspectJAutoProxy with proxyTargetClass = true option) 12345678910@Configuration@EnableWebMvc // &lt;annotation-driven /&gt;@EnableAspectJAutoProxy(proxyTargetClass = true)@ComponentScan(basePackages = &#123; &quot;com.air.*&quot; &#125;)@Slf4jpublic class WebConfig extends WebMvcConfigurerAdapter&#123; ...&#125; annotation 12345678910111213import java.lang.annotation.*;@Documented@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface DomActionLog &#123; String prId(); String pnr1(); String param() default &quot;&quot;;&#125; Aspect Source 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.expression.ExpressionParser;import org.springframework.expression.spel.standard.SpelExpressionParser;import org.springframework.expression.spel.support.StandardEvaluationContext;import org.springframework.stereotype.Component;import java.lang.reflect.Method;@Slf4j@Aspect@Componentpublic class CommonAspect &#123; @Around(value = &quot;@annotation(DomActionLog)&quot;) public Object domActionLogging(ProceedingJoinPoint joinPoint) throws Throwable &#123; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); DomActionLog annotation = method.getAnnotation(DomActionLog.class); Object pnr1 = getDynamicValue(signature.getParameterNames(), joinPoint.getArgs(), annotation.pnr1()); Object prId = getDynamicValue(signature.getParameterNames(), joinPoint.getArgs(), annotation.prId()); Object result = joinPoint.proceed(); return result; &#125; public static Object getDynamicValue(String[] parameterNames, Object[] args, String key) &#123; ExpressionParser parser = new SpelExpressionParser(); StandardEvaluationContext context = new StandardEvaluationContext(); for(int i$=0; i$&lt; parameterNames.length; i$++) &#123; context.setVariable(parameterNames[i$], args[i$]); &#125; return parser.parseExpression(key).getValue(context, Object.class); &#125;&#125; target source 123456789101112131415161718192021222324252627282930313233@Override@DomActionLog(prId = &quot;#req.prId&quot;, pnr1 = &quot;#req.pnr1&quot;)public PnrStatus.Res pnrStatus(PnrStatus.Req req) throws Exception &#123; /* 필수 파라미터 확인 */ if(req == null || StringUtils.isEmpty(req.getPnr1())) &#123; throw new Exception(&quot;파라미터 &#x27;pnr1&#x27; 정보가 null 이거나 공백입니다&quot;); &#125; /* 리트리브 */ RetrieveDetail retrieveDetail = (RetrieveDetail) jaxb.unMarshall(RetrieveDetail.class, airLineGateway.call( AirLineGateway.ServiceUrl.RETRIEVE.name(), airLineRQBuilder.retrieveRQBuilder(new PassengerRecordVO(req.getPnr1(), &quot;-1&quot;, req.getAirline()), &quot;&quot;), req.getAirline() ) ); /* 취소 리트리브 */ List&lt;RetrieveResult&gt; retrieveResults = new ArrayList&lt;&gt;(); for(String ticketNo : this.ticketNos(retrieveDetail)) &#123; retrieveResults.add((RetrieveResult) jaxb.unMarshall(RetrieveResult.class, airLineGateway.call( AirLineGateway.ServiceUrl.TICKET_RETRIEVE.name(), airLineRQBuilder.ticketDetailRetrieve(req.getPnr1(), &quot;&quot;, req.getAirline(), Collections.singletonList(ticketNo)), req.getAirline() ) )); &#125; return this.pnrStatus(retrieveResults);&#125; Test code 123456@Testpublic void run() throws Exception &#123; PnrStatus.Res res = airlineRS.pnrStatus(new PnrStatus.Req.Builder().airline(&quot;RS&quot;).prId(&quot;50001234&quot;).pnr1(&quot;JR85F&quot;).build());&#125; 예외처리3가지 형태의 케이스가 존재한다. 정상적인 경우-&gt; 소스를 짤때 일반적으로 이 부분에 몰두를 하고 작업을 한다. 처리가 가능한 예외가 발생한 경우-&gt; 보완로직을 수행하도록 분기한다. 처리가 불가능한 예외가 발생한 경우-&gt; 상세 에러 메시지를 포함하여 Exception을 던진다. null 체크할때 마지막애는 필수로 안해도된다 주제. JPA Tree Structure 매핑하기객체의 구조가 트리구조일때 이걸 엔티티로 어떻게 매핑?? 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.kidongyun.bridge.api.vo;import lombok.Getter;import lombok.Setter;import lombok.extern.slf4j.Slf4j;import java.util.ArrayList;import java.util.List;import java.util.Set;import java.util.function.Predicate;@Slf4j@Getter@Setterpublic class TreeNode&lt;T&gt; &#123; private T data; private TreeNode&lt;T&gt; parent; private List&lt;TreeNode&lt;T&gt;&gt; children; public TreeNode() &#123; children = new ArrayList&lt;&gt;(); &#125; public List&lt;T&gt; traversal() &#123; return dfs(this, new ArrayList&lt;&gt;()); &#125; public void addChild(T data) &#123; children.add(new TreeNode.Builder&lt;T&gt;().data(data).parent(this).build()); &#125; public void removeChild(Predicate&lt;T&gt; condition) &#123; List&lt;TreeNode&lt;T&gt;&gt; result = new ArrayList&lt;&gt;(); for(TreeNode&lt;T&gt; child : children) &#123; if(condition.test(child.data)) &#123; continue; &#125; result.add(child); &#125; this.setChildren(result); &#125; private List&lt;T&gt; dfs(TreeNode&lt;T&gt; treeNode, List&lt;T&gt; dataList) &#123; dataList.add(treeNode.data); for(TreeNode&lt;T&gt; child : treeNode.children) &#123; child.dfs(child, dataList); &#125; return dataList; &#125; public TreeNode&lt;T&gt; of(Set&lt;T&gt; set) &#123; return new TreeNode.Builder&lt;T&gt;().build(); &#125; @Override public String toString() &#123; return data.toString(); &#125; public static class Builder&lt;T&gt; &#123; private final TreeNode&lt;T&gt; treeNode; public Builder() &#123; this.treeNode = new TreeNode&lt;&gt;(); &#125; public Builder&lt;T&gt; data(T val) &#123; this.treeNode.data = val; return this; &#125; public Builder&lt;T&gt; parent(TreeNode&lt;T&gt; val) &#123; this.treeNode.parent = val; return this; &#125; public Builder&lt;T&gt; children(List&lt;TreeNode&lt;T&gt;&gt; val) &#123; this.treeNode.children = val; return this; &#125; public TreeNode&lt;T&gt; build() &#123; return this.treeNode; &#125; &#125;&#125; lombok@Builder.Default @Builder @SuperBuilder @ToString(callSuper) 주제Jackson 의존성 주입시 스프링 부트에서 버전관리를 해주끼 때문에 굳이 버저닝 하지 말자.했다가 스프링이랑 버전안맞아서 골치 아프다. 예외처리컨트롤러쪽과 서비스쪽의 예외처리 방식이 조금은 달라야할 것 같다. 둘다 모두 paramter, response 강경하게 예외 처리를 했더니. 서비스쪽에서 이 예외처리한 코드 때문에 컨트롤러가 유연하게 해당 서비스를 사용하지 못하는 케이스가 발생한다. 그래서 다시 정리한 내용은 우선 parameter, response 이 들이 예외처리를 해야하는 포인트인 것은 맞다. 다만 그렇다면 이것을 모두 한 함수 범위 내에서 검증을 해야하는가 에 대한 질문은 아니다로 바뀌었다. 컨트롤러는 스프링에서 엔드포인트이기 때문에 모두 검증을 하는것이 맞지만. 서비스쪽에서는 유연성을 보다 가지게 하기 위해서. paramter 검증을 하되 예외가 발생했을시 exception을 던지지말고 null 객체가 반환되게끔 return 하는 구조를 가지도록 하고 response 검증은 컨트롤러쪽에서 할수 있도록 null을 포함한 객체로 내려주자. 12345678910111213컨트롤러 parameter 검증 : 강경하게 모두 해야함 response 검증 : 강경하게 모두 해야함서비스 parameter 검증 : 검증을 하지만 문제가 있을경우 null을 반환 response 검증 : 검증하지 않고 컨트롤러에게 넘김null을 반환하는 종류(1) 단일 객체를 반환하는 함수 : Optional 을 사용하여 Optional.empty() 반환(2) Collection 객체를 반환하는 함수 : 해당 컬렉션의 빈 객체를 반환 ex) Set.of();(3) void 인 함수 : Exception을 던진다. React.Hook123456789101112131415161718useEffect(() =&gt; &#123; if(selectCell instanceof Objective &amp;&amp; selectCell.type === &quot;OBJECTIVE&quot;) &#123; postOrPut = &quot;PUT&quot;; setObjective(selectCell); if(selectCell.endDateTime === undefined) &#123; return; &#125; const deadline: string = selectCell.endDateTime.toISOString(); setYear(deadline.substring(0, 4)); setMonth(deadline.substring(5, 7)); setDate(deadline.substring(8, 10)); console.log(postOrPut); &#125;&#125;, [selectCell]); useEffect에 두번째 인자로 들어로는 배열에 값을 넣으면, 해당 값들이 변화가 생길때 useEffect() 첫번째 인자로 넣은 함수가 호출된다. WebMvcTest 슬라이스 테스트할떄 Spring Security 적용 안하기1234567891011@Slf4j@RunWith(SpringRunner.class)@WebMvcTest(controllers = ObjectiveController.class, excludeAutoConfiguration = SecurityAutoConfiguration.class)public class ObjectiveControllerTest &#123; @MockBean private SecurityConfig securityConfigMock; @MockBean private TokenProvider tokenProviderMock;&#125; JPA @Enumerated 애노테이션STRING으로 지정하면 “MALE”, “FEMALE” 문자열 자체가 저장된다. Gender에 선언되어 있는 순서가 값이 되기 때문에 2가 DB에 저장된다. Enum 기반의 객체를 QueryDSL로 쿼리를 날리면 타입이 안맞는 오류가 계속 뜨는데 이거 해결해야함.. maven12345&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt; 이거는 depencency에 넣으면 안댄다. 버전 관리가 안되서 unknown 뜬다. intellij 는 초기 설정시에 openjdk를 다운받아서 자동으로 설정해서 사용한다.이거를 환경변수로 등록해두어야 mvn 을 cli로 돌릴때 오류가 안생긴다. openjdk 경로를 확인하려면 maven install을 돌려보면 console 창에 java가 실행되는 경로가 나오는데 해당 경로 가지고 환경변수 등록한다. maven cli 에서 테스트를 스킵하고 jar 생성하려면 아래 명령어 추가 입력1mvn package -DskipTests 명령어 스킵하는 설정을 프로젝트의 디폴트로 가져가려면 아래 빌드 의존성을 추가하고 옵션을 추가 1234567&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt;&lt;/plugin&gt; Optional 에서 orElse() 함수의 페이크이름이 조건이 해당하지 않으면 실행되지 않을 것 같이 생겼지만. 이 함수도 근본적으로 자바로 이루어진 함수이다.실행되고 그 내부적으로 비즈니스가 실행되지 않을 뿐이다. 실제로는 함수 자체는 실행된다. Array 먼저시작하는 json 객체 TypeReference 객체 안쓰고 쉽게 readvalue() 하는 방법1Arrays.asList(objectMapper.readValue(response, Plan[].class)); Maven 프로젝트 임포트시 Class 객체를 인지를 못하고 Java 파일로 머물러 있을 때maven 프로젝트의 소스는 기본적으로 src &gt; main &gt; java 폴더 안 부터 패키지로 인정이 된다.해당 디렉토리를 생성해주고 그다음에 java 폴더를 src 디렉토리로 마킹해주자. Jwt DatatypeConverter 관련 오류가 발생시 아래 의존성이 있는지 확인Spring Security 프레임워크와 JsonWebToken 을 이용해 웹인증을 구현하는 도중, 로그인을 시도해서 서버로부터 토큰을 얻으려고 할때, 웹서버 로그에 다음과 같은 에러가 발생했습니다 java.lang.NoClassDefFoundError: Could not initialize class javax.xml.bind.DatatypeConverterImpl 오류 로그를 자세하게 읽어보고, 관련하여 코딩한 컨트롤러와 클래스들을 살펴보아도 문제가 없는 것 같아서 구글링했습니다. (stackoverflow.com/questions/55606519/getting-exception-java-lang-noclassdeffounderror-could-not-initialize-class-jav) 위 링크에서 답변한 솔루션을 참고하여 저같은 경우는 다음과 같은 종속성을 pom.xml 에 추가하여 해결하였습니다. 12345&lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt;&lt;/dependency&gt; 위 종속성을 추가하니, 서버에서 정상적으로 토큰을 반환했습니다. 궁금한 내용은 댓글 남겨주세요!","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"}]},{"title":"Mobx","slug":"2020-11-17-mobx","date":"2020-11-16T15:54:00.000Z","updated":"2022-05-31T07:19:53.000Z","comments":true,"path":"2020/11/17/","link":"","permalink":"http://kidongyun.github.io/2020/11/17/","excerpt":"","text":"123456789import &#123; observable, reaction, computed, autorun &#125; from &#x27;mobx&#x27;;/** You can create the observable state using observable object. */const calculator = observable(&#123; a: 1, b: 2&#125;); The observable state can know the timing when some their values are changed. 12345678910111213141516171819202122232425import &#123; observable, reaction, computed, autorun &#125; from &#x27;mobx&#x27;;const calculator = observable(&#123; a: 1, b: 2&#125;);reaction( () =&gt; calculator.a, (value, reaction) =&gt; &#123; console.log(`a is changed to $&#123;value&#125;`); &#125; );reaction( () =&gt; calculator.b, (value, reaction) =&gt; &#123; console.log(`b is changed to $&#123;value&#125;`); &#125;)calculator.a = 10; /** first reaction is occured. */calculator.b = 20; /** the second one is occured. */ reaction() function have a two parameters, The first one is the function signature, which the result of it is the value is changed.and the second one is callback function is occured when the value is changed. and this callback function have a value is changed. 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; observable, reaction, computed, autorun &#125; from &#x27;mobx&#x27;;const calculator = observable(&#123; a: 1, b: 2&#125;);reaction( () =&gt; calculator.a, (value, reaction) =&gt; &#123; console.log(`a is changed to $&#123;value&#125;`); &#125; );reaction( () =&gt; calculator.b, (value, reaction) =&gt; &#123; console.log(`b is changed to $&#123;value&#125;`); &#125;)/** It&#x27;s like a cache */const sum = computed(() =&gt; &#123; console.log(&quot;I am calculating.&quot;); return calculator.a + calculator.b;&#125;);/** sum observe whether two calculator values are changed or not and It will re-calculate itself if they are changed. */sum.observe(() =&gt; calculator.a);sum.observe(() =&gt; calculator.b);/** sum is re-calculating with these code. */calculator.a = 10;calculator.b = 20;/** It&#x27;s not happen */console.log(sum.value);console.log(sum.value); 123456789101112131415161718192021222324252627282930import &#123; decorate, observable, computed, autorun &#125; from &#x27;mobx&#x27;class GS25 &#123; basket = []; get total() &#123; console.log(&quot;I am calculating...&quot;); return this.basket.reduce((prev, curr) =&gt; prev + curr.price, 0); &#125; select(name, price) &#123; this.basket.push(&#123; name, price &#125;) &#125;&#125;decorate(GS25, &#123; basket: observable, total: computed&#125;);const gs25 = new GS25();autorun(() =&gt; gs25.total);gs25.select(&#x27;물&#x27;, 800);console.log(gs25.total);gs25.select(&#x27;물&#x27;, 800);console.log(gs25.total);gs25.select(&#x27;포카칩&#x27;, 1500);console.log(gs25.total); 12345678910111213141516171819202122232425262728293031import &#123; decorate, observable, computed, autorun, action &#125; from &#x27;mobx&#x27;class GS25 &#123; basket = []; get total() &#123; console.log(&quot;I am calculating...&quot;); return this.basket.reduce((prev, curr) =&gt; prev + curr.price, 0); &#125; select(name, price) &#123; this.basket.push(&#123; name, price &#125;) &#125;&#125;decorate(GS25, &#123; basket: observable, total: computed, select: action&#125;);const gs25 = new GS25();autorun(() =&gt; gs25.total);gs25.select(&#x27;물&#x27;, 800);console.log(gs25.total);gs25.select(&#x27;물&#x27;, 800);console.log(gs25.total);gs25.select(&#x27;포카칩&#x27;, 1500);console.log(gs25.total); Let’s use the decorator syntax. 12345678910111213141516171819202122232425262728293031323334import &#123; observable, computed, autorun, action, transaction &#125; from &#x27;mobx&#x27;;class GS25 &#123; @observable basket = []; @computed get total() &#123; console.log(&#x27;I am calculating...&#x27;); return this.basket.reduce((prev, curr) =&gt; prev + curr.price, 0); &#125; @action select(name, price) &#123; this.basket.push(&#123; name, price &#125;); &#125;&#125;const gs25 = new GS25();autorun(() =&gt; gs25.total);autorun(() =&gt; &#123; if(gs25.basket.length &gt; 0) &#123; console.log(gs25.basket[gs25.basket.length - 1]); &#125;&#125;);tansaction(() =&gt; &#123; gs25.select(&#x27;물&#x27;, 800); gs25.select(&#x27;물&#x27;, 800); gs25.select(&#x27;포카칩&#x27;, 1500);&#125;);console.log(gs25.total);","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"React - Mobx","slug":"React-Mobx","permalink":"http://kidongyun.github.io/tags/React-Mobx/"}]},{"title":"Java 기반의 객체지향 프로그래밍에 대한 고찰","slug":"2020-11-12-java-oop-basic","date":"2020-11-12T02:38:54.000Z","updated":"2022-05-31T07:19:44.000Z","comments":true,"path":"2020/11/12/","link":"","permalink":"http://kidongyun.github.io/2020/11/12/","excerpt":"","text":"클래스와 인스턴스의 개념객체지향 프로그래밍 관점에서 이 세상에 존재하는 모든 것들은 속성와 동작으로 이루어져 있다고 한다. 속성은 특정 사물이 지니고 있는 고유의 정보를 의미하고 동작이란 특정 사물들이 주체로써 행하는 모든 것들을 의미한다. 한 예시로 사람이라는 객체가 있다고 하면 이 사람의 이름, 키, 나이와 같은 정보들은 이 객체의 속성이 될 수 있으며, 이 사람이 밥을 먹고, 걷고, 말을 하는 행위들은 동작으로 볼 수 있다. 1객체 = 속성 + 동작 객체지향 프로그래밍 언어에서는 이 객체라는 것을 그려내기 위해 클래스, 인스턴스라는 두 가지 개념이 존재한다. 클래스는 객체의 필수 구성 요소인 속성과 동작을 활용해 프로그래밍 세계에서 객체를 만들기 위한 도구이며, ‘class’ 키워드를 활용해 나타낼 수 있다. 클래스에서 사용하는 용어가 실제 객체와는 약간 다른데 주로 속성은 필드라는 이름으로 불리고 동작은 메서드라는 이름으로 부른다. 개념 자체는 동일하다. 1클래스 = 필드 + 메서드 이 클래스를 통해서 만들어진 실제 객체를 프로그래밍 세계에서는 인스턴스라고 부른다. 인스턴스는 ‘new’ 키워드를 통해서 생성되어진다. ‘new’ 키워드를 활용해서 동일한 클래스를 여러번 호출하면 동일한 객체가 여러 개 생성될 수 있다. 1234567891011121314151617181920212223242526272829/* &#x27;class&#x27; 키워드를 통해서 객체를 표현할 수 있다. */class Person &#123; /* 필드 */ String name; float height; int age; /* 메서드 */ void eat(); void walk(); String talk() &#123; return &quot;제 이름은 &quot; + name + &quot; 이고, 키는 &quot; + height + &quot; 이고, 나이는 &quot; + age + &quot; 입니다. &quot;; &#125;;&#125;class Main &#123; public static void main(String[] args) &#123; /* &#x27;new&#x27; 키워드를 통해서 인스턴스를 생성한다. */ Person person = new Person(); person.name = &quot;john&quot;; person.height = 180.2; person.age = 31; System.out.println(person.talk()); &#125;&#125; 패키지의 개념기본적으로 패키지는 파일 시스템의 디렉토리의 개념과 유사하다고 보면 된다. 한 디렉토리 내에서는 동일한 이름을 가진 파일을 중복 생성할 수 없고 다른 디렉토리에서는 가능하듯이 자바파일도 한 패키지에서는 중복되는 이름을 가진 파일을 만들 수 없지만. 다른 패키지에서는 가능하다. 실무의 관점에서 패키지 경로에는 보통 특정 소스코드를 개발한 회사, 해당 프로젝트의 이름 등이 들어가는데. 이를 통해 각 코드의 출처를 구분지을 수 있다. 123456789101112131415161718192021222324252627282930313233package team1;public class Circle &#123; final double PI = 3.14; double rad; public void setRad(double r) &#123; rad = r; &#125; // 원의 넓이 반환 public double getArea() &#123; return (rad * rad) * PI; &#125;&#125;package team2;public class Circle &#123; final double PI = 3.14; double rad; public void setRad(double r) &#123; rad = r; &#125; // 원의 둘레 반환 public double getPerimeter() &#123; return (rad * 2) * PI; &#125;&#125; 동일하게 Circle.java 파일을 각각 team1, team2 패키지에 만들었다. 다른 패키지에 생성했음으로 이 둘다 정상 작동할 것이다. 1234567891011121314151617181920212223242526272829public class A_CircleUsing &#123; public static void main(String[] args) &#123; team1.Circle c1 = new team1.Circle(); c1.setRad(3.5); System.out.println(&quot;반지름 3.5 원 넓이: &quot; + c1.getArea()); team2.Circle c2 = new team2.Circle(); c2.setRad(3.5); System.out.println(&quot;반지름 3.5 원 둘레: &quot; + c2.getPerimeter()); &#125;&#125;import team1.Circle;import team2.Circle;public class A_CircleUsing &#123; public static void main(String[] args) &#123; Circle c1 = new team1.Circle(); c1.setRad(3.5); System.out.println(&quot;반지름 3.5 원 넓이: &quot; + c1.getArea()); Circle c2 = new team2.Circle(); c2.setRad(3.5); System.out.println(&quot;반지름 3.5 원 둘레: &quot; + c2.getPerimeter()); &#125;&#125; 사용하는 자바파일에서 중복되는 이름이 없으면 ‘import’ 키워드를 사용해서 패키지 경로를 생략할 수 있지만. 중복되는 경우는 사용하는 자바가 어떤 Circle을 요구하는지 인지하지 못 함으로 패키지 경로까지 입력해줘야 한다. 오버로딩의 개념오버로딩이란 하나의 클래스 내부에 함수의 시그니처는 다르지만 함수의 이름이 같은 메서드를 여러 개 정의하는 방법이다.아래는 덧셈의 기능을 가지고 있는 계산기 객체인데 덧셈 시 들어로는 파라미터의 타입 별로 add() 함수를 오버로딩 하였다. 12345678910111213141516171819202122232425class Calc &#123; int add(int a, int b) &#123; return a + b; &#125; int add(int a) &#123; return a + 1; &#125; double add(double a, double b) &#123; return a + b; &#125;&#125;public class calculation &#123; public static void main(String[] args) &#123; Calc calc = new Calc(); calc.add(3, 9); calc.add(3); calc.add(3.0, 9.0); &#125;&#125; 생성자의 개념생성자란 인스턴스 생성과 함께 자동적으로 호출되는 특수한 메서드. ‘new’ 키워드를 통해 인스턴스를 만들게 되면 필요한 전처리 작업을 이 곳에서 수행할 수 있다. 생성자를 명시하지 않는 경우에는 인수가 없는 디폴트 생성자가 자동으로 만들어진다. 생성자는 일반 함수와 조금은 다른 특성을 가지고 있는데 우선 메서드와 같은 모양이지만 반환형이 없고 클래스의 이름과 동일한 이름을 가진다. 개발자가 매개 변수가 잇는 생성자를 만든 경우 아무런 파라미터가 없는 디폴트 생성자를 호출하면 에러가 발생한다.이 경우 매개 변수가 없는 디폴트 생성자를 호출하기 위해서는 디폴트 생성자도 같이 구현해 주어야 한다. 1234567891011121314151617181920212223242526272829303132333435package step1;class Book &#123; String title; int price; int num; Book() &#123; title = &quot;자바 클래스 기초&quot;; price = 10000; &#125; Book(String title, int price) &#123; this.title = title; this.price = price; &#125; void print() &#123; System.out.println(&quot;제목 : &quot; + title); System.out.println(&quot;가격 : &quot; + price); System.out.println(&quot;주문수량 : &quot; + num); System.out.println(&quot;합계금액 : &quot; + price * num); &#125;&#125;public class MyBook &#123; public static void main(String[] args) &#123; Book book = new Book(); Book book = new Book(&quot;자바 디자인 패턴&quot;, 20000); book.num = 5; book.print(); &#125;&#125; 메모리 모델의 개념JVM도 하나의 응용프로그램으로 동작하는 것으로 운영체제로부터 할당받은 메모리 공간을 기반으로 자바 프로그램을 실행한다.JVM은 운영체제로부터 할당받은 메모리 공간을 이용해서 자기 자신도 실행을 하고, 자바 프로그램도 실행을 하는데 이 메모리 공간을 이용할 때 공간 활용의 효율성을 높이기 위해서 메서드영역, 스택영역, 힙영역으로 구분하여 사용한다. 바이트코드 : 고급언어로 작성된 소스 코드를 가상머신이 이해할 수 있는 중간 코드로 컴팡리 된것을 말한다.가상머신은 이 바이트코드를 각각의 하드웨어 아키텍처에 맞는 기계어로 번역. 메서드영역 : 자바 바이트코드는 JVM이 구분하는 메모리 공간 중에서 메서드 영역에 저장된다.static 으로 선언된 클래스 변수도 메서드 영역에 저장된다. 이 영역에 저장된 내용은 프로그램 시작 전에 로드되고 프로그램 종료 시 소멸 된다. 스택 영역 : 매개변수와 지역변수가 할당되는 메모리 공간. 프로그램이 실행되는 도중에 임시로 할당되었다가 바로 이어서 소멸되는 특징이 있는 변수가 할당 된다. 이 영역에 저장되는 변수는 해당 변수가 선언된 메서드 종료 시 소멸된다. 힙 영역 : 사실 자바에서 가장 유별나고, 중요하게 알고있어야 하는 메모리 모델은 바로 이 영역이다. 위에서 ‘new’ 연산을 통해서 인스턴스를 생성할 수 있음을 배웠는데, 그러면 이 생성된 인스턴스는 어느 시점에 사라질까?. 당연하게도자바라는 언어도 컴퓨터의 자원을 활용하기 때문에 항상 인스턴스를 생성만 하고 제거를 하지 않는다면 메모리 영역이 꽉 차서 문제가 생길 것이다. 자바에는 가비지 컬렉터라는 요소가 존재한다. 이 녀석은 주기적으로 당신이 만든 프로그램을점검하며 사용하지 않는 객체가 있는지 없는지 확인한다. 그리고 사용하지 않는 객체라고 확신이 들면 이를 소멸시킨다. 그렇다면 가비지 컬렉터가 사용하지 않는 객체라고 확신하는 기준은 무엇일까. 일반적으로 참조변수에 의한 참조가 전혀 이뤄지지 않는 인스턴스가 소명의 대상이 된다. 참조관계가 끊어진 인스턴스는 유저가 접근할 방법이 없기 때문이다. 가비지 컬렉터의 발생 주기는 개발자가 확신을 할수 없다. JVM 내부적으로 임의의 동작에 의해서 발현되기 때문이다. 그렇기 때문에 특정 시점에 반드시 객체를 소멸시켜야 할때도 있는데 그럴 때는 아래와 같은 코드를 짜서 소멸시킬 수 있다. 1234567/* 가비지 컬렉터를 호출함 */System.gc();/* 가비지 컬렉터에 의해서 소멸이 결정된 인스턴스를 즉시 소멸 */System.runFinalization(); 접근제어지시자의 개념실무의 관점에서 접근제어지시자는 중요한 키워드이다. 이 것을 활용해 내가 만든 이 코드를 누구에게까지 사용하도록 할 것인지를 결정할 수 있다. 이 접근제어지시자는 클래스 앞에 사용되었을 떄와 필드, 메서드 앞에 사용되었을 때는 약간 다름으로 구분해서 확인해보자. 클래스에 지정되었을 때public 으로 선언하게 되면 이 클래스는 어느 곳에서든 인스턴스 생성이 가능하다. 그리고 아무런 접근제어시시자를 주지 않는 것을 default 라고 하는데 default 는 동일 패키지로 묶인 클래스 내에서만 인스턴스 생성을 허용한다. 인스턴스 멤버에 지정했을 때1234567지시자 클래스내부 동일패키지 상속받은클래스 이외의영역private O X X Xdefault O O X xprotected O O O Xpublic O O O O 123456789101112131415package team1;public class AnotherClass1 &#123; public int num1; private int num2; protected int num3; int num4; public void test1() &#123; System.out.println(&quot;test1&quot;); &#125; private void test1() &#123; System.out.println(&quot;test2&quot;); &#125; protected void test1() &#123; System.out.println(&quot;test3&quot;); &#125; void test1() &#123; System.out.println(&quot;test4&quot;); &#125;&#125; 123456789101112131415package team2;public class AnotherClass2 &#123; public int num1; private int num2; protected int num3; int num4; public void test1() &#123; System.out.println(&quot;test1&quot;); &#125; private void test1() &#123; System.out.println(&quot;test2&quot;); &#125; protected void test1() &#123; System.out.println(&quot;test3&quot;); &#125; void test1() &#123; System.out.println(&quot;test4&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334public class AccessTest &#123; public int num1; private int num2; protected int num3; int num4; public void test1() &#123; System.out.println(&quot;test1&quot;); &#125; private void test1() &#123; System.out.println(&quot;test2&quot;); &#125; protected void test1() &#123; System.out.println(&quot;test3&quot;); &#125; void test1() &#123; System.out.println(&quot;test4&quot;); &#125; public static void main(String[] args) &#123; /* 같은 클래스이기 때문에 모두 접근이 가능함 */ AccessTest at = new AccessTest(); at.num1 = 1; at.num2 = 2; at.num3 = 3; at.num4 = 4; AnotherClass1 ac1 = new AnotherClass1(); ac1.num1 = 1; ac1.num2 = 2; // private 이기 때문에 접근 불가능 ac1.num3 = 3; ac1.num4 = 4; AnotherClass2 ac2 = new AnotherClass2(); ac2.num1 = 1; ac2.num2 = 2; // private 접근 불가능. ac2.num3 = 3; // 다른 패키지 이기 때문에 접근 불가능. ac2.num4 = 4; // 다른 패키지 이기 때문에 접근 불가능. &#125;&#125; 상속의 개념객체지향에서 상속이라 함은 상위클래스의 모든 것이 하위클래스에게 전달되는 것을 뜻한다. 그러나 상위클래스의 멤버변수와 멤버함수 중, private 으로 접근제한이 된 경우에는 하위클래스로 전달이 되지 않는다. 상속의 활용성, 그 의미는 여기서 다루기에는 사실 쉽지 않다. 다음에 다른 글에서 확인하도록 하고 여기서는 문법만 확인하도록 하자. 상속받은 클래스 즉 서브클래스를 만들기 위해서는 ‘extends’를 사용한다. 자바에서 여러 개의 클래스를 동시에 상속하는 다중 상속은 허용되지 않는다. 12345678910111213141516171819202122232425262728293031323334353637383940414243class Book &#123; String title; void printBook() &#123; System.out.println(&quot;제목: &quot; + title); &#125;&#125;class Novel extends Book &#123; String writer; void printNov() &#123; printBook(); System.out.println(&quot;저자: &quot; + writer); &#125;&#125;class Magazine extends Book &#123; int day; void printMag() &#123; printBook(); System.out.println(&quot;발매일: &quot; + day + &quot;일&quot;); &#125;&#125;public class Booshelf &#123; public static void main(String[] args) &#123; Novel nov = new Novel(); nov.title = &quot;홍길돌전&quot;; nov.writer = &quot;허균&quot;; Magazine mag = new Magazine(); mag.title = &quot;월간 자바&quot;; mag.day = 20; nov.printNov(); System.out.println(); mag.printMag(); &#125;&#125; 오버라이딩의 개념오버라이딩이란 부모 메서드와 동일한 이름, 동일한 인수를 가지는 메서드를 정의하여 메서드를 덮어쓰는 것이다. 반환값의 형도 같아야만 한다.오버라이딩은 하위클래스에서 상속 받은 메서드를 단순 재사용 하지 않고 재정의하여 기능을 변경하거나 새로운 기능을 추가를 하고 싶을 때 사용한다. 즉 하위클래스에서 상위클래스의 특정 메서드를 다시 정의하는 것이다.오버라이딩은 많은 객체지향 디자인 패턴에 매우 자주 사용되는 기법이다. 오버라이딩은 추상 클래스와 합쳐져서 객체지향 방법론에서 장점으로 많이 거론되는 확장성을 실현하는 데 많은 도움을 주게 되므로, 이 개념은 필수적이다. 123456789101112131415161718192021222324252627282930class Animal &#123; String name; int age; void printPet() &#123; System.out.println(&quot;이름 : &quot; + name); System.out.println(&quot;나이 : &quot; + age); &#125;&#125;class Dog extends Animal &#123; String variety; void printPet() &#123; super.printPet(); System.out.println(&quot;종류 : &quot; + variety); &#125;&#125;public class Pet &#123; public static void main(String[] args) &#123; Dog dog = new Dog(); dog.name = &quot;진돌이&quot;; dog.age = 5; dog.variety = &quot;진돗개&quot; dong.printPet(); &#125;&#125; 추상 클래스의 개념추상 클래스는 추상메서드를 한 개라도 가지고 있으면 추상 클래스라고 한다. 그렇다면 추상 클래스는 뭘까? 함수의 실제 동작이 되는 내부 과정은 없고 함수 시그니처만을 정의한 메서드를 추상 메서드라고 한다. 추상 메서드와 추상 클래스는 abstract 키워드를 사용하여 다음과 같이 정의할 수 있다. 추가적으로 추상클래스를 상속하는 클래스는 추상메서드를 반드시 오버라이딩해서 구현해야 한다. 12345678910111213141516171819202122232425262728abstract class Animal &#123; int age; abstract void cry();&#125;class Dog extends Animal &#123; void cry() &#123; System.out.println(&quot;멍멍&quot;); &#125;&#125;class Cat extends Animal &#123; void cry() &#123; System.out.println(&quot;야옹&quot;); &#125;&#125;public class AbstractClassEx &#123; public static void main(String[] args) &#123; Dog dog = new Dog(); dog.cry(); Cat cat = new Cat(); cat.cry(); &#125;&#125; 인터페이스의 개념인터페이스는 함수 시그니처만 가지고 있는 추상 클래스라고 생각하면 쉽다.(자바 버전이 올라가면서 인터페이스도 구현체, 필드를 가질 수 있게 되었다. 여기서는 전통적인 인터페이스의 개념이다) 이렇게 모두 선언만 되어있고 실제로 구현된 것은 없기 때문에 이를 구현하는 서브 클래스들은 인터페이스에 선언되어 있는 함수들을 모두 구현하여야 한다. 클래스에서 인터페이스를 이용하도록 하게 하는 것을 ‘인터페이스의 구현’이라고 하고 이를 위해서는 ‘implements’ 키워드를 사용한다.인터페이스는 다중상속이 가능하다. 인터페이스는 복수의 인터페이스를 상속하여 새로운 인터페이스를 만들수 있다. 123456789101112131415161718192021222324252627interface Greet &#123; void greet();&#125;interface Bye &#123; void bye();&#125;class Morning implements Greet, Bye &#123; public void bye() &#123; System.out.println(&quot;안녕히 계세요.&quot;); &#125; public void greet() &#123; System.out.println(&quot;안녕하세요.&quot;); &#125;&#125;public class Meet &#123; public static void main(String[] args) &#123; Morning morning = new Morning(); morning.greet(); morning.bye(); &#125;&#125; 123456789101112131415161718192021222324252627interface Greet &#123; void greet();&#125;interface Bye extends Greet &#123; void bye();&#125;class Morning implements Bye &#123; public void bye() &#123; System.out.println(&quot;안녕히 계세요.&quot;); &#125; public void greet() &#123; System.out.println(&quot;안녕하세요.&quot;); &#125;&#125;public class Meet &#123; public static void main(String[] args) &#123; Morning morning = new Morning(); morning.greet(); morning.bye(); &#125;&#125; 다형성상속한 클래스의 오브젝트는 슈퍼 클래스로도 서브 클래스로도 다룰 수 있다. 이렇게 하나의 오브젝트와 메서드가 많은 형태를 가지고 있는 것을 다형성이라고 한다. 슈퍼 클래스의 오브젝트 생성 서브 클래스의 오브젝트는 슈퍼 클래스의 오브젝트에 대입할 수 있다. 상위 클래스의 객체를 하위 클래스의 객체로 대입할 수는 없다. Sub 클래스의 설계도를 바탕을 name 변수를 사용하면, 생성된 객체에는 해당 변수가 없어 에러가 발생하게 된다. 이러한 이유로 상위 클래스의 객체를 하위 클래스의 객체로 대입하는 것을 막고 있다. 123456789101112131415161718192021222324252627abstract class Calc &#123; int a = 5; int b = 6; abstract void plus();&#125;class Mycalc extends Calc &#123; void plus() &#123; System.out.println(a + b); &#125; void minus() &#123; System.out.println(a - b); &#125;&#125;public class Polymorphism1 &#123; public static void main(String[] args) &#123; Mycalc mycalc1 = new MyCalc(); myCalc1.plus(); myCalc1.minus(); Calc myCalc2 = new MyCalc(); myCalc2.plus(); myCalc2.minus(); // 에러 &#125;&#125; 1234567891011121314151617181920212223242526272829interface Printable &#123; void print(String doc);&#125;class PrnDrvSamsung implements Printable &#123; public void print(String doc) &#123; System.out.println(doc + &quot;\\nFrom Samsung : Black-White Ver&quot;); &#125;&#125;class PrnDrvEpson implements printable &#123; public void print(String doc) &#123; System.out.println(doc + &quot;\\nFrom Epson : Black-White Ver&quot;); &#125;&#125;public class Polymoriphism2 &#123; public static void main(String[] args) &#123; String doc = &quot;프린터로 출력을 합니다&quot;; Printable prn1 = new PrnDrvSamsung(); prn1.print(doc); Printable prn2 = new PrnDrvEpson(); prn2.print(doc); &#125;&#125; 어있고 이를 스택영역의 참조변수가 가리키고 있다. 슈퍼타입의 참조변수가 이 힙 영역의 서브 타입의 인스턴스를 가리키고 다형성을 이용한 클래스 간의 형 변환, 서브 클래스의 오브젝트는 슈퍼 클래스의 오브젝트에 대입할 수 있다. 힙 영역에 실제 인스턴스가 저장 되 있을 때 슈퍼 타입을 서브 타입의 참조변수로 형변환하고 이 서브타입의 참조변수로 같은 인스턴스를 가리키게 하면 단순히 인스턴스는 그대로이고 참조변수의 형만 변환되는거기 때문에 서브클래스만의 필드들을 접근할 수 있다. 123456789101112131415161718class PBoard &#123; &#125;class CBoard extends PBoard &#123; &#125;public class ClassCast &#123; public static void main(String[] args) &#123; PBoard sbd1 = new CBoard(); CBoard sbd2 = (CBoard) sbd1; System.out.println(&quot;------------------------&quot;); PBoard ebd11 = new PBoard(); CBoard ebd2 = (CBoard) ebd1; /* 이건 슈퍼클래스 인스턴스를 서브클래스의 참조변수로 가리키려고 하기때문에 오류. */ &#125;&#125; 은닉화의 개념객체의 변수를 public 으로 설정하면 외부에서 마음대로 이 변수를 사용할 수 있다. 의도하지 않은 범위의 값을 넣을 수 있다. 원하지 않는 데이터타입을 강제적으로 형변환하여 넣을 수도 있다. 원하지 않는 데이터 넣는것을 방지하기 위해 Java Beans 패턴 (Getter / Setter) 를 사용. 12345678910111213141516171819202122232425class SimpleBox &#123; private int num; SimpleBox(int num) &#123; this.num = num; &#125; public int getNum() &#123; return num; &#125; public void setnum(int num) &#123; this.num = num; &#125;&#125;public class ThisUseEx &#123; public static void main(String[] args) &#123; SimpleBox box = new SimpleBox(5); box.setNum(10); System.out.println(box.getNum()); &#125;&#125; instanceof 연산자‘instanceof’는 오브젝트가 지정한 클래스의 오브젝트인지를 조사하기 위한 연산자이다. 왼쪽 오브젝트가 오른쪽 클래스 또는 서브 클래스의 오브젝트라면 true. ‘instanceof’는 지정한 인터페이스를 오브젝트가 구현하고 있는지를 조사할 수도 있다. 왼쪽 오브젝트가 오른쪽 인터페이스를 구현하고 있으면 true. 1234567891011121314151617181920212223242526272829interface Cry &#123; void cry();&#125;class Cat implements Cry &#123; public void cry() &#123; System.out.println(&quot;야옹&quot;); &#125;&#125;class Dog implements Cry &#123; public void cry() &#123; system.out.println(&quot;멍멍&quot;); &#125;&#125;public class CheckCry &#123; public static void main(String[] args) &#123; Cry test1 = new Cat(); Cry test1 = new Dog(); if(test1 instanceof Cat) &#123; test1.cry(); &#125; else &#123; System.out.println(&quot;고양이가 아닙니다.&quot;); &#125; &#125;&#125; Class 클래스자바의 모든 클래스와 인터페이스는 컴파일 후 class 파일로 생성된다. class 파일에는 객체의 정보(멤버변수, 메서드, 생성자 등)가 포함되어 있음Class 클래스는 컴파일된 class 파일에서 객체의 정보를 가져올 수 있음.reflection 프로그래밍 : Class 클래스르 ㄹ이용하여 클래스의 정보를 가져오고 이를 활용하여 인스턴스를 생성하고, 메서드를 호출하는 등의 프로그래밍 방식 Class.forName() 메서드로 동적 로딩하기 프로그래밍 할 때는 어떤 클래스를 사용할지 모를때 변수로 처리하고, 실행될 때 해당 변수에 대입된 값의 클래스가 실행될 수 있도록 Class 클래스에서 제공하는 static 메서드 동적로딩이란 -&gt; 컴파일 시에 데이터타입이 모두 바인딩되어 자료형이 로딩되는 것이 아니라 실행중에 데이터 타입을 알고 바인딩 되는 방식컴파일 타임에 체크 할 수 없음으로 해당 문자열에 댛나 클래스가 없는 경우 예외(ClassNotFoundException)이 발생할 수 있다. 외부에서 소스코드 없이 클래스만 제공받아 사용할 경우에도 많이 사용된다. 1234567891011121314151617181920212223242526272829303132333435363738public class MyBook &#123; private String title; public String author; public MyBook(String title) &#123; this.title = title; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125;&#125;public class ClassForNameTest &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Class strClass = Class.forName(&quot;MyBook&quot;); Constructor[] cons = strClass.getConstructors(); for(Constructor c : cons) &#123; System.out.println(c); &#125; Field[] fields = strClass.getFields(); for(Field f : fields) &#123; System.out.println(f); &#125; Method[] methods = strClass.getmethods(); for(Method m : methods) &#123; System.out.println(m); &#125; &#125;&#125; 절차지향 및 객체지향의 개념절차지향과 객체지향 개념은 반대되는 개념이 아니며, 서로가 보완 될 수 있는 개념이다. 자동차를 만드는 과정을 절차지향적 관점과 객체지향적 관점 두 부분으로 나누어 생각해보자. 자동차를 만들기 위해서는 차체, 바퀴,엔진, 핸들 ,의자, 엑셀 등등 많은 부품이들이 있어야 한다. 절차지향 프로그래밍의 경우 ‘차체 -&gt; 바퀴 -&gt; 엔진 -&gt; 핸들’ 와 같이 작업 순서가 존재한다. 트랜잭션 처리와 같이 순차적인 처리가 중요시 되는 곳에서는 이 절차지향 프로그래밍 방법을 사용해야 한다.이들은 서로 분리되면 안되고 함수 호출 순서가 틀려서도 안되며 하나가 고장나면 전체 기능이 마비된다.절차지향은 기본적으로 데이터를 중심으로 함수를 구성한다. 함수의 호출 순서가 바뀌면 데이터의 전달과 값이 변할 수 있다. 객체지향의 프로그래밍의 경우는 공장에서 각 공장에서 각 요소들의 제품들을 제작한다. 제작 순서 자체는 의미를 가지지 않을 때 활용할 수 있다. 물론 비동기 적으로 동작할수도 있고 아닐 수도 있다. 객체지향 프로그래밍은 개발하려는 것을 기능별로 묶어 모듈화를 하고 모듈을 재활용하는 프로그래밍 방식이다. 순서가 있을 수도 있지만 이는 고려의 대상은 아니다. 이들은 각각 따로 독립적으로 개발되어 나중에 한곳에 모여 자신의 기능만 제대로 발휘하면 된다. 부품들이 결합되어 움직이다 어느 하나가 고장이 나면 고장난 부품만 고쳐주면 되고 다른 부품들은 영향을 받지 않는다. 필요한 부품을 다른 것으로 교체할 수 있다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java - O.O.P","slug":"Java-O-O-P","permalink":"http://kidongyun.github.io/tags/Java-O-O-P/"}]},{"title":"O.O.P 해결방법과 F.P 해결방법에 대한 고찰","slug":"2020-11-12-composition-inheritance","date":"2020-11-11T15:54:00.000Z","updated":"2022-05-31T07:19:26.000Z","comments":true,"path":"2020/11/12/","link":"","permalink":"http://kidongyun.github.io/2020/11/12/","excerpt":"","text":"범용적으로 한가지 문제에 대해서 해결할 수 있는 방법은 보통 다양하게 존재하며 이 방법들은 상황에 따라 어떤 것이 좋은지가 달라진다. 이 글에서는 한가지 문제 상황을 제시할 것이며, 이 상황을 O.O.P 방식의 해결방법과 F.P 방식의 해결방법은 어떻게 다를지에 대해서 다루도록 한다. 이 글은 저자의 주관적인 생각이 담겨있음으로 맹목적인 신뢰는 지양하기 바란다. 문제 제시1라면을 잘 만드는 두 요리사가 있다. 이 두 요리사에게는 자신들 만의 라면 제조법이 있는데, 이 방법은 서로 간에 상이하며 다만 결과적으로 라면을 만든다라는 것만 동일하다. 위와 같은 상황을 코드에 녹여내기 위해서 O.O.P 방법과, F.P 방법 두가지를 활용해 제시할 것이다. 둘 간에 어떤 방법이 좋은지는 상황에 따라 달라지며, 개발자에 선택에 따라 맞추서 사용해야 한다. O.O.P 관점에서의 해결방법O.O.P 방식으로 이 문제를 해결하기 위해서는 우선 요리사라는 인터페이스, 혹은 추상 클래스를 만들고, React 라이브러리를 활용해서 처음으로 프론트 사이트 개발을 했을 때 나에게 가장 어려웠던 것은 Component의 구조를 잡는 것이였다. Java 개발을 주로 했었어서 React 라이브러리가 추구하는 방향성을 잘 이해하지 못했기 때문이였다. 나는 React 라이브러리를 활용해 Component를 만들면서 상속의 개념을 넣고 싶었다. 그러나 실제로 많은 자료들을 찾아보면 React는 상속패턴을 지원하지 않는다고 나와있고 또 상속패턴을 지원할 이유도 찾지 못했다고 나와있다. 이 글은 React 라이브러리는 Component를 어떤식으로 구성하는지, 왜 상속패턴이 필요하지 않고 이를 합성패턴으로 모두 대체가 가능한지에 대해서 저자의 생각을 담아놓은 글이다. 주관적인 생각이 많이 들어가기 때문에 맹목적인 지지를 지양하기를 바란다. ‘IS-A’, ‘HAS-A’ 관계객체지향 프로그래밍에 대해서 공부하면 위와 같은 용어를 접하게 되는데. 이 용어하는 바는 상속관계인가 혹은 합성관계인가로 바라볼 수 있다. 예를 들어서 노트북이 있다고 해보자. 노트북은 컴퓨터의 하위 개념으로 노트북은 컴퓨터다 라는 말이 적절하다. 혹은 기타라는 물건은 악기라는 개념의 하위 개념이다. 따라서 기타는 악기이다 라는 말도 적절하다. 객체지향 프로그래밍에서는 이런 관계를 상속관계라 말하고 보통 ‘IS-A’ 관계로 표현한다. 12Notebook is a ComputerGuitar is an instrument 반대로 HAS-A 관계는 소유의 개념이 있는지 없는지를 확인한다. 일반적으로 노트북은 모니터라는 개념이 필요하고 이를 가지고 있다. 또 기타의 경우 기타줄이라는 개념을 가지고 있다. 이러한 관계를 합성관계로 바라볼 수 있다. HAS-A 관계를 활용해 여러 객체들을 합칠 수 있기 때문이다. 12Notebook has a MonitorGuitar has a string 즉 다시 말하자면 상속개념은 어떤 특정 개념이 다른 개념과 상하위 관계가 있는가를 이야기 하고, 합성개념은 특정 개념이 다른 개념을 소유하는가를 이야기 한다. React 라이브러리는 왜 상속의 개념이 없을까?React 라이브러리는 정확히는 상속의 개념이 없으며, 사실 오직 합성의 개념만 존재한다. VanilaJS 에는 ES6 부터 Class 문법이 생겨나고 기존의 함수기반에 코딩에서 객체지향의 코드도 작성할 수 있도록 발전해가지만 왜 React 라이브러리는 상속관계를 지원하지 않을까? 그 이유는 왜 상속의 개념을 사용해야하는가를 먼저 이해하면 답을 찾을 수 있다. O.O.P 에서 상속 패턴을 사용하는 이유실무적으로 상속 패턴을 사용하는 가장 큰 이유는 다형성을 활용하기 위함이다. 비슷한 객체이나 특정 동작에 대해서 다르게 처리해야할 필요성이 있을 때 보통 O.O.P 방법으로는 이 비슷한 객체를 하나로 묶도록 부모 객체를 만들고 이를 상속 받아서 다르게 처리해야하는 부분을 오버라이딩한다. 이는 O.O.P 방식의 해결 방법이다. 그러나 React 라이브러리는 JS 기반을 동작하고 있고 JS는 F.P 방식을 지원한다. 그렇기 때문에 위와 같이 특정 동작에 대해서 다르게 처리해야할 필요성이 있다면 상속의 방법을 활용하지 않고 F.P 방법으로 해결이 가능하다. html 문법은 태그들을 계층형 구조로 만들어 낸다. React 라이브러리에서 객체에 해당하는 Component 들을 만들어도 사실 이 객체는 결국 html 태그들의 집합이다. 결과물 관점에서 봤을 때 즉 ht It’s really hard to understand about this. Why does React not support inheritance technique?. I think the answer is the purpose of React library is create the html tag. As you knew, the html tags are tree structures. This tags can’t express the inheritance relationship. so React don’t need to create ‘IS-A’ relationship because It eventually should present the html tags, which means tree structure. Abstract technique in CompositionMy hardest part is the problem how we show the abstrat thing without inheritance. But it’s possible. abstract thing means ‘It is something’ in the ‘IS-A’ relationship and ‘It has something’ in the ‘HAS-A’ relationship. 12345678910111213interface Computer &#123; &#125;class Laptop extends Computer &#123; &#125;class Desktop extends Computer &#123; &#125;class Main &#123; public static void main(String[] args) &#123; Computer computer = ...; &#125;&#125; The above code is expressing the abstract things using Inheritance technique. 123456789101112131415interface ComputerProps &#123; &#125;const Computer: React.FC&lt;ComputerProps&gt; = (&#123; children &#125;) =&gt; &#123; return &lt;&gt;&#123;children&#125;&lt;/&gt;; &#125;interface LaptopProps &#123; &#125;const Laptop: React.FC&lt;LaptopProps&gt; = (&#123;&#125;) =&gt; &#123; return &lt;Computer&gt;It’s Laptop&lt;/Computer&gt;&#125; And it’s expressing the abstract things using composition technique. Consequently, React support the more limit envrionment than the host languages like Java. but it’s not the limitation of the javascript. It’s just a principle of React. React don’t need to have a Inheritance techniques. because It eventually will return html tag tree. Atomic Design","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"O.O.P","slug":"O-O-P","permalink":"http://kidongyun.github.io/tags/O-O-P/"},{"name":"F.P","slug":"F-P","permalink":"http://kidongyun.github.io/tags/F-P/"}]},{"title":"The problem of mismatching type when you use List.","slug":"2020-10-31-inheritance-with-list","date":"2020-10-31T02:38:54.000Z","updated":"2022-05-31T07:19:11.000Z","comments":true,"path":"2020/10/31/","link":"","permalink":"http://kidongyun.github.io/2020/10/31/","excerpt":"","text":"Let’s think just a really simple struture for understanding of inheritance concept. 12345678910111213class A &#123;&#125;class B extends A &#123;&#125;class C &#123;&#125; Class A is a super class and Class B is extended Class A. Class C is independent thing. It doesn’t have any relationship with other classes. 12345678910/** It&#x27;s possible */A a = new A();/** It&#x27;s possible because B is sub-class of A. */A a = new B();/** It&#x27;s impossible because C doesn&#x27;t have any relationship with A. */A a = new C(); You could understand the above code. but let’s see the below, which i haven’t understood well just before now. 12345678910/** It&#x27;s possible. */ArrayList&lt;A&gt; aList = new ArrayList&lt;A&gt;;/** It&#x27;s possible. */aList.add(new B());/** It&#x27;s impossible. */aList = new ArrayList&lt;B&gt;; The last one is the main topic of this article. I usually think that code would work well. but it’s not. the reason why it isn’t work well is you should understand ArrayList is not extended ArrayList","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"The core of Spring Framework","slug":"2020-10-27-spring-core","date":"2020-10-27T02:38:54.000Z","updated":"2022-05-31T07:19:01.000Z","comments":true,"path":"2020/10/27/","link":"","permalink":"http://kidongyun.github.io/2020/10/27/","excerpt":"","text":"Inversion of Control (IOC), Denpendency Injection (DI)It means the technique what you give system the ability of controling the objects.That is you don’t consider for managing them. and Spring Framework can support this technique for user. The main advantage of this technique is removing the independent relationship beween each objects. 12345678910111213141516171819202122class A &#123; B b = new B();&#125;class B &#123; &#125;``` The above source code show A object has a B object and It create new B instance.the code of these styles should consider the time when i inject the instance of BIt means you should always consider the way how we inject the objects.```javaclass A &#123; @Autowired B b;&#125;@Componentclass B &#123; &#125; If you use Spring Framework then you can inject the objects like the above code.That means you don’t need to consider how i inject the object B and you just use this. Spring container is the store of the objects. and we can import these objects like the above sample code. and We usually call ‘bean’ about these objects is located in the Spring container. Actually i already told about the concept of DI (Dependency Injection). It’s the way for getting the object instances for example constructor, java bean pattern, ioc…. Spring ConfigurationThe beginning of Spring Framework usually use the xml format for configuration of itself. but These xml files are too difficult to manage than the java code. so most of Spring Framework users want to configure the Spring as a java code with annotation. so It’s changed. Spring containerI already told about it. It’s the store for saving the objects what would be injected by Spring Framework. and It’s the implementation of ‘BeanFactory’. Actually i don’t know about this interface. but you just remember the fact, which Spring Framework is the main store of application components. It would offer the beans from the Spring Configuration. BeanIt is the alias of java object in the Spring Framework. The one of features of bean is this could inject from Spring Framework for example @Autowired annotation. And we don’t need to manage these beans. It’s managed by Spring Framework.Otherwise the object what don’t manage by Spring Framework is not a bean. component-scanThe traditional way is we should assert all of the beans if you want to use. but It’s really not efficient. so ‘component-scan’ technique is appeared. It can register all the beans based package. Singleton, PrototypeThe bean usually is created only one instance by the Spring Framework. It’s singleton type. But you can create the bean as a different type for example prototype. The bean is created when your server start. so Your server would have some overhead at the beginning. but after this, the performance is better than what you don’t use singleton pattern. LifecycleSpring Framework provide the lifecycle for customizing of setting the beans. @PostConstructIt is used at the method what you want to make as a callback method. You can make the IoC System using Reflection technique. but the IoC of Spring Framework is really effective and universal. so if your case is not special then i just recommend to use the spring framework. 123456@Componentclass BookService &#123; private BookRepository bookRepository = new BookRepository()&#125; We usually use the above code when we learn Java language firstly. But actually this pattern has a imperfection. The BookService object has the denpendency of BookRepository. and this object inject instance directly. It doesn’t have any way to inject different BookRepository object. This always take the BookRepository instance from ‘new BookRepository()’ 12345678910@Componentclass BookService &#123; private BookRepository bookRepository; public BookService(BookRepository bookRepository) &#123; this.bookRepository = bookRepository; &#125;&#125; This way is more flexible than before one. because It can take a various bookRespository via the constructor. 12345678910111213class Main &#123; public static void main(String[] args) &#123; /* It’s the new one */ BookService bookService = new BookService(new BookRepository()); /* It’s the old one using before somewhere */ BookRepository bookRepository; /* Do something to bookRepository */ BookService bookService = new BookService(bookRepository); &#125;&#125; The purpose of Dependency Injection is shifting the the subject of managing dependency from the main source to third party for example Spring Container. Every object can approach these container so you don’t need to consider how we inject the instances. ApplicationContextThe one of the subclass of BeanFactory. It has a lot of functions of Spring Framework. Bean Containers, Lifecycle… applicationContext.xmlThis style could set the Spring Framework Initialization using xml file like ‘applicationContext.xml’. It’s really traditional style of Spring Framework. The main imperfection of this style is you should manage the xml files for keeping the Spring system. and It means the configuration source could not be as a object. in other word, you can’t do O.O.P for Spring configuration. @autowiredthe autowired annotaion basically infer the type, the name of varable. If you use component-scan, auto-scan attribute of Spring Framework, You could register the bean automatically in the specific package. Registering the Bean vs Dependency InjectionActually i often confused the annotation between for registering the beans and injecting dependencies. 1234567/** It’s for registering the beans */@Component, @Service, @Controller, @Repository, @Entity, @Configuration ..../** It’s injecting the dependencies */@autowired @resource -&gt; 그다음은 xml 기반이아닌 java 기반으로 bean 등록하기. @Bean 어노테이션을 활용해서 빈 등록.빈 등록할때에도 보이는 것이 해당 빈이 가지고 있는 의존성이 외부에서 주입될 수 있도록 코드를 왜 짜야하는지 알수 있을 것. setter를 활용해서 직접 의존성을 주입하는 방법과 달리 @autowired 를 사용하면 IoC 컨테이너를 먼저 확인을 하고 해당 빈과 합당한 빈을 찾을 수 있는 경우 바로 그 빈을 주입한다. -&gt; java로 bean 등록 할때에도 @ComponentScan() 을 사용하면 적용된 패키지 안에있는 클래스들은 모두 자동 빈 등록된다. @SpringBootApplication을 사용하면 자동적으로 ApplicationContext를 생성해준다. 스프링부트를 실행하면 생성되어 있는 Application.java 파일이 사실상 어노테이션으로 되어있지만 스프링 설정파일이라고 생각하면된다. 어노테이션들을 잘 확인해보면 알수 있다. ApplicationContext - ClassPathXmlApplicationContext (XML) - AnnotationConfigApplicationContext (JAVA) @Autowired 12345678910@Servicepublic class BookService &#123; BookRepository bookRepository; @Autowired public BookService(BookRepository bookRepository) &#123; this.bookRepository = bookRepository; &#125;&#125; 생성자 주입을 하는 코드이다. 생성자에서 @Autowired 선언을 해두면 해당 파라미터 객체들은 빈에서 가져오게 된다. 123456789101112@Servicepublic class BookService &#123; BookRepository bookRepository; @Autowired public void setBookRepository(BookRepository bookRepository) &#123; this.bookRepository = bookRepository; &#125;&#125; 이번에는 setter 에서 주입을 시도한다.실제로 setter는 무조건 호출되는 코드가 아니기 때문에 BookRepository 빈이 없어도 BookService 객체가 생성되는 것은 맞는데. @Autowired 는 무조건 호출되기 때문에 오류가 난다. 만약 호출하기 싫다면 @Autowired(required = false) 로 어노테이션 하면 된다. 생성자 주입에 비해 setter 주입이 좀더 자유롭다. BookService 를 먼저 만들고 추후에 의존성을 주입할 수 있으니까. 필드 주입은 이미 알고있는 그대로. 해당 타입의 빈이 여러개인 경우에는 명시를 해주지 않으면 스프링이 어떤 빈인지 모르기 때문에 주입해줄수 없다. 이럴땐 @Primary 사용하면 이렇게 여러개인 경우 @Primary를 우선적으로 주입한다. 혹은 중복되는 빈들을 모두 받을 수도 있다. 1234@AutowiredList&lt;BookRepository&gt; bookRepositories; ApplicationRunner 가 뭐지. @Autowired-&gt; type 먼저 확인 후 그다음에 이름을 확인하긴 한다. 그러나 비추 왜냐하면 타입세이프하지 않으니. 아래 코드와 같음. 1234@AutowiredBookRepository myBookRepository; BeanPostProcessor-&gt; 라이프사이클인데 빈의 인스턴스를 만들고 initialization 하기전에 부가적인 작업을 하기위한 콜백. initialization 이란 뭐냐 @PostConstruct-&gt; 빈주입 이후에 발생하는 콜백. 빈 등록할때 component scan 에 클래스 정보를 너어줄때 두가지 방법이 있는데basePackages -&gt; String 값을 받고basePackagesClass -&gt; 요거는 클래스를 받기떄문에 보다더 타입 세이프하다. 스프링부트의 경우 Application.java 에 config 관련 어노테이션이 있는데 component-scan도 이 패키지 하위만 가능. 따라서 저 파일이 없는 외부의 패키지의 경우는 자동으로 scane되지 않는다. 따로 추가해줘야한다. 빈주입이 안될떼는 컴포넌트스캔을 잘 살펴보라. @Filter 어노테이션은. 빈생성을 할때 요구조건에 따라 추가 제거를 할 수 있따. component-scan에 중요한 것은 스캔의 범위와. 필터링되어있는 빈들이 어떤거인지를 확인하는것. 스프링의 빈 등록은 스프링 프로젝트가 처음에 시작될때 모두가 빈을 등록하기때문에 구동시에는 좀 느려질수가 있따. 이런거에 민감한 프로젝트는 빈 등록을 스프링 부트가 뜨는 시점에 registerBean() 함수를 활용해서 생성 시점을 변경할 수 있나보다. 123456789public static void main(String[] args) &#123; var app = new SpringApplication(Demospring51Application.class); app.addInitializers((ApplicationContextInitializer&lt;GenericApplicationContext&gt;) ctx -&gt; &#123; ctx.registerBean(MyService.class); &#125;); app.run(args);&#125; java10 이후부터는 var 라는 로컬 변수명을 가질 수 있다. -&gt; 타입을 자동 추론하는 건가..? @ComponentScan은 BeanFactoryPostProcessor 라이프사이클에서 빈으로 등록한다. @ComponentScan이 빈등록 하는 대상은 @Component 어노테이션을 선언한 클래스이다. @Repository, @Service, @Controller, @Configuration 들도 @Component 어노테이션을 포함하고 있다. Function을 활용한 빈등록 (위에 언급한 방법)으로는 모든 빈들을 생성하기보다는 특별하게 @Bean 을 사용해서 등록하는 빈들만 쓰는게 나을듯. 빈의 스코프 싱글톤 -&gt; 모든 프로젝트 전반에 걸쳐서 해당 인스턴스(빈)이 오직 한개인 형태. 스프링의 기본 빈 생성방식은 싱글톤이다. 그래서 @Component 만을 붙였을 경우 이 클래스는 하나의 인스턴스만 생성된다. 대부분의 경우 싱글톤 스코프를 사용하는데 그렇지 않은 경우 프로토타입 스코프를 사용한다. 프로토타입 스코프 -&gt; 매 빈이 주입될 떄 새로운 인스턴스로 가져오는 것. 123456@Component @Scope(&quot;prototype&quot;)public class Proto &#123;&#125; 문제는 싱글톤 스코프의 빈이 프로토타입 스코프의 빈을 의존할고 있을 때가 이슈가 있다. 왜냐면 싱글톤 스코프의 빈은 한번만 생성되기 때문에 매번 프로토타입의 스코프의 빈을 새로 생성해주지 않는다 즉 변경되지 않는다. 이를 해결하기 방법. (1) proxyMode 를 사용한다. 123456@Component @Scope(value = &quot;prototype&quot;, proxyType = ScopedProxyMode.TARGET_CLASS)public class Proto &#123;&#125; Proxy로 감싸고. Proxy 빈을 사용하도록 한다. 싱글톤 스코프를 가진 빈이 프로토타입 스코프를 가진 빈을 의존하고 있을 때 직접 참조를 하게 되면 프로토타입 스코프의 빈이 변경이 될 수 없기 때문에 프록시라는 걸로 한번 감싸고 이 프록시의 빈이 변경되지 않도록 하고. 그 안에 있는 실제 프로토타입 빈은 변경될 수 있도록 한다. Proxy 선언을 하면 이 프록시 객체가 전혀 새로운 객체가 되는것은 아니고 감싸지는 클래스와 동일하다. 롱런하는 빈이 짧은 생명 주기를 가진 빈을 의존할 때에는 이 Scope를 고려해야한다. 프로파일. 각 서버(테스트, 스테이징, 프로덕트 등)에 종속적으로 필요한 빈들을 추가하기 위한 기능? 12345678Environment environment = ctx.getEnvironment();/* 프로파일 검색 */System.out.println(Arrays.tostring(environment.getActiveProfiles()));/* 기본적으로 적용되는 프로파일. */System.out.println(Arrays.toString(environment.getDefaultProfiles())) 일반적으로 생성한 빈들은 모두 우리가 특정 프로파일을 언급하지 않았기 때문에 이 defaultProfiles 에 들어갔을 것이다. 12345678910@Configuration@Profile(&quot;test&quot;)public class TestConfiguration &#123; @Bean public BookRepository bookReposigory() &#123; return new TestBookRepository(); &#125;&#125; test라는 프로파일로 스프링을 실행하지 않으면 위 빈 등록하는 코드가 실행되지 않는다. 이를 통해 서버 단위로 구분되어지는 빈 등록이 가능하다. 프로파일 설정.(1)intellij setting -&gt; active profiles (2)VM options-Dspring.profiles.active=”test” 2번 방법이 나은듯. 왜냐면 결국 서버에서 jar로 스프링 실행할 때 jvm option 줘야하기 때문. 1234567@Repository@Profile(&quot;test&quot;)public class TestBookRepository implements BookRepository &#123;&#125; @Configuration 쪽 뿐만아니라 Component-Scan 되어지는 빈들에게도 @Profile 활용할 수 있다. @Profile을 적용하지 않은 경우는 -&gt; @Profile(“default”) 로 생각하면 된다. environment property. jvm.option 같은 것들 가져오는 방법 말하는 거 같다. -Dvm.option 으로 줄수도있고혹은 .properties 파일 안에다가 넣어둔 값도 아래처럼 가져올 수 있다. 12Environment environment = ctx.getEnvironment();System.out.println(envrinment.getProperty(&quot;app.name&quot;)); 이렇게 바로 가져오는 방법도 있고.아 이걸로 계정 정보를 넣어두는것도 괜찮았을거 같은데.. MessageSource국제화 기능을 제공하는 인터페이스. 1greeting=안녕, &#123;0&#125; 12345678910111213141516@AutowiredApplicationContext applicationContext;@AutowiredMessageSource messageSource;@Overridepublic void run(ApplicationArguments args) throws Exception &#123; System.out.println(messageSource); System.out.println(messageSource.getMessage(&quot;greeting&quot;), Locale.KOREA); System.out.println(messageSource.getMessage(&quot;greeting&quot;), Locale.getDefault());&#125; message.propertiesmessages_ko_KR.properties 이와 같이 파일이름을 해서 만들어줘야함. 그러면 mesaageSourcerk message로 시작하는 properties 파일들을 자동적으로 읽어서 가져온다. 빈등록해서도 사용가능 12345678@Beanpublic MessageSource messageSource() &#123; var messageSource = new ReloadableResourceBundleMessageSource(); messageSource.setBasename(&quot;classpath:/messages&quot;); messageSource.setDefaultEncoding(&quot;UTF-8&quot;); return messageSource;&#125; 릴로딩 기능이 있다. -&gt; 빌드만 해주면 메시지 번들이 자동으로 빌드대서 변경된 내용이 적용된다. 내가 쓰려는 타입으로 선언해서 쓰는것이 좋다. 상위 크래스를 선언하는 것보다. 왜냐하면 어떤 용도로 쓰려는것인지 보다더 가독성이 드러나기 떄문. 12345678910111213141516171819ApplicationEventPublisher이벤트 기반의 코딩을 할떄 사용??public class MyEvent extends ApplicationEvent &#123; private int data; public MyEvent(Object source)&#123; super(source); &#125; public MyEvent(Object source, int data) &#123; super(source); this.data = data; &#125; public int getData() &#123; return this.data; &#125;&#125; 여기부분이 리스너다. 12345678@Componentpublic class MyEventHandler implements ApplicationListener&lt;MyEvent&gt; &#123; @Override public void onApplicationEvent(MyEvent event) &#123; System.out.println(&quot;이벤트 받았다. 데이터는 &quot; + event.getData()); &#125;&#125; 123456789@AutowiredApplicationEventPoblisher publishEvent;@Overridepublic void run(ApplicationArguments args) throws Exception &#123; publishEvent.publishEvent(new MyEvent(this, 100));&#125; 스프링 부트 설정하는 부분에서 이벤트를 등록하는 코드를 작성. 이벤트는 ApplicationEvent 를 상속 받아서 미리 구현해두고. 이 등록된 이벤트는 등록되어져 있는 빈들 중에 적절한 리스너를 찾아서 호출한다. 리스너는 위에 구현해놔씀 4.2 이전 버전 방법이고. 이후에는 이렇게 사용하지 않음. 스프링은 자기의 프레임워크가 비지니스 코드들에 들어가지 않기를 원함 비침투성을 원함 그런데 4.2 버전 이전에는 ApplicationEvent 등을 상속받는다거나 하는것들이 모두 스프링프레임워크에 의존되는 코드들 넣어야 했음. 이후에는 이제 안그래도 된다고 함. 어케 하느냐 리스너에 해당하는 코드에 @EventListener 어노테이션 달기만 하면 됨. Event 클래스는 POJO 클래스가 되었고 이를 @EventListener 가 리스너로 받는다 123456789101112@Componentpublic class MyEventHandler(MyEvent event) &#123; @EventListener @Order(Ordered.HIGHEST_PRECEDENCE + 2) public void handle(MyEvent event) &#123; System.out.println(Thread.currentThread().toString); system.out.println(&quot;이벤트 받았다. 데이터는 &quot; + event.getData()); &#125;&#125; 비동기적으로 쓰고시으면 @Async 붙여라. + 그리고 스프링 부트 설정 파일 …Application 이 클래스에 @EnableAsync 이걸 붙이면 각각의 쓰레드를 호출해서 비동기적으로(비순차적으로) 실행된다. ApplicationContext의 기능 ResourceLoader. 말 그대로 resource를 로딩해주는 역할을 하는데 이를 applicationcontext가 상속받고 있다. 1234567891011121314@Componentpublic class AppRunner implements ApplicationRunner &#123; @Autowired ResourceLoader resourceLoader; @Override public void run(ApplicationArguments args) throws Exception &#123; resourceLoader.getResource(&quot;classpath:test.txt&quot;); System.out.println(resource.exists()); &#125;&#125; resource 폴더 안에있는 것들이빌드되었을때 target &gt; classes 폴더 안에 들어아깄을거임. classpath가 저길 바라보는 것인가. ApplicationContext는 BeanFactory + Message… + Event + Resource … 등등 많은 기능을 내포. Resource 는 java.net.URL 이 객체를 추상화시켜 만든것. 기존의 것이 클래스패스를 기준으로 가져오는 경우가 없었고.. HTTP, FTP emd prefix 에 대한 기능도 없었고. 방법을 하나로 통일. getResource() Resource 객체가 스프링 내부적으로도 많이 사용된다. xml로 스프링 설정 했을 때에도 ClassPathXmlApplicationContext() 이 함수로 가져오는데. 여기 안에 파라미터로 들어가는 문자열이 Resource 객체로 된다. 이 Resource를 구현한 구현체들은 굉장히 만흥ㄴ데. 이중 UrlResource, ClassPathResource, FileSystemResource, ServletContextResource 이렇게 있따. classpath: file:/// 등과 같이 접두어를 사용해서 해당 파일이 어디에서 오는지 명시를 해주는 것이 더 좋다. getResource 할때 location의 접두어에 따라서 실제로 생성된 sub-class가 다르다. classpath 접두어를 지우면 default로 ServletContextResource 를 사용한다.이거는 웹 애플리케이션 루트에서 상대 경로로 리소스를 찾는다. applicationContext를 어떤것을 쓰냐에 따라서 저 경로가 달라지기 떄문에 명시적으로 경로를 적어주는 것이 좋다. Validation Validator. 웹 MVC에서 많이 사용하지만 사실 이것만을 위해서 만들어진 인터페이스는 아니다. Bean Valdidation.-&gt; Java EE 표준 스펙.-&gt; NotEmpty, NotNull, NotBlank…. 등등 Validator를 사용하기 위해서는 2가지 동작을 구현해야함. support()validate()이 두개. 123456public class Event &#123; Integer id; String title;&#125; 12345678910111213public class EventValidator implements Validator &#123; @Override public boolean supports(Class&lt;?&gt; clazz) &#123; return Event.class.equals(clazz); &#125; @Override public void validate(Object target, Errors errors) &#123; ValidationUtils.rejectIfEmptyOrWhitespace(errors, &quot;title&quot;, &quot;notempty&quot;, &quot;default message&quot;) &#125;&#125; 123456789101112131415161718192021@Componentpublic class AppRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; Event event = new Event(); EventValidator = eventValidator = new EventValidator(); Errors errors = new BeanPropertyBindingResult(event, &quot;&quot;) eventValidator.validate(event, errors); System.out.println(errors.hasErrors()); errors.getAllErrors().forEach(e -&gt; &#123; System.out.println(&quot;===== error code =====&quot;); Arrays.stream(e.getCodes()).forEach(System.out.::println); System.out.println(getDefaultMessage()); &#125;); &#125;&#125; 이렇게 Validator를 직접 인스턴스 생성해서 하는 방법은 정말 원시적인 방식. ValidationUtils 를 사용하지 않고 직접 조건을 걸수 있따. 123456Event event = (Event) target;if(event.getTitle() == null) &#123; errors.reject()&#125; 1234567891011@Componentpublic class AppRunner implements ApplicationRunner &#123; @Autowired Validator validator ....&#125; 12345678910public class Event &#123; Integer id; @NotEmpty String title; @NotNull @Min(0) Integer limit;&#125; 데이터 바인딩 -&gt; 컨트롤러 등에서 데이터를 받아올때 이를 string type이 아니고 도메인으로 바로 받을수 있게끔 하는 기능 1234567891011121314151617181920212223242526272829303132333435public class Event &#123; private Integer id; private String title;&#125;@RestControllerpublic class EventController &#123; @InitBinder public void init(WebDataBinder webDataBinder) &#123; webDataBinder.registerCustomEditor(Event.class, new EventEditor()); &#125; @GetMapping(&quot;/event.&#123;event&#125;&quot;) public String getEvent(@PathVariable Event event) &#123; System.out.println(event); return event.getId().toString(); &#125;&#125;@RunWith(Springrunner.class)@WebMvcTestpublic class EventControllerTest &#123; @Autowired MockMvc movkMvc; @Test public void getTest() &#123; mockMvc.perform(get(&quot;/event/1&quot;)) .andExpect(status().isOk()) .andExpect(content().string(&quot;1&quot;)); &#125;&#125; {event} 에 해당하는 1의 값이 string 형태인데 이걸 Event 타입으로 변경하지 못하기 때문에 오류가 날거임. 이럴때 사용하는게 PropertyEditor 를 사용해서 적용할 수 있음. 123456789101112131415public class EventEditor extends PropertyEditorSupport &#123; @Override public String getAsText() &#123; Event event = (Event)getValue() return event.getId().toString(); &#125; @Override public void setAsText(String text) throws IllegalArgumentException &#123; setValue(new Event(Integer.parseInt(text))); &#125;&#125; getValue(), setValue() 가 서로다른 쓰레드에게 공유가 되기 때문에 Stateful하다. 상태정보를 저장하고 있다. Thread-safe 하지 않다.여러 쓰레드에서 공유해서 사용하면 안된다 -&gt; 빈으로 등록하면 안된다. (일반적으로 싱글톤이기 때문)그냥 빈이 아닌 Thread Scope 으로 생성해서 사용하면 가능. 근데 그냥 빈으로 등록 안하는 것을 추천함. 구현체를 직접 구현하는 경우에는 구현해야할 메서드들이 매우 많아지기 때문에 일반적으로 이러한 interface를 구현해둔 디폴트 클래스가 있다.이걸 상속받고 필요한 메서드들만 오버라이딩 해서 구현하는게 일반적이다. PropertyEditor는 구현하기도 너무 거추장하고 Thread-safe 하지 않고 Object -&gt; String 으로 변환이 가능하다는 단점 때문에 새로 추가된 것이 있는데 그게 Converter와 Formatter ConverterS 타입을 T 타입으로 변환할 수 있는 매우 일반적인 변환기.상태 정보를 없앴음 == Stateless == Thread-safe 123456789101112131415161718public class EventConverter implements &#123; /* Convert from String to Event */ public static class StringToEventConverter implements Converter&lt;String, Event&gt; &#123; @Ovevrride public Event convert(String source) &#123; return new Event(Integer.parseInt(source)); &#125; &#125; public static class EventToStringConverter implements Converter&lt;Event, String&gt; &#123; @Override public String convert(Event source) &#123; return source.getId().toString(); &#125; &#125;&#125; Bean 으로 등록해도 되며 보통 ConverterRegistry 에 등록한다. BOOT가 아닌경우123456789@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Override public void addFormatters(FormatterRegistry registry) &#123; registry.addConverter(new EventConverter.StringToEventConverter()); &#125;&#125; Formatter 123456789101112131415161718192021public class EventFormatter implements Formatter&lt;Event&gt; &#123; @Override public Event parse(String, text, Locale locale) throws ParseException &#123; return new Event(Integer.parseInt(text)); &#125; @Override public String print(Event object, Locale locale) &#123; object...; &#125;&#125;@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Override public void addFormatters(FormatterRegistry registry) &#123; registry.addFormatter(new EventFormatter()); &#125;&#125; 타입은 모두다 ConversionService.WebConversionService extends DefaultFormattingConersionService;Web… 요거가 스프링 부트에서 제공해주는거. converter, formatter 사용을 위해서 스프링 부트에서는 webconfig를 새로 추가해서 등록할 필요가 없다.자동으로 Conversion service에 빈등록 시켜준다. @WebMvcTest()-&gt; 계층형 테스트, 웹과 관련된것만 Bean 등록, 보통 컨트롤러만 빈등록이 됨, 컨버터나, 포매터는 등록이 안될 가능성이 있다. 1@WebMvcTest(&#123;EventFormatter.class, EventController.class&#125;) 저렇게 {} 안에다가 추가적으로 객체를 넣어주면 특정 객체도 수동적으로 빈 등록이 가능하다. 등록되어있는 컨버터들을 전부 보는 방법.1System.out.println(conversionService); SpEL (Sprng Expression Language) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* application.properties */my.value = 100/* bean sample */@Getter@Setter@Componentpublic class Sample &#123; private int data = 200;&#125;@Componentpublic class AppRunner implements ApplicationRunner &#123; @Value(&quot;&#123;#&#123;1 + 1&#125;&#125;&quot;) int value; @Value(&quot;#&#123;&#x27;hello&#x27; + &#x27;world&#x27;&#125;&quot;) String greeting; /* 표현식을 사용하는 방법 */ @Value(&quot;#&#123;1 eq 1&#125;&quot;) boolean trueorFalse; /* 프로퍼티 접근 */ @Value(&quot;$&#123;my.value&#125;&quot;) int myValue; /* 표현식 안에서도 프로퍼티 접근이 가능함.*/ @Value(&quot;#&#123;$&#123;my.value&#125; eq 100&#125;&quot;) boolean isMyValue100; /* 문자열이 그대로 들어간다. */ @Value(&quot;#&#123;&#x27;spring&#x27;&#125;&quot;) String spring; @Value(&quot;#&#123;sample.data&#125;&quot;) int sampleData; /* 특정 조건에 따라 선별적으로 빈등록을 해주는 어노테이션. */ @ConditionalOnExpression /* 이 annotation을 사용해서 쿼리 만들때 파라미터 전달할 때에도 SpEL 사용. */ @Query @Override public void run(ApplicationArguments args) throws Exception &#123; &#125;&#125; 가장 심플한 SpEL 사용법. SpEL 어떻게 동작하는가. 123456ExpressionParser parser = new SpelExpressionParser();Expression expression = parser.parseExpression(&quot;2 + 100&quot;);Integer value = expression.getValue(Integer.class);System.out.println(value); AOP 개념-&gt; 흩어진 Aspect를 모듈화 할수 있는 프로그래밍 기법. concerns -&gt; 비슷한 형태의 코드 대표적인 예제가 transaction -&gt; transaction 처리를 할때 set auto commit …. commit rollback.기존의 서비스 코드를 하나로 묶는 것. transaction 처리!!!! 요거 함 봐야될거 같은데. 중요한거같은데. 이러한 유사한 코드들 concern 들을 Aspect 라는 곳에 모아둬서 처리한다. 해야할일과 어디에 적용해야하는지를 묶어서 저장해둔다. 이게 AOP 처리 기법. 용어가 좀 어려워서 처음에 포기하는데 실제로는 어렵지 않다. Aspect -&gt; 묶은 모듈 이 모듈에 Advice, Pointcut 두가지가 들어가는데 Advice -&gt; Aspect로 관리되는 코드 Pointcut -&gt; 어디에 적용해야하는지 Target -&gt; 적용이 되는 대상 JoinPoint -&gt; 메서드 실행시점. 쓰레드가 분기되고 합쳐지는 것처럼. 합쳐지는 지점을 의미. CrossCut -&gt; 흩어져있따. AOP 적용 방법 - 컴파일 타임 =&gt; 바이트코드를 만들때 수정된 버전으로 만든다. -&gt; It doesn&#39;t have any limit when it is running. - 로드 타임 =&gt; jvm 로드타임 위빙. 낑겨서 넣는다 -&gt; you should set the load time weaver. and it would occur a little of load. - 런 타임 =&gt; 스프링 AOP가 사용하는 방법. -&gt; A라는 클래스의 빈을 만들때 프록시 빈을 만든다.. 프록시 기반의 AOP. -&gt; 가장 유동적이나 부하가 클수 있음. 최초에 빈을 생성할때 약간의 성능 이슈가 있을수 있으나 로드 타임과 거의 유사하다고 봄. -&gt; 런 타임에서 적용하기 때문에 별도의 설정등이 적다. AspectJ (컴파일, 로드타임에서도 제공)-&gt; 매우 많은 JoinPoint 등을 제공 Spring AOP (런타임으로 제공)-&gt; 제한된 환경으로 제공. Spring AOP dependency는 Spring-core, Spring-context에 없다 그래서 새로 추가해야함. Spring AOP 특징-&gt; 프록시 기반의 AOP-&gt; 스프링 빈에만 AOP를 적용 client -&gt; subject(interface) -&gt; proxy, read subject프록시 패턴 : 기존 코드 변경없이 접근 제어 또는 부가 기능 추가. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public interface EventService &#123; public void createEvent(); public void publishEvent(); public void deleteEvent();&#125;public class SimpleEventService implements EventService &#123; @Override public void createEvent() &#123; long begin = System.currentTimeMillis(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;Created an event&quot;); System.out.println(System.currentTimeMillis() - begin); &#125; @Override public void publishEvent() &#123; long begin = System.currentTimeMillis(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;Published an event&quot;); System.out.println(System.currentTimeMillis() - begin); &#125; @Override public void deleteEvent() &#123; System.out.println(&quot;Deleted an event&quot;); &#125;&#125;public class AppRunner implements ApplicationRunner &#123; @Autowired EventService eventService; @Override public void run(ApplicationArguments args) throw Exception &#123; eventService.createEvent(); eventService.publishEvent(); eventService.deleteEvent(); &#125;&#125; 위의 코드는 성능 측정을 위해 기존 코드에 추가하고 있음.이런거를 하고싶지 않다! 이럴때 프록시 패턴을 사용!! 성능을 측정하는 코드 같은것들은 사실 메인의 기능이 아님. 이런것들을 프록시에 넣어두면기존코드를 수정하지 않으면서 이러한 새로운 코드를 추가할 수 있다. 한 인터페이스에 모두가 동일하게 사용하는 기능들이 있을경우.이런걸 프록시 패턴을 사용해서 처리하면 좋은가?? 이거 좋을거 같은데!!?!?!? 이거 필요했는데 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public interface EventService &#123; public void createEvent(); public void publishEvent(); public void deleteEvent();&#125;@Primary@Servicepublic class ProxySimpleEventService implements EventService &#123; @Autowired SimpleEventService simpleEventService; @Override public void createEvent() &#123; long begin = System.currentTimeMillis(); simpleEventService.createEvent(); System.out.println(System.currentTimeMillis() - begin); &#125; @Override public void publishEvent() &#123; long begin = System.currentTimeMillis(); simpleEventService.publishEvent(); System.out.println(System.currentTimeMillis() - begin); &#125; @Override public void deleteEvent() &#123; simpleEventService.deleteEvent(); &#125;&#125;public class SimpleEventService implements EventService &#123; @Override public void createEvent() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;Created an event&quot;); &#125; @Override public void publishEvent() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;Published an event&quot;); &#125; @Override public void deleteEvent() &#123; System.out.println(&quot;Deleted an event&quot;); &#125;&#125;public class AppRunner implements ApplicationRunner &#123; @Autowired EventService eventService; @Override public void run(ApplicationArguments args) throw Exception &#123; eventService.createEvent(); eventService.publishEvent(); eventService.deleteEvent(); &#125;&#125; ProxyService 이거를 만드는데 드는 비용이 꽤 크다.그리고 기능이 결국 비슷한걸 적용하기위해 Proxy를 만들었으니 이걸 AOP 로 사용??-&gt; 프록시 객체를 동적(런타임 시점에)으로 만드는 방법이있다.-&gt; 어떤 객체를 감싸는 프록시 객체를 만드는 거(프록시 객체 자체는 굉장히 심플)-&gt; AbstractAutoProxyCreator 를 활용해서 SimpleEventService 를 감싸는 프록시 객체를 만들어서 빈 등록해준다.AbstractAutoProxyCreator는 BeanPostProcessor 라이프사이클을 구현한 녀석. 12dependency 추가spring-boot-starter-aop 12345678910111213141516@Component@Aspectpublic class PerfAspect &#123; /** 요거가 Advice 이다. */ /** Around 안에있는 것이 Pointcut. */ @Around(&quot;execution(* me.whiteship..*.EventService.*(..))&quot;) public Object logPerf(ProceedingJoinPoint pjp) throw Throwable &#123; long begin = System.currentTimeMillis(); Object retVal = pjp.proceed(); System.out.println(System.currentTimeMillis() - begin); return retVal; &#125;&#125; Advice : 해야할 일PointCut : 적용되는 지점 AOP 정말 필요한 기능이였다. 프록시 패턴을 활용해서 AOP를 구현하는것 같다.-&gt; AOP는 보통 annotation으로 활용해서 쓰는게 좋다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** 이 어노테이션 정보를 어디까지 유지할 것인가. CLASS 라면 CLASS 까지 유지한다는 의미*/@Documented@Target(ElementType.METHOD)@Retention(RetentionPolicy.CLASS)public @interface PerLogging &#123;&#125;@Component@Aspectpublic class PerfAspect &#123; /** 요거가 Advice 이다. */ /** Around 안에있는 것이 Pointcut. */ @Around(&quot;@annotation(PerLogging)&quot;) public Object logPerf(ProceedingJoinPoint pjp) throw Throwable &#123; long begin = System.currentTimeMillis(); Object retVal = pjp.proceed(); System.out.println(System.currentTimeMillis() - begin); return retVal; &#125;&#125;public class SimpleEventService implements EventService &#123; @PerLogging @Override public void createEvent() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;Created an event&quot;); &#125; @PerLogging @Override public void publishEvent() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;Published an event&quot;); &#125; @Override public void deleteEvent() &#123; System.out.println(&quot;Deleted an event&quot;); &#125;&#125; 위처럼 annotation 기반으로도 Pointcut을 설정할 수 있다. 123456@Before(&quot;bean(simpleEventService)&quot;)public void hello() &#123; System.out.println(&quot;hello&quot;);&#125; 이렇게 빈으로도 등록이 가능. @Before 는 해당 메서드가 실행되기 이전에만 실행되게금. 12345어드바이스 정의@Before@AfterReturning@AfterThrowing@Around 123456포인트컷 정의@Pointcut@annotationbeanexecution.... Null-Safety @NonNull@Nullable@NonNullApi -&gt; 패키지 레벨에서 모두 Null을 허용하지 않게끔 설정@NonNullFields 런타임 시점에서 NullPointerException을 방지하기 위함. 12345678910public class EventService &#123; @NonNull public String createEvent(@NonNull String name) &#123; return &quot;hello &quot; + name; &#125;&#125; 메소드 위에다가 저 어노테이셔을 사용하면 Return 값이 Null을 허용하지 않는다는 의미이고파라미터 옆에다가 두면 보이는 그대로 파라미터를 Null 허용하지 않는다는 의미이다. 어노테이션이 효과가 없을 경우IDE에서 설정을 해야함 Intellij -&gt; Preferences -&gt; Compiler Spring resource path1234String path = new File(BatchLogWorkerThread.class.getResource(&quot;/&quot;).getPath()).getParent() + &quot;/&quot;;return new File(path + new SimpleDateFormat(&quot;yyyyMMdd&quot;).format(date) + &quot;_batchLog.xlsx&quot;);","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"}]},{"title":"Junit 예외 테스트하는 방법에 대한 고찰","slug":"2020-10-26-expected-exception","date":"2020-10-26T02:38:54.000Z","updated":"2022-05-31T07:18:41.000Z","comments":true,"path":"2020/10/26/","link":"","permalink":"http://kidongyun.github.io/2020/10/26/","excerpt":"","text":"테스트를 하게 되면 특정 예외를 발생시키는 코드에 대해서도 테스트를 해야할 경우가 있다. 예를 들면 파라미터 검증을 할 때 특정 값이 없다면 예외가 던져지는지 확인해야하고, 외부 연동을 하고 나서 응답 값이 비정상일 때에도 원하는 흐름대로 예외가 던져지는지 확인해야 한다. Junit을 활용하여 예외를 테스트하는 방법은 기본적으로 크게 어려운 것이 없어 단순하게 샘플 코드만을 제시했다. 123456789@Test(expected = Exception.class)public void refundFee_PnrIsNull() throws Exception &#123; ee.expect(Exception.class); ee.expectMessage(&quot;PNR 이 없습니다&quot;); airlineTW.refundFee(null);&#125; @Test 어노테이션에는 ‘expected’ 속성이 있으며 해당 속성에 예측되는 예외 클래스 타입을 적어주면 된다. 그러면 테스트 함수 내부에서 지정된 예외 클래스가 던져진다면 테스트는 성공이 되고 그렇지 않다면 실패한다. 던져지는 예외에 특정 메시지에 대한 여부도 테스트해야 할 경우에는 위와 같이 @Test 어노테이션 만으로는 불가능 하고 @Rule 어노테이션과 ExpectedException 객체를 활용해야 한다. 주의해야할 점은, ExpectedException 와 관련된 소스가 테스트하려는 비지니스 소스보다 상단에 존재해야 한다. 12345678910111213@Rulepublic ExpectedException ee = ExpectedException.none();@Testpublic void refundFee_PnrIsNull() throws Exception &#123; /* 이 소스가 테스트하려는 소스보다 위에 작성되어야 한다.*/ ee.expect(Exception.class); ee.expectMessage(&quot;PNR 이 없습니다&quot;); airlineTW.refundFee(null);&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Test","slug":"Test","permalink":"http://kidongyun.github.io/tags/Test/"}]},{"title":"Building Jpa with Querydsl","slug":"2020-10-26-querydsl-with-jpa","date":"2020-10-26T02:38:54.000Z","updated":"2022-05-31T07:18:52.000Z","comments":true,"path":"2020/10/26/","link":"","permalink":"http://kidongyun.github.io/2020/10/26/","excerpt":"","text":"Gradle 프로젝트 기준으로 JPA에 QueryDSL을 연동하는 방법을 알아본다. build.gradleQueryDSL은 QClass라는 객체를 자동으로 생성하고 이를 기반으로 타입 세이프한 쿼리를 작성할 수 있도록 돕는다. 이 QClass 객체들이 생성이 될 수 있도록 아래처럼 플러그인을 추가해줘야한다. 123456789plugins &#123; ... id &quot;com.ewerk.gradle.plugins.querydsl&quot; version &quot;1.0.10&quot; ...&#125; 아래는 QueryDSL 의존성 추가하는 코드이다. 123456789dependencies &#123; ... implementation &#x27;com.querydsl:querydsl-jpa&#x27; ...&#125; QueryDSL이 QClass를 만들 때 어느 경로에 생성할지와 같은 부가적인 설정 정보이다. 123456789101112131415161718192021222324def querydslDir = &quot;$buildDir/generated/querydsl&quot;querydsl &#123; jpa = true querydslSourcesDir = querydslDir&#125;sourceSets &#123; main.java.srcDir querydslDir&#125;configurations &#123; querydsl.extendsFrom compileClasspath&#125;compileQuerydsl &#123; options.annotationProcessorPath = configurations.querydsl&#125;test &#123; useJUnitPlatform()&#125; 여기까지 추가했다면 Gradle 탭을 열고 Gradle build를 하자. 그러면 위에서 설정한 경로에 QClass 파일이 생성될 것이다.확인해보자. QuerydslConfig.javaQueryDSL로 쿼리를 만들때 주로 사용하게 되는 객체는 JPAQueryFactory이다. 이 객체를 빈으로 등록하여 사용하자. 12345678910@Configurationpublic class QuerydslConfig &#123; @PersistenceContext private EntityManager entityManager; @Bean public JPAQueryFactory jpaQueryFactory() &#123; return new JPAQueryFactory(entityManager); &#125;&#125; EntityQueryDSL이 정상 동작하는지 확인하기 위해 샘플 Entity를 만든다. Cell.java1234567891011121314151617181920212223242526272829@Slf4j@Getter@Setter@ToString@SuperBuilder@NoArgsConstructor@AllArgsConstructor@Entity@Inheritance(strategy = InheritanceType.JOINED)public class Cell &#123; public enum Type &#123; Objective, Plan, Todo &#125; @Id @GeneratedValue protected Long id; protected LocalDateTime startDateTime; protected LocalDateTime endDateTime; protected String status; protected Type type; @ManyToOne(cascade = CascadeType.PERSIST) protected Member member;&#125; RepositoryQueryDSL이 정상 동작하는지 확인하기 위해 샘플 Repository 만든다. JpaRepository를 상속받는 메인 Repository를 만들고 Custom Repository를 만든다. 그 후에 Custom Repository의 구현체를 만들고 여기서 QueryDSL을 사용한다. CellRepository.java1234567891011121314151617@Transactionalpublic interface CellRepository&lt;T extends Cell&gt; extends JpaRepository&lt;T, Long&gt;, CellRepositoryCustom&lt;T&gt; &#123; List&lt;T&gt; findByType(Cell.Type type);&#125;public interface CellRepositoryCustom&lt;T extends Cell&gt; &#123;&#125;@RequiredArgsConstructorpublic class CellRepositoryCustomImpl&lt;T extends Cell&gt; implements CellRepositoryCustom&lt;T&gt; &#123; private final JPAQueryFactory queryFactory; &#125; You could use this repository when you need to create more complexible query. It’s operated by querydsl. ObjectiveQueryRepository.java12345678910111213@RequiredArgsConstructor@Repositorypublic class ObjectiveQueryRepository &#123; private final JPAQueryFactory queryFactory; public List&lt;Objective&gt; findByTitle(String title) &#123; return queryFactory.selectFrom(objective) .where(objective.title.eq(title)) .fetch(); &#125;&#125; You can make a various queries using both method-query and querydsl. TestFinally we can use the querydsl. 1234567891011121314151617181920212223242526272829@SpringBootTestclass ObjectiveRepositoryTest &#123; @Autowired private ObjectiveRepository objectiveRepository; @Autowired private ObjectiveQueryRepository objectiveQueryRepository; @Test void save() &#123; Objective obj = Objective.builder() .title(&quot;title&quot;) .priority(1) .status(1) .startDateTime(LocalDateTime.now()) .endDateTime(DateTimeUtil.of(2021, 4, 30)) .description(&quot;It&#x27;s description&quot;) .build(); objectiveRepository.save(obj); List&lt;Objective&gt; result = objectiveQueryRepository.findByTitle(&quot;title&quot;); System.out.println(result2); &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Jpa","slug":"Jpa","permalink":"http://kidongyun.github.io/tags/Jpa/"}]},{"title":"Reflection technique","slug":"2020-10-23-reflection","date":"2020-10-23T02:38:54.000Z","updated":"2022-05-31T07:18:35.000Z","comments":true,"path":"2020/10/23/","link":"","permalink":"http://kidongyun.github.io/2020/10/23/","excerpt":"","text":"Creating new instanceCreating new instance using Reflection technique means You would call the contructor of the class.First of all, you gotta set the parameters for the constructor. Create Class&lt;?&gt; by Class name1Class&lt;T&gt; clazz = (Class&lt;T&gt;) Class.forName(&quot;CLASSNAME&quot;); You could do either like this. Setting Parameters1Class[] classArgs = &#123;Map.class, Map.class&#125;; Setting Contruction method1Constructor constructor = clazz.getDeclaredConstructor(classArgs); Create new instance1Object obj = constructor.newInstance(map1, map2); Access All fields12345678Field[] fields = object.getClass().getDeclaredFields();for(Field field : fields) &#123; field.getName(); // It&#x27;s the name of that field field.getType(); // It&#x27;s the type of that field like String, int or some custom object&#125; Getter/Setter Invoke12345678910111213141516171819202122232425262728293031323334353637383940414243444546private void callSetter(Object obj, String fieldName, Object value)&#123; PropertyDescriptor pd; try &#123; pd = new PropertyDescriptor(fieldName, obj.getClass()); pd.getWriteMethod().invoke(obj, value); &#125; catch (IntrospectionException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;private void callGetter(Object obj, String fieldName)&#123; PropertyDescriptor pd; try &#123; pd = new PropertyDescriptor(fieldName, obj.getClass()); System.out.println(&quot;&quot; + pd.getReadMethod().invoke(obj)); &#125; catch (IntrospectionException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;public static void main(String[] args) &#123; GetterAndSetter gs = new GetterAndSetter(); TestClass tc = new TestClass(); gs.callSetter(tc, &quot;name&quot;, &quot;John&quot;); gs.callSetter(tc, &quot;value&quot;, 12); gs.callSetter(tc, &quot;flag&quot;, true); // Getting fields of the class Field[] fields = tc.getClass().getDeclaredFields(); for(Field f : fields)&#123; String fieldName = f.getName(); System.out.println(&quot;Field Name -- &quot; + fieldName); &#125; gs.callGetter(tc, &quot;name&quot;); gs.callGetter(tc, &quot;value&quot;); gs.callGetter(tc, &quot;flag&quot;);&#125; They are offered from PropertyDescriptor object. But i think it’s too restrict. so You can invoke just a getter method via the getter name. 1234567891011121314private static &lt;T&gt; String getter(T t, String fieldName) &#123; try &#123; String getterMethodName = &quot;get&quot; + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1); Method method = t.getClass().getDeclaredMethod(getterMethodName); return String.valueOf(method.invoke(t)); &#125; catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123; log.info(e.toString()); e.printStackTrace(); return &quot;&quot;; &#125;&#125; 1234567891011121314@SuppressWarnings(&quot;unchecked&quot;)public static &lt;T, U&gt; List&lt;T&gt; map(List&lt;U&gt; srcs, String fieldName, Class&lt;T&gt; clazz) throws NoSuchFieldException, IllegalAccessException &#123; List&lt;T&gt; res = new ArrayList&lt;&gt;(); for(U src : srcs) &#123; Field field = src.getClass().getDeclaredField(fieldName); field.setAccessible(true); res.add((T) field.get(src)); &#125; return res;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"Importing Hexo Project","slug":"2020-10-19-import-hexo-project","date":"2020-10-19T02:38:54.000Z","updated":"2022-05-31T07:18:05.000Z","comments":true,"path":"2020/10/19/","link":"","permalink":"http://kidongyun.github.io/2020/10/19/","excerpt":"","text":"Creating the directory.let’s create the directory which is used the root directory of your hexo project. Pulling your git repository.123&gt; git init&gt; git remote add origin [YOUR GIT REPOSITORY]&gt; git pull origin master You just initialize the git in your hexo project and connect with you remote repository. and finally pulling the codes. Installing node modules.You should install the packages for using hexo. I think the two commands would operate well each alone. I just always do these both. 12&gt; npm install&gt; yarn Downloading your own hexo themeIf you use the hexo theme, then download it from somewhere and copy and paste to ‘directory/themes/‘ and You should check the ‘config.yml’ file name whether it is needed transition or not. 12&gt; mv [YOUR THEME] ./directory/themes&gt; delete &#x27;.example&#x27; at &#x27;config.yml.example&#x27; Launching local Hexo serverLet’s check your thing is operated well or not. 1&gt; hexo server Installing Git deploy package.You gotta need to install ‘hexo-deployer-git’ package to upload your hexo project to remote using git. 1&gt; npm install --save hexo-deployer-git Uploading Hexo1&gt; hexo deploy --generate Git source upload123&gt; git add .&gt; git commit -m &quot;COMMENT&quot;&gt; git push -u origin master You should know one thing that the real source code and hexo project are sperated. so you gotta push both two repositories.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://kidongyun.github.io/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"http://kidongyun.github.io/tags/Hexo/"}]},{"title":"Checking network status using telnet command","slug":"2020-10-12-check-network-using-telnet","date":"2020-10-11T15:00:00.000Z","updated":"2022-05-31T07:17:58.000Z","comments":true,"path":"2020/10/12/","link":"","permalink":"http://kidongyun.github.io/2020/10/12/","excerpt":"","text":"telnet actually is operated on 23 port number. but if you just check the network status whether it’s opened or blocked, you can use telnet command. 1&gt; telnet 180.70.98.168 6393 If it is opened, It would give the messages like the below. 123Trying 180.70.98.168...Connected to 180.70.98.168.Escape character is &#x27;^]&#x27;. Or not 1Trying 180.70.98.168...","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://kidongyun.github.io/tags/Network/"},{"name":"Telnet","slug":"Telnet","permalink":"http://kidongyun.github.io/tags/Telnet/"}]},{"title":"How to use Jira Client","slug":"2020-10-08-jira-client","date":"2020-10-08T05:30:54.000Z","updated":"2022-05-31T07:17:48.000Z","comments":true,"path":"2020/10/08/","link":"","permalink":"http://kidongyun.github.io/2020/10/08/","excerpt":"","text":"DependencyYou could refer ‘https://mvnrepository.com/artifact/net.rcarz/jira-client/0.5‘ site. 1compile group: &#x27;net.rcarz&#x27;, name: &#x27;jira-client&#x27;, version: &#x27;0.5&#x27; Usage of Jira Client libraryCreating Credentials Object.Most of Jira sites have an authentication system. You could sign in to there using this object. 1BasicCredentials creds = new BasicCredentials(&quot;ID&quot;, &quot;PASSWORD&quot;); Creating Jira Client.Jira Client means a sort of the clients using this system. but It’s a robot not a human. 1JiraClient jiraClient = new JiraClient(&quot;https://pms.interpark.com/&quot;); If you should enter there with authentication then add credential object as second parameter. 1JiraClient jiraClient = new JiraClient(&quot;https://pms.interpark.com/&quot;, creds); Connecting Issue.You could connect issue using the below code. 1Issue issue = jiraClient.getIssue(&quot;AIRDEV-176&quot;); Add WatcherYou could add the watchers using the name of each users. 12345/* adding itself */issue.addWatcher(jiraClient.getSelf());/* adding another user */issue.addWatcher(&quot;USERNAME&quot;); Add CommentYou could add the comments 12345/* It&#x27;s default */issue.addComment(&quot;It&#x27;s the test written by Jira-Client.&quot;);/* If you need to set the scope of the comment as the project members */issue.addComment(&quot;It&#x27;s the test written with 2 parameters by Jira-Client&quot;, &quot;role&quot;, &quot;Developers&quot;); Get Reporter Informations12System.out.println(&quot;Reporter: &quot; + issue.getReporter());System.out.println(&quot;Reporter&#x27;s Name: &quot; + issue.getReporter().getDisplayName()); Change the assignee123issue.update() .field(Field.ASSIGNEE, &quot;batman&quot;) .execute(); Change transition12issue.transition() .execute(&quot;HOLDING&quot;); Add/Remove Label (It’s like Hashtag)1234issue.update() .fieldAdd(Field.LABELS, &quot;baz&quot;) .fieldRemove(Field.LABELS, &quot;foo&quot;) .execute(); Change Summary123issue.update().field(Field.SUMMARY, &quot;tubes are clogged&quot;).execute(); Change Priority123issue.update().field(Field.PRIORITY, Field.valueById(&quot;1&quot;)).execute(); Add Attachment12File file = new File(&quot;C:\\\\Users\\\\John\\\\Desktop\\\\screenshot.jpg&quot;);issue.addAttachment(file); Create a new Issue123456Issue newIssue = jira.createIssue(&quot;TEST&quot;, &quot;Bug&quot;) .field(Field.SUMMARY, &quot;Bat signal is broken&quot;) .field(Field.DESCRIPTION, &quot;Commissioner Gordon reports the Bat signal is broken.&quot;) .field(Field.REPORTER, &quot;batman&quot;) .field(Field.ASSIGNEE, &quot;robin&quot;) .execute(); 1234567891011121314/* Creating Authentication */BasicCredentials creds = new BasicCredentials(&quot;ID&quot;, &quot;PASSWORD&quot;);/* Creating Jira Client is needed url of your site and It could take the credential object optionally */JiraClient jiraClient = new JiraClient(&quot;https://pms.interpark.com/&quot;, creds);/* Connecting issue of jira */Issue issue = jiraClient.getIssue(&quot;AIRDEV-176&quot;); issue.addWatcher(jiraClient.getSelf()); issue.addWatcher(&quot;N10135&quot;); Custom Field Select Box123456789List&lt;CustomFieldOption&gt; cfselect = Field.getResourceArray( CustomFieldOption.class, issue.getField(&quot;customfield_11928&quot;), jira.getRestClient());for (CustomFieldOption cfo : cfselect) log.info(&quot;Custom Field Select: &quot; + cfo.getValue());","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Jira","slug":"Jira","permalink":"http://kidongyun.github.io/tags/Jira/"}]},{"title":"How to use POI library","slug":"2020-10-08-poi-excel","date":"2020-10-08T05:30:54.000Z","updated":"2022-05-31T07:17:53.000Z","comments":true,"path":"2020/10/08/","link":"","permalink":"http://kidongyun.github.io/2020/10/08/","excerpt":"","text":"Dependency123compile group: &#x27;org.apache.xmlbeans&#x27;, name: &#x27;xmlbeans&#x27;, version: &#x27;3.1.0&#x27;compile group: &#x27;org.apache.commons&#x27;, name: &#x27;commons-compress&#x27;, version: &#x27;1.18&#x27;compile group: &#x27;org.apache.commons&#x27;, name: &#x27;commons-collections4&#x27;, version: &#x27;4.1&#x27; Create Workbook1Workbook xlsxWb = new XSSFWorkbook(); Create Sheet1Sheet sheet = xlsxWb.createSheet(&quot;SHEETNAME&quot;); Create Row1Row row = sheet.createRow(0); Create Cell1Cell cell = row.createCell(0);","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Excel","slug":"Excel","permalink":"http://kidongyun.github.io/tags/Excel/"}]},{"title":"The way how create object in Java","slug":"2020-10-5-java-create-object","date":"2020-10-04T23:47:54.000Z","updated":"2022-05-31T07:17:42.000Z","comments":true,"path":"2020/10/05/","link":"","permalink":"http://kidongyun.github.io/2020/10/05/","excerpt":"","text":"1. Static Factory MethodThe java language offer to us the constructor for creating new object. It’s simplest way to do that but It has a lot of limitation.So We would study the new way for creating java object. It’s the Static Factory Method. 1-1. Naming.12345678910111213141516171819class Person &#123; private int age; /* It&#x27;s the constructor */ public Person(int age) &#123; this.age = age; &#125; /* Below two things are static factory method. */ public static Person young() &#123; return new Person(20); &#125; public static Person elder() &#123; return new Person(70); &#125;&#125; If you use the static factory method pattern then your source code could have the readability than the only constructor.The example is too simple so you might not be able to understand the needs of it. but Let’s imagine your class is bigger than this.The larger than larger things should need like static factory method pattern. The main advantage of static factory method is It could have the name to enable express the purpose of the method.but the constructor can’t do this. The name of some method is always important for the readability. 1-2. Instance-ControlledThe constructor always creates new instances, which need a new space for keeping itself. but static factory method wouldn’tbe as your building code. 1234567891011121314151617181920class Person &#123; private static Person person = new Person(0); private int age; public Person(int age) &#123; this.age = age; &#125; public static Person young() &#123; person.age = 20; return person; &#125; public static Person old() &#123; person.age = 70; return person; &#125;&#125; It’s singleton pattern. As you can see the above, you can control the way to create the java object as the requirement.We have called ‘Instance-Controlled’ about these attributes. 1-3. It can be returned sub-classThe constructor can be returned only itself no sub-classes.but you could make the code more scalable if you use the static factory method like below. 12345678910111213141516171819class Person &#123; public static Person create(String type) &#123; if(&quot;man&quot;.equals(type)) &#123; return new Man(); &#125; if(&quot;woman&quot;.equals(type)) &#123; return new Woman(); &#125; return new Person(); &#125;&#125;class Man extends Person &#123;&#125;class Woman extends Person &#123;&#125; This person class can be returned all of the classes related to itself as the type parameter.but this code has a little disadvantage, which always add the new code whenever you create new sub-class.You could improve this code using reflection technique of java. 123456789101112131415class Person &#123; public static Person create(Class&lt;?&gt; clazz) throws Exception &#123; Class[] classArgs = &#123;&#125;; Constructor constructor = clazz.getDeclaredConstructor(classArgs); Object obj = constructor.newInstance(); return (Person) clazz.cast(obj); &#125;&#125;class Man extends Person &#123;&#125;class Woman extends Person &#123;&#125; 2. Builder2-1. When we have a lot of optional parameters.At this time, we would consider the situation, which have a lot of optional parameters. if we build it using the constructor,then the number of the constructors are should be increased exponentially. 12345678The number of fields : The number of constructors1 : 1 2 : 3 (= 2 + 1)3 : 6 (= 3 + 2 + 1)4 : 10 (= 4 + 3 + 2 + 1) ...10 : 45 (= 9 + 8 + ... + 2 + 1) It looks like that we should need to use different way certainly. the first one among them is Java Beans Pattern.It is also called getter/setter. 2-2. Java Beans PatternWe already know this way. It would use the getter/setter methods like the below code. 1234567891011121314151617181920212223242526272829303132333435class Person &#123; private String name; private String sex; private String country; private int age; public void setName(String name) &#123; this.name = name; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public void setCountry(String country) &#123; this.country = country; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;class Main &#123; public static void main(String[] args) &#123; Person person = new Person(); person.setName(&quot;John&quot;); person.setAge(25); person.setCountry(&quot;Japan&quot;); person.setSex(&quot;M&quot;); &#125;&#125; We could use this like the builder pattern if we return the class itself on the setter methods. 12345678910111213141516171819202122232425262728293031323334class Person &#123; private String name; private String sex; private String country; private int age; public Person setName(String name) &#123; this.name = name; &#125; public Person setSex(String sex) &#123; this.sex = sex; &#125; public Person setCountry(String country) &#123; this.country = country; &#125; public Person setAge(int age) &#123; this.age = age; &#125;&#125;class Main &#123; public static void main(String[] args) &#123; Person person = new Person() .setName(&quot;John&quot;) .setAge(25) .setCountry(&quot;Japan&quot;) .setSex(&quot;M&quot;); &#125;&#125; Main disadvantage of Setter methods is It couldn’t keep the consistency of the code.It means the person object could be accessed and changed from another code after completing to create an object. 1234567891011121314151617class Main &#123; public static void main(String[] args) &#123; /* It&#x27;s the initialization of Person object */ Person person = new Person() .setName(&quot;John&quot;) .setAge(25) .setCountry(&quot;Japan&quot;) .setSex(&quot;M&quot;); /* after this this person object can be changed. */ person.setAge(30); &#125;&#125; 2-3. BuilderIt is commonly used ways all programming world when we create objects especially python or scala. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Person &#123; private String name; private String sex; private String country; private int age; static class Builder &#123; private final Person person; public Builder() &#123; this.person = new Person(); &#125; public Builder name(String val) &#123; this.person.name = val; return this; &#125; public Builder sex(String val) &#123; this.person.sex = val; return this; &#125; public Builder country(String val) &#123; this.person.country = val; return this; &#125; public Builder age(int val) &#123; this.person.age = val; return this; &#125; public Person build() &#123; return this.person; &#125; &#125;&#125;class Main &#123; public static void main(String[] args) &#123; Person person = new Person.Builder() .name(&quot;John&quot;) .age(25) .country(&quot;Japan&quot;) .sex(&quot;M&quot;) .build(); &#125;&#125; This way should keep the consistency. That means It could not change the object attributes after creating instance.Many things are similar with Setter pattern. It would be only main difference between them. It’s little difficult to use builder pattern when you object has hierarchy structure.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"SSL","slug":"2020-09-17-ssl","date":"2020-09-16T15:00:00.000Z","updated":"2022-05-31T07:17:09.000Z","comments":true,"path":"2020/09/17/","link":"","permalink":"http://kidongyun.github.io/2020/09/17/","excerpt":"","text":"1.2. SSL은 뭐고, 인증서는 뭔가?Secure Socket Layer(SSL) 프로토콜은 넷스케이프사에서 웹서버와 브라우저 간의 보안 통신을 위해 만들어졌다. SSL은 통신할 때 인증기관(Certificate Authority, CA)라는 것을 이용해서 서로 인식하게끔 되어 있다. 이 과정을 간단하게 설명하면 다음과 같다. [웹브라우저] 보안 페이지를 요청한다. (일반적으로 주소에 https:// 라고 붙는다). [웹서버] 자신의 공개키를 인증서와 함께 웹브라우저로 보낸다. [웹브라우저] 웹서버의 인증서가 신뢰할 수 있는 제3자(신뢰할 수 있는 루트 인증기관,Trusted root CA)에게 서명되었는지 확인한다. 그리고 인증서가 아직 유효한지, 그리고 접속하려는 사이트와 연관되어 있는지 최종 확인한다. [웹브라우저] 최종 확인이 되었으면 웹브라우저는 대칭 암호화키(대칭키)를 생성해서 웹서버의 공개키로 암호화한 후 송신한다. URL이나 기타 HTTP 데이터는 방금 생성한 대칭키를 이용해서 암호화한 후 웹서버로 전송한다. [웹서버] 자신의 개인키를 이용해서 수신한 대칭키의 암호를 풀고, 이것을 이용해서 나머지 URL이나 기타 HTTP 데이터의 암호를 푼다. [웹서버] 처리 결과(HTML문서+HTTP데이터)를 대칭키를 이용해서 암호화한 후 웹브라우저로 전송한다. [웹브라우저] 대칭키를 이용해서 HTTP데이터와 HTML문서의 암호를 풀고 화면에 출력한다. 위 개념은 SSL의 기본 동작 원리이므로 반드시 이해하고 넘어가야 한다. 다음 장에서 각 용어에 대해 자세히 설명할 것이다. 1.2.1. Private Key/Public Key:개인키/공개키개인키/공개키 암호의 가장 큰 특징은 하나의 키로 암호화를 하면, 해당되는 쌍의 다른 키로만 풀 수 있는 점이다. 예를 들어 A키와 B키가 하나의 쌍이라면, A키로 암호화를 하면 B키로만 풀 수 있으며, B키로 암호화를 하면 A키로만 풀 수 있다. 이 특징이 이해하기 어려울 수도 있지만, 일단 그렇다고 암기하는 것이 좋다. 이러한 키는 소수(Prime numbers)를 기반으로 생성되며, 그 길이(bit단위)가 길수록 암호화의 강도가 쎄진다. 개인키/공개키는 이러한 이론을 바탕으로 약간 응용한 기법이다. 하나의 키는 비밀로 간직하고, 다른 키는 모두에게 공개한다. 그렇게하면 다른 사람들이 여러분에게 메시지를 보낼 때 공개키를 이용해서 암호화된 메시지를 보낼 수 있다. 이 메시지는 비밀키를 가지고 있는, 여러분 혼자만이 풀 수 있다. 그렇다면 반대의 경우엔 어떻게 될까? 메시지를 개인키로 암호화해서 보낸다면 어떻게 될까? 이 경우에는 모든 사람이 메시지를 열어볼 수 있을 것이다. 하지만 특정 개인키를 가지고 암호화했다는 것이 증명되기 때문에, 특정인이 보낸 메시지라는 것을 증명할 수 있다. 주의해야할 점은 메시지를 보낸 사람이 누구라는 것을 증명할 뿐이지, 메시지 자체는 모든 사람이 열어볼 수 있다는 것이다! 이제 서로 간에 공개키를 주고받기만 하면 된다. 그냥 상대방에게 공개키를 보내달라고만 하자. 어짜피 공개되어도 무방한 키이기 때문에 별다른 보안장치 필요없이 인증서와 함께 전송하면 된다. 평문—&gt;[공개키]—&gt;암호화된 메시지—&gt;[개인키]—&gt;평문1.2.2. 인증서자. 앞에서 개인키/공개키 기법을 익혔으니 그것을 적용하기만 하면 된다. 하지만 잘 생각해보면 뭔가 문제가 있다는 것을 깨달을 수 있을 것이다. 내가 받은 공개키가 그 사람(또는 웹사이트)의 것이라는 것을 어떻게 알 수 있을까? 혹시 제3자가 상대방을 가장해서 보낸 것이 아닐까? 이를 확인하기 위해 일일히 직접 상대방을 찾아가 볼 수도 없는 노릇이다. 이를 해결하기 위해서 모든 사람이 믿을 수 있는 제 3자가 나서게 된다. 그 사람의 인증서는 너무나도 유명해서 기본적으로 모든 사람이 알고 있다고 해보자. 그 사람은 특정 키가 그 사람의 것이라는 서명한 인증서를 발급한다. 여기에는 E-mail 주소, 소유자의 이름, 인증서 사용 용도, 유효기간, 위치, Common Name(CN, 웹사이트 주소나 E-mail 주소), 인증서ID 등등의 정보가 저장되어 있다. 그리고 마지막으로 이 정보를 공개키와 공개키의 해쉬값과 같이 저장해서 인증서를 만든다. 이러한 개념은 신뢰하고 있는 사람이 서명한 인증서 역시 신뢰할 수 있다는 생각을 전제로 한 것이다. 이런 신뢰 관계가 트리 형태로 형성되어 점점 불어난다. 웹브라우저의 경우를 살펴보자. 신뢰할 수 있는 제 3자의 인증서는 인증기관(Certification Authorities, CA), 또는 루트 인증기관(Root CA)이라고 불리며, 브라우저속에 기본적으로 내장되어 있다. 이러한 CA는 인증서나 인증 철회된 인증서 목록을 전문적으로 관리하는 기관이다. CA가 서명한 인증서는 조금이라도 변경되면 서명이 깨지기 때문에 안전하다. 인증서를 서명할 때 자신의 개인키로 서명할 수도 있다. 이러한 인증서는 자체 서명 인증서(Self signed certificate)라고 불린다. 모든 루트 인증기관의 인증서는 자체 서명되어 있다. Certificate: Data: Version: 3 (0x2) Serial Number: 1 (0x1) Signature Algorithm: md5WithRSAEncryption Issuer: C=FJ, ST=Fiji, L=Suva, O=SOPAC, OU=ICT, CN=SOPAC Root CA/Email=administrator@sopac.org Validity Not Before: Nov 20 05:47:44 2001 GMT Not After : Nov 20 05:47:44 2002 GMT Subject: C=FJ, ST=Fiji, L=Suva, O=SOPAC, OU=ICT, CN=www.sopac.org/Email=administrator@sopac.org Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public Key: (1024 bit) Modulus (1024 bit): 00:ba:54:2c:ab:88:74:aa:6b:35:a5:a9:c1:d0:5a: 9b:fb:6b:b5:71:bc:ef:d3:ab:15:cc:5b:75:73:36: b8:01:d1:59:3f:c1:88:c0:33:91:04:f1:bf:1a:b4: 7a:c8:39:c2:89:1f:87:0f:91:19:81:09:46:0c:86: 08:d8:75:c4:6f:5a:98:4a:f9:f8:f7:38:24:fc:bd: 94:24:37:ab:f1:1c:d8:91:ee:fb:1b:9f:88:ba:25: da:f6:21:7f:04:32:35:17:3d:36:1c:fb:b7:32:9e: 42:af:77:b6:25:1c:59:69:af:be:00:a1:f8:b0:1a: 6c:14:e2:ae:62:e7:6b:30:e9 Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Basic Constraints: CA:FALSE Netscape Comment: OpenSSL Generated Certificate X509v3 Subject Key Identifier: FE:04:46:ED:A0:15:BE:C1:4B:59:03:F8:2D:0D:ED:2A:E0:ED:F9:2F X509v3 Authority Key Identifier: keyid:E6:12:7C:3D:A1:02:E5:BA:1F:DA:9E:37:BE:E3:45:3E:9B:AE:E5:A6 DirName:/C=FJ/ST=Fiji/L=Suva/O=SOPAC/OU=ICT/CN=SOPAC Root CA/Email=administrator@sopac.org serial:00 Signature Algorithm: md5WithRSAEncryption 34:8d:fb:65:0b:85:5b:e2:44:09:f0:55:31:3b:29:2b:f4:fd: aa:5f:db:b8:11:1a:c6:ab:33:67:59:c1:04:de:34:df:08:57: 2e:c6:60:dc:f7:d4:e2:f1:73:97:57:23:50:02:63:fc:78:96: 34:b3:ca:c4:1b:c5:4c:c8:16:69:bb:9c:4a:7e:00:19:48:62: e2:51:ab:3a:fa:fd:88:cd:e0:9d:ef:67:50:da:fe:4b:13:c5: 0c:8c:fc:ad:6e:b5:ee:40:e3:fd:34:10:9f:ad:34:bd:db:06: ed:09:3d:f2:a6:81:22:63:16:dc:ae:33:0c:70:fd:0a:6c:af: bc:5a ——-BEGIN CERTIFICATE——- MIIDoTCCAwqgAwIBAgIBATANBgkqhkiG9w0BAQQFADCBiTELMAkGA1UEBhMCRkox DTALBgNVBAgTBEZpamkxDTALBgNVBAcTBFN1dmExDjAMBgNVBAoTBVNPUEFDMQww CgYDVQQLEwNJQ1QxFjAUBgNVBAMTDVNPUEFDIFJvb3QgQ0ExJjAkBgkqhkiG9w0B CQEWF2FkbWluaXN0cmF0b3JAc29wYWMub3JnMB4XDTAxMTEyMDA1NDc0NFoXDTAy MTEyMDA1NDc0NFowgYkxCzAJBgNVBAYTAkZKMQ0wCwYDVQQIEwRGaWppMQ0wCwYD VQQHEwRTdXZhMQ4wDAYDVQQKEwVTT1BBQzEMMAoGA1UECxMDSUNUMRYwFAYDVQQD Ew13d3cuc29wYWMub3JnMSYwJAYJKoZIhvcNAQkBFhdhZG1pbmlzdHJhdG9yQHNv cGFjLm9yZzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAulQsq4h0qms1panB 0Fqb+2u1cbzv06sVzFt1cza4AdFZP8GIwDORBPG/GrR6yDnCiR+HD5EZgQlGDIYI 2HXEb1qYSvn49zgk/L2UJDer8RzYke77G5+IuiXa9iF/BDI1Fz02HPu3Mp5Cr3e2 JRxZaa++AKH4sBpsFOKuYudrMOkCAwEAAaOCARUwggERMAkGA1UdEwQCMAAwLAYJ YIZIAYb4QgENBB8WHU9wZW5TU0wgR2VuZXJhdGVkIENlcnRpZmljYXRlMB0GA1UdDgQWBBT+BEbtoBW+wUtZA/gtDe0q4O35LzCBtgYDVR0jBIGuMIGrgBTmEnw9oQLl uh/anje+40U+m67lpqGBj6SBjDCBiTELMAkGA1UEBhMCRkoxDTALBgNVBAgTBEZp amkxDTALBgNVBAcTBFN1dmExDjAMBgNVBAoTBVNPUEFDMQwwCgYDVQQLEwNJQ1Qx FjAUBgNVBAMTDVNPUEFDIFJvb3QgQ0ExJjAkBgkqhkiG9w0BCQEWF2FkbWluaXN0 cmF0b3JAc29wYWMub3JnggEAMA0GCSqGSIb3DQEBBAUAA4GBADSN+2ULhVviRAnw VTE7KSv0/apf27gRGsarM2dZwQTeNN8IVy7GYNz31OLxc5dXI1ACY/x4ljSzysQb xUzIFmm7nEp+ABlIYuJRqzr6/YjN4J3vZ1Da/ksTxQyM/K1ute5A4/00EJ+tNL3b Bu0JPfKmgSJjFtyuMwxw/Qpsr7xa——-END CERTIFICATE——-위 내용은 인증서 샘플이다. 위에서 볼 수 있다시피 인증서는 서명자의 정보, 인증서 주인의 공개키, 인증서 유효기간, 인증서 서명값 등으로 이루어져 있다. 비밀키는 인증서에 들어가 있지 않으며, 절대로 들어가서도 안되고 노출되어서도 안된다. 이 인증서를 가지고 인증서 주인에게 암호화된 메시지를 보낼 수 있으며, 인증서 주인이 보낸 메시지가 진짜라는 것을 확인할 수 있다. 1.2.3. 대칭키공개키 기반 암호화 알고리즘은 정말 강력한 알고리즘이다. 하지만 실전에서 써먹을려고 하면 좀 생각해봐야 한다. 공개키 기반 암호화 알고리즘은 비대칭 형태이기 때문에 복호화를 하기 위해서는 다른 키가 반드시 필요하다. 암호화한 키로는 암호화만 가능할 뿐, 풀 수가 없다. 반면에 대칭키 기반 알고리즘은 하나의 키로 암호화하고 해독한다. 보안 측면에서는 키가 노출될 가능성이 적은 공개키 기반 암호화 알고리즘이 안전하다. 하지만 공개키 기반 알고리즘의 문제점은 너무 느리다는 것이다. 그렇다면 안전하고 속도도 빠른 방법은 없을까? 해결책은 대칭키를 공개키로 암호화해서 전송하면 된다. 물론 개인키는 전송할 필요도 없고, 해서도 안된다. 이렇게 하면 대칭키는 송,수신자만 알아볼 수 있다. 여기에다 대칭키를 랜덤으로 생성하는 기능까지 넣으면 혹시 한번 누출되더라도 다음 통신할 때는 다른 키를 사용하기 때문에 안전하다. 이렇게 대칭키를 송신한 후에는 대칭키를 가지고 암호화해서 통신하면 된다. keytools 사용법 특정 스토어의 인증서 목록 확인D:\\interpark\\air\\java\\jdk1.8.0_161\\jre\\bin&gt;keytool -list -keystore “D:\\interpark\\air\\java\\jdk1.8.0_161\\jre\\lib\\security\\cacerts” 특정 스토어에 특정 인증서 추가D:\\interpark\\air\\java\\jdk1.8.0_161\\jre\\bin&gt;keytool -import -file “D:\\kidongyun\\ca\\jinair_com_HQSSL.pem” -keystore “D:\\interpark\\air\\java\\jdk1.8.0_161\\jre\\lib\\security\\cacerts” -storepass “changeit” portecie 사용법 java 에는 기본적으로 루트 CA가 있따.여기에다가 각 hostname 별로 인증서를 만들고 로컬일경우 이걸 바라보도록 수정한거임.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"}]},{"title":"Static Factory Method","slug":"2020-09-15-java-static-factory-method","date":"2020-09-14T23:47:54.000Z","updated":"2022-05-31T07:16:59.000Z","comments":true,"path":"2020/09/15/","link":"","permalink":"http://kidongyun.github.io/2020/09/15/","excerpt":"","text":"Static Factory MethodWe have often used the constructor when You need to create the object. because This function is basically offered a lot of the programming languages like Java, C++, JS, python and so on. But actually, It is only a basic technique not good thing. We could get a lot of advantage if use the static factory method techniques not the constructor. The advantages1. Readability ( You could give the names for these functions. )1234567891011121314151617181920212223242526272829303132class Member &#123; private String name; private String type; public Member(String name, String type) &#123; this.name = name; this.type = type; &#125; public static Member ofGold(String name) &#123; return new Member(name, &quot;GOLD&quot;); &#125; public static Member ofPlatinum(String name) &#123; return new Member(name, &quot;PLATINUM&quot;); &#125;&#125;class Main &#123; public static void main(String[] args) &#123; /* We want to create the member object who has the each another level. */ /* The case using the constructor */ Member gold = new Member(&quot;John&quot;, &quot;GOLD&quot;); Member platinum = new Member(&quot;John&quot;, &quot;PLATINUM&quot;); /* The case using the static factory method */ Member gold = Member.ofGold(&quot;John&quot;); Member platinum = Member.ofPlatinum(&quot;John&quot;); &#125;&#125; If a parameters of Member are more than now, the way using constructor would be difficult to read on the source code.And If the most of parameter types are number then It’s also too hard to read those. 2. Immutability. ( You could create the java object on singleton pattern. )The constructor should create the new one whenever you use that although you don’t need it. 123456789101112131415161718192021class God &#123; private Member member; public static Member valueOf(String name) &#123; if(member == null) &#123; member = new Member(); &#125; this.member.setName(name); return this.member; &#125;&#125;class Main &#123; public static void main(String[] args) &#123; Member hera = God.valueOf(&quot;Hera&quot;); Member apollo = God.valueOf(&quot;Apollo&quot;); &#125;&#125; A constructor always use with ‘new’ keyword so It’ too hard to create the object as the singleton type when you use a constructor way.We could achieve the immutability attribute like the above way whenever we want to do that.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"Dockerfile","slug":"2020-09-07-dockerfile","date":"2020-09-08T15:00:00.000Z","updated":"2022-05-31T07:16:40.000Z","comments":true,"path":"2020/09/09/","link":"","permalink":"http://kidongyun.github.io/2020/09/09/","excerpt":"","text":"docker run oracle example1docker run -d -p 59160:22 -p 59161:1521 jaspeen/oracle-xe-11g DockerfileENTRYPOINTThis keyword is used to execute some scripts when you start docker container. That is this keword related to the command ‘docker run’, ‘docker start’It can use only one time in Dockerfile. FROM [IMAGENAME:IMAGETAG]it could define the image name and image tag. If you use this keyword then the dockerfile would import the image written with this.‘lastest’ would be default value if you don’t specify image tag. 1FROM ubuntu:14.04 BUILD CONTEXTIt’s usually a directory, which have files is needed when you do docker build. ENVYou can set the environment variables using this keyword. and you can also get this like ‘${ENV_NAME}’ or $ENV_NAME 12345/* SET */ENV SCOUTER_SERVER=$scouter_ip/* GET */#&#123;SCOUNTER_SERVER&#125; VOLUMEThis keyword can set the shareable directory with a host when you create container. and It could be array type. 1VOLUME /home/volume ARGIt’s similar with the parameters of programming languages. You can access some value is came from outside of docker container. it should be set with ‘—build-arg’ option when you build dockerfile. 1docker build --build-arg my_arg=/home","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Container","slug":"Container","permalink":"http://kidongyun.github.io/tags/Container/"},{"name":"Docker","slug":"Docker","permalink":"http://kidongyun.github.io/tags/Docker/"}]},{"title":"Summary Oracle Query Briefly","slug":"2020-09-09-oracle-query","date":"2020-09-08T15:00:00.000Z","updated":"2022-05-31T07:16:52.000Z","comments":true,"path":"2020/09/09/","link":"","permalink":"http://kidongyun.github.io/2020/09/09/","excerpt":"","text":"UNIONIt would resort when your select queries are merged. 1234567SELECT DCI_TKT_CAR, DCI_USE_YN, DCI_CLASS, DCI_CLASS_DESC FROM DOM_CLASS_INFO WHERE LENGTH(DCI_CLASS) = 1 AND DCI_TKT_CAR = &#x27;LJ&#x27;UNIONSELECT DCI_TKT_CAR, DCI_USE_YN, DCI_CLASS, DCI_CLASS_DESC FROM DOM_CLASS_INFO WHERE LENGTH(DCI_CLASS) != 1 AND DCI_TKT_CAR = &#x27;LJ&#x27; AND DCI_CLASS_DESC = &#x27;할인석&#x27;UNIONSELECT DCI_TKT_CAR, DCI_USE_YN, DCI_CLASS, DCI_CLASS_DESC FROM DOM_CLASS_INFO WHERE LENGTH(DCI_CLASS) != 1 AND DCI_TKT_CAR = &#x27;LJ&#x27; AND DCI_CLASS_DESC = &#x27;특가석&#x27; UNION ALLIt should keep the sorting status each the result of queries. And You should remember just one thing, which you couldn’t use the ‘order by’ keyword for each select queries whenyou want to use the ‘union’ or ‘union all’ keyword. 1234567SELECT DCI_TKT_CAR, DCI_USE_YN, DCI_CLASS, DCI_CLASS_DESC FROM DOM_CLASS_INFO WHERE LENGTH(DCI_CLASS) = 1 AND DCI_TKT_CAR = &#x27;LJ&#x27;UNION ALLSELECT DCI_TKT_CAR, DCI_USE_YN, DCI_CLASS, DCI_CLASS_DESC FROM DOM_CLASS_INFO WHERE LENGTH(DCI_CLASS) != 1 AND DCI_TKT_CAR = &#x27;LJ&#x27; AND DCI_CLASS_DESC = &#x27;할인석&#x27;UNION ALLSELECT DCI_TKT_CAR, DCI_USE_YN, DCI_CLASS, DCI_CLASS_DESC FROM DOM_CLASS_INFO WHERE LENGTH(DCI_CLASS) != 1 AND DCI_TKT_CAR = &#x27;LJ&#x27; AND DCI_CLASS_DESC = &#x27;특가석&#x27; LENGTH([FIELD_NAME])Having you wanted to know the length of some field, You can use this. 1LENGTH(&#x27;A&#x27;) = 1 // It would be true. COUNT(*) AS CNT1234567DBResultSet rset = db.executeQuery(sql.toString(), new Object[] &#123; prId &#125;);if(rset.next())&#123; return rset.getInt(&quot;CNT&quot;);&#125; INSTR()오라클에서 내가 원하는 컬럼의 값에 내가 원하는 구문이 포함되어 있는 여부를 확인할 때 사용한다.그냥 포함되어 있는 여부를 확인하고 싶다면 ‘LIKE’ 함수를 사용하면 되지만,만약 포함되어 있고, 포함되어 있는 위치가 어디인지 알고 싶다면? 그럴때 사용하는 함수가 ‘INSTR()’ 함수이다.사용하는 방법은 생각외로 아주 간단하다INSTR(‘비교할 대상’, ‘비교하고자하는 값’, 비교를 시작할 위치, 검색된 결과의 순번) SELECT INSTR(‘TEST SAMPLE CODE’, ‘E’, 1, 1) AS INSTR_RS FROM DUAL ‘TEST SAMPLE CODE’라는 구분에서 ‘E’를 찾는데 1부터 시작을 해서 1번째 찾아지는 ‘E’의 위치는 어디인가? TO_CHAR(SYSDATE, ‘D’)D 만 주면 요일이 번호 순으로 나온다. 일 -&gt; 1, 월 -&gt; 2 … PIVOTPIVOT XMLAS “”WITHDynamic Query. (Procedure)PL/SQLPL/SQL (Procedural Language extension to SQL) SQL을 확장한 절차적 언어(Procedural Language)이다. 관계형 데이터베이스에서 사용되는 Oracle의 표준 데이터 엑세스 언어로, 프로시저 생성자를 SQL과 완벽하게 통합한다. 블록 단위의 실행을 제공한다. 이를 위해 BEGIN과 END;를 사용한다. 그리고 마지막 라인에 /를 입력하면 해당 블록이 실행된다. 변수, 상수 등을 선언하여 SQL과 절차형 언어에서 사용 변수의 선언은 DECLARE절에서만 가능하다. 그리고 BEGIN 섹션에서 새 값이 할당될 수 있다. IF문을 사용하여 조건에 따라 문장들을 분기 가능 LOOP문을 사용하여 일련의 문장을 반복 가능 커서를 사용하여 여러 행을 검색 및 처리 [ PL/SQL에서 사용 가능한 SQL은 Query, DML, TCL이다. ] DDL (CREATE, DROP, ALTER, TRUNCATE …), DCL (GRANT, REVOKE) 명령어는 동적 SQL을 이용할 때만 사용 가능하다. ECLARE (선언부) PL/SQL에서 사용하는 모든 변수나 상수를 선언하는 부분으로서 DECLARE로 시작 =&gt; 변수/상수/커서 등 을 선언 옵션 BEGIN (실행부) 절차적 형식으로 SQL문을 실행할수있도록 절차적 언어의 요소인 제어문, 반복문, 함수 정의 등 로직을 기술할수있는 부분이며 BEGIN으로 시작 필수 EXCEPTION (예외 처리부) PL/SQL문이 실행되는 중에 에러가 발생할수있는데 이를 예외 사항이라고 한다. 이러한 예외 사항이 발생했을때 이를 해결하기 위한 문장을 기술할수있는 부분 옵션 END (실행문 종료) 필수 — 프로시저 output 매개변수 사용하기 =&gt; 프로시저를 실행하여 특정결과값을 out변수에 저장하여 보냄. (프로시저에서 실행환경으로 값을 전달(반환)) — out있는 프로시저 작성방법 CREATE PROCEDURE 프로시저이름( 변수이름 IN 데이터타입, 변수이름 IN 데이터타입, .... --in 생략가능 변수이름 OUT 데이터타입, 변수이름 OUT 데이터타입 ...----프로시저를 호출하는곳으로 값을 보낸다. ) IS [ 변수이름 데이터타입; -- 프로시저내에서 사용할 변수선언 변수이름 데이터타입; 변수이름 데이터타입; .. ] BEGIN 기능 구현; END; EXEC 오류SQL PLUS에서는 EXEC SCOTT.PROC_TEST; 를 수행할 시 에러가 뜨지 않고 정상적으로 수행된다 이게 왜 이러냐면 EXEC는 SQL PLUS에서만 사용 가능한 명령어이기 때문에 DBeaver 같은 툴에서 쓰려고 하면 에러가 뜨는 것이다 DBMS_OUTPUT.Put_lineALTER TABLE 테이블 명 MODIFY(필드명 VARCHAR2(4000));CONCAT(SUBSTR(DCI_CLASS, 1, 1), LPAD(SUBSTR(DCI_CLASS, 2), 2, ‘0’))SIGN(A - B)123-1 (A가 B보다 작은 경우) -&gt; 0 (A와 B가 같은 경우) -&gt;1 (A가 B보다 큰 경우) -&gt; 12345678910111213141516SELECT F.PF_LAST_NAME, F.PF_FIRST_NAME, DECODE(F.PF_PAX_TYPE, &#x27;ADT&#x27;, &#x27;성인&#x27;, &#x27;CHD&#x27;, &#x27;소아&#x27;, &#x27;INF&#x27;, &#x27;유아&#x27;, &#x27;&#x27;) PF_PAX_TYPE, TO_CHAR(F.PF_FARE, &#x27;FM9,999,999&#x27;) PF_FARE, TO_CHAR(F.PF_TAX, &#x27;FM9,999,999&#x27;) PF_TAX, TO_CHAR(F.PF_TASF, &#x27;FM9,999,999&#x27;) PF_TASF, TO_CHAR(F.PF_AMOUNT, &#x27;FM9,999,999&#x27;) PF_AMOUNT, DECODE(TO_CHAR(R.PR_TKT_DLVRY_TIME, &#x27;yyyymmdd&#x27;), TO_CHAR(SYSDATE, &#x27;yyyymmdd&#x27;), &#x27;0&#x27;, DECODE(SIGN(F.PF_FARE - 1000), -1, &#x27;0&#x27;, 0, &#x27;1,000&#x27;, 1, &#x27;1,000&#x27;)) TASF_FEEFROM PASSENGER_FARE_RECORD F, PASSENGER_RECORD RWHERE F.PF_PR_ID = &#x27;500020783&#x27; AND F.PF_PR_ID = R.PR_ID SYSDATE - 1어제를 의미한다","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"}]},{"title":"Jvm options","slug":"2020-09-03-java-argument","date":"2020-09-03T01:00:00.000Z","updated":"2022-05-31T07:16:27.000Z","comments":true,"path":"2020/09/03/","link":"","permalink":"http://kidongyun.github.io/2020/09/03/","excerpt":"","text":"SETJvm argumentJvm arguments are begun with ‘-D’. 1java -jar -Dfoo heumsi-springboot.jar Application argumentApplication arguments are begun with ‘—‘. 1java -jar --bar heumsi-sprinboot.jar GETapplication.propertiesthe arguments can be stored at ‘application.properties’ file as key-value type. and It can is approached using @Value in Java code. 123456// set value in application.propertiesheumsi.name = heumsi// get value in *.java@Value(&quot;$&#123;heumsi.name&#125;&quot;)private String name; EnvironmentYou can approach the arguments without ‘.properties’ file using Environment object. 1234@AutowiredEnvironment environment;private String name = environment.getProperty(&quot;heumsi.name&quot;);","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"}]},{"title":"CSS Transition attribute","slug":"2020-08-26-css-transition","date":"2020-08-26T01:00:00.000Z","updated":"2022-05-31T07:16:23.000Z","comments":true,"path":"2020/08/26/","link":"","permalink":"http://kidongyun.github.io/2020/08/26/","excerpt":"","text":"1. the properties of the transition attribute.transitionwhenever you put down your cursor on this object, It would be larger 3 times than now. 1234567891011div.keyboard &#123; width: 100px; -webkit-transition: width 1s; transition: width 1s;&#125;div.keyboard:hover &#123; width: 300px; &#125; We can control multiple attributes of the transition at a once. It’s width and height in this example. 1234567891011121314#resize &#123; height: 100px; width: 150px; -webkit-transition: width 1s, height 3s; transition: width 1s, height 3s;&#125;#resize:hover &#123; width: 300px; height: 500px; &#125; transition-timing-functionIt’s for controling the velocity per times when it’s strated or finished. 123456781. linear : 전환(transition) 효과가 처음부터 끝까지 일정한 속도로 진행됩니다.2. ease : 기본값으로, 전환(transition) 효과가 천천히 시작되어, 그다음에는 빨라지고, 마지막에는 다시 느려집니다.3. ease-in : 전환(transition) 효과가 천천히 시작됩니다.4. ease-out : 전환(transition) 효과가 천천히 끝납니다.5. ease-in-out : 전환(transition) 효과가 천천히 시작되어, 천천히 끝납니다.6. cubic-bezier(n,n,n,n) : 전환(transition) 효과가 사용자가 정의한 cubic-bezier 함수에 따라 진행됩니다. 1234567891011121314151617181920212223div &#123; width: 100px; -webkit-transition: width 1s; transition: width 1s;&#125;#div_01 &#123; -webkit-transition-timing-function: linear; transition-timing-function: linear;&#125;#div_05 &#123; -webkit-transition-timing-function: ease-in-out; transition-timing-function: ease-in-out;&#125;div:hover &#123; width: 300px; &#125; transition-delayHaving you set this attribute, It should be started after this delay time. 12345678910111213#resize &#123; height: 100px; width: 150px; -webkit-transition: width 1s, height 2s; transition: width 1s, height 2s; -webkit-transition-delay: 1s; transition-delay: 1s;&#125;#resize:hover &#123; width: 300px; height: 300px; &#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://kidongyun.github.io/tags/Css/"}]},{"title":"How to use the Redux with Hook technique.","slug":"2020-08-25-react-redux-with-hook","date":"2020-08-25T06:00:00.000Z","updated":"2022-05-31T07:16:18.000Z","comments":true,"path":"2020/08/25/","link":"","permalink":"http://kidongyun.github.io/2020/08/25/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243import CellType from &#x27;../model/CellType&#x27;const DELETE_CELL = &#x27;cell/DELETE&#x27; as constconst OPEN_CELL = &#x27;cell/OPEN&#x27; as constconst UPDATE_CELL = &#x27;cell/UPDATE&#x27; as constexport const deleteCell = (cell: CellType) =&gt; (&#123; type: DELETE_CELL, payload: cell &#125;)export const openCell = (cell: CellType) =&gt; (&#123; type: OPEN_CELL, payload: cell &#125;)export const updateCell = (cell: CellType) =&gt; (&#123; type: UPDATE_CELL, payload: cell &#125;)type ApiAction = | ReturnType&lt;typeof deleteCell&gt; | ReturnType&lt;typeof openCell&gt; | ReturnType&lt;typeof updateCell&gt;type ApiState = &#123; deletedCell: CellType openedCell: CellType updatedCell: CellType&#125;const initialState = &#123; deletedCell: &#123; id: -1, type: &quot;CELL&quot; &#125;, openedCell: &#123; id: -1, type: &quot;CELL&quot; &#125;, updatedCell: &#123; id: -1, type: &quot;CELL&quot;&#125;&#125;function api(state: ApiState = initialState, action: ApiAction) &#123; switch (action.type) &#123; case DELETE_CELL : return &#123; deletedCell: action.payload, openedCell: state.openedCell, updatedCell: state.updatedCell &#125; case OPEN_CELL : return &#123; deletedCell: state.deletedCell, openedCell: action.payload, updatedCell: state.updatedCell &#125; case UPDATE_CELL : return &#123; deletedCell: state.deletedCell, openedCell: state.openedCell, updatedCell: action.payload &#125; default : return state &#125;&#125;export default api; 12345678910111213141516171819202122232425262728import &#123; useSelector, useDispatch &#125; from &#x27;react-redux&#x27;;import &#123; RootState &#125; from &#x27;../modules&#x27;;import &#123; useCallback &#125; from &#x27;react&#x27;import &#123; deleteCell, openCell, updateCell &#125; from &#x27;../modules/cell&#x27;import CellType from &#x27;../model/CellType&#x27;;export default function useApi() &#123; const deletedCell = useSelector((state: RootState) =&gt; state.cell.deletedCell ); const openedCell = useSelector((state: RootState) =&gt; state.cell.openedCell ); const updatedCell = useSelector((state: RootState) =&gt; state.cell.updatedCell ); const dispatch = useDispatch(); const onDeleteCell = useCallback((cell: CellType) =&gt; dispatch(deleteCell(cell)), [dispatch]); const onOpenCell = useCallback((cell: CellType) =&gt; dispatch(openCell(cell)), [dispatch]); const onUpdateCell = useCallback((cell: CellType) =&gt; dispatch(updateCell(cell)), [dispatch]); return &#123; deletedCell, openedCell, updatedCell, onDeleteCell, onOpenCell, onUpdateCell &#125;&#125; 1234567891011121314151617181920import &#123; combineReducers &#125; from &#x27;redux&#x27;;import stage from &#x27;./stage&#x27;import noti from &#x27;./noti&#x27;import modal from &#x27;./modal&#x27;import data from &#x27;./data&#x27;import cell from &#x27;./cell&#x27;const rootReducer = combineReducers(&#123; stage, noti, modal, data, cell&#125;)export default rootReducer;export type RootState = ReturnType&lt;typeof rootReducer&gt;; 12345678910111213141516171819202122232425&quot;dependencies&quot;: &#123; &quot;@testing-library/jest-dom&quot;: &quot;^4.2.4&quot;, &quot;@testing-library/react&quot;: &quot;^9.3.2&quot;, &quot;@testing-library/user-event&quot;: &quot;^7.1.2&quot;, &quot;@types/jest&quot;: &quot;^24.0.0&quot;, &quot;@types/node&quot;: &quot;^12.0.0&quot;, &quot;@types/react&quot;: &quot;^16.9.0&quot;, &quot;@types/react-bootstrap&quot;: &quot;^1.0.1&quot;, &quot;@types/react-dom&quot;: &quot;^16.9.0&quot;, &quot;@types/react-redux&quot;: &quot;^7.1.9&quot;, &quot;@types/styled-components&quot;: &quot;^5.1.0&quot;, &quot;axios&quot;: &quot;^0.19.2&quot;, &quot;bootstrap&quot;: &quot;^4.4.1&quot;, &quot;class-transformer&quot;: &quot;^0.2.3&quot;, &quot;react&quot;: &quot;^16.13.1&quot;, &quot;react-bootstrap&quot;: &quot;^1.0.0&quot;, &quot;react-dom&quot;: &quot;^16.13.1&quot;, &quot;react-redux&quot;: &quot;^7.2.0&quot;, &quot;react-scripts&quot;: &quot;3.4.1&quot;, &quot;redux&quot;: &quot;^4.0.5&quot;, &quot;styled-components&quot;: &quot;^5.1.0&quot;, &quot;typescript&quot;: &quot;~3.7.2&quot;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"React","slug":"React","permalink":"http://kidongyun.github.io/tags/React/"},{"name":"Javascript","slug":"Javascript","permalink":"http://kidongyun.github.io/tags/Javascript/"}]},{"title":"Swagger","slug":"2020-09-28-swagger","date":"2020-08-24T01:00:00.000Z","updated":"2022-05-31T07:17:32.000Z","comments":true,"path":"2020/08/24/","link":"","permalink":"http://kidongyun.github.io/2020/08/24/","excerpt":"","text":"Add Dependencies1234compile group: &#x27;io.springfox&#x27;, name: &#x27;springfox-swagger2&#x27;, version: &#x27;2.9.2&#x27;compile group: &#x27;io.springfox&#x27;, name: &#x27;springfox-swagger-ui&#x27;, version: &#x27;2.9.2&#x27; Create SwaggerConfig.java and Register the Bean123456789101112131415@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket api() &#123; return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.any()) // 현재 RequestMapping으로 할당된 모든 URL 리스트를 추출 .paths(PathSelectors.ant(&quot;/api/**&quot;)) // 그중 /api/** 인 URL들만 필터링 .build(); &#125;&#125; @EnableSwagger2Swagger2 버전을 활성화 하겠다는 어노테이션입니다. DocketSwagger 설정의 핵심이 되는 Bean입니다.API 자체에 대한 스펙은 컨트롤러에서 작성합니다.설정 정보useDefaultResponseMessages()false로 설정하면, swagger에서 제공해주는 응답코드 ( 200,401,403,404 )에 대한 기본 메시지를 제거합니다.불필요한 응답코드와 메시지를 제거하기 위함이며, 컨트롤러에서 명시해줄 것입니다.groupName()Docket Bean이 한 개일 경우기본 값은 default이므로, 생략가능여러 Docket Bean을 생성했을 경우groupName이 충돌하지 않아야 하므로, 여기서는 각 Docket Bean의 버전을 명시해줬습니다.select()ApiSelectorBuilder를 생성합니다.apis()api 스펙이 작성되어 있는 패키지를 지정합니다.즉, 컨트롤러가 존재하는 패키지를 basepackage로 지정하여, RequestMapping( GetMapping, PostMapping … )이 선언된 API를 문서화합니다.paths()apis()로 선택되어진 API중 특정 path 조건에 맞는 API들을 다시 필터링하여 문서화합니다.apiInfo()제목, 설명 등 문서에 대한 정보들을 보여주기 위해 호출합니다.파라미터 정보는 다음과 같습니다.public ApiInfo( title, description, version, termsOfServiceUrl, contact, license, licenseUrl, vendorExtensions ) PathSelectors.ant(“/api/**”) 의 경우 /api/ path를 가진 url들만 공개하겠다는 얘기인데, 모든 url들을 화면에 노출시키고 싶다면 /api를 지우면 된다. Check the Swagger-uihttp://127.0.0.1:38080/swagger-ui.html 포트는 WAS가 돌아가는 포트와 동일 @Api@Api - Controller 단위로 API 메타데이터 명시@ApiOperation - 하나의 REST API 요청 URL에 메핑되며, 문서화 대상을 처리 됨@ApiParam, @ApiImplicitParam - REST API 호출 시 전달되는 파라미터에 대한 설명@ApiModelProperty - Model Class 필드에 대한 설명 @ApiImplicitParam( name = &quot;requestBody&quot;, dataTypeClass = String.class, examples = @io.swagger.annotations.Example( value = @ExampleProperty(value = &quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot; ?&gt;&lt;AirApiRequestInfo Version=\\&quot;1.1\\&quot;&gt;&lt;Config service=\\&quot;cancelPnr\\&quot; validationModule=\\&quot;VALIDATION_DOM_RS\\&quot; format=\\&quot;airseoul\\&quot;/&gt;&lt;Response type=\\&quot;pc\\&quot; format=\\&quot;xml\\&quot;/&gt;&lt;PnrService pnrKey=\\&quot;500017442\\&quot; pnrAddr=\\&quot;JGBVE\\&quot;&gt;&lt;AirlineCode&gt;RS&lt;/AirlineCode&gt;&lt;/PnrService&gt;&lt;/AirApiRequestInfo&gt;&quot;, mediaType = &quot;application/xml&quot;) ) ) paramType -&gt; @RequestParam : “query” -&gt; @PathVariable : “path” -&gt; @RequestBody : “body” Default valueResponseEntitydto를 innerclass 스타일로 작성할 경우 이름이 겹치는 경우가 생기는 데 이럴 때 Swagger는 getSimpleName()함수를 활용해서 모델을 만들어내기 떄문에 구분이 되지 않는다. 이러한 방식을 사용하려면 모델 생성시 이름을 적용하는 방법을 변경하여야 한다. 아래는 그 코드이다.1234567891011121314151617181920212223242526272829@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket api() &#123; return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.ant(&quot;/api/**&quot;)) .build(); &#125; @Component @Order(SwaggerPluginSupport.SWAGGER_PLUGIN_ORDER) public static class CustomTypeNameProvider implements TypeNameProviderPlugin &#123; @Override public String nameFor(Class&lt;?&gt; type) &#123; String fullName = type.getName(); return fullName.substring(fullName.lastIndexOf(&quot;.&quot;) + 1); &#125; @Override public boolean supports(DocumentationType documentationType) &#123; return true; &#125; &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"}]},{"title":"Docker Commands","slug":"2020-08-24-docker-command","date":"2020-08-23T15:00:00.000Z","updated":"2022-05-31T07:16:12.000Z","comments":true,"path":"2020/08/24/","link":"","permalink":"http://kidongyun.github.io/2020/08/24/","excerpt":"","text":"Dockerfile vs Image vs ContainerI thought that they are really different things before, but It’s not true. Actually they are like the concept of the program and process It’s the summaries about the docker, which are gotten when i’ve struggled for getting the jvm option the java on the docker. The useful command of Docker.docker runThis command is usually used when you want to create the docker image and runs it. It’s a lot of the options soIt’s important to know about these options for using this command well. ‘-d’ option is for executing your docker image on the background. ‘d’ spelling might means ‘daemon’.Having you done this, You could see the process of the launching your image. 1&gt; docker run -d ‘-p’ option is for setting the port of your docker container and host system. It is usually used like the below commandand first one is for the host system and the later is for the your container. they are connected each other.so The data are shoot to the host port would be transferred to the container port was connected.38080 is for the host system and 38081 is for the container on the view of the below command. 1&gt; docker run -p 38080:38081 ‘-e’ option is for setting ‘env’ values. this values are often needed when you would like to get some data of outside of the container.for example host’s ip, host’s name or the thing that we could not get in the container easily. and This spelling might means the ‘environment variable’. 1&gt; docker run -e host.ip=123.123.123.123 You can set the image name using ‘—name’ option when you use the ‘docker run’ command. It will give the alias for your containerIt might be needed well because the CONTAINER_ID are too difficult to remember. so Whenever you write your command on the docker CLI,you could see yourself who would use the alias of the docker image. If you don’t use this option, then your image alias will create automatically using the name pool. 1&gt; docker run -name kidongyun ‘-h’ option is for giving the host name value to your container. Actually I don’t know the default value butI recommend use this option if you need to get the hostname of your host system in the docker container. 1&gt; docker run -h kidongyun ‘-v’ option can connect the some files from host to the containers. in other words, You can mount the files. If you done this,Your container could get the host directories not the directories are copied from the host. That is you can access the modified thingswhen you change your source code in host. 1&gt; docker run -v /home/docker/kidong/identidock/app:/app kidongyun 1234567891011&gt; docker inspect kidongyun &quot;Mounts&quot;: [ &#123; &quot;Type&quot;: &quot;bind&quot;, &quot;Source&quot;: &quot;/home/docker/kidong/identidock/app&quot;, &quot;Destination&quot;: &quot;/app&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;rprivate&quot; &#125; ], docker psThis command would be used a lot of the time, This command give to use the information related to the docker container.for example the container name, id, the time when it’s started, the execution status of the container and so on.They are usually useful information to us. so Don’t forget this command. 1&gt; docker ps Having you used ‘-a’ option, It will give the all information about the containers included are not worked.I’ve used this option when i need to remove the containers are not operated in my case. 1&gt; docker ps -a docker stopYou can stop your docker container using this command. after this, you might not be able to see this container on ‘docker ps’ commandfor seeing this, you should attach the option ‘-a’ when you use the ‘docker ps’ command. 1&gt; docker stop kidong yun docker rm / docker rmiIf you want to eliminate the docker container, then use this command. It’s do similar with the linux command so You could get this easily.and The second command is for removing the docker image not container. 12&gt; docker rm kidongyun&gt; docker rmi kidongyun docker inspect [CONTAINER_ID] or [CONTAINER_NAME]Having you wanted to know about the detail of your docker container, This command will give them you want.It has really a lot of the information like the status of network, environment variables, the information associated with host systemand the everything, which i think. 1&gt; docker inspect kidongyun docker exec -it [CONTAINER_ID] /bin/bashWe can open the shell of the docker container using this command. ‘-it’ options actually could be separated with ‘-i’ and ‘-t’but We usually use this like that. This options mean that I would like to interact with the my container and please open the ttybetween host and the container. and We execute the /bin/bash program on the container and we could communicate using this shell named ‘bash’ docker build —tag [IMAGE_ID]:[IMAGE_TAG] [DIRECTORY_PATH]You can create the images using this command. This command is needed the directory path included the DockerFile with the informationrelated to the setting about the image. and You could also create the images differently as the tag name if you want.in my company, This tag use as the release number of some business. docker network lsHaving you wanted to see the specification of your docker network information, Let follow the below command. 1&gt; docker network ls The sort of network type.The communication way between host system and the containers is do similar with the concept of real network thing.when you install the docker program, Your system would be installed new NIC(Network Interface Card might be virtual thing).This NIC is called docker0 and you can see about these information at the below command. 123456789 &gt; routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Ifacedefault gateway 0.0.0.0 UG 0 0 0 eth0link-local 0.0.0.0 255.255.0.0 U 1002 0 0 eth0172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0180.70.96.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0 bridgeIt’s the default way of the docker network. This way always use the docker0 interface. It’s the new virtual network area.So They’ve been in the independent place. It means you cannot access them at anywhere, anytime. the docker0 network usuallyhas the 172.17.0.0/16 network. and whenever you add the new host, their ip is increase from the 172.17.0.1. Every container hasthe their own network area. so It’s also impossible to communicate with each containers. in other words, The bridge network type isthat give to each containers independent network area. The below command could get the detail of the bridge network setting specification. 1&gt; docker network inspect bridge hostThis way share the network area the host and each containers are used this type. You have to use the option ‘—net=host’like the below. 1&gt; docker run --net=host httpd web01 You can check using the below command whether your starting is right or not. 1&gt; docker exec web01 ip addr show 3. containerThis way share the network area with another container. 4. noneHaving you picked this option, This container would have the isolated network, which is not with interface. 1&gt; docker run --name web04 --net=none -d httpd","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Container","slug":"Container","permalink":"http://kidongyun.github.io/tags/Container/"},{"name":"Docker","slug":"Docker","permalink":"http://kidongyun.github.io/tags/Docker/"}]},{"title":"The concepts of DTO","slug":"2020-08-20-dto","date":"2020-08-20T01:00:00.000Z","updated":"2022-05-31T07:15:58.000Z","comments":true,"path":"2020/08/20/","link":"","permalink":"http://kidongyun.github.io/2020/08/20/","excerpt":"","text":"The concept of DTO and VO.A data transfer object’s purpose is to represent the data to be transferred to another process, e.g. from your backend to a web frontend. If the information you are transferring has a nested structure, also using a nested type for the DTO does make sense. However, the DTO must not include unnecessary data you aren’t actually using – that’s just misleading. A DTO is absolutely not the same as your domain model. Your model describes entities like a Customer or an Order with all properties that are relevant for your problem domain. This includes properly modelling the relationship between an Order and a Customer. It is not unusual to end up with a complex object graph describing all of these relationships (and equivalently: many foreign keys in a relational database). VO is usually known as the represent for expressing the objective attributes. so It is used by the business part of the system. Whenever you should to get the structure of some object then It’s the good choice to check the VO file, which will help you understand their business. Why do we separate DTO and VO?First of all, We couldn’t treat the source code in only one file. Having you used just the VO without DTO, this VO should include a lot of information like the validation code, for connecting jpa, the jaxb options and so on. These many information would gave us the big confusion. Secondly, The parameters of the client request could be different as the thing is required. So the thinking to use only one domain model for taking the request is do not well. It always has the posibility be changed. Thirdly, We should be certainly the purpose when you create some sourece code. To separate DTO and VO is the good way to make sure the purpose. 12DTO - Data Transfer Object.VO - Value Object.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Dto","slug":"Dto","permalink":"http://kidongyun.github.io/tags/Dto/"}]},{"title":"The briefly summary of Rest Api types","slug":"2020-08-20-rest-api-type","date":"2020-08-20T01:00:00.000Z","updated":"2022-05-31T07:16:03.000Z","comments":true,"path":"2020/08/20/","link":"","permalink":"http://kidongyun.github.io/2020/08/20/","excerpt":"","text":"GETIt’s just like the ‘SELECT’ query. when you need to get some data from server, then we use this type of api. Actually this is not the main topic of this article. so I will skip the detail of it. before I write this article, I’ve always confused about the concept between POST, PUT and PATCH things. They are too same to me so I can’t use them at proper places. Let’s to summary about them now. POSTIt’s like the ‘INSERT’ query. It could add the new items of your service and if your request of it is overlapped, then I gotta create new one over and over. Yes, It always create new ones. and For create new one, this api should get all of the field your system need. PUTIt’s like the ‘UPDATE’ query. The main difference with ‘POST’ and ‘PUT’ is that ‘PUT’ have to keep the fault-tolerant attributes. It’s already introduced at the above. in other word, It should be not changed the data when your request is overlapped. and It also take all of the parameters for updating your one. PATCHIt’s do similar thing with ‘PUT’, but It should take the pare of the fields. It’s the only difference with ‘PUT’ api. DELETEI think you might know about this api. It’s not special. It just delete the data based the parameters requested from client.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Rest","slug":"Rest","permalink":"http://kidongyun.github.io/tags/Rest/"}]},{"title":"The sort of Spring Bean injections","slug":"2020-08-20-spring-bean-injection","date":"2020-08-20T01:00:00.000Z","updated":"2022-05-31T07:16:08.000Z","comments":true,"path":"2020/08/20/","link":"","permalink":"http://kidongyun.github.io/2020/08/20/","excerpt":"","text":"@Autowired, @Resource, @Inject 어노테이션으로만 자동적으로 객체를 주입할 경우 컨테이너에서 주입할 대상이 여러 개여서 의존성을 주입하지 못하는 경우가 발생할 수 있다 @Primary, @Qualifer 로 같은 우선순위로 있는 클래스가 여러 개가 있을 시 그 중 가장 우선순위로 주입할 클래스 타입을 선택할 수 있다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"}]},{"title":"The sort of Rest Api Clients in Java","slug":"2020-08-18-java-rest-api-client","date":"2020-08-17T23:47:54.000Z","updated":"2022-05-31T07:15:31.000Z","comments":true,"path":"2020/08/18/","link":"","permalink":"http://kidongyun.github.io/2020/08/18/","excerpt":"","text":"I just record the way how we use a lot of the way to communicate each others on the HTTP.It might be really a lots. I record just the summary about them and the way how to use them at here. HttpURLConnection1 HttpClientRestTemplateOkHttpRetrofit","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"}]},{"title":"The basic of Spring Data JPA","slug":"2020-08-18-jpa","date":"2020-08-17T23:47:54.000Z","updated":"2022-05-31T07:15:49.000Z","comments":true,"path":"2020/08/18/","link":"","permalink":"http://kidongyun.github.io/2020/08/18/","excerpt":"","text":"The concepts of JPA, Spring Data JPA, HibernateFirst time to study this, I just think they are same techniques but as you know, They aren’t same so I would like to explain about them briefly in here. JPA is the interface for expressing the query, which we always used at the DBMS. You can apply this using Java language, Query DSL or JPDL. We should remember the one thing that It’s not the library but only just interface so You want to use these then should implement everything follow the JPA interface. Spring Data JPA has the advantage about creating the beans. JPA is not only for the Spring Framework, so We could suffer the difficulty when we connect between two things. It’s offered to us these basic function for connecting like ‘repository’ Hibernate is the real object not interface. 1. build.gradleFor using the JPA techniques, We should import the dependecies in build.gradle. 12345678910111213dependencies &#123; ... implementation(&#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27;) compile group: &#x27;com.zaxxer&#x27;, name: &#x27;HikariCP&#x27;, version: &#x27;3.3.1&#x27; compile group: &#x27;oracle&#x27;, name: &#x27;ojdbc6&#x27;, version: &#x27;11.2.0.3&#x27; ...&#125; And we gotta remember the one thing more, which is you should choose what you want to use the Database in your system. i’ve used the Oracle in my system so as you can see the above, I added the dependency named ‘ojdbc6’, which is always needed the another maven repository introduced the below code. If you don’t add that, then It might be work incorrectly. 123456789repositories &#123; // It&#x27;s basic. mavenCentral() // We should add this. maven &#123; url &quot;http://www.datanucleus.org/downloads/maven2/&quot; &#125;&#125; It’s my exeperience that I suffered the Jpa and OJDBC are not work correctly, but I didn’t know the the reason why they aren’t concretely. The reason is the local OJDBC library. This problem was occured by the launching of the Spring boot system without OJDBC library. So please keep this. 2. set the OJDBC in application.ymlFor using OJDBC, It’s needed the information basically like host, port and database name and so on. Let’s follow like the below code in your application.yml 12345678spring: datasource: driver-class-name: oracle.jdbc.driver.OracleDriver url: jdbc:oracle:thin:@localhost:59161:XE username: system password: oracle The port number might be different between you and me cause the docker system. My oracle database is on the docker. because it’s not supported the mac system. and I am running my oracle through that port. but it always be able to change as you want. 3. EntityIt’s the bridge for connecting between the VO in java and Table in database. We have to specify the feature of them like primary key, cardinality, column name and column types and so on. 12345678910111213141516171819202122232425262728@Getter@Setter@ToString@Entity@Table(name = &quot;OBJECTIVE&quot;)public class Objective &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;OBJ_ID&quot;) private long objectiveId; @Column(name = &quot;OBJ_TITLE&quot;) private String title; @Column(name = &quot;OBJ_DESCRIPTION&quot;) private String description; @Column(name = &quot;OBJ_DEADLINE&quot;) private LocalDate deadline; @Column(name = &quot;OBJ_PRIORITY&quot;) private int priority; @Column(name = &quot;OBJ_STATUS&quot;) private int status;&#125; @Id annotation means that it’s the primary key. We can use the @Table annotation when your table’s name in VO is different with the table’s name in database. and This annotation is not required. @Column is also not required, but It’s same with the @Table annotation. If you need to connect with the fields in VO and the columns in database, It’s needed. 4. Repository123456789101112131415package com.kidongyun.bridge.api.repository;import com.kidongyun.bridge.api.vo.Objective;import org.springframework.data.repository.CrudRepository;import java.util.Optional;public interface ObjectiveRepository extends CrudRepository&lt;Objective, Long&gt; &#123; @Override Optional&lt;Objective&gt; findById(Long aLong);&#125; It’s the repository of your queries. you can create a lot of the queries using the real query, QueryDSL or just method name. if you’ve completed to build this file, you just use this methods without any thinking. 5. The sort of GenerationTypeIf you want to allocate the id value yourself then, you don’t need to use the @GeneratedValue annotation. Just use the @Id annotation. This technique is usually named directly allocation and It have to process this part yourself. GenerationType.IDENTITY GenerationType.SEQUENCE Sequence jpa로 직접 생성하고 직접 연결하는 방식 1234567@Id@GeneratedValue(strategy= GenerationType.SEQUENCE, generator = &quot;OBJ_SEQ_GEN&quot;)@SequenceGenerator(name = &quot;OBJ_SEQ_GEN&quot;, sequenceName = &quot;OBJ_ID_SEQ&quot;)@Column(name = &quot;OBJ_ID&quot;)private long id; GenerationType.AUTO 6. @MappedSuperclassHaving you wanted to create the inheritance relationship between your java objects, You gotta know the one thing, which most of all RDB are not supported to make the inheritance. So It’s little different to build something between them. if you want to create the inheritance at only each java objects not tables, then follow the below coding styles. 1234567891011121314// It&#x27;s super class.@Getter@Setter@ToString@MappedSuperclasspublic class Cell &#123; @Id protected long id; @Transient protected String type;&#125; the ‘Cell’ class isn’t a table. It’s only existed on the java. and the belows are sub classes. 123456789101112131415161718192021222324@Getter@Setter@ToString@Entity@Table(name = &quot;OBJECTIVE&quot;)@AttributeOverride(name = &quot;id&quot;, column = @Column(name = &quot;OBJ_ID&quot;))public class Objective extends Cell &#123; @Column(name = &quot;OBJ_TITLE&quot;) private String title; @Column(name = &quot;OBJ_DESCRIPTION&quot;) private String description; @Column(name = &quot;OBJ_DEADLINE&quot;) private LocalDate deadline; @Column(name = &quot;OBJ_PRIORITY&quot;) private int priority; @Column(name = &quot;OBJ_STATUS&quot;) private int status;&#125; 123456789101112131415161718192021@Getter@Setter@ToString@Entity@Table(name = &quot;PLAN&quot;)@AttributeOverride(name = &quot;id&quot;, column = @Column(name = &quot;PLAN_ID&quot;))public class Plan extends Cell &#123; @Column(name = &quot;PLAN_CONTENT&quot;) private String content; @Column(name = &quot;PLAN_START_DATE&quot;) private LocalDate startDate; @Column(name = &quot;PLAN_END_DATE&quot;) private LocalDate endDate; @Column(name = &quot;PLAN_STATUS&quot;) private String status;&#125; We can create the id attribute on each sub-classes as the thing named differently 7. @Inheritancesuper-class 12345678910111213141516171819@Getter@Setter@ToString@Entity@Inheritance(strategy = InheritanceType.JOINED)@DiscriminatorColumnpublic class Cell &#123; @Id @GeneratedValue(strategy= GenerationType.SEQUENCE, generator = &quot;CELL_SEQ_GEN&quot;) @SequenceGenerator(name = &quot;CELL_SEQ_GEN&quot;, sequenceName = &quot;CELL_ID_SEQ&quot;) @Column(name = &quot;CELL_ID&quot;) protected long id; @Column(name = &quot;CELL_TYPE&quot;) protected String type;&#125; sub-classes 1234567891011121314151617181920212223@Getter@Setter@ToString@Entity@Table(name = &quot;OBJECTIVE&quot;)public class Objective extends Cell &#123; @Column(name = &quot;OBJ_TITLE&quot;) private String title; @Column(name = &quot;OBJ_DESCRIPTION&quot;) private String description; @Column(name = &quot;OBJ_DEADLINE&quot;) private LocalDate deadline; @Column(name = &quot;OBJ_PRIORITY&quot;) private int priority; @Column(name = &quot;OBJ_STATUS&quot;) private int status;&#125; 123456789101112131415161718192021@Getter@Setter@ToString@Entity@Table(name = &quot;PLAN&quot;)public class Plan extends Cell &#123; @Column(name = &quot;PLAN_CONTENT&quot;) private String content; @Column(name = &quot;PLAN_START_DATE&quot;) private LocalDate startDate; @Column(name = &quot;PLAN_END_DATE&quot;) private LocalDate endDate; @Column(name = &quot;PLAN_STATUS&quot;) private String status;&#125; 8. The strategy of InheritanceYou should set the strategy of inheritance with @Inheritance(strategy=InheritanceType.XXX) annotation. The sort of the inheritance strategy SINGLE_TABLE (default) JOINED TABLE_PER_CLASS @DiscriminatorColumn you can define this annotation at parent entity to separate the children entity. this annotation will add the new field named DTYPE that is for separating sub entities. @DiscriminatorValue you can customize the sub entity name used in DTYPE field with @DiscriminatorValue(“XXX”) annotation. the default value is the sub entities name itself. 9. The strategy of Primary keywhen you use @Id annotation, @GeneratedValue will be helpful that you initialize the way setting primary key. @GeneratedValue(strategy = GenerationType.IDENTITY) @GeneratedValue(strategy = GenerationType.SEQUNCE) … @GeneratedValue(strategy = GenerationType.IDENTITY) This way will set the id field automatically as the database vendor way.for example, if you use Mysql vender then this annotation will use AUTO_INCREMENT keyword only used in Mysql. @GeneratedValue(strategy = GenerationType.SEQUNCE) This way create new sequence table in vender to manage the primary key. It’s more universal way because most of database vendors use the sequence technique. 상속받는 구조일때 자식객체가 PK를 가지면 안된다. @MappedSuperclass 에서 @Id 를 적용할 때에는 자식클래스에 Id를 적용하는게 아니고. 부모클래스에 적용한다음 이름을 다르게 하고 싶다면@AttributeOverride 를 사용해서 컬럼명을 변경해주어야 함. @Embeddable 과 @Embedded엔티티를 구현하다보면 공통적인 부분을 제거하기 위해 객체를 따로 분리하고 싶은 경우가 있다. 분리한 객체의 필드 정보를 테이블에 매핑하고 싶을 때 사용하는 어노테이션이다. @Embeddable: 분리한 클래스 위에 선언한다.@Embedded: 분리한 클래스를 사용하는 엔티티 필드 위에 선언한다.@Embeddablepublic class Name { private final String firstName; private final String lastName; // …}@Entitypublic class User { @Embedded private final Name userName; // …} Tip.기본키는 변경되면 안되기 때문에,직접할당 전략이 아니라면 엔티티에서 setId() 메소드를 비공개(private)하는 것이 좋다 객체 는 다른 객체와 참조(reference) 를 통해 관계를 맺고,테이블 은 외래키(foreign key) 를 통해서 관계를 맺는다. 방향(Direction): 객체가 다른 객체를 참조하는 방향. 단방향/양방향테이블은 외래키를 기반으로 테이블간 양방향으로 JOIN이 가능하다. 하지만, 객체의 참조는 항상 단방향이다.다중성(Multiplicity): 객체의 관계(Relationships) 표현. 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)연관관계의 주인(Owner): 객체간 양방향 으로 방향성을 가질때 연관관계에 있어 누가 주인 인가를 정해야 된다.테이블로 보면 누가 FK를 가져야 하는가의 문제이다. 연관관계의 주인인 엔티티가 FK를 업데이트 한다. 객체는 상속관계가 존재하지만, 관계형 데이터베이스는 상속 관계가 없다.(대부분) 그나마 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사하다. 상속관계 매핑이라는 것은 객체의 상속 구조와 DB의 슈퍼타입 서브타입 관계를 매핑하는 것이다. @MappedSuperclass 에 관하여 일반적으로, 상속 관계 매핑 전략에서 부모 클래스와 자식 클래스 모두 데이타베이스 테이블과 매핑을 한다. 이와 달리, 부모 클래스를 상속받는 자식클래스에게 매핑 정보만 제공하고 싶을때 이 어노테이션을 사용하면 된다. 엔티티 종류에 상관없이 공통으로 가지고 있어야 하는 정보가 있다면 ( ex. 데이타 생성시간, 수정시간 등 ) 공통 클래스로 추출하고 이를 상속받는 방식으로 구현할 때 사용 한다. 그러나 엔티티는 엔티티만 상속받을 수 있기 때문에 엔티티가 아닌 클래스를 상속받기 위해서 @MappedSuperclass 를 사용한다. @AttributeOverride none: 아무것도 실행하지 않는다 (대부분의 DB에서 기본값이다)create-drop: SessionFactory가 시작될 때 drop및 생성을 실행하고, SessionFactory가 종료될 때 drop을 실행한다 (in-memory DB의 경우 기본값이다)create: SessionFactory가 시작될 때 데이터베이스 drop을 실행하고 생성된 DDL을 실행한다update: 변경된 스키마를 적용한다validate: 변경된 스키마가 있다면 변경점을 출력하고 애플리케이션을 종료한다 만약 book 테이블의 생성일시만 createdAt이 아닌 publishedAt 으로 바꾸고 싶으면 Book만 BaseEntity를 상속받지 않고 따로 만들어야할까 ? 그럴 필요는 없고, 아래와 같이 @AttributedOverride 어노테이션으로 필요한 매핑정보만 재정의가 가능하다. Spring Data JPA는 Spring에서 제공하는 모듈 중 하나로, 개발자가 JPA를 더 쉽고 편하게 사용할 수 있도록 도와준다. 이는 JPA를 한 단계 추상화시킨 Repository라는 인터페이스를 제공함으로써 이루어진다. 사용자가 Repository 인터페이스에 정해진 규칙대로 메소드를 입력하면, Spring이 알아서 해당 메소드 이름에 적합한 쿼리를 날리는 구현체를 만들어서 Bean으로 등록해준다. DDL(테이블 생성하거나 지우는거) 도 hibernate를 쓰는가. 어떻게해야하는가 여러 개의 정보를 바꾸고 싶을 때 방법은 아래와 같다. @Entity@AttributeOverrides({ @AttributeOverride(name = “id”, column = @Column(name = “article_id”)), @AttributeOverride(name = “createTime” column = @Column(name = “article_create_time”))})public class Article extends BaseEntity { // …} DB TABLE 에는 상속관계가 없고 Java Class들 끼리만 상속관계를 가지게 하고싶을때 아래처럼 구현. 애초에 DB TABLE은 상속관계를 구현할 수 없다. Repository 에서는 Entity 아닌 VO 객체를 사용할수 없다. 그리고 추가적으로 Java의 가장 기본이되는 객체인 Object도 사용이 불가능하다. 상속관계를 맺을때 알게된 내용인데. 중요한것 같다. 공통이되는 부분을 부모클래스로 잡고 싶지만 이를 테이블화 시키기 싫을때에 @MappedSuperClass를 사용하려고 고군분투 하였으나 결과적으로 이 어노테이션을 사용한 vo 객체는 Entity가 아니기 때문에 이 객체를 Repository 클래스에 적용시킬수 없다. 만약 Repository 에서도 이 부모클래스를 사용해야한다면 @Inheritance에서 타입을 TABLE_PER_CLASS 를 사용해보자.근데 이방법은 쿼리 속도가 안나온다고함. JPA에서도 Optional로 제공하다보니 환경에따라서 모두 적용될수있다가 보장되지 않기때문에커뮤니티에서 다들 이 타입을 쓰는걸 권장하지 않아하네.. 그냥 @MappedSuperClass 이걸 써서 JPA를 위한 하나의 Base class를 만들자. @MappedSuperClass 이 필요할떄위에서 말한 상속 관계 매핑에서 테이블까지 고민하기 싫음.DB는 따로 쓰되, 객체입장에서 속성만 상속 받아서 쓰고 싶을때!","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"}]},{"title":"Singleton Pattern","slug":"2020-09-18-java-singleton","date":"2020-08-17T23:47:54.000Z","updated":"2022-05-31T07:17:22.000Z","comments":true,"path":"2020/08/18/","link":"","permalink":"http://kidongyun.github.io/2020/08/18/","excerpt":"","text":"Use private keywordThe main topic of the singleton pattern is It has to block the access for create new instance from outside because It’s needed only one object.We often use the ‘private’ keyword for solving this problem. 1234567891011121314class Singleton &#123; /* Use the &#x27;private&#x27; keyword */ private static final Singleton instance = new Singleton(); /* The constructor also should be announced with the &#x27;private&#x27; keyword */ private Singleton() &#123; &#125; /* It should be approached at only here. */ public static Singleton getInstance() &#123; return instance; &#125;&#125; Initialzation TimingIf your system has a lot of the singleton pattern objects, then It could be too heavy to your system when It’s started.Because Your system should initialize these objects at an once. We can solve this problem using the Lazy Initialization. Thread-Safe","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"}]},{"title":"ElasticSearch","slug":"2020-08-12-elastic-search","date":"2020-08-11T23:47:54.000Z","updated":"2022-05-31T07:15:17.000Z","comments":true,"path":"2020/08/12/","link":"","permalink":"http://kidongyun.github.io/2020/08/12/","excerpt":"","text":"ELK = Elasticsearch + Logstash + Kibana ELK 는 Elasticsearch + Logstash + Kibana 세개의 오픈 소스 프로젝트를 하나의 스택으로 쓰는 것 노드라는 걸 기반으로 데이터를 저장하고 한 데이터는 복사본, 원본 을 위해 여러개의 노드로 저장. 이 노드들이 유기적으로 연결되고 함으로써 확장성을 가진다고 함. 각 노드는 1개 이상의 데이터 원본과 보사본을 서로 다른 위치에 나누어 저장 인덱스 = RDBMS의 데이터베이스에 대응 JSON DOCUMENT / RESTFUL API 하나의 클러스터는 여러개의 노드. 여러대의 서버가 하나의 클러스터를 구성할 수 있으며 그 반대도 가능. 노드는 마스터 노드와 데이터 노드로 구분, 마스터노드는 전체 클러스터 상태의 메타 정보를 관리. 데이터 노드는 실제 데이터가 저장되는 노드 9200번 부터 REST API를 위한 HTTP 통신 포트 할당. 9300번 부터 노드간 바인딩을 위한 포트로 할당. 일반적으로 데이터노드는 외부 접근을 차단 젠 디스커버리? 샤드는 데이터 검색을 위해 구분되는 최소 단위 멀티 테넌시를 활용하여 여러 인덱스를 동시에 검색 가능 인덱스들을 쉼표로 구분하여 입력. AND 와 OR를 사용하여 조건 명령 가능 앞 뒤에 공백을 넣어 지정 (%20) q 가 질의 부분 sort 등의 옵션 사용 간ㅇ. URI 방식으로 검색을 할수도 있고 BODY 안에 DSL 이라는 쿼리 형태로 날릴수도 있다. Bulk API 라는걸 활용해서 데이터 Insert 하는것 같다. Query DSL 문법 모든 Document 를 출력한다 SELECT * FROM TABLE 같은 느낌.123456&#123; &quot;query&quot; : &#123; &quot;match_all&quot; : &#123;&#125; &#125;&#125; 12345&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;DATE&quot; : &quot;202008131200&quot; &#125; &#125;&#125; 123456789&#123; &quot;query&quot; : &#123; &quot;bool&quot; : &#123; &quot;must&quot; : [ &#123; &quot;match&quot; : &#123; &quot;AIRLINE&quot; : &quot;TW&quot; &#125;&#125; ] &#125; &#125;&#125; 123456789&#123; &quot;query&quot; : &#123; &quot;bool&quot; : &#123; &quot;must_not&quot; : [ &#123; &quot;match&quot; : &#123; &quot;AIRLINE&quot; : &quot;TW&quot; &#125;&#125; ] &#125; &#125;&#125; 123456789&#123; &quot;query&quot; : &#123; &quot;bool&quot; : &#123; &quot;must_not&quot; : [ &#123; &quot;match&quot; : &#123; &quot;AIRLINE&quot; : &quot;TW&quot; &#125;&#125; ] &#125; &#125;&#125; 12345678910111213&#123; &quot;query&quot; : &#123; &quot;bool&quot; : &#123; &quot;must&quot; : [ &#123; &quot;match&quot; : &#123; &quot;AIRLINE&quot; : &quot;RS&quot; &#125;&#125;, &#123; &quot;match&quot; : &#123; &quot;TYPE&quot; : &quot;RetrieveRefund&quot; &#125;&#125;, &#123; &quot;match&quot; : &#123; &quot;PNR&quot; : &quot;JY0S4&quot; &#125;&#125; ], &quot;filter&quot; : &#123; &#125; &#125; &#125;&#125; 아래의 URI를 GET 형식으로 호출할 경우 이름이 asdasdasd인 인덱스가 존재하는지 확인 할 수 있고 PUT으로 호출할 경우 해당 이름의 인덱스를 생성한다. DELETE는 삭제.1http://192.168.28.176:9200/asdasdasd?pretty ex) getcurl -XGET localhost:9200/classes/class/1select * from class where id = 1 ex) postcurl -XPOST localhost:9200/classes/class/1 -d ‘{xxx}’insert into class values (xxx) ex) putcurl -XPUT localhost:9200/classes/class/1 -d ‘{xxx}’update class set xxx where id = 1; ex) deletecurl -XDELETE localhost:9200/classes/class/1delete from class where id = 1;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"}]},{"title":"O.O.P","slug":"2020-07-28-oop","date":"2020-07-28T08:43:00.000Z","updated":"2022-05-31T07:13:55.000Z","comments":true,"path":"2020/07/28/","link":"","permalink":"http://kidongyun.github.io/2020/07/28/","excerpt":"","text":"Especially, I don’t know about the topic on today. It’s so subjective thinking of me. So I hope to read this lightly. What is the O.O.P ?I don’t want to consider the technical things at here for explaining O.O.P. I just wanna express this more simply, easily and intuitively.I always think that O.O.P means the combination between data and method. 1Object = data + method Actually, a lot of the books are related to the O.O.P are introduced the above concept. and I really agree about this idea.Abstraction, Encapsulation, Inheritance, Polymorphism and Information Hiding are just a feature of the object. in other wordsIt doesn’t means that they are not able to explain the core of O.O.P concept. Some books said The O.O.P has created for express the everything in the world, but i really would like to thinkthe programming language is not a complex. I just believe, someday, some code might be needed the unification at a once andwe maybe use the function technique for solving it. in the programming perspective, The O.O.P use the object (data + method) for theusability, code re","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"}]},{"title":"Usage of JUnit when it's private method.","slug":"2020-07-22-junit-private-method","date":"2020-07-21T23:47:54.000Z","updated":"2022-05-31T07:13:50.000Z","comments":true,"path":"2020/07/22/","link":"","permalink":"http://kidongyun.github.io/2020/07/22/","excerpt":"","text":"How to test the private method in junit.Actually you can’t access the methods declared private thing. so You have to use the another way to test the below code. 123456789101112131415public class NaverConvertApi &#123; /** It calculate the distances between two times taken from parameters */ private String getTimeInterval(String dateTimeStr1, String dateTimeStr2) throws Exception &#123; SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;YYYYMMddHHmm&quot;); long dateTime1 = dateFormat.parse(dateTimeStr1).getTime(); long dateTime2 = dateFormat.parse(dateTimeStr2).getTime(); return Math.abs(dateTime1 - dateTime2) / 60000 + &quot;&quot;; &#125; &#125; Everythings are okay. but your code is declared as the private thing. I will use the reflection technique for solving it. 12345678910111213141516171819public class NaverConvertApiTest &#123; NaverConvertApi naverConvertApi = new NaverCovertApi(); @Test public void GetTimeInterval_ShouldBe60() throws Exception &#123; String dateTimeStr1 = &quot;202007221635&quot;; String dateTimeStr2 = &quot;202007221735&quot;; Method method = naverConvertApi.getClass().getDeclaredMethod(&quot;getTimeInterval&quot;, String.class, String.class); method.setAccessible(true); String result = (String) method.invoke(naverConvertApi, dateTimeStr1, dateTimeStr2); assertThat(result, is(&quot;60&quot;)); &#125;&#125; I think it is little complicated so someday i would like to introduce the easier technique for solving it using library named ‘PowerMock’","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Test","slug":"Test","permalink":"http://kidongyun.github.io/tags/Test/"}]},{"title":"About the role of Spring Controller and Service.","slug":"2020-07-15-spring-controller-service","date":"2020-07-15T01:00:00.000Z","updated":"2022-05-31T07:13:42.000Z","comments":true,"path":"2020/07/15/","link":"","permalink":"http://kidongyun.github.io/2020/07/15/","excerpt":"","text":"During I work as Java developer with Spring Framework, I was thrown into the confusion of the role. How do I build the MVC pattern?, What is better thing?I can’t always answer about these questions though. This article is the content, which my opinion about the role of each parts of Spring Framework. 1. The needs of The Spring Service logicAs you know, The service logic might be necessary on Spring Framework. Let’s suppose that the Spring Framework has only controller logic without service thing.When you want to share the function, which be made by you, You can not it at this situation. How do you access between each controllers? You might be able to think the below. 123456789101112131415161718 /** in AController.java */public class AController &#123; public void aFunction() &#123; &#125;&#125;/** in BController.java */public class BController &#123; public AController aController = new AController(); public void BFunction() &#123; aController.aFunction(); &#125; &#125; If You are already the person of familiar with the Spring. You could get that the above code is really stupid thinking cause a lot of reasons.You gotta always keep the independence between all of controllers, But It isn’t. And You could not make the parameters of the thing you want from another controllers. What is the best way to access the aFunction() from BController.java? If you get it, You could understand the needs of service either. 12345678910111213141516171819202122232425/** in AController.java */public class AController &#123; CService cService = new CService(); public void aFunction() &#123; cService.cFunction(); &#125;&#125; /** in BController.java */public class BController &#123; CService cService = new CService(); public void bFunction() &#123; cService.cFunction(); &#125;&#125;/** in CService.java */public class CService &#123; public void cFunction() &#123; &#125;&#125; I think that it would be more normal pattern of Spring. You can keep the independence among the your code when you would like to use some function at many places.You can do like the above code whenever you need to create some function. The controllers would be more dependent than the services cause It need to consider the data given from client side.The important thing is that you have to make the your own functions to the service files when you would like to keep the independence from others. 2. Aspect of building a Spring service.2.1 How to offer the parameters.To keep the independence of own functions located at service needs to manipulate the parameter properly.First of all, It must get a primitive type data or POJO object. No dependent object like HttpServletRequest. 1234567891011121314151617181920212223242526272829/** in Person.java */public class Person &#123; String name; int age;&#125;/** in AService.java */public class AService &#123; /** It&#x27;s dependent case. */ public void dependentCase(HttpServletRequest request) &#123; String name = request.getParameter(&quot;name&quot;); int age = request.getParameter(&quot;name&quot;); // do Something &#125; /** It&#x27;s independent case */ public void independentCase(String name, int age) &#123; // do Something &#125; /** It&#x27;s independent case */ public void independentcase(Person person) &#123; String name = person.name(); int age = person.age(); &#125;&#125; If you choose the bad one at the above, then the controller what want to use your function always have to possess the Request object. 2.2 The function in Service has to be pure function.Do you know the concept of a pure function? It’s really simple. That function has to be clear. in other words, The result is always same if parameter is equal. 12345678910111213public class AService &#123; int c = 10; public int pureFunction(int a, int b) &#123; return a + b; &#125; public int impureFunction(int a, int b) &#123; return a + b + c; &#125;&#125; the pureFunction always return the same result but impureFunction isn’t case the variable named c.We can’t make sure the result is same if variable c is changed. Your function located at service should be used by a lot of controllers. but the static variable like c could make some errors unpredicted.And It might be most important reason to use the pure function technique that Impure function can’t be used the test code. 3. The exception handling on the service.To check your code in your business for the safety would be important as you know. like to check a Null exception, type casting exception or format things..Where is best place for putting this code on Spring Framework? It’s really difficult to me and I can’t figure it out until now.but I just found one fact, which is that the exception handling code be always dependent by some code. Let’s see the below codes. 1234567891011121314151617181920212223/** Structure 1. No try-catch syntax */public class AService &#123; public String aFunction() &#123; return result; &#125;&#125;public class AController &#123; AService aService = new AService(); public String controller() &#123; String result = aService.aFunction(); if(&quot;error&quot;.equals(result)) &#123; // do error processing return &quot;ERROR&quot;; &#125; return &quot;SUCCESS&quot;; &#125; &#125; I think it might be simplest way to create the exception handling code. It doesn’t use the try-catch syntax andthis structure is processing exception handling at the controller logic. but the longer error code is the more it’s too hard to read.That is you couldn’t understand that main business because the exception handling. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** Structure 2. Exception Handling on Controller */public class AService &#123; public String aFunction() &#123; return result; &#125;&#125;public class AController &#123; AService aService = new AService(); public String controller() &#123; try &#123; String result = aService.aFunction(); if(&quot;error&quot;.equals(result)) &#123; throw new Exception(); &#125; &#125; catch(Exception e) &#123; // do error processing return &quot;ERROR&quot;; &#125; return &quot;SUCCESS&quot;; &#125; &#125;/** Structure 3. Exception Handling on Service */public class AService &#123; public String aFunction() &#123; String result = getFromSomewhere(); if(&quot;error&quot;.equals(result)) &#123; throw new Exception(); &#125; return result; &#125;&#125;public class AController &#123; AService aService = new AService(); public String controller() &#123; try &#123; String result = aService.aFunction(); &#125; catch(Exception e) &#123; // do error processing return &quot;ERROR&quot;; &#125; return &quot;SUCCESS&quot;; &#125; &#125; Specific exception handling is always dependent with specific code. 4. For Reducing the redundant codes.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class AService &#123; public String aFunction() &#123; String result = getFromSomewhere(); if(&quot;error&quot;.equals(result)) &#123; throw new Exception(); &#125; return result; &#125;&#125;public class AController &#123; AService aService = new AService(); public String controller() &#123; try &#123; String result = aService.aFunction(); &#125; catch(Exception e) &#123; // do error processing return &quot;ERROR&quot;; &#125; return &quot;SUCCESS&quot;; &#125; &#125;public class BController &#123; AService aService = new AService(); public String controller() &#123; try &#123; String result = aService.aFunction(); &#125; catch(Exception e) &#123; // do error processing return &quot;ERROR&quot;; &#125; return &quot;SUCCESS&quot;; &#125; &#125;public class CController &#123; AService aService = new AService(); public String controller() &#123; try &#123; String result = aService.aFunction(); &#125; catch(Exception e) &#123; // do error processing return &quot;ERROR&quot;; &#125; return &quot;SUCCESS&quot;; &#125; &#125; To handle Exception at the service logic is better from a redundant point of view. If not you gotta handle at each controllers are used this.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"}]},{"title":"How to use the parallel stream","slug":"2020-03-23-parallel_stream","date":"2020-03-23T02:21:54.000Z","updated":"2022-05-31T07:13:36.000Z","comments":true,"path":"2020/03/23/","link":"","permalink":"http://kidongyun.github.io/2020/03/23/","excerpt":"","text":"1. .parallel() and .sequential()Stream API has the .parallel() function. It offers the parallel attrbute to the stream literally. You can use this function at the mid place and the calculations will be divided after calling this function. The below is the example how to add from 1 to n using the parallel stream. 12345678public long parallelSum(long n) &#123; return Stream.iterate(1L, i-&gt;i+1) .limit(n) .parallel() .reduce(0L, Long::sum);&#125; You can change the type between sequential and parallel in the one stream either like the below. 12345678stream().parallel() .filter(...) .sequential() .map(...) .parallel() .reduce(); 2. the sort of overheads of the stream technique.If you are the novice of the parallel programming or stream thing then you may misunderstand about what these new techniques are always better then the sequential or conventional things. but it’s not truth. Because new techniques must have the additional task. for example the context switching or creating the new thread or translating the object type to primitive type, it’s called boxing and unboxing. so You have to consider about the overhead of new techniques when you use that. boxing and unboxingLook at the below the code. 123456public long sum() &#123; final long N = 10_000_000L; return Stream.iterate(1L, i-&gt; i + 1).limit(N).reduce(0L, Long::sum);&#125; It’s the calculation using the sequential stream. but if you know the boxing and unboxing, You can upgrade your code more effectively. the method reference ‘Long::sum’ in the reduce() function needs the object type of long. It’s not a primitive type but the source and the result of the stream is the primitive type of long. so the above code must always translate the type between object and primitive of long. Actually It’s really high cost. so the below is more faster than the above thing. 123456public long sum() &#123; final long N = 10_000_000L; return LongStream.iterate(1L, i -&gt; i + 1).limit(N).reduce(0L, Long::sum);&#125; Change the from Stream to LongStream. It’s for the primitive type of long. then you don’t need to translate betweens the types. Shared Variable.like the public toilet of which someone use that then the others can’t use the toilet, the shared variables can be approached only one thread at a time for keeping the MUTEX status. so the design needed the shared variable isn’t well to the parallel technique. if you use just like that, It’s more worse than sequential because of the overhead like the context swiching. the below code is the conventional design using the shared variable and the second thing is the same code using the stream. 12345678910111213public long sum() &#123; final long N = 10_000_000L; long result = 0; // It&#x27;s the shared variable. for(long i = 1L; i&lt;= N; i++) &#123; result += i; &#125; return result;&#125; 12345678public long sum() &#123; final long N = 10_000_000L; return LongStream.iterate(1L, i -&gt; i + 1).limit(N).reduce(0L, Long::sum);&#125; They aren’t useful code from the parallel perspective. iterate() function of the stream use the shared variables internally either. so when you use the parallel stream you should avoid the iterate() function and use the rangeClosed() function. 123456public long sum() &#123; final long N = 10_000_000L; return LongStream.rangeClosed(1, N).parallel().reduce(0L, Long::sum);&#125; rangeClosed() function can divide the stream itself. and the divided streams are so useful to the parallel technique.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"Java 8 Reduce and Collector","slug":"2020-3-16-java-collector","date":"2020-03-16T05:30:54.000Z","updated":"2022-05-31T07:13:27.000Z","comments":true,"path":"2020/03/16/","link":"","permalink":"http://kidongyun.github.io/2020/03/16/","excerpt":"","text":"1. reduce()reduce() calculation return the value no like any list, array, collection model. Usually It’s called ‘Fold’ Calculation at the Functional Programming. Because The process getting the value from the stream is so similar to fold the paper. 1234567/** Example of the reduce utilizing the Rambda */int sum = numbers.stream().reduce(0, (a, b) -&gt; a + b)/** Example 2 of the reduce utilizing the Method Reference */int sum = numbers.stream().reduce(0, Integer::sum) the first among the reduce parameters means the initial value, the second is the definition mean how to calculate or accumulate about this initial value. Additionally, You can skip the first parameter. but if you do that, the reduce function have to been returned with the Optional class. because The reduce don’t know the initial status. 1234/** Example of the reduce that doesn&#x27;t have initial value */Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; a + b); External Iteration and Internal Iteration may have two major differences. The one is readable. Internal iteration only need the code related to the ‘what do you want’ no ‘how do we build’. but External iteration is not. and the second one is the performance. It’s difficult to give the parallel attribute to External Iteration. but the Internal Iteration case, You can give the parallel thing automatically if you want. 2. CollectorsIt’s the Reduce Computation already made from Java Developers. If you don’t use this about the normal problem, then you always should create the logic for that using the reduce function. Collectors class occurs the useful computation for the normal situation like getting the max value, getting the summing of the all values. The difference meaning between Collection, collect, Collectors,They have really similar the term. but they are really different. First of all, Collection is the Collection Framework. Actually We already know about that from previous Java 8. It’s for expressing the structure of the data like List, Set, Map. The collect is the one of the function used from the Stream API. Usually it takes the Collectors object including the stream parameter and returns any value like the reduce function. and finally Collectors is the one of the class. It implements the Collector interface. and It can give a lot of the useful function when you need the Collector object. Collection It’s just the Collection Framework which may know a lot of Java programmer. collect() It’s the one of the function used from the Stream API. Collectors It’s the implementation of the Collector interface. and They are usually used from collect function. maxBy()12345Comparator&lt;Dish&gt; dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);Optional&lt;Dish&gt; mostCaloriesDish = menu.stream().collect(maxBy(dishCaloriesComparator)); minBy()12345Comparator&lt;Dish&gt; dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);Optional&lt;Dish&gt; mostCaloriesDish = menu.stream().collect(minBy(dishCaloriesComparator)); summingInt()123int totalCalories = menu.stream().collect(summingInt(Dish::getCalories)); joining()1234567/** You can merge the set of names using joining function without separator */String shortMenu = menu.stream().map(Dish::getName).collect(joining());/** You can merge the set of names using joining function with separator */String shourMenu = menu.stream().map(Dish::getName).collect(joining(&quot;, &quot;)); groupingBy()groupingBy function can be overlaid itself like the below. You can make a group using the filter function of the Stream. but if you use the way using filter, it doesn’t keep the empty status. In other word, if some groups don’t have the elements then it will be not exist. 1234567891011121314Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel = menu.stream().collect( groupingBy(Dish::getType, groupingBy(dish -&gt; &#123; if(dish.getCalories() &lt;= 400) return CaloricLevel.DIET; else if(dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; &#125;) )) partitioningBy()It’s the special case of the groupingBy function. It can separate using only predicate function returning boolean value. and It can be also overlaid itself. 1234Map&lt;Boolean, Map&lt;Dish.Type, List&lt;Dish&gt;&gt;&gt; vegetarianDishesByType = menu.stream().collect( partitioningBy(Dish::isVegetarian, groupingBy(Dish::getType)));","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"Java 8 Stream","slug":"2020-3-16-java-stream","date":"2020-03-16T02:21:54.000Z","updated":"2022-05-31T07:13:31.000Z","comments":true,"path":"2020/03/16/","link":"","permalink":"http://kidongyun.github.io/2020/03/16/","excerpt":"","text":"1. Why do we use the stream ? You don’t need to think about how to build. It’s like the Query. How do we get the max value before the Java8, We always use the ‘for’ keyword or ‘if’ keyword for getting that data. And We should consider the logic for getting the result of calculating like the max value. In other word, If you don’t use the Stream then you always think about how we build the logic for getting some data. But if you use this, you don’t need to think about the focus of the building. You can get the advantage of the parallel. Previus the Java8, Parallel coding is too difficult to a lot of the Java developers. You should use the ‘Thread’ technic and always consider about the ‘Mutual Exclusion’ It’s too low technic to Application Developers. So If you use the Stream then you can get the parallel advantage without Thread, The thinking about the Locking. It’s more readable than previous. You just concentrate about the think you want using the stream like the query. so consequently, the source code is more shorter that previous and more intuitive. 2. Stream Manipulation ComputationIt’s the summary of the use of stream basically. filter() ‘filter()’ function is for seperating the elements of the stream utilzing any function returning boolean value. 123456List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);/** Get the even numbers from the number list. */List&lt;Integer&gt; evenNumbers = numbers.stream().filter(i -&gt; i % 2 == 0).collect(toList()); takewhile() Do you know the break keyword for the Java ? when you want to finish some iteration status, You can use this keyword. In the filter() function, It’s always iterate everything elements although you got the value you want. If you want to stop the iteration when you complete your mission then use this keyword. 123456List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);/** Get the small numbers from the number list. */List&lt;Integer&gt; smallNumbers = numbers.stream().takeWhile(i -&gt; i &lt; 5).collect(toList()) dropwhile() It’s other side of the takewhile() function. If you want to get the large number then use this keyword. 123456List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);/** Get the large numbers from the number list. */List&lt;Integer&gt; smallNumbers = numbers.stream().dropWhile(i -&gt; i &lt; 5).collect(toList()); distinct() If you don’t want to get duplicate value like the Set then use this. 123456List&lt;Integer&gt; numbers = Arrays.asList(1, 1, 2, 2, 3, 3, 4, 4, 5, 5);/** Get the numbers without duplcate value. */List&lt;Integer&gt; uniqueNumbers = numbers.stream().distinct().collect(toList()); limit() You can limit the number of the result using this function 123456List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);/** Get the limited numbers */List&lt;Integer&gt; limitedNumbers = numbers.stream().limit(3).collect(toList()); skip() If you want to skip the elements coming first, then use this function. 123456List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);/** Get the skipped numbers */List&lt;Integer&gt; skipedNumbers = numbers.stream().skip(3).collect(toList()); map() If you want translate the type of the stream. then use this function. 1234List&lt;Dish&gt; menu;/** Get the list of names from the menu. */List&lt;String&gt; dishNames = menu.stream().map(Dish::getName).collect(toList()); The type of the menu is the List and the type of the dishNames is the List. It’s different. So You should convert the type using the map() function like the above code. 3. Stream Search Computation allMatch() It return the boolean value. It checkes what the all of the elements pass the condition off or not. 12345List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);boolean allMatechNumbers = numbers.stream().allMatch(i -&gt; i &gt; 0); anyMatch() If the elements pass the condition at least 1 thing, then It will return true. 12345List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);boolean anyMatechesNumbers = numbers.stream().anyMatch(i -&gt; i &gt; 9); nonMatch() Everyting should be fail about the condition. if you want get the true. 12345List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);boolean nonMatchNumbers = numbers.stream().noneMatch(i -&gt; i &gt; 10); findFirst() If you want to get the first element of the result, then use this. 1234567List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);/** Get the first element value but It may be null. */Optional&lt;Integer&gt; firstNumber = numbers.stream().findFirst();/** Get the first element value. It has to be not null. */Integer firstNumber = numbers.stream().findFirst().get(); This function allow to get the null value basically because of empty list source. So It’s return the type Optional thing. but If you sure that don’t have the null value, You can get the result without Optional using the get() function. findAny() If you want to get element randomly from the result, then use this. 123456789List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);/** Get the any element value but It may be able to be null */Optional&lt;Integer&gt; randomNumber = numbers.stream().findAny();/** Get the any element value */Integer firstNumber = numbers.stream().findFirst().get(); 4. Primitive Specialized StreamThe stream offer the privitive specialized stream like IntStream, LongStream, DoubleStream. I think you already know the terms of Boxing, Unboxking. It’s the translating between the primitive type and the Object type. Actually You should pay really high cost when it occurred. So Java8 offer us primitive specialized stream to avoid this high cost. 12345678/** It&#x27;s the example of &#x27;IntStream&#x27; */int Calories = menu.stream().mapToInt(Dish::getCalories).sum();/** You can translate between primitive type and object type like the below if you want */IntStream intStream = menu.stream().mapToInt(Dish::getCalories);Stream&lt;Integer&gt; stream = intStream.boxed(); 5. The various way to build the stream Stream.of() 12345Stream&lt;String&gt; stream = Stream.of(&quot;Mordern&quot;, &quot;Java&quot;, &quot;In&quot;, &quot;Action&quot;);stream.map(String::toUpperCase).forEach(System.out::println); Arrays.stream() 12345int[] numbers = &#123;2, 3, 5, 7, 11, 13&#125;;int snum = Arrays.stream(numbers).sum(); Stream.iterate() 12345Stream.iterate(0, n -&gt; n + 2) .limit(10) .forEach(System.out::println); Stream.generate() 12345Stream.generate(Math::random) .limit(5) .forEach(System.out.println);","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"How to use the mysql dump file.","slug":"2020-02-24-mysqldump","date":"2020-02-24T02:21:54.000Z","updated":"2022-05-31T07:13:22.000Z","comments":true,"path":"2020/02/24/","link":"","permalink":"http://kidongyun.github.io/2020/02/24/","excerpt":"","text":"This article is just for recording the way how to use rgw mysql dump file. Export (dump)First of all, You have to move the directory to the root of mysql. and then You can see the mysqldump.exe file. at there, Let’s start to type the below command. then your file will save with the below file name. 1mysqldump -u [user id] -p [database name] &gt; [.sql file] ImportIt has to go the root directory either. and then follow the below. 1mysql -u [user id] -p database name &lt; [.sql file]","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://kidongyun.github.io/tags/Mysql/"}]},{"title":"Lambda and Method Reference","slug":"2020-02-16-lambda-and-method-reference","date":"2020-02-15T23:47:54.000Z","updated":"2022-05-31T07:13:13.000Z","comments":true,"path":"2020/02/16/","link":"","permalink":"http://kidongyun.github.io/2020/02/16/","excerpt":"","text":"자바에서의 함수자바에서 함수, 메소드는 독립적으로 존재할 수 없는 개체이다. 하지만 함수형 프로그래밍이 대두됨에 따라서 ‘Java8’ 에서는 함수를 독립적으로 사용하기 위해서 ‘FunctionalInterface’ 이라는 방법을 제공한다. 123456@FunctionalInterfaceinterface DummyInterface &#123; int doSomething(String string);&#125; 위 코드는 ‘doSomething()’ 이라는 함수를 Java에서 구현하기 위한 방법이다. 실제로 함수만 따로 존재할 수 없기 때문에 위와 같은 단 하나의 함수만 가질 수 있는 제한된 인터페이스를 활용해 함수를 구현한다. 람다Java8의 람다식은 함수 자체를 표현하는 방법 중 하나이며 이 람다식이 중요하게되는 근본적인 이유는 Java8에서 바로 이 함수를 값으로 받을 수 있기 때문이다. Java8 이전의 Java에서는 ‘String’ 타입의 값을 ‘int’ 타입으로 변환하여 저장하는 기능을 구현하기 위해서는 아래의 함수를 구현하고 각 필드에 따라서 이 함수를 사용해야 했다. 123456789public int stringToInt(String string) &#123; return Integer.parseInt(string);&#125;public void main() &#123; int number = stringToInt(&quot;20&quot;);&#125; 기존의 Java 에서는 ‘stringToInt()’ 함수 자체를 저장하기 위한 방법이 존재 하지 않았지만 Java8 이후에서는 이 ‘stringToInt()’ 함수 자체를 값으로써 저장이 가능해진다. 다만 이를 위해서는 람다식을 사용해야한다. 12345public void main() &#123; ToIntFunction&lt;String&gt; stringToInt = (String string) -&gt; Integer.parseInt(string);&#125; ‘ToIntFunction‘ 객체는 int 타입을 반환하는 함수들을 위한 타입이라고 보면된다. 다시 말하면 int가 정수를 위한 타입이라면 이 ‘ToIntFunction‘ 객체는 함수를 위한 타입이다. 함수를 값으로 줄 때 가장 중요하게 다뤄야 할 부분은 바로 파라미터의 형태와 반환 형태이다. 이를 Java8 에서는 ‘함수 디스트립터’ 라고 부르는데 쉽게 함수의 모양이라고 생각하면 된다. 메소드 참조람다는 기존 자바에서 익명 클래스와 비슷하다. 별도로 선언하지 않고 필요한 코드블록에서 함수 디스크립터가 동일한 구조의 람다식을 제공하면 그 함수 자체가 값에 저장이 되어진다. 그렇다면 함수를 만약에 명시적으로 사용하고 싶다면 어떻게 해야할까. 바로 메소드 참조를 사용한다. 우선 ‘FunctionalInterface’ 를 활용해 함수를 위한 제한된 인터페이스 하나를 구현하고 이를 메소드 참조 연산자를 활용해 호출하면 된다. 12345678910111213141516```여기 좀 더 공부해서 보강해야 할 듯.### 람다의 타입 검사, 추론, 제약#### 타입 검사람다식을 사용할 때 사용된 함수 디스크립터가 맞는지 아닌지를 어떻게 확인 할 수 있을까. 위의 예를 활용해 확인해보자.```java public void main() &#123; ToIntFunction&lt;String&gt; stringToInt = (String string) -&gt; Integer.parseInt(string);&#125; 람다식은 ‘ToIntFunction‘ 의 함수 디스크립터를 확인해서 타입 검사를 한다. 타입 추론ToIntFunction 의 함수 디스크립터를 활용해 람다식의 함수 디스크립터를 추론할 수 있다. 따라서 필요한 경우 파라미터의 타입은 생략이 가능하다. 12345public void main() &#123; ToIntFunction&lt;String&gt; stringToInt = (string) -&gt; Integer.parseInt(string);&#125; 제약사항람다식은 익명 클래스와 유사하게 동작하기 때문에 람다식이 구현된 코드블록 외부에 있는 변수에도 접근이 가능하다. 이렇게 외부에 있는 변수를 람다식 안에 쓸수 있도록 하는 것을 람다 캡처링이라고 한다. 12345678class Main &#123; public void main() &#123; String str1 = &quot;10&quot;; ToIntFunction&lt;String&gt; stringToInt =(str2) -&gt; Integer.parseInt(str1 + str2); &#125;&#125; 위의 예에서 ‘str1’ 은 람다식 외부에 있는 변수임에도 접근이 가능하다. 하지만 중요한 점은 이 ‘str1’ 변수는 final 로 선언이 되거나 수정이 되지 않는 변수여야 한다. 람다 캡처링을 할 때 람다식은 외부에 있는 이 지역변수를 쓸수 있도록 공유 가능한 힙 메모리로 올리는데 이 때 복사본이 올라가게 된다. 람다식에서 이 값을 쓰고 그 이후에 지역 변수가 값을 수정하게되면 서로 상이하게 됨으로 람다 캡처링을 위한 지역변수는 수정을 하지 않는 값이여야 한다. 메모리 참조아래와 같은 세가지 타입이 존재. 1234567// Lambda(args) -&gt; ClassName.staticMethod(args)// Method ReferenceClassName::staticMethod 1234567// Lambda(arg0, rest) -&gt; arg0.instanceMethod(rest)// Method ReferenceClassName::instanceMethod 1234567//Lambda(args) -&gt; expr.instanceMethod(args)// Method Referenceexpr::instanceMethod","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"Refactor java code using the strategy pattern and behavior parameterization in Java 8","slug":"2020-02-16-refactoring-java-with-strategy-behavior-parameterization","date":"2020-02-15T23:47:54.000Z","updated":"2022-05-31T07:13:18.000Z","comments":true,"path":"2020/02/16/","link":"","permalink":"http://kidongyun.github.io/2020/02/16/","excerpt":"","text":"전략 패턴과 동작 파라미터화를 활용해서 자바 코드를 리팩토링 해보자실무의 관점에서 코드를 올바르고 좋게 짠다는 것은 다양한 관점이 있겠지만 그 중 하나는 ‘확장성’ 있는 코드를 만드는 것이다. 어떤 비즈니스가 어떠한 방향으로 새롭게 변경될지는 아무도 모르기 때문에 개발자의 입장에서 어떤 코드를 작성할 때에는 최대한 그 변화들을 수용할 수 있는 코드를 작성할 수 있어야 새로운 비즈니스가 들어왔을 때 필요한 비용이 획기적으로 적어진다. 여기서 이 ‘확장성’이라는 의미는 기존의 코드를 수정하지 않음을 포함한다. 실무를 경험해본 이들은 모두 아시다시피 이 전에 작성된 코드를 수정하는 것은 정말 어렵다. 파악하기가 어려운 것도 맞는 말이고 또 그 코드를 수정했을 때 잘 돌아가고 있던 서비스가 문제가 발생할 수도 있기 때문에 개발자들은 새로운 코드를 추가할 때 기존의 코드는 최대한 건드리지 않게 된다. 즉 결과적으로 확장성을 고려하지 않는다면 나도 모르는 사이에 어느 순간 코드들은 더러워지게 된다. 그렇다면 사과장수라는 한가지 예를 들어서 어떻게하면 확장성을 가지는 자바 코드를 구현할 수 있는지 전략 디자인 패턴과 동작 파라미터화 개념을 활용해 생각해보자. 123456789101112131415161718192021222324252627class Apple &#123; private String color; private int weight; public String getColor() &#123; return this.color; &#125; public int getWeight() &#123; return this.weight; &#125;&#125;class Melon &#123; private String color; private int weight; public String getColor() &#123; return this.color; &#125; public int getWeight() &#123; return this.weight; &#125;&#125;enum Color &#123; RED, GREEN &#125; 위의 자바코드는 아래에서 진행할 이해를 위한 예시에 필요한 기본 코드다. 사과를 표현하는 ‘Apple’ 객체와 멜론을 표현하는 ‘Melon’ 객체 그리고 색의 값들을 가지고 있는 ‘Color’ 열거형 객체다. 초록색을 구분하려고 하는 사과장수어떤 사과장수가 온라인에서도 사과를 팔고 싶어해 우리에게 프로그램 제작을 의뢰했다. 사과장수의 한가지 요구사항은 초록색 사과를 구분할 수 있는 기능을 가져야 한다는 것이다. 그렇기에 우리는 아래와 같은 코드를 구현했다. 1234567891011121314151617181920212223class Main &#123; public List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple: inventory) &#123; if(Color.GREEN.equals(apple.getColor())) &#123; result.add(apple); &#125; &#125; return result; &#125; public void main() &#123; List&lt;Apple&gt; inventory = new ArrayList&lt;&gt;(); List&lt;Apple&gt; greenApples = filterGreenApples(inventory); &#125;&#125; ‘filterGreenApples()’ 함수는 초록색을 구분하는 자바코드이고 ‘main()’ 함수에서 사용 예시를 보여주고 있다. ‘filterGreenApples()’ 함수는 파라미터로 전체 사과리스트를 받고 반복문을 돌려 초록색을 가진 사과들만 새로운 ‘result’ 라는 리스트에 넣어서 반환하고 있다. 이 코드는 초록색을 구분해준다는 기능의 관점에서는 아무런 문제가 없을 것 같다. 다만 이 코드가 정말 확장성이 있을지는 아래의 새로운 요구사항을 보면서 고민해보자. 빨간색도 구분하려고 하는 사과장수.이번에는 이 사과장수가 빨간색도 구분하고 싶다고 한다. 초록색처럼 동일하게 구현하면 되겠다고 생각한 우리 팀 초보 자바개발자는 아래와 같이 코드를 구현했다. 123456789101112131415161718192021222324252627282930313233343536class Main &#123; public List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple : inventory) &#123; if(Color.GREEN.equals(apple.getColor())) &#123; result.add(apple); &#125; &#125; return result; &#125; public List&lt;Apple&gt; filterRedApples(List&lt;Apple&gt; inventory) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple : inventory) &#123; if(Color.RED.equals(apple.getColor())) &#123; result.add(apple); &#125; &#125; return result; &#125; public void main() &#123; List&lt;Apple&gt; inventory = new ArrayList&lt;&gt;(); List&lt;Apple&gt; greenApples = filterGreenApples(inventory); List&lt;Apple&gt; redApples = filterRedApples(inventory); &#125;&#125; 자 여기서 무엇이 확장성의 관점에서 문제가 될지를 확인해보자. 내 생각에 확장성을 따질 때 고려해야할 사항은 아래와 같다. 123451. 코드의 중복의 정도2. 기존 코드를 수정해야 하는 정도. 중복된 코드가 많으면 코드에 수정이 일어날 때 이 코드들을 모두 수정해야 하는 이슈가 발생한다. 그런 의미로 ‘코드의 중복’은 확장성의 관점에서 좋지 않다. 그렇기에 지금 짜여진 ‘filterGreenApples()’, ‘filterRedApples()’ 함수들을 중복을 제거해서 코드를 구현해보도록 하자. 123456789101112131415161718192021222324class Main &#123; public List&lt;Apple&gt; filterApplesByColor(List&lt;Apple&gt; inventory, Color color) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple : inventory) &#123; if(color.equals(apple.getColor())) &#123; result.add(apple); &#125; &#125; return result; &#125; public void main() &#123; List&lt;Apple&gt; inventory = new ArrayList&lt;&gt;(); List&lt;Apple&gt; greenApples = filterApplesByColor(inventory, Color.GREEN); List&lt;Apple&gt; redApples = filterApplesByColor(inventory, Color.RED); &#125;&#125; 색이라는 값을 파라미터로 전달해 ‘filterApples()’ 함수가 색에 따라서 유연하게 대처할 수 있도록 했다. 이제 이 사과장수는 어떤 색이 오더라도 이 함수를 활용해 구분할 수 있을 것이다. 무게도 구분하고 싶어하는 사과장수자 이제 ‘filterApplesByColor()’ 함수가 확장성에서 또 어떤 한계점을 가지는지 확인해보자. 사과장수가 이번에는 ‘150g’ 이상의 사과들을 무거운 사과로 구분할 수 있는 기능을 가지고 싶다고 한다. 여기서 우리는 색과 동일한 구조로 무게를 위한 함수를 구현할 수 있을 것이다. 1234567891011121314151617181920212223242526272829303132333435363738class Main &#123; public List&lt;Apple&gt; filterApplesByColor(List&lt;Apple&gt; inventory, Color color) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple : inventory) &#123; if(color.equals(apple.getColor())) &#123; result.add(apple); &#125; &#125; return result; &#125; public List&lt;Apple&gt; filterApplesByWeight(List&lt;Apple&gt; inventory, int weight) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple : inventory) &#123; if(apple.getWeight() &gt; weight) &#123; result.add(apple); &#125; &#125; return result; &#125; public void main() &#123; List&lt;Apple&gt; inventory = new ArrayList&lt;&gt;(); List&lt;Apple&gt; greenApples = filterApplesByColor(inventory, Color.GREEN); List&lt;Apple&gt; redApples = filterApplesByColor(inventory, Color.RED); List&lt;Apple&gt; heavyApples = filterApplesByWeight(inventory, 150); &#125;&#125; 자 이제 위의 코드를 다시 확장성의 관점에서 보자. 아까 색과 관련해 리팩토링했던 것과 같이 비슷한 코드의 형태가 나타나고 있다. 이번에는 이 코드들의 중복을 어떻게 하면 제거할 수 있을지, 어떻게 하면 확장성 있는 코드를 짤 수 있을지 고민해보자. 전략패턴을 활용하자.우리는 왜 ‘filterApplesByColor()’, ‘filterApplesByWeight()’ 두 함수가 유사한 구조를 가진다고 판단했을까? 이는 두 함수가 공통된 사항을 가지고 있기 때문이다. 다시 말하면 이 함수들은 결과적으로 함수 내부적으로 어떠한 기준(색, 무게)에 따라서 각 사과들을 참과 거짓으로 구분하고 있다는 점이다. 이 사과가 빨간색인지 아닌지 혹은 150g 이상인지 아닌지처럼 말이다. 우리는 무언가를 구분한다는 공통된 요소들을 하나의 인터페이스화 하기 위해서 전략패턴을 사용할 것이다. 전략패턴이란 한 함수에서 비즈니스적인 부분과 알고리즘적인 부분을 서로 구분하여 구현하는 방법론이다. 1234567891011121314151617181920212223242526272829303132// algorithmpublic boolean algorithmForColor1(Apple apple, Color color) &#123; if(color.equals(apple.getColor())) &#123; return true; &#125; else &#123; return false; &#125;&#125;// algorithmpublic boolean algorithmForColor2(Apple apple, Color color) &#123; if(!color.equals(apple.getColor())) &#123; return false; &#125; else &#123; return true; &#125;&#125;// businesspublic List&lt;Apple&gt; filterApplesByColor(List&lt;Apple&gt; inventory, Color color) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple : inventory) &#123; if(algorithmForColor1(apple, color)) &#123; result.add(apple); &#125; &#125; return result;&#125; 위의 예시처럼 사과의 색을 구분한다는 ‘filterApplesByColor()’ 비즈니스 함수에서 실제 색을 구분하는 부분은 별도의 알고리즘 함수를 제공해서 구현하고 있다. 이렇게 구현을 해두면 필요에 따라 다른 알고리즘을 선택해 비즈니스 영역을 구현할 수 있다. 일반적으로 기존의 코드를 수정하게 되는 경우는 비즈니스가 변경되는 경우가 많은데 이렇게 구현을 해두면 알고리즘 부분은 건드리지 않고 비즈니스 영역 코드만 수정하면 됨으로 중복의 관점의 문제점도 해결이 가능하다. 혹시나 위와 같이 비즈니스와 알고리즘을 굳이 예시처럼 구현해야하나 라는 생각이 들수 있지만 이는 지금 알고리즘 내용이 비교적 매우 간단하기 때문이다. 만약 어떤 비지니스가 최단거리를 탐색하는 알고리즘을 써야하는 경우라면 이를 DFS를 커스터마이징하여 구현할 수도 있고, Dijkstra, A* 등 다양한 형태로 구현이 가능하다. 이렇게 비지니스 적인 부분과 알고리즘적인 부분을 구분해서 코딩하는 것은 ‘확장성’ 면에서 굉장히 중요하다. 알고리즘 영역을 위한 코드를 인터페이스로 묶자.위처럼 알고리즘 부분을 별도의 함수로 구분하게 되면 이 알고리즘 코드들은 굉장히 유사해진다. 입력되어지는 값과 출력해야하는 값의 구조가 동일하기 때문이다. 이 공통적인 부분을 인터페이스를 활용해 묶어보도록 하자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748interface ApplePredicate &#123; boolean test(Apple apple);&#125;class AppleHeavyWeightPredicate implements ApplePredicate &#123; public boolean test(Apple apple) &#123; return apple.getWeight() &gt; 150; &#125;&#125;class AppleGreenColorPredicate implements ApplePredicate &#123; public boolean test(Apple apple) &#123; return Color.GREEN.equals(apple.getColor()); &#125;&#125;class AppleRedAndHeavyPredicate implements ApplePredicate &#123; public boolean test(Apple apple) &#123; return Color.RED.equals(apple.getColor()) &amp;&amp; apple.getWeight() &gt; 150; &#125;&#125;class Main &#123; public List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory, ApplePredicate p) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple : inventory) &#123; if(p.test(apple)) &#123; result.add(apple); &#125; &#125; return result; &#125; public void main() &#123; List&lt;Apple&gt; inventory = new ArrayList&lt;&gt;(); List&lt;Apple&gt; greenApples = filterApples(inventory, new AppleGreenColorPredicate()); List&lt;Apple&gt; heavyApples = filterApples(inventory, new AppleHeavyWeightPredicate()); List&lt;Apple&gt; redAndHeavyApples = filterApples(inventory, new AppleRedAndHeavyPredicate()); &#125;&#125; 비즈니스 역할을 하는 ‘filterApple()’ 함수는 이제 공통된 인터페이스 ‘ApplePredicate’ 를 파라미터로 가짐으로 여러 개를 만들 필요가 없다. 그 안에 필요한 알고리즘 영역 ‘(ApplePredicate)’ 들만 필요한 때에 새로운 ‘class’ 를 만들어서 제공하면 된다. 정말 코드가 좋아졌는가?여기서 의문을 가져보자. 지금까지 전략패턴을 활용해서 비즈니스 영역과 알고리즘 영역의 코드를 구분하고 알고리즘 영역의 코드들의 공통 부분을 인터페이스로 묶어서 코드들을 구현했다. 이 코드가 맨 처음 리팩토링 하기 전 ‘filter…..()’ 함수를 계속 만들어 가는 코드보다 분명히 좋은 코드인지 궁금증을 가져보자. 1. ‘코드의 중복’의 관점에서는 결국에는 개선되지 않았다.12345678910111213141516171819class AppleHeavyWeightPredicate implements ApplePredicate &#123; public boolean test(Apple apple) &#123; return apple.getWeight() &gt; 150; &#125;&#125;class AppleGreenColorPredicate implements ApplePredicate &#123; public boolean test(Apple apple) &#123; return Color.GREEN.equals(apple.getColor()); &#125;&#125;class AppleRedAndHeavyPredicate implements ApplePredicate &#123; public boolean test(Apple apple) &#123; return Color.RED.equals(apple.getColor()) &amp;&amp; apple.getWeight() &gt; 150; &#125;&#125; 아래의 3개의 알고리즘 영역 코드들을 보면 상당히 비슷해 보이는 코드들을 계속해서 사용하고 있다. 따라서 코드의 중복의 관점에서는 완전히 해결한것이라고 보기는 어렵다. 다만 이부분은 Java8 문법을 활용하면 말끔히 해결 할 수 있다. 즉 이 문제는 기존의 Java로는 해결이 불가능한 문제이다. 2. ‘기존의 코드를 수정해야 하는가’ 관점에서는 성공적이다.맨 처음 리팩토링되기 전 ‘filter….()’ 함수들을 계속 생성하는 방법은 사실 기존의 코드를 수정할 필요는 없다. 계속 중복된 새로운 코드 만을 만들기 떄문이다. 다만 전체적인 구조를 바꿔야 하는 작업에서는 만들어진 모든 중복된 ‘filter….()’ 함수들을 개선해야 하는데 이것은 지금 리팩토링된 코드에서는 비즈니스 영역과 알고리즘의 영역이 구분되어져 있기 때문에 딱 하나 있는 비즈니스 영역의 ‘filterApples()’ 함수 만 변경하면 된다.(알고리즘 영역이 변경되는 드문 일이며 이를 개선해야하는 것은 애초에 알고리즘 영역에 비즈니스가 포함된건 아닌지 의심해야 한다. ) 3. 컴파일러가 인식할 수 있다.만약에 알고리즘의 영역 코드 (Predicate를 상속하고 있는 클래스들) 들이 수정되야 한다고 가정해보자. 그럼에도 이 코드들은 리팩토링 되기 이전의 코드보다 좋다. 왜냐하면 하나의 인터페이스로 공통화가 되어있기 때문에 수정되지 않은 코드블록이 있다면 타입이 안 맞아 이는 컴파일러가 인지할 수 있다. 단순히 ‘filter….()’ 형태로 만들게 되면 이 함수들은 서로 독립적이기 때문에 컴파일러는 각 함수들이 새로운 요구사항에 수정되어졌는지 아닌지 알수 없다. 즉 런타임 환경에서 에러를 확인해야 한다. 익명 클래스를 활용해 class 수를 줄여보자.전략패턴을 활용해 알고리즘을 영역 코드들을 새로운 class를 만드는 방식으로 개선했다. 하지만 이 방법도 한계가 있는데 새로운 class를 계속 만들게 됨으로 너무 많은 class를 가지게되는 문제점이 있다. 이를 해결하기 위해 익명 클래스를 활용해 보자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546interface ApplePredicate &#123; boolean test(Apple apple);&#125;class Main &#123; public List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory, ApplePredicate p) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple : inventory) &#123; if(p.test(apple)) &#123; result.add(apple); &#125; &#125; return result; &#125; public void main() &#123; List&lt;Apple&gt; inventory = new ArrayList&lt;&gt;(); List&lt;Apple&gt; greenApples = filterApples(inventory, new ApplePredicate() &#123; @Override public boolean test(Apple apple) &#123; return apple.getWeight() &gt; 150; &#125; &#125;); List&lt;Apple&gt; heavyApples = filterApples(inventory, new ApplePredicate() &#123; @Override public boolean test(Apple apple) &#123; return Color.GREEN.equals(apple.getColor()); &#125; &#125;); List&lt;Apple&gt; redAndHeavyApples = filterApples(inventory, new ApplePredicate() &#123; @Override public boolean test(Apple apple) &#123; return Color.RED.equals(apple.getColor()) &amp;&amp; apple.getWeight() &gt; 150; &#125; &#125;); &#125;&#125; 각 알고리즘 마다 새로운 클래스를 만들었던 이전의 방법과 달리 그 클래스들을 ‘main()’ 안에서 직접 생성하고 있다. 하지만 이 방법은 알고리즘 코드가 길다면 사용하기 어렵고 또 위와 같이 조금만 사용하는 양이 많아져도 가독성이 떨어지게 된다. Java8 함수의 혁신위의 까지의 리팩토링은 Java8 이전에 가능한 방법이였다. 이제는 Java8의 람다식을 활용해서 더 좋은 코드를 만들어보자. 기존의 자바는 함수를 값으로 생각하는 함수형 프로그래밍을 제공하지 않았다. 즉 파라미터로 값을 전달할 때 기존의 자바가 가능했던 것은 필드값, 객체가 전부였다. 따라서 위의 익명 클래스 부분에 ‘ApplePredicate’ 객체를 보면 정작 필요한 것은 참과 거짓을 구분하는 ‘test()’ 함수 이지만 Java에서는 함수가 혼자 존재할 수 없음으로 새로운 익명 클래스를 만들고 그 안에서 ‘test()’ 함수를 구현하고 있다. 그러나 typescript, swift 등 다양한 언어에서 이미 이 함수형 프로그래밍 언어의 장점을 보여주고 있어서 Java8에서는 이 함수형 프로그래밍 방법을 수용했다. 바로 이 함수 자체를 파라미터의 값으로 전달이 가능한 것이다. 1234567891011121314151617181920212223242526272829class Main &#123; public List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory, ApplePredicate p) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for(Apple apple : inventory) &#123; if(p.test(apple)) &#123; result.add(apple); &#125; &#125; return result; &#125; public void main() &#123; List&lt;Apple&gt; inventory = new ArrayList&lt;&gt;(); List&lt;Apple&gt; greenApples = filterApples(inventory, (Apple apple) -&gt; apple.getWeight() &gt; 150); List&lt;Apple&gt; heavyApples = filterApples(inventory, (Apple apple) -&gt; Color.GREEN.equals(apple.getColor())); List&lt;Apple&gt; redAndHeavyApples = filterApples(inventory, (Apple apple) -&gt; Color.RED.equals(apple.getColor()) &amp;&amp; apple.getWeight() &gt; 150); &#125;&#125;interface ApplePredicate &#123; boolean test(Apple apple);&#125; 위의 코드를 익명 클래스를 사용해 리팩토링한 코드와 한번 비교해보자. 이는 아래와 같다. 1234567891011List&lt;Apple&gt; greenApples = filterApples(inventory, new ApplePredicate() &#123; @Override public boolean test(Apple apple) &#123; return apple.getWeight() &gt; 150; &#125;&#125;)List&lt;Apple&gt; greenApples = filterApples(inventory, (Apple apple) -&gt; apple.getWeight() &gt; 150); Java8 이후에서는 함수가 클래스 안에 있지 않아도 되기 때문에 굳이 구현한 ‘ApplePredicate’ 객체 안에 ‘test()’ 함수를 ‘(Apple apple) -&gt; apple.getWeight() &gt; 150’ 한 줄로 끝내버릴 수 있게 되었다. Java8에서는 정말로 함수를 독립적인 단위로 가질수 있는가?사실 답은 그렇지 않다. 지금까지 자바의 구조가 함수를 값으로써 인정하지 않았기 때문에 기존의 뿌리 구조를 흔들면서 함수를 값으로 볼수 있게 하는 것은 Java를 개발하는 개발자들도 굉장히 힘든일일 것이다. 그래서 Java8은 함수를 값으로 존재하기 위해 한가지 편법을 사용한다. 단순히 함수를 만들고 싶다면 Interface를 하나 만들고 거기에 오직 한 가지 함수를 존재하게 하자. 이렇게 되면 사용자가 이 interface의 함수를 단순히 함수로써 사용할 수 있게 된다. 이러한 형태의 interface를 함수형 인터페이스라고 칭하며 ‘@FunctionalInterface’ 어노테이션을 활용해 함수로써 사용하는 인터페이스라고 선언할 수 있다. 확장성을 위한 마지막 시도.한번 사과장수인 사람은 영원히 사과장수 일까? 지금까지 우리의 확장성을 위한 노력은 사과를 구분할때 사용하는 ‘filter()’ 함수를 중심으로 잡고 리팩토링을 진행했다. 그러나 이 코드들은 사과장수가 만약 멜론장수가 된다면 전혀 사용할 수 없게 된다. 그래서 제네릭 문법을 활용해서 최종적인 확장성을 위한 시도를 하자. 즉 어떤 대상이 와도 우리가 만든 ‘filter()’ 함수를 사용할 수 있도록 구현하는 것이다. 123456789101112131415161718192021222324252627282930@FunctionalInterfaceinterface Predicate&lt;T&gt; &#123; boolean test(T t);&#125;class Main &#123; public &lt;T&gt; List&lt;T&gt; filterApples(List&lt;T&gt; inventory, Predicate&lt;T&gt; p) &#123; List&lt;T&gt; result = new ArrayList&lt;&gt;(); for(T t : inventory) &#123; if(p.test(t)) &#123; result.add(t); &#125; &#125; return result; &#125; public void main() &#123; List&lt;Apple&gt; inventory = new ArrayList&lt;&gt;(); List&lt;Apple&gt; greenApples = filterApples(inventory, (Apple apple) -&gt; apple.getWeight() &gt; 150); List&lt;Apple&gt; heavyApples = filterApples(inventory, (Apple apple) -&gt; Color.GREEN.equals(apple.getColor())); List&lt;Apple&gt; redAndHeavyApples = filterApples(inventory, (Apple apple) -&gt; Color.RED.equals(apple.getColor()) &amp;&amp; apple.getWeight() &gt; 150); &#125;&#125; 지금까지 전략패턴과 ‘Java8’ 에서 제공하는 동작 파라미터화를 활용하여 확장성있는 코드를 작성하는 방법에 대해 알아보았다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"Let's know the way how do we use the JMeter briefly.","slug":"2020-1-29-jmeter","date":"2020-01-28T23:47:54.000Z","updated":"2022-05-31T07:13:08.000Z","comments":true,"path":"2020/01/29/","link":"","permalink":"http://kidongyun.github.io/2020/01/29/","excerpt":"","text":"1. Install the ‘Tomcat’Download apache-tomcat-8.5.50.zip Let’s move this ‘.zip’ file into your project directory. and please unzip the file. then You can see the directory named same with the ‘.zip’ file. 1unzip apache-tomcat-8.5.50.zip Download jmeter.war Let’s download the ‘jmeter.war’ file. It will help you to understand about the way how it works. This file isn’t special just You can approach the web service more easily. After completing, You should move the file to ‘apache-tomcat-8.5.50/webapps’ directory. 1apache-tomcat-8.5.50/webapps&gt; move jmeter.war Let’s execute your tomcat service using ‘apache-tomcat-8.5.50/bin/startup.sh’ from the ‘terminal’ 12apache-tomcat-8.5.50&gt; cd ./binapache-tomcat-8.5.50/bin&gt; sudo ./startup.sh Sometimes you may need the ‘chmod’ command for changing the authority of the ‘startup.sh’ file. otherwise It’s not working. http://127.0.0.1:8080/jmeter/search/index.html If you enter the above link then you can see the below picture, Your ‘Tomcat’ was installed perfectly. 2. Install the ‘JMeter’Download apache-jmeter-5.2.1.zip Let’s download the ‘jmeter’ from the above link. and unzip the file. Download jmeter-plugins-manager-1.3.jar It will show the graphical the status about your test request. You should put down this file into ‘/lib/ext’ 1apache-jmeter-5.2.1/lib/ext&gt; move meter-plugins-manager-1.3.jar Let’s execute your jmeter service using ‘apache-jmeter-5.2.1/bin/jmeter.sh’ from the ‘terminal’ 12apache-jmeter-5.2.1&gt; cd ./binapache-jmeter-5.2.1&gt; sudo ./jmeter.sh 3. JMeter simple test.First of all, We will test your service is well or not just using the response code. like ‘200’, ‘404’ and The below is our test scenario. 12345- 1. http://127.0.0.1:8080/jmeter/index.html GET- 2. http://127.0.0.1:8080/jmeter/search/search?key=jmeter POST Let’s make the ‘Thread Group’. It’s the collection of something like the users. These thread will request to your service as your configuration. and You can configure the number of the thread and the time for setting … 1Test plan &gt; Right click &gt; Add &gt; Threads (Users) &gt; Thread Group 12345- Number of Threads : 10 - Loop Count : 10 Secondly, We should create the ‘HTTP Request Default’. in here, You can control the overall setting associated to the HTTP Connection. like Server IP, Domain, Port, Url… 1Thread Group &gt; Right Click &gt; Add &gt; Config Element &gt; HTTP Request Defaults 12345- Server Name or IP : 127.0.0.1- Port Number : 8080 Additionally, If you want to control the Header and the Cookie, then you can use ‘HTTP Header Manager’, ‘HTTP Cookie Manager’ at that time. It’s actual the task to request some service to your project. You should create two things of this. 1Thread Group &gt; Right Click &gt; Add &gt; Sampler &gt; HTTP Request 12345678910// First One- Name : /jmeter/index.html- Path : /jmeter/index.html- Method : GET// Second One- Name : /jmeter/search/search?key=jmeter- Path : /jmeter/search/search?key=jmeter- Method : POST Importantly, Your ‘HTTP Request Defaults’ setting should be located more higher than the ‘HTTP Request’ because all of the settings are applied only to the lower things. And you have to add the listeners to two ‘HTTP Request’. They are for the monitoring your test. 123451. Thread Group &gt; Right Click &gt; Add &gt; Listener &gt; View Result Tree2. Thread Group &gt; Right Click &gt; Add &gt; Listener &gt; Summary Report Let’s execute the test 4. If you want to put the parameters dynamically using ‘.csv’Please move the ‘HTTP Request Defaults’ item to outside of ‘Thread Group’. because It will use continuously. and We should disable about the above codes ‘Thread Group’ for this coding except ‘HTTP Request Defaults’. and Let’s make new one. Finally Copy and pase the ‘/jmeter/search/search?key=jmeter’ without parameter. 123456789Thread Group &gt; Right Click &gt; DisableTest plan &gt; Right click &gt; Add &gt; Threads (Users) &gt; Thread GroupCopy and Paste &#x27;/jmeter/search/search&#x27;And change the Number of Thread option to &#x27;10&#x27; from new &#x27;Thread Group&#x27; ‘JMeter’ offer the function to change the parameters when you test your project. For that, You have to create the ‘.csv’ file. It’s named ‘search_keyword.csv’ 1234567891011121314// search_keyword.csvnumber, search_keyword0, 0keyword1, 1keyword2, 2keyword3, 3keyword4, 4keyword5, 5keyword6, 6keyword7, 7keyword8, 8keyword9, 9keyword This file should save into the directory having the save file(.jmx) of this. In my case, It’s root directory. and We should get this file into the JMeter program. 1&#x27;/jmeter/search/search&#x27; &gt; Add &gt; Config Element &gt; CSV Data Set Config Configure like the below. 12345678910111213141516171819Filename : Find your &#x27;search_keyword.csv&#x27; file using browser.File encoding :Variable Names : number,search_keywordIgnore first line : TrueDelimeter : ,Allow quoted data : FalseRecycle on EOF ? : TrueStop Thread on EOF ? : FalseSharing mode : All Threads And Add the parameter from the ‘/jmeter/search/search’. 1234567Press Add Button.Name: KeyValue : $&#123;search_keyword&#125;URL_Encode : clicked Let’s execute the test. You have to compare between the parameters of the above codes. First one has the ‘2keyword’, and Second one have the ‘5keyword’. 5. If you want to redirect dynamically after page.Before doing this step, You should disable your previous task like the above. and Create new ‘Thread Group’ 123456789Thread Group &gt; Right Click &gt; DisableTest plan &gt; Right click &gt; Add &gt; Threads (Users) &gt; Thread GroupCopy and Paste &#x27;/jmeter/search/search&#x27;, And please empty the value of parameter without keyAnd change the Number of Thread option to &#x27;10&#x27; from new &#x27;Thread Group&#x27; Let’s see the response of the ‘/jmeter/search/search’. It has a lot of url so we will redirect that url using regular expression extractor. 1&#x27;/jmeter/search/search&#x27; &gt; Add &gt; Post Processors &gt; Regular Expression Extractor 123456789- Name of created variable : next_url- Regular Expression : class=&quot;url&quot;&gt;\\( &lt;a href=&quot;(.+?)://([^:]+?):*([0-9]*?)/(.*?)&quot;- Template ($i$ ...) : $2$- Match No. : 0- Default Value And We have to create to connect for the next url. that is we need ‘HTTP Request’ one more. 12345Thread Group &gt; Add &gt; Sampler &gt; HTTP RequestHTTP Request &gt; Add &gt; Listener &gt; View Result TreeHTTP Request &gt; Add &gt; Listener &gt; Summary Report Follow the below setting. 123456789Name : next_url - $&#123;next_url&#125;Protocol : $&#123;next_url_g1&#125;Server Name or IP : $&#123;next_url_g2&#125;Port Number : $&#123;next_url_g3&#125;Path : $&#123;next_url_g4&#125; Let’s execute the test You can see the ‘next_url’ variable is different when it happened. 6. If you want to make the custom error on 200 response.Let do disable your previous things. and Create new one. and It’s really different. We will create 4 ‘HTTP Request’ items. 123456789101112131415- Create 4 &#x27;HTTP Request&#x27;Each name is the below. - No Assertion - Duration Assertion - Size Assertion - Response Assertion- Create Listeners. We should modify the ‘HTTP Request defaults’ file. please add the below url into the ‘path’ 1path : /jmeter/index.html And We will give the Assertion to each ‘HTTP Request’ 123456789101112131415161718192021Duration Assertion - Add &gt; Assertions &gt; Duration Assertion - Duration in milliseconds : 1000Size Assertion - Add &gt; Assertions &gt; Size Assertion - 500 and pres &#x27;&gt;&#x27; buttonResponse Assertion - Add &gt; Assertions &gt; Response Assertion - Write &#x27;Error occur!!&#x27; - Press &#x27;Contains&#x27; button and &#x27;Not&#x27; Let’s execute the test JMeter Lecture","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Jmeter","slug":"Jmeter","permalink":"http://kidongyun.github.io/tags/Jmeter/"}]},{"title":"To build the Spring + Mybatis + Oracle using Java configuration without XML","slug":"2020-1-26-spring-mybatis-oracle-java-config","date":"2020-01-25T23:47:54.000Z","updated":"2022-05-31T07:13:01.000Z","comments":true,"path":"2020/01/26/","link":"","permalink":"http://kidongyun.github.io/2020/01/26/","excerpt":"","text":"1. The need of Spring Framework -&gt; Third party place for creating the java objects.Have you ever thought about the reason why the Spring framework was borned? Actually When I studied this framework, I can’t understand the need of this. Everything can be implemented without the ‘Spring Framework’ but I realized the important need of ‘Spring’ at this time, Um… Have you ever felt the difficult to create the instance of the Java Object? When you have 3 Java objects, We should create these Java object using ‘new’ keyword at the somewhere. But These object are really independent then It’s really hard to determine the place where is better than another. Most of developers use the third party place like the ‘main function’ for create these java objects. Actually The important thing of the Spring Framework can offer the third party place for creating Java Objects and We say this place as ‘Spring Container’ and The java objects using the ‘Spring Container’ are named ‘Bean’. 2. Create the new projectPlase follow the below steps. First of all We should make a new project for learning the process of building the Spring + Mybatis + Oracle using Java configuration. 1File &gt; New &gt; Project then You can see the below picture, Please click the ‘Web’ option at this window. totally You should get two options. If you finished then go to next window, Press the ‘Next’ button. 1234567Selected Options. - Java - Web You should write GroupId, ArtifactId. please just typing like me. It’s not important at this topic. press ‘Next’ button. 123GroupId : com.kidongyunArtifactId : SpringMybatisOracleJavaConfiguration If you type correctly at the above step, then your project name is correct either like the below. press ‘Next’ button. 123Project name : SpringMybatisOracleJavaConfigurationProject location : The place you want Press ‘Finish’ button. 3. Configure the ‘build.gradle’After creating the new project, We gotta get the dependencies related to the Spring, Mybatis, Oracle… Please copy and paste the code to your ‘build.gradle’ build.gradle1234567891011121314151617181920212223242526272829303132plugins &#123; id &#x27;java&#x27; id &#x27;war&#x27;&#125;apply plugin: &#x27;war&#x27;group &#x27;com.kidongyun&#x27;version &#x27;1.0-SNAPSHOT&#x27;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.11&#x27; testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.12&#x27; providedCompile group: &#x27;javax.servlet&#x27;, name: &#x27;javax.servlet-api&#x27;, version: &#x27;3.1.0&#x27; runtime &#x27;javax.servlet:jstl:1.1.2&#x27; compile group: &#x27;javax.annotation&#x27;, name: &#x27;javax.annotation-api&#x27;, version: &#x27;1.3.2&#x27; compile &#x27;org.springframework:spring-webmvc:4.3.18.RELEASE&#x27; compile group: &#x27;org.springframework&#x27;, name: &#x27;spring-jdbc&#x27;, version: &#x27;3.1.0.RELEASE&#x27; compile group: &#x27;org.mybatis&#x27;, name: &#x27;mybatis-spring&#x27;, version: &#x27;1.3.2&#x27; compile group: &#x27;org.mybatis&#x27;, name: &#x27;mybatis&#x27;, version: &#x27;3.4.6&#x27; compile group: &#x27;org.apache.commons&#x27;, name: &#x27;commons-dbcp2&#x27;, version: &#x27;2.0&#x27;&#125; You should type the version of each things. If you don’t, You may encounter the error at the console especially mybatis and mybatis-spring. and the detail role of each dependency is written at here. 4. Import the local ‘ojdb6.jar’ fileLet’s download ojdbc6.jar You have to read this thing not the above. the repository for ‘OJDBC’ is not working after yesterday. for solving this problem, We will import the ‘OJDBC’ library locally. that is we will download the ‘.jar’ file related to ‘OJDBC’ and import that thing like the below Create new folder named ‘lib’ for the local jar file ‘ojdbc6.jar’. 123workspace/src/main/webapp&gt; mkdir WEB-INFworkspace/src/main/webapp/WEB-INF&gt; mkdir lib and then Let’s copy and paste ‘ojdbc6.jar’ into the ‘lib’ folder. And follow the below. 1Ctrl + Shift + Alt + S -&gt; Libraries Tab -&gt; &#x27;+&#x27; Button -&gt; Java &gt; Select your file &gt; Apply 5. Delete index.jsp files for new one1workspace&gt; rm src/main/webapp/index.jsp 6. Make the Directories and Files.For setting this proejct, You should a lot of the directories, and files. You should keep the concentration when you make these. 123456789101112131415161718192021222324252627workspace&gt; mkdir src/main/java/com/kidongyunworkspace/src/main/java/com/kidongyun&gt; mkdir configworkspace/src/main/java/com/kidongyun/config&gt; touch WebConfig.javaworkspace/src/main/java/com/kidongyun/config&gt; touch ServletConfig.javaworkspace/src/main/java/com/kidongyun/config&gt; touch DatabaseConfig.javaworkspace/src/main/resources&gt; touch mybatis-config.xmlworkspace/src/main/resources&gt; mkdir mappersworkspace/src/main/resources/mappers&gt; touch personMappers.xmlworkspace/src/main/java/com/kidongyun&gt; mkdir voworkspace/src/main/java/com/kidongyun/vo&gt; touch PersonVO.java workspace/src/main/java/com/kidongyun&gt; mkdir daoworkspace/src/main/java/com/kidongyun/dao&gt; touch PersonDAO.java // It&#x27;s Interface.workspace/src/main/java/com/kidongyun&gt; mkdir serviceworkspace/src/main/java/com/kidongyun/service&gt; touch PersonService.javaworkspace/src/main/java/com/kidongyun&gt; mkdir controllerworkspace/src/main/java/com/kidongyun/controller&gt; touch PersonController.javaworkspace/src/main/webapp/WEB-INF&gt; mkdir viewworkspace/src/main/webapp/WEB-INF/view&gt; index.jsp 7. Configure each files.WebConfig.javaIt has really similar function with ‘web.xml’. The main function of this file is actually to create the ‘Root container’ and ‘Servlet’. as you know, ‘Root Container’ is the fundamental third party place of the ‘Bean’. 123456789101112131415161718192021222324252627package com.kidongyun.config;import org.springframework.web.WebApplicationInitializer;import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;import org.springframework.web.servlet.DispatcherServlet;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.ServletRegistration;public class WebConfig implements WebApplicationInitializer &#123; @Override public void onStartup(ServletContext servletContext) throws ServletException &#123; /** Create the Root Container. */ AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); context.setConfigLocation(&quot;com.kidongyun.config&quot;); /** Create the Servlet. */ ServletRegistration.Dynamic dispatcher = servletContext.addServlet(&quot;DispatcherServlet&quot;, new DispatcherServlet(context)); dispatcher.setLoadOnStartup(1); dispatcher.addMapping(&quot;/&quot;); &#125;&#125; ServletConfig.javaActually if you want, you can create ‘Servlet’ more than one. So ‘ServletConfig.java’ file is the setting for each servlet. The core of ‘Servlet’ is to take the request of a client and to return the response of the request from the client. You will configure about these setting in this file. It equal the ‘dispatcher-servlet.xml’ file. 123456789101112131415161718192021222324package com.kidongyun.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import org.springframework.web.servlet.view.InternalResourceViewResolver;@Configuration /** It means the Spring Container.*/@EnableWebMvc@ComponentScan(&quot;com.kidongyun&quot;) /** &lt;context:component-scan base-package=&quot;com.kidongyun&quot; /&gt; */public class ServletConfig extends WebMvcConfigurerAdapter &#123; @Bean public InternalResourceViewResolver internalResourceViewResolver() &#123; InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(&quot;/WEB-INF/view/&quot;); resolver.setSuffix(&quot;.jsp&quot;); return resolver; &#125;&#125; DatabaseConfig.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.kidongyun.config;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.SqlSessionTemplate;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.annotation.Resource;@Configuration@MapperScan(&quot;com.kidongyun.dao&quot;)public class DatabaseConfig &#123; @Resource private ApplicationContext applicationContext; /** Datasource is the object for connecting between database and java from JDBC. */ @Bean public DriverManagerDataSource dataSource() &#123; DriverManagerDataSource source = new DriverManagerDataSource(); source.setDriverClassName(&quot;oracle.jdbc.driver.OracleDriver&quot;); source.setUrl(&quot;jdbc:oracle:thin:@localhost:1521:XE&quot;); source.setUsername(&quot;c##scott&quot;); source.setPassword(&quot;tiger&quot;); return source; &#125; /** Setting Datasource, Mybatis configuration file and mapper directories */ @Bean public SqlSessionFactory sqlSessionFactory() throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource()); sqlSessionFactoryBean.setConfigLocation(applicationContext.getResource(&quot;classpath:mybatis-config.xml&quot;)); sqlSessionFactoryBean.setMapperLocations(applicationContext.getResources(&quot;classpath:mappers/**/*.xml&quot;)); return sqlSessionFactoryBean.getObject(); &#125; @Bean public SqlSession sqlSession() throws Exception &#123; SqlSessionTemplate sqlSessionTemplate = new SqlSessionTemplate(sqlSessionFactory()); return sqlSessionTemplate; &#125;&#125; mybatis-config.xml123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0/EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;/configuration&gt; personMappers.xml123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kidongyun.dao.PersonDAO&quot;&gt; &lt;select id=&quot;selectPerson&quot; resultType=&quot;com.kidongyun.vo.PersonVO&quot;&gt; SELECT * FROM PERSON &lt;/select&gt;&lt;/mapper&gt; PersonVO.java12345678910111213141516171819package com.kidongyun.vo;public class PersonVO &#123; String name; int age; String birthday; /** ALT + INSERT -&gt; GENERATE toString() */ @Override public String toString() &#123; return &quot;PersonVO&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, birthday=&#x27;&quot; + birthday + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; PersonDAO.java1234567891011121314/** It&#x27;s interface */package com.kidongyun.dao;import com.kidongyun.vo.PersonVO;import org.apache.ibatis.annotations.Mapper;import java.util.List;@Mapperpublic interface PersonDAO &#123; List&lt;PersonVO&gt; selectPerson();&#125; PersonService.java123456789101112131415161718192021package com.kidongyun.service;import com.kidongyun.dao.PersonDAO;import com.kidongyun.vo.PersonVO;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;@Servicepublic class PersonService &#123; @Resource private PersonDAO personDAO; public List&lt;PersonVO&gt; selectPerson() &#123; return personDAO.selectPerson(); &#125;&#125; PersonController.java123456789101112131415161718192021222324252627package com.kidongyun.controller;import com.kidongyun.service.PersonService;import com.kidongyun.vo.PersonVO;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;import java.util.List;@Controllerpublic class PersonController &#123; @Resource PersonService personService; @RequestMapping(value = &quot;/&quot;) public String hello(Model model)&#123; List&lt;PersonVO&gt; data = personService.selectPerson(); model.addAttribute(&quot;data&quot;, data.toString()); return &quot;index&quot;; &#125;&#125; index.jsp1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;data&#125;&lt;/body&gt;&lt;/html&gt; 8. Make the Person Table using Oracle DB12345CREATE TABLE PERSON ( NAME VARCHAR2(10), AGE NUMBER(3), BIRTHDAY DATE) It’s for making the new PERSON Table at Oracle. 1INSERT INTO PERSON VALUES (&#x27;martin&#x27;, 18, SYSDATE); and this query for putting the dummy datas. 9. Configure the tomcat for executing the web server from local.Skip. Additional. Change the ‘WebConfig.java’ for adding the ‘RootConfig’If you follow the above code style, You can’t configure the ‘Root Context’ file separately. But if you follow this code style then you can do that. First of all, You should make the ‘RootConfig.java’ file into the com/kidongyun/config/ directory. RootConfig.java1234567891011package com.kidongyun.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(basePackages = &#123;&quot;com.kidongyun&quot;&#125;)public class RootConfig &#123;&#125; When you want to create the some beans, You can do over there. and You have to change your ‘WebConfig.java’ file for recognizing about your new ‘RootConfig.java’ file. WebConfig.java123456789101112131415161718192021222324package com.kidongyun.config;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;public class WebConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; RootConfig.class &#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; ServletConfig.class &#125;; &#125; @Override protected String[] getServletMappings() &#123; return new String[] &#123; &quot;/&quot; &#125;; &#125;&#125; ‘getRootConfigClasses()’ method is for setting the ‘RootConfig.java’ and ‘getServletConfigClasses()’ method is for the ‘ServletConfig.java’ I think it’s more better idea than the above configuration.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://kidongyun.github.io/tags/Mybatis/"}]},{"title":"Let's configure the environment of Postgresql + TypeORM + Typescript + Graphql","slug":"2020-1-19-postgresql_typeorm_typescript_graphql","date":"2020-01-19T02:21:54.000Z","updated":"2022-05-31T07:12:55.000Z","comments":true,"path":"2020/01/19/","link":"","permalink":"http://kidongyun.github.io/2020/01/19/","excerpt":"","text":"postgresql + typeORM + typescript + graphql 활용한 Backend 구성하기typescript + graphql.backend 폴더 생성하자.백엔드 서비스를 위한 루트 디렉토리를 만들자. 이름은 ‘backend’ 이다. 1workspace&gt; mkdir backend package.json 파일 생성하자.백엔드 디렉토리 안에서 npm init 명령을 사용해 node 기반 서비스를 구성하기 시작함을 알리자. 1workspace/backend&gt; npm init 필요한 package 들을 설치하자.그렇다면 위의 이미지와 같이 node 서비스에서 기본적으로 필요한 package.json 파일을 생성하기 위해서 많은 것들을 물어본다. 모두 Enter를 눌러서 무시해주자. 이제 postgresql + typeORM + typescript + graphql 기술들을 사용하기 위해서 필요한 라이브러리, 모듈, 패키지들을 npm을 활용해 설치할 것이다. backend 폴더로 이동한 이후 아래의 명령어를 입력하자. 1workspace/backend&gt; npm install graphql-to-typescript graphql-tools graphql-yoga nodemon ts-node tslint-config-prettier babel-runtime typescript 만약 설치가 잘 완료되었다면 ‘package.json’ 파일 안에 ‘dependencies’ 항목이 생기는데 위와같이 그 항목 안에 우리가 설치한 패키지들을 확인할 수 있다. 그 다음으로는 프로덕션 환경이 아닌 개발 환경에서만 사용할 패키지를 설치할 것이다. backend 폴더로 이동하여 아래와 같이 명령어를 입력하자. 1workspace/backend&gt; npm install --save-dev @types/node —save-dev 속성을 넣어주게되면 해당 패키지는 개발 환경의 의존성으로만 추가가 되며 package.json 에도 dependencies 항목이 아닌 devDependencies 항목에 추가가 된다. 각 package들의 역할을 간략하게 알아보자.각 패키지들의 역할을 간략하게나마 소개하자면 아래와 같다. graphql-to-typescripttype, resolver와 같은 graphql 관련 타입들을 typescript 문법이 이해할수 있는 타입으로 변환할 수 있게 도와주는 패키지이다. graphql-toolsschema와 resolver를 분리해주는 구조를 만들어 주는 패키지라고 하는데 잘 모르겠다. graphql-yogaReact에서 ‘create-react-app’과 같이 손쉽게 graphql 설치를 할 수 있도록 도와주는 graphql 종합 패키지라고 보면 될 것 같다. 이 패키지를 설치하게 되면. 실제 서버의 역할을 해주는 ‘express’, ‘apollo server’ 패키지와 graphql 핵심 기능을 담고 있는 ‘graphql.js’, 위에서 설명한 ‘graphql-tools’, 그리고 웹 환경에서 GUI로 REQ/RES를 테스트할 수 있는 ‘graphql-playground’와 같은 IDE 등이 종합적으로 제공된다. nodemon서버가 실행중일 때 코드에 어떤 수정사항이 생기면 바로 적용할 수 있도록 도와주는 패키지이다. babel-runtimeBabel은 기본적으로 ES6/ES7 코드를 ECMAScript5 코드로 트랜스파일링하기 위한 도구이다. ts-node타입스크립트에서는 타입스크립트를 자바스크립트로 변환해주는 tsc 라는 도구를 제공한다. 이 도구를 이용하면 타입스크립트 코드가 그와 같은 기능을 하는 자바스크립트 코드로 변경되는데 이 과정을 transpile 이라 한다. 그러나 코드 수정이 일어날 때마다 매번 transpiling 작업을 하게되면 작업속도가 현저히 느려질 수 밖에 없는데 그래서 ts-node는 메모리상에서 타입스크립트를 transpiling 하여 바로 실행할 수 있게 한다. tslint-config-prettiertslint는 typescript 언어를 작성할 때 코드 표준 규칙들을 잘 준수하고 있는지 체크해주는 정적 코드 분석 도구이며 prettier는 vscode에서 코드를 정리해주는 패키지이다. typescripttypescript 언어는 트랜스파일링 언어로 코드 작성 완료후 트랜스파일링 작업을 진행해야 하는데 이 패키지에 있는 tsc 도구 등을 통해 자바스크립트로 변환이 가능하다. java에서 jdk같은 느낌으로 받아들이자. ‘.gitignore’ 파일을 생성해 git에 올릴 파일을 조절해보자.git commit/push 전에 nodemodules 폴더 내부를 보자. 우리가 설치한 패키지들 고작 몇개인데 그것들로 인해 node_modules 폴더는 수많은 파일들로 가득 차있다. 이 파일들도 git에 올리게 되면 참 고생길이 훤할 것이다. 또 정작 실제 소스들도 아님으로 그렇게 중요한 파일들은 아니다. git 업로드 내용에 제거하기 위해서 ‘backend’ 폴더 내부에 ‘.gitignore’_ 파일을 생성하자. 그리고 그 안에 node_modules 라고 적자. 1workspace/backend&gt; touch .gitignore .gitignore1node_modules 이렇게 하면 node_modules 폴더에 해당하는 파일들을 git remote repository로 업로드 되지 않는다. typescript + graphql 환경설정 파일들 생성 및 작성해보자우선 typescript + graphql 기술들을 활용한 backend 환경을 구성하기 위해 필요한 설정 파일들을 만들자. 하나 알아둘 것은 현재 설치한 node package 들 중에 typeORM과 관련된 항목은 없는데 이는 이후에 관련된 package 들을 추가로 설치할 것이다. backend 폴더에서 아래 4개의 파일을 만든다. 123456workspace/backend&gt; touch nodemon.jsonworkspace/backend&gt; touch tsconfig.jsonworkspace/backend&gt; touch tslint.jsonworkspace/backend&gt; touch .babelrc 각 파일들에 들어가야할 내용들은 아래와 같다. 파일이름이 헷갈리지 말고 각 내용들을 복사, 붙여넣기하자. nodemon.json12345&#123; &quot;ext&quot;: &quot;ts graphql&quot;&#125; 위 파일 ‘nodemon.json’ 에서 “ext” 속성은 확장자를 의미하는데 그 속성값으로 적혀있는 확장자의 코드가 (여기서는 ts와 graphql) 수정될 경우 프로젝트는 새로고침된다. tsconfig.json12345678910111213141516171819202122232425262728293031323334&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;module&quot;: &quot;commonjs&quot;, &quot;target&quot;: &quot;es5&quot;, &quot;lib&quot;: [&quot;es6&quot;, &quot;dom&quot;, &quot;esnext.asynciterable&quot;], &quot;sourceMap&quot;: true, &quot;allowJs&quot;: true, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;rootDir&quot;: &quot;src&quot;, &quot;forceConsistentCasingInFileNames&quot;: true, &quot;noImplicitReturns&quot;: true, &quot;noImplicitThis&quot;: true, &quot;noImplicitAny&quot;: false, &quot;strictNullChecks&quot;: true, &quot;suppressImplicitAnyIndexErrors&quot;: true, &quot;noUnusedLocals&quot;: true, &quot;esModuleInterop&quot;: true, &quot;skipLibCheck&quot;: true, &quot;experimentalDecorators&quot;: true, &quot;emitDecoratorMetadata&quot;: true, &#125;, &quot;exclude&quot;: [ &quot;node_modules&quot;, &quot;build&quot;, &quot;scripts&quot;, &quot;acceptance-tests&quot;, &quot;webpack&quot;, &quot;jest&quot;, &quot;src/setupTests.ts&quot; ]&#125; tsconfig.json은 typescript가 js 파일로 transpiling 할 때 고려되어지는 설정 정보들을 담고있는 파일 같다. 자세히는 모르겠다. tslint.json1234567891011121314151617&#123; &quot;extends&quot;: [&quot;tslint:recommended&quot;, &quot;tslint-config-prettier&quot;], &quot;linterOptions&quot;: &#123; &quot;exclude&quot;: [&quot;config/**/*.js&quot;, &quot;node_modules/**/*.&quot;] &#125;, &quot;rules&quot;: &#123; &quot;no-console&quot;: false, &quot;member-access&quot;: false, &quot;object-literal-sort-keys&quot;: false, &quot;ordered-imports&quot;: true, &quot;interface-name&quot;: false, &quot;strict-null-checks&quot;: false &#125;, &quot;rulesDirectory&quot;: [] &#125; TSlint, ESlint, JSlint 등 다양하게 있는데 이 들은 작성되어지는 코드들이 표준을 잘 지키는지 등을 확인하는 정적 분석 도구이다. 아마도 위 tslint.json 설정파일은 이 정적 분석 도구의 어떠한 설정을 하는 파일 같다. .babelrc12345&#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;]&#125; babel 관련 설정파일 이겠지.. typescript + graphql 관련 소스 코드 생성소스 코드를 담기위한 ‘src’ 폴더를 만들자. 현재 우리는 백엔드 환경을 구축하고 있는 것을 잊지 말자. 즉 backend 폴더 내부에 ‘src’ 폴더를 만들라는 의미다. 그리고 graphql 서버 실행을 위한 ‘index.ts’ 파일을 ‘src’ 폴더 안에 생성하자. 1234workspace/backend&gt; mkdir srcworkspace/backend/src&gt; touch index.ts index.ts12345678910111213141516171819202122232425262728import &#123; GraphQLServer &#125; from &quot;graphql-yoga&quot;// graphql-yoga 패키지를 GraphQLServer 라는 이름으로 가져온다.const typeDefs = ` type Query &#123; sayHello : String! &#125;`// graphql server를 실행시키기 위해 필요한 파라미터 둘 중 하나 &#x27;typeDefs&#x27; 정의// &#x27;typeDefs&#x27;는 인자값과 리턴되는 값의 타입을 지정한다. // 추가적으로 &#x27;String!&#x27;에서 !는 null을 허용하지 않음을 의미한다. const resolvers = &#123; Query : &#123; sayHello: () =&gt; &quot;Hi there :0)&quot; &#125;&#125;// graphql server를 실행시키기 위해 필요한 파라미터 둘 중 하나 &#x27;resolvers&#x27; 정의// &#x27;resolvers&#x27;는 비지니스 로직이 실제로 들어가는 부분이다.const server = new GraphQLServer(&#123; typeDefs, resolvers &#125;);// &#x27;graphql-yoga&#x27;를 import한 GraphQLServer 객체와 위에 정의한 2개의 파라미터를 활용해 server 객체를 생성한다.// &#123; &#125; 이 표시는 왜 있을까? 한 객체로 파라미터를 전달한다는 의미일까?server.start(() =&gt; console.log(&#x27;My first GraphQL Server is running on localhost:4000&#x27;))// 실제 서버를 실행시키는 코드이다. package.json script 수정하기node 기반 서비스들을 동작시키기 위해서 보통 npm, yarn 등의 패키지 관리자를 활용해 스크립트를 실행시킨다. 이 스크립트는 package.json 안에 script 속성을 활용해서 임의적으로 구현할 수 있으며 우리는 ‘index.ts’ 에서 짠 graphql server가 잘 실행될 수 있도록 스크립트를 구성할것이다. 123456789...&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;cd src &amp;&amp; nodemon --exec ts-node index.ts -e ts, graphql&quot;&#125;... 기존에 존재하던 “test”: “echo \\”Error: no test specified\\” &amp;&amp; exit 1” 소스는 지우고 해당 부분에 위와 같이 “dev” 라는 이름을 가진 스크립트를 추가하자. 수정된 package.json 전문은 아래와 같다. package.json1234567891011121314151617181920212223242526&#123; &quot;name&quot;: &quot;backend&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;cd src &amp;&amp; nodemon --exec ts-node index.ts -e ts, graphql&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;babel-runtime&quot;: &quot;^6.26.0&quot;, &quot;graphql-to-typescript&quot;: &quot;^0.1.2&quot;, &quot;graphql-tools&quot;: &quot;^4.0.6&quot;, &quot;graphql-yoga&quot;: &quot;^1.18.3&quot;, &quot;nodemon&quot;: &quot;^2.0.2&quot;, &quot;ts-node&quot;: &quot;^8.6.2&quot;, &quot;tslint-config-prettier&quot;: &quot;^1.18.0&quot;, &quot;typescript&quot;: &quot;^3.7.4&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@types/node&quot;: &quot;^13.1.7&quot; &#125;&#125; graphql server 실행하기.‘package.json’ 안에 ‘scripts’ 속성 안에 “dev”에 해당하는 코드를 살펴 보면 src 폴더로 이동한 이후 ‘index.ts’ 파일을 ts-node를 활용해서 트랜스파일링 하고, 그 트랜스파일링된 js 파일을 nodemon으로 실행시키는 형태이다. 123451. src 폴더로 이동.2. ts-node를 이용해서 index.ts transpiling.3. nodemon으로 실행. 아래의 명령어를 통해 “dev” 스크립트를 실행시켜 보자. 123workspace/backend&gt; npm dev run 혹시 위와 같은 오류가 전시되면서 실행이 안된다면 yarn 패키지 매니저를 설치하고 아래와 같이 명령어를 실행하자. / 위와 같은 에러가 나는 이유는 나도 잘 모르겠다. 1234workspace/backend&gt; yarnworkspace/backend&gt; yarn dev yarn 만 입력한 첫번째 명령어는 ‘yarn’ 패키지 매니저의 관련 기능들을 최신화 시켜주는 것이고 ‘yarn dev’ 명령어가 위의 ‘npm dev run’ 명령어와 동일하게 ‘dev’ 스크립트를 실행하는 역할을 한다. 위와 같은 로그가 보인다면 아래 링크를 클릭 혹은 ‘localhost:4000’ 으로 접속해보자. 그러면 graphql-playground 패키지가 제공해주는 IDE를 확인할 수 있다. localhost:4000 이 IDE는 postman의 역할과 유사하며, graphql 형식으로 REQ를 던지면 RES가 어떻게 나오는지를 확인해볼수 있다. graphql에서 query?query 타입과 mutation 타입은 graphql에서 일반적인 객체 타입과 동일하나 모든 graphql 타입 정의에서 첫부분에 사용된다는 점이 특별하다. 즉 이 타입들은 스키마에서 ‘entry point’ 즉 하나의 진입점으로 생각할 수 있다. query나 mutation 타입이 있다면 ‘아 이부분 부터 시작하는구나’ 라고 인지시킬수 있다는 것이다. 그러나 아까 말했다시피 이들도 객체 타입임으로 object 타입과 동일하게 동작함을 기억하고 있는 것은 중요하다. 12345678910query &#123; hero &#123; name &#125; droid(id: &quot;2000&quot;) &#123; name &#125;&#125; 위와같은 쿼리를 본다면 ‘query’ 키워드를 통해 진입점을 찾고 그 안에 있는 ‘hero’, ‘droid’ 필드를 요청한다. postgresql + typeORM + typescript + graphql 환경을 위해 새로운 패키지 추가하자지금까지 작업한 내용은 typescript + graphql 까지만을 활용한 환경 구축하는 방법이였다. 이제 여기에 postgresql 데이터베이스와 typeORM을 추가 연동하여 DB에 접근이 가능하도록 해보자. 위에서 패키지들을 설치할 때 postgresql, typeORM와 관련된 패키지들은 설치하지 않았다. 이제 아래의 명령어를 활용해서 3개의 패키지를 더 추가해보자. 백엔드 폴더에서 설치해야함을 잊지말자. 1workspace/backend&gt; npm install pg typeorm dotenv 설치가 잘 되었다면 아래처럼 ‘dependecies’ 항목에 추가되었을 것이다. 각 패키지에 대해 간략히 이해해보자.pgpostgresql 데이터베이스를 node에서 사용하기 위해서 추가로 설치해야 하는 패키지. typeorm말 그대로 typeORM을 사용하기 위한 패키지. dotenv데이터베이스의 환경설정 정보 같은 것을 다른 파일에 정의 해두고 사용하고 싶을 때 사용하는 패키지. 이렇게 되면 git 관리를 통해 보안성을 좀 더 향상 시킬 수 있다. typeORM을 위한 ormConfig.ts, .env 파일 생성typeORM을 활용해서 postgresql 데이터베이스를 함께 연동할 것이다. 연동할 때 필요한 설정들을 가지고 있는 파일 ‘ormConfig.ts’과 DB 정보를 가지고 있는 ‘.env’ 파일을 생성하자. 12workspace/backend/src&gt; touch ormConfig.tsworkspace/backend/src&gt; touch .env .env123DB_HOST = &quot;localhost&quot;DB_USERNAME = &quot;slack_clone&quot;DB_PASSWORD = &quot;root&quot; ormConfig.ts123456789101112131415161718192021222324252627282930313233343536import &#123; ConnectionOptions, Connection, createConnection &#125; from &quot;typeorm&quot;;// typeorm 패키지에서 위 3개의 객체들을 가져온다.// ConnectionOptions : typeORM에서 DB 환경 정보를 받기 위한 객체 타입.// Connection : typeORM에서 제공하는 연결 객체 타입 인듯.// createConnection : 연결을 만드는 함수import dotenv from &quot;dotenv&quot;;dotenv.config();// dotenv 패키지를 통해서 미리 만들어둔 DB 환경설정 정보를 가져온다. (계정, 패스워드 ...)const connectionOptions:ConnectionOptions = &#123; type : &quot;postgres&quot;, // typeORM 통해 사용할 DBMS database : &quot;slack_clone&quot;, // 데이터베이스 이름 synchronize : true, // DB관련 코드 수정 내용을 바로바로 적용할지에 대한 여부 logging : true, // 서버가 시작될 때 DB 생성하는 쿼리 등의 로그를 보여줄지에 대한 여부 entities : [&quot;entities/**/*.*&quot;], // typeORM은 테이블의 생성을 도와주는데 그 테이블의 스키마 등을 명세하는 객체를 entity라고 함 그 파일들의 경로를 가리킴. host : process.env.DB_HOST, // 데이터베이스 접근할 때 port : 5432, // 데이터베이스 연결할 때 어떤 포트를 쓸건지에 대한 설정 username : process.env.DB_USERNAME, // 데이터베이스 연결할 때 사용자 이름. password : process.env.DB_PASSWORD // 데이터베이스 연결할 때 사용자 비밀번호.&#125;const connection:Promise&lt;Connection&gt; = createConnection(connectionOptions);// 위에서 정의한 connectionOptions와 연결 객체를 만드는 createConnection() 함수를 활용해서 DB connection 객체를 만들고 이를 반환. 이 connection 타입은 Promise&lt;Connection&gt; 으로 Connection 객체인데 비동기로 받겠다는 의미.export default connection; Promise 잠깐 알아보고 가자ES6로 넘어오기 전 JS의 문법에서는 Ajax와 같은 비동기 처리를 위해서 아래와 같은 형식의 콜백함수를 활용해야했다. 이러한 코드는 읽을 때 흐름이 계속 이리저리 바뀌게 되어 가독성에 좋지 않고 비동기 처리가 chaining될 경우 계속 중첩된 코드를 작성해야하는 이슈가 있다. 1234567891011function getData(callbackFunc) &#123; $.get(&#x27;url&#x27;, function (response) &#123; callbackFunc(response); &#125;); &#125;getData(function (tableData) &#123; console.log(tableData);&#125;); Promise 객체를 사용하게되면 이러한 비동기 처리를 보다 가독성이 좋은 방법으로 구현할 수 있다. 12345678910111213function getData(callback) &#123; return new Promise(function (resolve, reject) &#123; $.get(&#x27;url 주소/products/1&#x27;, function (response) &#123; resolve(response); &#125;); &#125;);&#125;getData().then(function (tableData) &#123; console.log(tableData);&#125;); Promise 도입에 의해 정의하는 부분은 코드가 더 복잡하다고 생각할 수 있지만 실제 비동기 처리를 요구하는 실제로 getData() 함수를 사용하는 부분은 보다 더 간단해진다. index.ts를 수정하고 postgresql + typeORM + typescript + graphql 환경 실행해보자.graphql 서버만 실행하는 기존코드에서 typeORM을 통해 postgresql DB를 먼저 연결 하고 그다음에 graphql 서버를 시작하는 코드로 수정하였다. 123456// (AS-IS)server.start(() =&gt; console.log(&#x27;My first GraphQL Server is running on localhost:4000&#x27;)) 12345678// (TO-BE)connection.then(() =&gt; server.start(() =&gt; console.log(&#x27;My first GraphQL Server is running on localhost:4000&#x27;) )); 아래는 ‘index.ts’ 의 수정된 전문이다. connection 개체는 방금 위에서 ‘ormConfig.ts’ 에서 생성한 녀석임으로 사용하기 위해서는 import 해야한다. 12345678910111213141516171819202122import &#123; GraphQLServer &#125; from &quot;graphql-yoga&quot;import connection from &quot;./ormConfig&quot; const typeDefs = ` type Query &#123; sayHello : String! &#125; ` const resolvers = &#123; Query : &#123; sayHello: () =&gt; &quot;Hi there :0)&quot; &#125; &#125; const server = new GraphQLServer(&#123; typeDefs, resolvers &#125;);connection.then(() =&gt; server.start(() =&gt; console.log(&#x27;My first GraphQL Server is running on localhost:4000&#x27;) )); 1workspace/backend&gt; yarn dev 위의 이미지 처럼 테이블들을 생성하는 로그가 나오고 서버가 실행되었다면 잘 구현한것이다. localhost:4000 entity를 활용하여 테이블을 구성해보자.typeORM을 활용하면 데이터베이스에 들어가서 직접 쿼리를 날려 테이블을 생성하지 않아도 된다. typeORM에서 제공하는 entity라는 것을 활용하면 보다 자유롭게 테이블을 생성할 수 있다. 이러한 방식의 이점은 테이블을 이루는 스키마가 변경해야할 경우 단순히 entity에 관련된 소스코드 수정만 하면 됨으로 직접 생성하는 방법보다 훨씬 간단하다. 그리고 typeORM에서 다양한 데이터베이스를 지원하고 있기에 어떤 시스템의 데이터베이스가 다른 종류로 변경될 경우(예를 들어 mariaDB -&gt; oracle) 큰 리스크 없이 변경이 가능하다. entity를 관리하는 폴더 ‘entities’ 를 만들고 그 안에 ‘Message.ts’, ‘Channel.ts’ 두 개의 파일을 만들자. 123workspace/backend/src&gt; mkdir entitiesworkspace/backend/src/entities&gt; touch Message.tsworkspace/backend/src/entities&gt; touch Channel.ts ‘Message.ts’, ‘Channel.ts’ 두 파일은 각각 Message 테이블, Channel 테이블을 생성할 때 필요한 스키마 정보들을 가지고 있다. Message.ts1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; Entity, BaseEntity, PrimaryGeneratedColumn, Column, ManyToOne, CreateDateColumn, UpdateDateColumn &#125; from &quot;typeorm&quot;;import Channel from &#x27;./Channel&#x27;// 로컬에 만든 파일을 가져올 때는 확장자 생략이 가능하다.@Entity()// @Entity() : typeORM의 entity임을 선언class Message extends BaseEntity &#123; // @PrimaryGeneratedColumn() : mariaDB의 auto_increment와 유사한 역할, Primary Key로 사용할 목적 @PrimaryGeneratedColumn() id: number; // @Column(&#123;type: &quot;text&quot;, nullable: false&#125;) : 컬럼임을 가리키며 해당 컬럼의 스키마 타입과 null값 허용 여부 명시 @Column(&#123;type: &quot;text&quot;, nullable: false&#125;) nickname: string; @Column(&#123;type: &quot;text&quot;, nullable: false&#125;) contents: string; @Column(&#123;type: &quot;text&quot;, nullable: false&#125;) thumbnail: string; // 본인과 대상의 관계까 N : 1 임을 표현할 때 사용하는 어노테이션. Message : Channel = N : 1 // type에는 대상이 되는 클래스 명을 적고 서로 관계되어있는 컬럼으로 연결지음. @ManyToOne(type =&gt; Channel, channel =&gt; channel.messages) innerChannel: Channel; @Column(&#123;type: &quot;text&quot;, nullable: false&#125;) innerChannelId: number; // 테이블이 생성되는 시점을 저장하는 필드로 typeORM에서 제공하는 @CreateDateColumn()을 활용해서 바로 구현 가능 @CreateDateColumn() createdAt: string; // 테이블이 생성되는 시점을 저장하는 필드로 typeORM에서 제공하는 @UpdateDateColumn()을 활용해서 바로 구현 가능 @UpdateDateColumn() updatedAt: string;&#125;export default Message Channel.ts1234567891011121314151617181920212223242526import &#123; Entity, BaseEntity, PrimaryGeneratedColumn, Column, OneToMany, CreateDateColumn, UpdateDateColumn &#125; from &quot;typeorm&quot;;import Message from &quot;./Message&quot;;@Entity()class Channel extends BaseEntity &#123; @PrimaryGeneratedColumn() id: number; @Column(&#123;type: &quot;text&quot;, nullable: false&#125;) channelName: string; // 본인과 대상의 관계가 1: N 관계를 표현하기 위한 어노테이션. 대상의 관계가 N임으로 이를 표현하기 위해 배열을 사용하고 있음을 볼 수 있다. @OneToMany(type =&gt; Message, message =&gt; message.innerChannel) messages: Message[] @CreateDateColumn() createdAt: string; @UpdateDateColumn() updatedAt: string;&#125;export default Channel 일대다&amp;다대일부모와 자식의 관계에서 자식이 그 부모에 고유성을 가지는 것이면 일대다&amp;다대일 관계를 사용.그러나 고유성이 없다면 다대다 관계를 사용. 오직 N:M 관계를 사용하는 방법과 1:N, M:1 두가지를 관계를 사용하는 방법의 차이에 대해서 의아할 수도 있다. 이는 자식의 고유성을 고려했을 때 존재한다면 1:N, M:1으로 표현하고 그렇지 않다면 N:M 관계로 생각하자. 추가적으로 N:M 관계는 사실상 물리적으로 구현이 불가능하고 성능 상의 문제가 있어 사실상 N:1, 1:M으로 표현되어야 한다. 결론적으로 자식의 고유성에 따라 DB 모델링 할때 고려되어지는 방안은 아래와 같다. 12345if(자식의 고유성 유) then 1:N, M:1else if(자식의 고유성 무) then N:1, 1:M 프로젝트를 실행한 후 postgresql에 두 테이블이 생성되었는지 확인해보자. 1workspace/backend&gt; yarn dev graphql 구조 개선을 위해 새로운 ‘merge-graphql-schemas’ 패키지 설치‘index.ts’ 파일을 보자. graphql 서버를 실행시키기 위해서는 ‘typeDefs’, ‘resolvers’ 이 두가지 파라미터가 필요하다.이러한 정보들을 graphql의 스키마라고 부르는데 지금까지의 스키마 정보는 단순히 graphql을 실행시키기 위해서 임의의 샘플 정보를 넣어둔 것이였다. 이번에는 실제로 slack을 구현할 수 있도록 이 스키마 정보를 수정해보자. 또 스키마 관리의 효율성을 증대시키기 위해서 이 스키마 데이터들을 별도의 파일로 관리하는 방법을 알아보자. graphql의 schema, resolver 들을 별도의 폴더로 관리할 수 있게 해주는 패키지 이다.npm 혹은 yarn을 활용해서 위의 패키지를 설치하자. 1workspace/backend&gt; npm install merge-graphql-schemas Graphql을 위해 ‘Type’ 들을 정의해보자이 환경에 가장 아쉬운 부분이라고 생각되는 것은 typeORM을 이용하기 위한 VO와 graphql을 이용하기 위한 모델이 별도로 관리되어야 하는 점이다. 이는 아직 graphql의 버전이 낮아서 개선이 안된 부분이라고 함. 위에서 typeORM을 활용할 때에는 ‘Message’, ‘Channel’ 테이블을 구성하기 위해서 이들을 위한 ‘Message.ts’, ‘Channel.ts’ 파일을 만들었다. 이번에는 graphql를 활용해 Client, Server의 api 통신하기 위한 모델을 작성할 것이다. 이 모델들은 graphql 서버를 실행할 때 반드시 필요한 ‘type’, ‘resolver’ 정보를 필히 규명해야 한다. ‘index.ts’ 에서 sample 사용되었던 ‘type’, ‘resolver’ 를 대신하기 위해 별도의 폴더, 파일로 관리되는 구조를 만들자. 123456789101112workspace/backend/src&gt; mkdir apiworkspace/backend/src/api&gt; mkdir Channelworkspace/backend/src/api&gt; mkdir Messageworkspace/backend/src/api/Channel&gt; mkdir Sharedworkspace/backend/src/api/Channel/Shared&gt; touch Channel.graphqlworkspace/backend/src/api/Message&gt; mkdir Sharedworkspace/backend/src/api/Message/Shared&gt; touch Message.graphql Channel.graphql123456789type Channel &#123; id: Int! channelName: String! messages: [Message] createdAt: String! updatedAt: String&#125; Message.graphql123456789101112type Message &#123; id: Int! nickname: String! thumbnail: String! contents: String! innerChannel: Channel! innerChannelId: Int! createdAt: String! updatedAt: String&#125; 이 graphql을 위한 모델은 typeORM을 위한 모델과 동일한 필드, 타입을 가지고 있다. 만약 여러가지 상황에 의해 서로 상이해야할 경우가 생긴다면. 커스터마이징된 type을 새로 생성하거나 resolver에서 필요하지않은 필드의 값을 null로 주고 api 통신을 진행할 수도 있다. 지금까지 만든 스키마 파일들을 GraphQLServer 객체로 전달하기에 적절한 형태로 융합하고 정제하는 ‘schema.ts’ 를 만들자. 1workspace/backend/src&gt; touch schema.ts schema.ts1234567891011121314151617181920212223import &#123; fileLoader, mergeResolvers, mergeTypes &#125; from &quot;merge-graphql-schemas&quot;import &#123; makeExecutableSchema &#125; from &quot;graphql-tools&quot;import path from &quot;path&quot;const allTypes: any = fileLoader(path.join(__dirname, &quot;./api/**/*.graphql&quot;));// type 관련 파일들을 가져옴.const allResolvers: any = fileLoader(path.join(__dirname, &quot;./api/**/*.resolvers.*&quot;));// resolver 관련 파일들을 가져옴.const mergedTypes = mergeTypes(allTypes);const mergedResolvers: any = mergeResolvers(allResolvers);// 가져온 type, resolver 들을 가지고 무언가 작업을 해주는 것 같은데 잘 모르겠다.const schema = makeExecutableSchema(&#123; typeDefs: mergedTypes, resolvers: mergedResolvers&#125;);// type, resolver를 가지고 schema를 구성한다.export default schema; ‘index.ts’ 파일에서 기존에 작업해두었던 샘플 type, resolver는 지우고 위 schema.ts에서 만들어진 schema 정보를 사용할 수 있도록 구성해보자. index.ts1234567891011121314import &#123; GraphQLServer &#125; from &quot;graphql-yoga&quot;import connection from &quot;./ormConfig&quot;import schema from &quot;./schema&quot;const server = new GraphQLServer(&#123; schema &#125;);// schema.ts 에서 생성해서 export한 객체를 typeDefs, resolvers를 대신해서 파라미터로 넘겨주고 있다.connection.then(() =&gt; server.start(() =&gt; console.log(&#x27;My first GraphQL Server is running on localhost:4000&#x27;) )); 나의 경우 schema 파라미터를 넘겨주었는데 타입이 안맞다는 문구와 함께 계속 에러메시지가 표출되었었는데 이러한 경우 ‘yarn’ 명령어를 통해 패키지를 업데이트 및 재설치를 진행해주면 개선된다 1workspace/backend&gt; yarn 지금까지 작업을 정리해보면 우리는 graphql를 위한 ‘type’ 즉 모델을 정의하고 이 모델들을 효율적으로 관리하기 위해 별도의 폴더로 분리. 그리고 마지막으로 그 분리된 graphql type 파일들을 ‘schema.ts’ 하나로 합쳐 ‘index.ts’ 파일에서 graphql 서버에 임시로 만들었던 typeDefs, resolver를 대신해서 넘겨주었다. 하나 명확히 이해해야하는 것은 위에에서도 언급했지만 ‘Channel’, ‘Message’ 라는 두 모델이 현재 두 곳에서 관리되어 진다는 점이다. 123456 Graphql TypescriptChannel Channel.graphql Channel.tsMessage Message.graphql Message.ts 이 두 형태의 모델들은 각각 다른 역할을 가지고 있다. graphql의 확장자를 가지고 있는 ‘Channel.graphql’, ‘Message.graphql’ 들은 graphql api를 만들기위해 사용되어졌고 ts 확장자를 가지고 있는 ‘Channel.ts’, ‘Message.ts’ 들은 typescript가 이해할 수 있는 형태로 여기서는 typeORM이 엔티티를 생성할때 그 엔티티 정보를 주기 위해서 사용되어지고 있다. 함수(동작)에 대한 타입 정의를 해보자.우리는 이전까지 만들었던 ‘Channel.ts’, ‘Message.ts’, ‘Channel.graphql’, ‘Message.graphql’ 들은 모두 모델에 대한 정의 즉 데이터의 형태에 대한 정의이다. 이제는 실제 api라고 불릴만한 함수에 관한 타입들을 만들어보자. 위에서 모델을 위한 타입들이 ‘graphql’ 을 위한 것, ‘typescript’ 두 종류로 나뉘어졌던것 처럼 함수에 대한 타입들도 ‘graphql’ 을 위한 것, ‘typescript’ 를 위한 것으로 나누어야한다. 그러나 분명하게 다른 점은 모델은 이 두가지를 위해 코드를 작성해야 했지만 함수를 위한 타입들은 ‘graphql’ 과 관련된 코드만 만들어내고 ‘graphql-to-typescript’ 패키지를 통해서 ‘typescript’ 관련된 코드들을 자동으로 생성시킬 것이다. 그렇다면 이 변환된 ts 파일을 가지고 resolvers.ts 파일에서 비지니스 로직을 구성할 수 있다. 함수(동작) 타입을 구현하기 위한 순서12345678910111213141516171. resolvers 공통 인터페이스 &#x27;Resolver&#x27; 생성2. 필요한 폴더 및 파일 생성3. 함수 타입 변환을 위해 &#x27;gql-merge&#x27;, &#x27;graphql-to-typescript&#x27; 패키지 설치 4. 함수 타입 변환을 위한 &#x27;package.json&#x27;의 &#x27;script&#x27; 부분 수정5. 함수 타입 정의6. &#x27;gql-merge&#x27;, &#x27;graphql-to-typescript&#x27; 를 활용하여 typescript 함수 타입 생성7. 변환된 typescript 함수 타입을 활용하여 resolvers 영역에 비지니스 코드 생성.8. graphql 실행 및 api 테스트 1. resolvers 공통 인터페이스 ‘Resolver’ 생성12345workspace/src&gt; mkdir typesworkspace/src/types&gt; touch resolvers.d.ts resolvers를 정의할 때 필요한 무언가라고 했었는데 명확히 이해하지는 못했다 다시 물어봐야할듯. resolvers.d.ts123456789export type Resolver = (parent: any, args: any, context: any, info: any) =&gt; any;export interface Resolvers &#123; [key: string]: &#123; [key: string]: Resolver; &#125;;&#125; 2. 필요한 폴더 및 파일 생성아래의 폴더와 파일들을 만들어보자. ‘schema.graphql’ 파일은 우리가 손수 정의한 함수 타입들을 총괄하여 저장하는 파일이며 ‘graphql.d.ts’ 파일은 이 ‘schema.graphql’ 파일을 입력으로하여 typescript를 위해 변환된 함수 타입을 저장하는 파일이다. 12345workspace/backend&gt; touch schema.graphqlworkspace/backend/types&gt; touch graphql.d.ts 3. 함수 타입 변환을 위해 ‘gql-merge’, ‘graphql-to-typescript’ 패키지 설치typescript를 위한 각 함수 타입들을 자동 생성 및 변환하기 위해서 아래의 패키지를 설치한다. ‘graphql-to-typescript’ 패키지는 이미 설치되어있을수도 있다. 정확히는 ‘gql-merge’ 를 통해 분산되어있던 함수타입 파일들을 하나의 파일(‘schema.graphql’)에 통합시킬 수 있으며 ‘graphql-to-typescript’를 통해 ‘.graphql’ 로 정의되어있던 함수타입을 ‘.ts’ 으로 변환하여 ‘graphql.d.ts’ 파일에 저장한다. 1workspace/backend&gt; npm install gql-merge graphql-to-typescript 4. 함수 타입 변환을 위한 ‘package.json’의 ‘script’ 부분 수정‘gql-merge’ 패키지외 ‘graphql-to-typescript’ 패키지는 node script 기능을 활용하여 실행할 수 있다. ‘package.json’ scripts 부분을 아래와 같이 변경하자. package.json1234567891011...&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;cd src &amp;&amp; nodemon --exec ts-node index.ts -e ts,graphql&quot;, &quot;predev&quot;: &quot;yarn run types&quot;, &quot;types&quot;: &quot;graphql-to-typescript ./src/schema.graphql ./src/types/graphql.d.ts&quot;, &quot;pretypes&quot;: &quot;gql-merge --out-file ./src/schema.graphql ./src/api/**/*.graphql&quot;&#125;... node script의 특성 중에 하나는 앞이 ‘pre-‘ 가 붙은 스크립트들은 같은 이름을 가진 스크립트 보다 먼저 실행시킬 수 있다. 위 스크립트를 해석해보면 ‘dev’ 스크립트를 실행하기 이전에 ‘predev’가 실행되고 이 스크립트에 따라서 ‘types’ 스크립트가 실행된다. ‘types’ 스크립트도 같은 원리에 따라 ‘pretypes’ 가 먼저 실행되어 우리가 만들었던 ‘graphql’를 위한 타입들이 ‘schema.graphql’ 파일에 합쳐지고 정리된다. 그리고 ‘types’ 에서 ‘schema.graphql’ 에 정의되어진 타입들을 ‘typescript’ 를 위한 타입들로 변환한다. 이 변환된 타입들은 ‘./src/types/graphql.d.ts’ 파일 안에 저장된다. 12345678910scripts 실행 순서1. &quot;predev&quot; : &quot;types&quot; 스크립트를 실행한다.2. &quot;pretypes&quot; : &#x27;.graphql&#x27; 형태의 타입들을 &#x27;schema.graphql&#x27;파일에 통합 저장한다.3. &quot;types&quot; : 타입들이 통합 저장되어진 &#x27;schema.graphql&#x27;파일을 활용해 함수 타입들을 typescript 형태로 변환하고 이들을 &#x27;graphql.d.ts&#x27;에 저장한다.4. &quot;dev&quot; : 서버가 실행된다. 5. 함수 타입 정의함수 타입을 생성할 준비가 되었다 이번에는 메시지를 가져오는 동작을 하는 ‘GetMessages’ api 함수를 만들어보자. 우선 이를 위한 폴더 및 파일를 만든다. GetMessages.1234567workspace/backend/src/api/Message&gt; mkdir GetMessagesworkspace/backend/src/api/Message/GetMessages&gt; touch GetMessages.graphqlworkspace/backend/src/api/Message/GetMessages&gt; touch GetMessages.resolvers.ts ‘.graphql’ 형태의 ‘GetMessages’ 동작의 타입을 지정하자. GetMessages.graphql1234567891011type GetMessagesResponse &#123; ok : Boolean! error : String messages : [Message]&#125;type Query &#123; GetMessages(innerChannelId: Int!) : GetMessagesResponse!&#125; ‘GetMessages’ 함수 타입의 비지니스 로직은 ‘GetMessages.resolvers.ts’ 에서 구성한다. 6. ‘gql-merge’, ‘graphql-to-typescript’ 를 활용하여 typescript 함수 타입 생성위에서 정의한 스크립트를 활용하여 ‘schema.graphql’ 파일에 각 타입들을 통합시키고 ‘graphql.d.ts’ 파일에 typescript를 위한 함수 타입을 만들어내자. 1workspace/backend&gt; yarn types 7. 변환된 typescript 함수 타입을 활용하여 ‘GetMessages.resolvers.ts’ 영역에 비지니스 코드 생성.변환된 함수 타입을 활용하여 ‘GetMessages.resolvers.ts’ 안에 비즈니스 코드를 작성한다. 해당 형태는 거의 유사하며 눈에 익혀두거나 코드를 복사해두어 다른 함수 타입들을 생성할 때에도 활용하자. GetMessages.reseolvers.ts123456789101112131415161718192021222324252627282930313233343536373839404142import &#123; Resolvers &#125; from &quot;src/types/resolvers&quot;;// 상대경로로 사용해야함 (절대경로로는 파일을 못찾음)import Message from &quot;../../../../src/entities/Message&quot;;// 아래 쿼리 구조는 graphQL에서 정해놓은 규격const resolvers: Resolvers = &#123; Query: &#123; GetMessages: async(_, args) =&gt; &#123; // GetMessages 라는 동작에 대한 비즈니스 로직 (Spring의 Controller와 유사) // 사용자가 API를 호출했을때 인자값이 args 안으로 들어온다. try &#123; const &#123;innerChannelId&#125; = args; // = const innerChannelId = args.innerChannerId; // Message (typeORM) 을 사용하여 쿼리 메소드를 실행할 수 있음 // innerChannelId와 일치하는 데이터를 조회해달라는 의미 const messages = await Message.find(&#123;innerChannelId&#125;); // await : 동기적으로 실행되고있으므로 데이터를 가져올때까지 기다려줘야해서 await 선언 // &#123;innerChannelId&#125; =&gt;(동일) innerChannelId = innerChannelId // 리스트 조회 =select * from Message where innerChannelId = 0 return &#123; ok: true, // 성공 error: null, // 성공했으므로 error는 null messages: messages // 위 쿼리메소드를 통해 조회해온 데이터를 담음 &#125; &#125; catch(error) &#123; return &#123; ok: false, // 에러 발생 error: error.message, // js에서 지원해줌 messages: null // 에러가 발생하였으므로 messages는 비어있다 &#125; &#125; &#125; &#125;&#125;export default resolvers; 8. graphql 실행 및 api 테스트아래 명령어를 입력하고 위에서 만든 ‘GetMessages’ api가 정상적으로 작동하는지를 확인하자. 여기서 한가지 중요한 점은 이 api는 CRUD에 R의 기능을 함으로 Channel 테이블과 Message 테이블이 각각 튜플을 직접 생성을 해야 테스트가 정상작동한다. 1workspace/backend&gt; yarn dev 123456789101112#### GetMessages() API&#123; GetMessages(innerChannelId : 1) &#123; ok error messages &#123; contents &#125; &#125; &#125; ‘CreateChannel’ 함수 타입을 만들어보자.함수타입을 만들고 이를 api화 하는 과정은 ‘GetMessages’ 와 유사함으로 상세한 설명은 생략하겠다. ‘CreateChannel’()는 새로운 채널을 만드는 api이다 ‘CreateChannel’ 에 필요한 폴더 및 파일들을 만든다. 1234567workspace/backend/src/api/Channel&gt; mkdir CreateChannelworkspace/backend/src/api/Channel&gt; touch CreateChannel.graphqlworkspace/backend/src/api/Channel&gt; touch CreateChannel.resolvers.ts ‘CreateChannel’ 함수 타입을 정의한다. CreateChannel.graphql12345678910type CreateChannelResponse &#123; ok: Boolean! error: String&#125;type Mutation &#123; CreateChannel(channelName: String!):CreateChannelResponse!&#125; ‘gql-merge’, ‘graphql-to-typescript’ 를 활용하여 typescript 함수 타입 생성한다. 1workspace/backend&gt; yarn types 변환된 typescript 함수 타입을 활용하여 ‘CreateChannel.resolvers.ts’ 영역에 비지니스 코드 생성한다. CreateChannel.resolvers.ts1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import &#123; Resolvers &#125; from &quot;src/types/resolvers&quot;;import &#123; CreateChannelMutationArgs, CreateChannelResponse &#125; from &quot;../../../../src/types/graphql&quot;import Channel from &quot;../../../../src/entities/Channel&quot;;// 상대경로로 사용해야함 (절대경로로는 파일을 못찾음)const resolvers:Resolvers = &#123; Mutation: &#123; // args는 channel name. CreateChannel: async(_, args: CreateChannelMutationArgs):Promise&lt;CreateChannelResponse&gt; =&gt; &#123; // GetMessages 라는 동작에 대한 비즈니스 로직 (Spring의 Controller와 유사) // 사용자가 API를 호출했을때 인자값이 args 안으로 들어온다. try &#123; const &#123; channelName &#125; = args; // const &#123; channelName &#125; = args.channelName; const existChannel = await Channel.findOne(&#123; channelName &#125;); // Message (typeORM) 을 사용하여 쿼리 메소드를 실행할 수 있음 // await : 동기적으로 실행되고있으므로 데이터를 가져올때까지 기다리기 위함. // &#x27;channelName&#x27; 일치하는 데이터를 조회해달라는 의미 // findOne()은 SELECT Query와 유사하며 한가지의 튜플만 가져온다. if(existChannel) &#123; return &#123; ok: false, error: &quot;이미 존재하는 채널입니다.&quot; &#125; &#125; // 채널이름이 중복될 경우 채널을 새로이 만들지 않기위함 await Channel.create(&#123;channelName&#125;).save(); // 채널은 새롭게 만드는 부분. // Create()는 INSERT Query와 유사하며 새로운 튜플을 생성할 수 있다. // 뒤의 save() 함수를 호출하여야 실제 데이터베이스에 생겨남 COMMIT 개념같음. return &#123; ok: true, error: null &#125; // 성공했을 때의 응답 / &#x27;CreateChannelResponse&#x27;를 &#x27;gql-merge&#x27;를 활용해서 변환하여 얻어낸 타입. &#125; catch(error) &#123; return &#123; ok: false, error: error.message &#125; // 실패했을 때의 응답 / &#x27;CreateChannelResponse&#x27;를 &#x27;gql-merge&#x27;를 활용해서 변환하여 얻어낸 타입. &#125; &#125; &#125;&#125;export default resolvers; 아래 명령어를 통해 graphql 서버를 실행하고 및 api를 테스트해보자. 서버 실행1workspace/backend&gt; yarn dev CreateChannel() API123456mutation &#123; CreateChannel(channelName: &quot;마블리게시판&quot;) &#123; ok error &#125;&#125; ‘SendMessage’, ‘GetChannel’함수타입 즉 API를 만드는 방법은 위 ‘GetMessage’, ‘CreateChannel’ 에서 적응했을 것이다. 이제 앞으로 필요한 두가지 ‘SendMessage’, ‘GetChannel’ API를 만든다. 1234567workspace/backend/src/api/Message&gt; mkdir SendMessageworkspace/backend/src/api/Message&gt; touch SendMessage.graphqlworkspace/backend/src/api/Message&gt; touch SendMessage.resolvers.tsworkspace/backend/src/api/Channel&gt; mkdir GetChannelworkspace/backend/src/api/Channel&gt; touch GetChannel.graphqlworkspace/backend/src/api/Channel&gt; touch GetChannel.resolvers.ts 윗 부분은 ‘SendMessage API’ 를 위한 파일들이며 아랫 부분은 ‘GetChannel API’ 를 위한 파일들이다. 아래는 각 파일들에 들어가야할 내용들이다. SendMessage.graphql123456789101112131415type SendMessageResponse &#123; ok: Boolean! error: String&#125;type Mutation &#123; SendMessage( nickname: String! contents: String! thumbnail: String! innerChannelId: Int! ): SendMessageResponse!&#125; GetChannel.graphql1234567891011type GetChannelsResponse &#123; ok: Boolean! error: String channels: [Channel]&#125;type Query &#123; GetChannels: GetChannelsResponse!&#125; 위 두 파일에 내용을 채워준 후에 yarn types 명령어로 typescript 를 위한 타입을 생성한다. 1workspace/backend&gt; yarn types 정상적으로 생성되었다면 types/graphql.d.ts 파일에 ‘SendMessage’, ‘GetChannel’ 과 연관된 타입들이 생성되었을 것이다. 이제 resolver 안에 비지니스 로직을 완성하자. SendMessage.resolvers.ts12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import &#123; Resolvers &#125; from &quot;src/types/resolvers&quot;;import Channel from &quot;../../../../src/entities/Channel&quot;;import Message from &quot;../../../../src/entities/Message&quot;;import &#123; SendMessageMutationArgs, SendMessageResponse &#125; from &quot;src/types/graphql&quot;;const resolvers: Resolvers = &#123; Mutation:&#123; SendMessage: async(_, args:SendMessageMutationArgs):Promise&lt;SendMessageResponse&gt; =&gt; &#123; try &#123; const &#123;nickname, contents, thumbnail, innerChannelId &#125; = args; // args 파라미터에서 필요한 정보들을 가져온다. const isExistChannel = await Channel.findOne(&#123;id: innerChannelId&#125;); // 메시지를 보내려는 채널이 존재하는 채널인지 확인하기 위해 findOne() 쿼리를 날린다. // findOne() 함수는 기존 DB에서 SELECT ... LIMIT 1 와 같은 쿼리로 봐도 무방하다. if(!isExistChannel) &#123; return &#123; ok: false, error: &quot;채널이 존재하지 않습니다.&quot; &#125; &#125; // 메시지를 보내려는 채널이 존재하지 않는 케이스를 위해 예외처리를 한다. await Message.create(&#123; nickname, thumbnail, contents, innerChannelId &#125;).save(); // create() 함수는 기존 DB의 INSERT ... 쿼리 개념으로 봐도 무방하다. // save() 함수는 기존 DB의 commit 개념으로 보자. return &#123; ok: true, error: null &#125; // 최종적으로 INSERT가 잘 되었음을 알리기 위해 ok에 true를 주고 반환한다. &#125; catch(error) &#123; return &#123; ok: false, error: error.message &#125; &#125; &#125; &#125;&#125;export default resolvers; GetChannel.resolvers.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445import &#123; Resolvers &#125; from &quot;src/types/resolvers&quot;;import &#123; GetChannelsResponse &#125; from &quot;src/types/graphql&quot;;import Channel from &quot;../../../../src/entities/Channel&quot;;const resolvers:Resolvers = &#123; Query:&#123; GetChannels: async (_, __):Promise&lt;GetChannelsResponse&gt; =&gt; &#123; // args 부분에 __ 값을 주고 있다. // 파라미터가 없을 때에는 위와 같이 처리하는 것 같다. try &#123; const channels = await Channel.find(); // find() 함수는 기존 RDB의 SELECT .... 와 유사하게 보자. // 채널목록을 가져와서 channels에 저장한다. if(!channels) &#123; return &#123; ok: true, error: &quot;It&#x27;s empty&quot;, channels: null &#125; &#125; //channels에 아무것도 없다면 channel이 하나도 생성되지 않았다고 예외처리한다. return &#123; ok: true, error: null, channels: channels &#125; //channels에 저장된 channel 목록들을 반환한다. &#125; catch(error) &#123; return &#123; ok: false, error: error.message, channels: null &#125; &#125; &#125; &#125;&#125;export default resolvers; 새로 만둔 두 API가 잘 동작하는지 테스트하기 위해서 graphql 서버를 실행하자. 1workspace/backend&gt; yarn dev Graphql 에서 사용하는 Query, Mutation 을 활용해 API를 요청해보자 SendMessage API12345678910111213mutation &#123; SendMessage( nickname: &quot;dev4us&quot;, contents: &quot;하이염!&quot;, thumbnail: &quot;1&quot;, innerChannelId: 1 ) &#123; ok error &#125; &#125; GetChannels API123456789101112&#123; GetChannels&#123; ok error channels&#123; id channelName &#125; &#125; &#125; SubscriptionGraphql에서","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Typescript","slug":"Typescript","permalink":"http://kidongyun.github.io/tags/Typescript/"},{"name":"Graphql","slug":"Graphql","permalink":"http://kidongyun.github.io/tags/Graphql/"}]},{"title":"Overview of the Test Code","slug":"2020-1-12-overview-test-code","date":"2020-01-11T15:00:00.000Z","updated":"2022-05-31T07:12:15.000Z","comments":true,"path":"2020/01/12/","link":"","permalink":"http://kidongyun.github.io/2020/01/12/","excerpt":"","text":"Overview of the Test Code1. The purpose and significance of test code.You have to remember the thing that Your system always be processed the management of operational tasks.Actually, If you just think that the building IT systems is temporary thing. then Making the test code is definitely inefficient task. because We gotta write more code than it’s not. then Why do we write the code for the test? The building of the IT system is really not temporary thing in the real world. The management of the system is really important than the building of it. and The business may be going to change because of any factor like the demand of customer, the modification of the policy of the companies. then We should change our code for this change at this time. but You can’t trust your code written before long times ago for this system. because You can’t remember about these code clearly. so When you change your code for the new business change, You could make any mistake. Sometimes It’s really critical code. for the difficult of changing your code, You should make the test code. You don’t need to test a whole of the system because of the tiny change of the code.If you don’t write the test code then you always have to test your whole of the systems because of the tiny change of the code. The bigger the size of the system, the harder it test. and It need more time. but If you use the test thing, then you can validate your modification using only the Unit Test code without any whole thing. For this, The test code should be independent thing between each other. Eventually You can save the time for testing using the Unit Test code. The Refactoring of Production code based the Test code.Refactoring the code is always important to most of the IT services. The Test code can propose some the direction for the refactoring of the production code. Basically The Test code should be written for th only one operation of the production thing. If one of the methods of the production code has many operations, then The test code for this method can’t validate for each operation. That is we can improve our production code has whether the proper operation range or not via Test code. For example, When we have the code call the API via HTTP connection and marshall the XML data from the API, then we can define it as the two operation like the below. 123451. The operation calling the API via HTTP connection.2. The operation marshalling the XML data to VO object. You can understand the important thing that your production code should be configured separately between the above things because you can’t validate each operation if you made the above tasks in only one method. It’s possible to make the document for the explaining only used the test code itself.The test code should be written more detail than the same things of production code. ex) name of function, name of variables … as you can see the above of this article, The test code is meaningful in terms of maintenance. additionally The test code can be the document itself without adding any text. I think it could be more important than maintenance perspective. The developers except main developers of the some project can understand to read the test code as the document. so Increasing readability of the code in the test code is very important. another words, To write a code that can be understood by the code itself without making any comments or any real documents is very important factor at the test code part than production code. 2. Which do we test the code?Does the code have the importance at the business persective?You could take a directly financial loss when the important code from business perspective face the problem. so from this perspective, The business code always have to get some barrier thing using the test code to protect the any various change things. and You have to be enable controlling these errors occurred at the business code right that time. Does the code have the complexible logic including a loop or conditional statement?Usually, Most of the developers are difficult to understand the code having a loop or conditional statement. and usually, These code has the high possibility of the error. so It’s also really good habit to test the complexible logic. and at the many cases, The complexible code often same with the business code. Does the code have any conversion of the data?from many situations of developing, Most of developers use a lot of the time for transforming the data like from JSON to VO or Primitive Type like the map to XML. and Also most of developers always find the errors occurred from what related to transforming. For saving these time, I strongly recommend to make the test code to check the conversion of the data. Does the code call the API from external environment?If your system use the API service from outer environment, You can test that these API calling is right or not. for example, Your parameters for requesting the API is right or not, The response is right or not. But You should remember the one thing that This test always has the dependency between the system provided the API. That is if the system providing the API is died, then we can’t test out code related to API Calling. But actually it is the critical problem because our test code could be fail although our logic is well. In these case, We gotta use the Mock or Stub Object. Yes. It’s the solution of dependency. Does the code get some data from the database?In modern web services, databases are used as a basis. So Validating the data from database is important either. If your system is asynchronous thing. then Actually It’s more considerable than it’s not. and this also should use the Mock or Stub thing. because These code is related to the database that is outer environment. Does the code take the client request like the Spring Controller?It’s really hard thing to test the request and response between client and server from the web service. because It always have the dependency between each other. but If we use the Mock library, then we can make the fake client object like the customer used the browser. and Testing these part is very important because If you provide the web service, Most of the errors are occured from here. 3. Test Code Creation TipsThe Rule of Naming for the Test ClassUsually The name of Test class is made by the production class name and ‘Test’ text. If your production class name is ‘PersonService.java’ then I’d recommend to use ‘PersonServiceTest.java’. When you use like this, You can find and know the test code related to the production code. and these files should be located at the same package. 123Production Class Name : PersonService.javaTest Class Name : PersonServiceTest.java The Rule of Naming for the Test Method.I think this topic is really important from this article. In most of cases, The name of test method in test class is more longer than the normal production code. because we should express the role of that test code only via the test method name. So actually test method name had the sentence includes over the 7 terms. the below the sample naming example for the understanding. To make the test code as the document for description of the code, Naming is very fundamental and basis. 1234567@TestCreateTheSomeObject_ValidParameter_ShouldBePassed() &#123; &#125;@TestAddAlphaAndBeta_NullAlpha_ShouldThrowException() &#123; &#125; Let’s keep the coherence using ‘Triple-A’We found out the way how do we type the name for the test code from the above. then Next step is the way How do we write the test code in the test method. usually, We gotta keep the rule called ‘AAA’ for the readability. If you keep this rule then you could get the documetation more easier than it’s not. You always effort for the test code to be the documentation. Let’s know the meaning of the each ‘AAA’ things. 123A : Arrange // To prepare the test.A : Act // To execute the test.A : Assert // To determine the result of the test. ‘Arrange’ is the task like the thing what prepare the some object needed at test. Usually this part could be more longer than others. but the long code is not well from the readability perspective. so We should extract these code to another method. for example ‘@Before’, ‘@After’, ‘normal method thing’ … but It’s not the main content of this article so I will introduce these content at the document related the refactoring of test code. ‘Act’ is the part to execute the operation of the test. this operation is like the transaction so It has one or more methods. ‘Assert’ is for determining the result of test. finally we will get the actual value and the expected value, then using these values, We should assert the result of the test. Use the Hamcrest matcher library.The default assert syntaxs occured from the JUnit are too simple, so We will not read the debug thing easily. but the Hamcrest Matcher can give the more kind, detail information when your test is failed. and Your test code will be more easier to read than it doesn’t use. the below text is the log when you test is failed. 12345Expected: &lt;100&gt; but: was &lt;101&gt;java.lang.AssertionError: Expected: &lt;100&gt; but: was &lt;101&gt; you know what? Computer can’t express the real number perfectly like ‘2.32’. You might studied about this in the university. So when you test the real number, you should consider the range of error. It’s like the below. 123assertTrue(Math.abs((2.32 * 3) - 6.96) &lt; 0.0005); // AS-ISassertThat(2.32 * 3, closeTo(6.96, 0.0005)); // TO-BE but The above code is really bad from the readability perspective. It’s just for the test whether two values are same or not, but We can’t get it easily. so we can use the Hamcrest matcher method named ‘isCloseTo()’. If you want to use this, you have to import the dependency of the ‘hamcrest-all’. The way how to throw the Exception.Test code has a various the solution for processing the exception. among them, the way associated with the ‘@Test’ annotation is very simple and powerful so I’d recommend to use this way. 123456789101112131415161718192021// Definition of the Exception class.class CreateSomeObjectException extends RuntimeException &#123; public CreateSomeObjectException(String message) &#123; super(message); &#125;&#125;// Production code sampleclass SomeObject &#123; public Object create() &#123; throw new CreateSomeObjectException(&quot;Error Message&quot;); &#125;&#125;// Test code sample@Test(expected=CreateSomeObjectException.class)public void CreateSomeObject_InvalidParameter_ShouldThrowException() &#123; new SomeObject.create();&#125; importantly, You don’t have to consider the basic exceptions like ‘NullpointerException’, ‘ClassCastException’, ‘NumberFormatException’ … because if we face that situation, your test code will return the fail with the exception information. Building the test code from operation perspective.When you make the test code, You can do it based the each production methods. but it’s not well. because the methods could always be changed because of many factors. So you should think what is the main concept or operation in this business. and to do the test from this perspetive. then you don’t need to change the test code although the production code is changed. The rule named ‘FIRST’FastIf your project is not too big then The test code may is going to do fast. but The more bigger your system, The more slower doing the test code. If you don’t do any refactoring for the test code then Your test code could need a lot of the time at least over 20 minutes. so you always effort to velocity of the test code doing. for that we need to do the test refactoring. we will treat this thing from another article. IsolatedWe already know the meaning of this word. as you can see from the above contents, test code should always keep the independence. RepeatableIf you keep the independence, then It will do again and again forever. then we can tell our test code is repeatable. Self-validatingThe test code have to get the ability enable to validate the production code without any assistance from outside of the test method. Timely","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Test","slug":"Test","permalink":"http://kidongyun.github.io/tags/Test/"}]},{"title":"The usage of Jaxb","slug":"2020-1-1-jaxb","date":"2019-12-31T23:47:54.000Z","updated":"2022-05-31T07:12:06.000Z","comments":true,"path":"2020/01/01/","link":"","permalink":"http://kidongyun.github.io/2020/01/01/","excerpt":"","text":"1. add The dependencies for JAXB1234567891011121314dependencies &#123; ... compile group: &#x27;javax.xml.bind&#x27;, name: &#x27;jaxb-api&#x27;, version: &#x27;2.3.0&#x27; compile group: &#x27;com.sun.xml.bind&#x27;, name: &#x27;jaxb-core&#x27;, version: &#x27;2.3.0.1&#x27; compile group: &#x27;com.sun.xml.bind&#x27;, name: &#x27;jaxb-impl&#x27;, version: &#x27;2.2.11&#x27; compile group: &#x27;javax.activation&#x27;, name: &#x27;activation&#x27;, version: &#x27;1.1.1&#x27; ...&#125; 2. type the code for marshalling and unmarshalling using the JAXB.Marshalling (POJO -&gt; XML)1234567891011121314151617public String jaxbMarshalling(Object target) &#123; String result = &quot;&quot;; try &#123; JAXBContext jaxbContext = JAXBContext.newInstance(target.getClass()); Marshaller jaxbMarshaller = jaxbContext.createMarshaller(); StringWriter stringWriter = new StringWriter(); jaxbMarshaller.marshal(target, stringWriter); result = stringWriter.toString(); &#125; catch (JAXBException e) &#123; e.printStackTrace(); &#125; return result;&#125; UnMarshalling (XML -&gt; POJO)12345678910111213141516public Object jaxbUnmarshalling(Class&lt;?&gt; type, String target) &#123; Object result = null; try &#123; JAXBContext jaxbContext = JAXBContext.newInstance(type); Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller(); result = jaxbUnmarshaller.unmarshal(new StringReader(target)); &#125; catch (JAXBException e) &#123; e.printStackTrace(); &#125; return result;&#125; Actually, Doing to Make the Jaxb Object like JAXBContext is too heavy task to computer. so I recommend to use the code related to ‘JAXBContext’ separately when you make it. 3. Sample The XML file1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465String xmlSample = &quot;&lt;?xml version=\\&quot;1.0\\&quot;?&gt;&quot; + &quot;&lt;Tests&gt;&quot; + &quot;&lt;Test TestId=\\&quot;0001\\&quot; TestType=\\&quot;CMD\\&quot;&gt;&quot; + &quot;&lt;Name&gt;Convert number to string&lt;/Name&gt;&quot; + &quot;&lt;CommandLine&gt;Examp1.EXE&lt;/CommandLine&gt;&quot; + &quot;&lt;Input&gt;1&lt;/Input&gt;&quot; + &quot;&lt;Output&gt;One&lt;/Output&gt;&quot; + &quot;&lt;Messages&gt;&quot; + &quot;&lt;Content&gt;Message Content Sample1&lt;/Content&gt;&quot; + &quot;&lt;Date&gt;Message Date Sample2&lt;/Date&gt;&quot; + &quot;&lt;/Messages&gt;&quot; + &quot;&lt;/Test&gt;&quot; + &quot;&lt;Test TestId=\\&quot;0002\\&quot; TestType=\\&quot;CMD\\&quot;&gt;&quot; + &quot;&lt;Name&gt;Find succeeding characters&lt;/Name&gt;&quot; + &quot;&lt;CommandLine&gt;Examp2.EXE&lt;/CommandLine&gt;&quot; + &quot;&lt;Input&gt;abc&lt;/Input&gt;&quot; + &quot;&lt;Output&gt;def&lt;/Output&gt;&quot; + &quot;&lt;Messages&gt;&quot; + &quot;&lt;Content&gt;Message Content Sample1&lt;/Content&gt;&quot; + &quot;&lt;Date&gt;Message Date Sample2&lt;/Date&gt;&quot; + &quot;&lt;/Messages&gt;&quot; + &quot;&lt;/Test&gt;&quot; + &quot;&lt;Test TestId=\\&quot;0003\\&quot; TestType=\\&quot;GUI\\&quot;&gt;&quot; + &quot;&lt;Name&gt;Convert multiple numbers to strings&lt;/Name&gt;&quot; + &quot;&lt;CommandLine&gt;Examp2.EXE /Verbose&lt;/CommandLine&gt;&quot; + &quot;&lt;Input&gt;123&lt;/Input&gt;&quot; + &quot;&lt;Output&gt;One Two Three&lt;/Output&gt;&quot; + &quot;&lt;Messages&gt;&quot; + &quot;&lt;Content&gt;Message Content Sample1&lt;/Content&gt;&quot; + &quot;&lt;Date&gt;Message Date Sample2&lt;/Date&gt;&quot; + &quot;&lt;/Messages&gt;&quot; + &quot;&lt;/Test&gt;&quot; + &quot;&lt;Test TestId=\\&quot;0004\\&quot; TestType=\\&quot;GUI\\&quot;&gt;&quot; + &quot;&lt;Name&gt;Find correlated key&lt;/Name&gt;&quot; + &quot;&lt;CommandLine&gt;Examp3.EXE&lt;/CommandLine&gt;&quot; + &quot;&lt;Input&gt;a1&lt;/Input&gt;&quot; + &quot;&lt;Output&gt;b1&lt;/Output&gt;&quot; + &quot;&lt;Messages&gt;&quot; + &quot;&lt;Content&gt;Message Content Sample1&lt;/Content&gt;&quot; + &quot;&lt;Date&gt;Message Date Sample2&lt;/Date&gt;&quot; + &quot;&lt;/Messages&gt;&quot; + &quot;&lt;/Test&gt;&quot; + &quot;&lt;Test TestId=\\&quot;0005\\&quot; TestType=\\&quot;GUI\\&quot;&gt;&quot; + &quot;&lt;Name&gt;Count characters&lt;/Name&gt;&quot; + &quot;&lt;CommandLine&gt;FinalExamp.EXE&lt;/CommandLine&gt;&quot; + &quot;&lt;Input&gt;This is a test&lt;/Input&gt;&quot; + &quot;&lt;Output&gt;14&lt;/Output&gt;&quot; + &quot;&lt;Messages&gt;&quot; + &quot;&lt;Content&gt;Message Content Sample1&lt;/Content&gt;&quot; + &quot;&lt;Date&gt;Message Date Sample2&lt;/Date&gt;&quot; + &quot;&lt;/Messages&gt;&quot; + &quot;&lt;/Test&gt;&quot; + &quot;&lt;Test TestId=\\&quot;0006\\&quot; TestType=\\&quot;GUI\\&quot;&gt;&quot; + &quot;&lt;Name&gt;Another Test&lt;/Name&gt;&quot; + &quot;&lt;CommandLine&gt;Examp2.EXE&lt;/CommandLine&gt;&quot; + &quot;&lt;Input&gt;Test Input&lt;/Input&gt;&quot; + &quot;&lt;Output&gt;10&lt;/Output&gt;&quot; + &quot;&lt;Messages&gt;&quot; + &quot;&lt;Content&gt;Message Content Sample1&lt;/Content&gt;&quot; + &quot;&lt;Date&gt;Message Date Sample2&lt;/Date&gt;&quot; + &quot;&lt;/Messages&gt;&quot; + &quot;&lt;/Test&gt;&quot; + &quot;&lt;/Tests&gt; &quot;; I proposed the above xml file for understanding the process to make the VO file when you use JAXB Marsharlling, UnMarshalling. It has various type of the data like List, the nested VO Object , Default type data. 4. Create the VO files.Importantly, JAXB can’t parse any data partly. If you want to get some data from the api written by xml, then you should take all of the xml api without any the skip. In the above sample xml data, You should make 3 VO files totally. They are the parent node of the sample xml data. 1234...&gt; touch TestsVO.java...&gt; touch TestVO.java...&gt; touch MessagesVO.java TestsVO.java1234567891011@Getter@Setter@ToString@XmlAccessorType(XmlAccessType.FIELD)@XmlRootElement(name=&quot;Tests&quot;)public class TestsVO &#123; @XmlElement(name=&quot;Test&quot;) protected List&lt;TestVO&gt; test;&#125; TestVO.java12345678910111213141516171819@Getter@Setter@ToString@XmlAccessorType(XmlAccessType.FIELD)@XmlRootElement(name=&quot;Test&quot;)public class TestVO &#123; @XmlElement(name=&quot;Name&quot;) protected String name; @XmlElement(name=&quot;CommandLine&quot;) protected String commandLine; @XmlElement(name=&quot;Input&quot;) protected String input; @XmlElement(name=&quot;Output&quot;) protected String output; @XmlElement(name=&quot;Messages&quot;) protected MessagesVO messages;&#125; MessagesVO12345678910111213@Getter@Setter@ToString@XmlAccessorType(XmlAccessType.FIELD)@XmlRootElement(name=&quot;Messages&quot;)public class MessagesVO &#123; @XmlElement(name=&quot;Content&quot;) protected String content; @XmlElement(name=&quot;Date&quot;) protected String date;&#125; These 3 VO files are exactly expressed to XML data. @XmlRootElement this annotation is for expressing the each root node of the xml. and the annotation can has the ‘name’ attribute. It’s for occuring the exactly xml tag name. If the names are different between POJO and XML then JAXB can’t parse. then This annotation throw the exception of JAXB. @XmlElement this annotation is for the each filed of the JAXB VO classes. It also can has the ‘name’ attribute, This attribute is the role for connection between POJO variable name and XML tag name like the @XmlRootElement annotation. If those names are not same then the field will have the null value. @XmlAccessorType(XmlAccessType.FIELD) It’s for definition of the namespace when you parse the data using JAXB. If you don’t use this annotation then maybe your jaxb vo fields are overlapped. 5. Example of the usage of Jaxb.1234567TestsVO tests = (TestsVO)jaxbUnmarshalling(TestsVO.class, xmlSample);System.out.println(tests);String xml = jaxbMarshalling(tests);System.out.println(xml);","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Xml","slug":"Xml","permalink":"http://kidongyun.github.io/tags/Xml/"}]},{"title":"The usage of Xpath","slug":"2019-12-28-xpath","date":"2019-12-27T23:47:54.000Z","updated":"2022-05-31T07:12:02.000Z","comments":true,"path":"2019/12/28/","link":"","permalink":"http://kidongyun.github.io/2019/12/28/","excerpt":"","text":"If you want to use the Xpath thing when you face the situation that you need to parse the xml thing, then You don’t have to import any dependencies because this function is occured from basic java. I think it’s best point of this library. 1. Get XML String from the URL using HttpConnection.12345678910111213141516171819202122232425public String getXml(String urlStr) &#123; String result = &quot;&quot;; try &#123; URL url = new URL(urlStr); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); BufferedReader br = new BufferedReader(new InputStreamReader(urlConnection.getInputStream(), &quot;UTF-8&quot;)); String line; while((line = br.readLine()) != null) &#123; result += line.trim(); &#125; &#125; catch(MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return result;&#125; You can get the xml file using the above thing. 2. Transform XML String to Document Object.12345678910111213141516171819202122232425private Document getDocument(String xml) &#123; DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder; Document document = null; try &#123; InputSource is = new InputSource(new StringReader(xml)); builder = factory.newDocumentBuilder(); document = builder.parse(is); &#125; catch(ParserConfigurationException e) &#123; e.printStackTrace(); &#125; catch(IOException e) &#123; e.printStackTrace(); &#125; catch(SAXException e) &#123; e.printStackTrace(); &#125; return document;&#125; Actually Document object is same thing with DOM Object in html. so you can use this object like the DOM thing. 3. Parse Document using XPath1234567891011121314151617181920private NodeList getNodeList(Document document, String expression) &#123; NodeList nodeList = null; try &#123; XPathFactory xPathFactory = XPathFactory.newInstance(); XPath xPath = xPathFactory.newXPath(); XPathExpression expr = xPath.compile(expression); nodeList = (NodeList) expr.evaluate(document, XPathConstants.NODESET); &#125; catch(XPathExpressionException e) &#123; e.printStackTrace(); &#125; return nodeList;&#125; 4. Main12345678910111213141516String urlStr = &quot;urlStr&quot;;String xml = getXml(urlStr);Document document = getDocument(xml);NodeList nodeList = getNodeList(document, &quot;expression&quot;);for(int i=0; i&lt;nodeList.getLength(); i++) &#123; System.out.println(node.getNodeName()); System.out.println(node.getLocalName()); System.out.println(node.getNodeType()); System.out.println(node.getTextContent()); System.out.println(node.getPrefix()); System.out.println(node.getAttributes().item(0));&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Xml","slug":"Xml","permalink":"http://kidongyun.github.io/tags/Xml/"}]},{"title":"The effective way how to handle the Json type data","slug":"2019-12-27-json-serialize","date":"2019-12-26T23:47:54.000Z","updated":"2022-05-31T07:11:57.000Z","comments":true,"path":"2019/12/27/","link":"","permalink":"http://kidongyun.github.io/2019/12/27/","excerpt":"","text":"1. Cofiguration of the json environment.build.gradle12345678910111213dependencies &#123; ... compile group: &#x27;com.googlecode.json-simple&#x27;, name: &#x27;json-simple&#x27;, version: &#x27;1.1.1&#x27; compile group: &#x27;com.google.code.gson&#x27;, name: &#x27;gson&#x27;, version: &#x27;2.8.5&#x27; compile group: &#x27;com.fasterxml.jackson.core&#x27;, name: &#x27;jackson-databind&#x27;, version: &#x27;2.9.8&#x27; ...&#125; We have to import the libraries for handling the json data effectively. and The above are the code to add the dependencies for json handling. 1234567891011import lombok.Data;import java.util.List;@Datapublic class PersonVO &#123; String name; int age; List&lt;String&gt; friends;&#125; We need a some VO object to know the way how to handle the Json either. so The PersonVO Object is for that. 2. Object -&gt; Json StringJSON Simple123456789101112131415// JSONObject -&gt; JSON String.JSONArray jsonArray = new JSONArray();jsonArray.add(&quot;Hwanghyun&quot;);jsonArray.add(&quot;Seungyeun&quot;);jsonArray.add(&quot;Haein&quot;);JSONObject jsonObject = new JSONObject();jsonObject.put(&quot;name&quot;, &quot;kidongyun&quot;);jsonObject.put(&quot;age&quot;, 20);jsonObject.put(&quot;friends&quot;, jsonArray);return jsonObject.toJSONString(); It’s the way how you convert the type of json data to String using JSON Simple library. But as you can see, this library should use the JSONArray for the list type. and use the JSONObject for converting the Json data. importantly, This object is not a common thing. so It’s too difficult to transform to another common object when you use this library. so Eventually this library isn’t useful than the below. because This library doesn’t support the function of VO Object mapping directly. And This is more slower than the Gson or the Jackson library. So I really don’t recommend to use this library. Gson123456789101112131415161718// Map -&gt; JSON String.Map&lt;String, Object&gt; personMap = new HashMap&lt;&gt;();List&lt;String&gt; friendList = new ArrayList&lt;&gt;();friendList.add(&quot;HwangHyeun&quot;);friendList.add(&quot;Seungyeun&quot;);friendList.add(&quot;JuKyu&quot;);personMap.put(&quot;name&quot;, &quot;Kidong&quot;);personMap.put(&quot;age&quot;, 26);personMap.put(&quot;friends&quot;, friendList);Gson gson = new Gson();return gson.toJson(personMap); 12345678910111213141516171819// VO -&gt; JSON String.List&lt;String&gt; friendList = new ArrayList&lt;&gt;();friendList.add(&quot;HwangHyeun&quot;);friendList.add(&quot;Seungyeun&quot;);friendList.add(&quot;JuKyu&quot;);PersonVO personVO = new PersonVO();personVO.setName(&quot;kidong&quot;);personVO.setAge(26);personVO.setFriends(friendList);Gson gson = new Gson();return gson.toJson(personVO); The main advantage of this library is you can use the common type of Java like List&lt;&gt; or Map&lt;&gt; for converting the Json data. and This library is really small, light compared with another Json libraries. You can use the VO type object and It’s really simple to use the library. Jackson12345678910111213141516171819202122// Map -&gt; JSON String.Map&lt;String, Object&gt; personMap = new HashMap&lt;&gt;();List&lt;String&gt; friendList = new ArrayList&lt;&gt;();friendList.add(&quot;HwangHyeun&quot;);friendList.add(&quot;Seungyeun&quot;);friendList.add(&quot;JuKyu&quot;);personMap.put(&quot;name&quot;, &quot;Kidong&quot;);personMap.put(&quot;age&quot;, 26);personMap.put(&quot;friends&quot;, friendList);ObjectMapper mapper = new ObjectMapper();try &#123; return mapper.writeValueAsString(personMap);&#125; catch(JsonProcessingException e) &#123; e.printStackTrace();&#125; 123456789101112131415161718192021// VO -&gt; JSON String.List&lt;String&gt; friendList = new ArrayList&lt;&gt;();friendList.add(&quot;HwangHyeun&quot;);friendList.add(&quot;Seungyeun&quot;);friendList.add(&quot;JuKyu&quot;);PersonVO personVO = new PersonVO();personVO.setName(&quot;kidong&quot;);personVO.setAge(26);personVO.setFriends(friendList);try &#123; return mapper.writeValueAsString(personVO);&#125; catch(JsonProcessingException e) &#123; e.printStackTrace();&#125; 3. JSON String -&gt; ObjectGson12345678910// JSON String -&gt; MapString json = &#123;&quot;name&quot;:&quot;Kidong&quot;,&quot;age&quot;:26,&quot;friends&quot;:[&quot;HwangHyeun&quot;,&quot;Seungyeun&quot;,&quot;JuKyu&quot;]&#125;;Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();map = gson.fromJson(json, map.getClass());return map; 12345678910// JSON String -&gt; VOString json = &#123;&quot;name&quot;:&quot;Kidong&quot;,&quot;age&quot;:26,&quot;friends&quot;:[&quot;HwangHyeun&quot;,&quot;Seungyeun&quot;,&quot;JuKyu&quot;]&#125;;PersonVO personVO = new PersonVO();personVO = gson.fromJson(json, PersonVO.class);return personVO; Jackson123456789101112131415// JSON String -&gt; MapString json = &#123;&quot;name&quot;:&quot;Kidong&quot;,&quot;age&quot;:26,&quot;friends&quot;:[&quot;HwangHyeun&quot;,&quot;Seungyeun&quot;,&quot;JuKyu&quot;]&#125;;ObjectMapper mapper = new ObjectMapper();try &#123; Map&lt;String, Object&gt; map = mapper.readValue(json, Map.class);&#125; catch(IOException e) &#123; e.printStackTrace();&#125;return map; 123456789101112131415// JSON String -&gt; VOString json = &#123;&quot;name&quot;:&quot;Kidong&quot;,&quot;age&quot;:26,&quot;friends&quot;:[&quot;HwangHyeun&quot;,&quot;Seungyeun&quot;,&quot;JuKyu&quot;]&#125;;ObjectMapper mapper = new ObjectMapper();try &#123; PersonVO personVo = new PersonVO(); personVO = mapper.readValue(json, PersonVO.class);&#125; catch(IOException e) &#123; e.printStackTrace();&#125;return personVO; Gson and Jackson are really similar things. So You can think the differences between these two libraries. Actually The usage of the two is almostly same. but You have to know whether is more effectively as the many situation. Jackson library is more heavier than Gson. and If you have to parse a lot of the Json data then It’s more better idea to choose this library then Gson. Jackson is more powerful, flexible and is known to many developer. but It’s not small thing. If you need to parse just a little Json data then I recommend to use the Gson library. in this case, It’s more faster than the Jackson. Jackson with Generic Type123456789101112131415161718192021222324252627282930313233343536373839404142434445import com.fasterxml.jackson.annotation.JsonInclude;import lombok.Getter;import lombok.Setter;import lombok.ToString;import org.springframework.stereotype.Component;@Getter@Setter@ToString@Component@JsonInclude(JsonInclude.Include.NON_NULL)public class Response&lt;T&gt; &#123; private int errorCode; private String errorDesc; private T data; public static class Builder&lt;T&gt; &#123; private final Response&lt;T&gt; response; public Builder() &#123; this.response = new Response&lt;&gt;(); &#125; public Builder&lt;T&gt; errorCode(int val) &#123; this.response.errorCode = val; return this; &#125; public Builder&lt;T&gt; errorDesc(String val) &#123; this.response.errorDesc = val; return this; &#125; public Builder&lt;T&gt; data(T val) &#123; this.response.data = val; return this; &#125; public Response&lt;T&gt; build() &#123; return response; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142import com.sun.istack.NotNull;import lombok.Getter;import lombok.Setter;import lombok.ToString;import java.util.ArrayList;import java.util.List;@Getter@Setter@ToStringpublic class PenaltyRes &#123; @NotNull private double totalPenalty; private List&lt;PenaltyTicket&gt; penaltyTickets; public static class Builder &#123; private final PenaltyRes penaltyRes; public Builder() &#123; this.penaltyRes = new PenaltyRes(); this.penaltyRes.penaltyTickets = new ArrayList&lt;&gt;(); &#125; public Builder totalPenalty(double val) &#123; this.penaltyRes.totalPenalty = val; return this; &#125; public Builder penaltyTickets(List&lt;PenaltyTicket&gt; val) &#123; this.penaltyRes.penaltyTickets = val; return this; &#125; public PenaltyRes build() &#123; return this.penaltyRes; &#125; &#125;&#125; 123Response&lt;PenaltyRes&gt; res = new ObjectMapper().readValue(result, new TypeReference&lt;Response&lt;PenaltyRes&gt;&gt;()&#123;&#125;); You should use th TypeReference Object when you want to parse the object including the generic type.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Json","slug":"Json","permalink":"http://kidongyun.github.io/tags/Json/"}]},{"title":"Spring Controller Test using Junit and Mockito","slug":"2019-12-13-spring-controller-test","date":"2019-12-12T23:47:54.000Z","updated":"2022-05-31T07:11:53.000Z","comments":true,"path":"2019/12/13/","link":"","permalink":"http://kidongyun.github.io/2019/12/13/","excerpt":"","text":"This article will skip the configuration of Spring Framework Environment basically because It’s not main focus of this and It’s too longer then the thing related to the spring test. If you want to know about those either then I recommend to read this document. 1. Add Dependency in your build.gradleYou should have all of the below dependencies for testing your spring project. build.gradle123456789101112131415dependencies &#123; testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.11&#x27; // It may be default setting. testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.12&#x27; // It may be default setting. testCompile group: &#x27;org.mockito&#x27;, name: &#x27;mockito-all&#x27;, version: &#x27;1.9.5&#x27; // Let&#x27;s add this code. testCompile group: &#x27;org.springframework&#x27;, name: &#x27;spring-test&#x27;, version: &#x27;5.1.5.RELEASE&#x27; // Let&#x27;s add this code. providedCompile group: &#x27;javax.servlet&#x27;, name: &#x27;javax.servlet-api&#x27;, version: &#x27;3.1.0&#x27; compile &#x27;org.springframework:spring-webmvc:4.3.18.RELEASE&#x27; compile group: &#x27;org.springframework&#x27;, name: &#x27;spring-jdbc&#x27;, version: &#x27;5.0.3.RELEASE&#x27; runtime &#x27;javax.servlet:jstl:1.1.2&#x27;&#125; And you should condsider the version of javax.sevlet dependency carefully. If your thing is lower than 2.5 then maybe It’s not working well when you test your project. and I don’t know why this happen but You have to add the ‘spring-jdbc’ dependency for testing. 2. Configure the HomeController.javaFor testing, We will make a one controller thing in the project. and the code is like the below. 12345678910111213141516171819202122import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HomeController &#123; @ResponseBody @RequestMapping(value = &quot;/&quot;) public String hello( @RequestParam String name, @RequestParam int age, @RequestParam String major) &#123; String res = name + &quot; &quot; + age + &quot; &quot; + major; return res; &#125;&#125; If you want to test whether hello function work well or not in this HomeController, then you always turn on the WAS in locally and you also must send some request to your controller. But It’s sometimes really tiresome. Surely, You can use the another service like postman for solving this issue. But I think to use the test code in project is really simple way to test the controller. The above code is taken three parameters from someone who certainly doesn’t know. and return this parameter using the String type. and the url is only ‘/‘. 3. Make the packages for testing the controller.12&gt; mkdir src/test/java/com/kidongyun/controller&gt; touch src/test/java/com/kidongyun/controller/HomeControllerTest.java 4. Configure the HomeControllerTest.javaHomeControllerTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546import org.junit.After;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123; &quot;file:src/main/webapp/WEB-INF/dispatcher-servlet.xml&quot;, &quot;file:src/main/webapp/WEB-INF/applicationContext.xml&quot;&#125;)public class HomeControllerTest &#123; @Autowired HomeController homeController; private MockMvc mockMvc; @Before public void setUp() throws Exception &#123; mockMvc = MockMvcBuilders.standaloneSetup(homeController).build(); &#125; @After public void tearDown() throws Exception &#123; &#125; @Test public void hello() throws Exception &#123; mockMvc.perform(get(&quot;/&quot;) .param(&quot;name&quot;, &quot;kidongyun&quot;) .param(&quot;age&quot;, &quot;20&quot;) .param(&quot;major&quot;, &quot;computer engineering&quot;)) .andDo(print()) .andExpect(status().isOk()); &#125; &#125; MockMvc Object is like browser. It can send the request to our controller. So We can test our code using this object without any server running now. This MockMvc Object is from the spring-test library. so whenever you want to use this, You should add the dependency of this. Actually You can see this code at the above related to build.gradle. And You should know the truth whether to test the controller in spring framework is an unit test or intergration test. Many developers over the world said that It’s not Unit test because Unit test should be independent. but to test the controller is not. But I think this among all of the test technic is really important than others. Many problems usually were occured from the connection between client and server part. 123456789101112mockMvc.perform(get(&quot;/&quot;) // You can insert the url you want to test. .param(&quot;name&quot;, &quot;kidongyun&quot;) // The part for adding the parameters. .param(&quot;age&quot;, &quot;20&quot;) .param(&quot;major&quot;, &quot;computer engineering&quot;)) .andDo(print()) // This code can show the result of the MockMvc.perform() test. .andExpect(status().isOk()); // status().isOk() means that we expect the success of the connection like &#x27;200&#x27; status code // so If this test has any problems then It will return the fail because of this code. If your test is successed then you can take the result like the below picture. Your MockHttpServletResponse status is 200. Otherwise you forget one of the parameters at the above code like the below then you will take the failed result. 12345mockMvc.perform(get(&quot;/&quot;) .param(&quot;name&quot;, &quot;kidongyun&quot;) .param(&quot;major&quot;, &quot;computer engineering&quot;)) .andDo(print()) .andExpect(status().isOk()); 5. Test Controller using Java Configuration.Actually according to my experience, When you configure your Spring project using the java configruation without xml code, The Controller Test code is little different. But if you don’t understand about these things, It may be going to feel too difficult. build.gradle12345678910111213141516testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.11&#x27;testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.12&#x27;testCompile group: &#x27;org.mockito&#x27;, name: &#x27;mockito-all&#x27;, version: &#x27;1.9.5&#x27;testCompile group: &#x27;org.springframework&#x27;, name: &#x27;spring-test&#x27;, version: &#x27;4.3.18.RELEASE&#x27;providedCompile group: &#x27;javax.servlet&#x27;, name: &#x27;javax.servlet-api&#x27;, version: &#x27;3.1.0&#x27;runtime &#x27;javax.servlet:jstl:1.1.2&#x27;compile group: &#x27;javax.annotation&#x27;, name: &#x27;javax.annotation-api&#x27;, version: &#x27;1.3.2&#x27;compile &#x27;org.springframework:spring-webmvc:4.3.18.RELEASE&#x27;compile group: &#x27;org.springframework&#x27;, name: &#x27;spring-jdbc&#x27;, version: &#x27;3.1.0.RELEASE&#x27;compile group: &#x27;org.mybatis&#x27;, name: &#x27;mybatis-spring&#x27;, version: &#x27;1.3.2&#x27;compile group: &#x27;org.mybatis&#x27;, name: &#x27;mybatis&#x27;, version: &#x27;3.4.6&#x27;compile group: &#x27;org.apache.commons&#x27;, name: &#x27;commons-dbcp2&#x27;, version: &#x27;2.0&#x27; And you should consider the version of the ‘spring-test’ dependency. in my case, I used 5.X.X version of this, But It’s not proper about the 4.X.X ‘Spring’ Environment. So First of all, Let’s see the version of libraries via the above code. these dependencies include the function of the ‘mybatis’. so don’t confuse about that. HomeControllerTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546import org.junit.After;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfiguration@ContextConfiguration(classes = &#123;WebConfig.class, RootConfig.class, ServletConfig.class&#125;)public class HomeControllerTest &#123; @Autowired HomeController homeController; private MockMvc mockMvc; @Before public void setUp() throws Exception &#123; mockMvc = MockMvcBuilders.standaloneSetup(homeController).build(); &#125; @After public void tearDown() throws Exception &#123; &#125; @Test public void hello() throws Exception &#123; mockMvc.perform(get(&quot;/&quot;) .param(&quot;name&quot;, &quot;kidongyun&quot;) .param(&quot;age&quot;, &quot;20&quot;) .param(&quot;major&quot;, &quot;computer engineering&quot;)) .andDo(print()) .andExpect(status().isOk()); &#125; &#125; 6. Create Application Context directly at the Test Code.Actually To use the application context used from production environment is sometimes too hard. If you project is too big, then whenever you do the test, you test code configure your all of things related to application context. so I will introduce the new way to solve these problems. HomeControllerTest.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfiguration@ContextConfiguration(loader = AnnotationConfigWebContextLoader.class)public class HomeControllerTest &#123; @Configuration static class ApplicationContext &#123; @Bean public HomeController registerHomeController() &#123; HomeController homeController = new HomeController(); return homeController; &#125; @Bean public HomeService registerHomeService() &#123; HomeService homeService = new HomeService(); return homeService; &#125; &#125; @Autowired HomeController homeController; private MockMvc mockMvc; @Before public void setUp() throws Exception &#123; mockMvc = MockMvcBuilders.standaloneSetup(homeController).build(); &#125; @After public void tearDown() throws Exception &#123; &#125; @Test public void hello() throws Exception &#123; mockMvc.perform(get(&quot;/&quot;) .param(&quot;name&quot;, &quot;kidongyun&quot;) .param(&quot;age&quot;, &quot;20&quot;) .param(&quot;major&quot;, &quot;computer engineering&quot;)) .andDo(print()) .andExpect(status().isOk()); &#125;&#125; If the object you want to register to application context has another your custom object, then you should register that object either. 7. The way how to test Controller.First of all, You can measure the result of the connection using this test code. That’s exactly status code. and Second, You can check whether the parameter types are correct or not if you want. HomeControllerTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.kidongyun.controller;import com.kidongyun.config.RootConfig;import com.kidongyun.config.ServletConfig;import com.kidongyun.config.WebConfig;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.MvcResult;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import java.util.HashMap;import java.util.Map;import static org.hamcrest.CoreMatchers.equalTo;import static org.hamcrest.MatcherAssert.assertThat;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfiguration@ContextConfiguration(classes = &#123;WebConfig.class, RootConfig.class, ServletConfig.class&#125;)public class HomeControllerTest &#123; @Autowired HomeController homeController; private MockMvc mockMvc; @Before public void setUp() &#123; mockMvc = MockMvcBuilders.standaloneSetup(homeController).build(); &#125; @After public void tearDown() &#123; &#125; @Test public void requestResponseHello_validParameters_ShouldBePassed() throws Exception &#123; /** Arrange */ MvcResult result = mockMvc.perform(get(&quot;/&quot;) .param(&quot;name&quot;, &quot;kidongyun&quot;) .param(&quot;age&quot;, &quot;20&quot;) .param(&quot;major&quot;, &quot;computer&quot;)) .andDo(print()) .andExpect(status().isOk()) .andReturn(); /** Act */ String response = result.getResponse().getContentAsString(); /** Assert */ Map&lt;String, Object&gt; expected = new HashMap&lt;&gt;(); expected.put(&quot;name&quot;, &quot;kidongyun&quot;); expected.put(&quot;age&quot;, &quot;20&quot;); expected.put(&quot;major&quot;, &quot;computer&quot;); assertThat(response, equalTo(expected.toString())); &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Controller","slug":"Controller","permalink":"http://kidongyun.github.io/tags/Controller/"},{"name":"Test","slug":"Test","permalink":"http://kidongyun.github.io/tags/Test/"}]},{"title":"Mockito","slug":"2019-12-09-mockito","date":"2019-12-08T23:47:54.000Z","updated":"2022-05-31T07:11:49.000Z","comments":true,"path":"2019/12/09/","link":"","permalink":"http://kidongyun.github.io/2019/12/09/","excerpt":"","text":"1. Add the ‘mockito-all’ dependency to your build.gradle file1234567891011dependencies &#123; ... testCompile group: &#x27;org.mockito&#x27;, name: &#x27;mockito-all&#x27;, version: &#x27;1.9.5&#x27; ...&#125; Please add the above dependency in your build.gradle code. 2. Make the sample VO Object.We need a sample VO Object for knowing how does the Mockito Test is configured. so We will make the PersonVO like the below code. 12345678@Datapublic class PersonVO &#123; String name; int age; String major;&#125; 3. @MockYou can create the new object using this annotation. It’s really similar with the ‘autowired’ annotation in Spring but Mock annotation is only able to use in Test case. 12345678910import org.mockito.Mock;public class PersonVOTest &#123; @Mock PersonVO;&#125; at the above code, You can see the code creating the PersonVO object using @Mock annotation. Actually You need a one more code for creating the object using @Mock. It’s like the below 123456789101112131415import org.mockito.Mock;public class PersonVOTest &#123; @Mock PersonVO; @Before public void setUp() &#123; MockitoAnnotations.initMocks(this); &#125;&#125; When you use the @Mock annotation, you should add ‘MockitoAnnotations.initMock(this)’ code in your test case. It’s like the constructor in Java. 4. @InjectMocksFor understanding the @InjectMocks Let’s define new class named ‘PersonService’ like the below. 12345678public class PersonService &#123; @Autowired PersonVO personVO;&#125; If you type the code like the below then you will face a problem what you can’t control the PersonVO object in the PersonService. 12345678910import org.mockito.Mock;public class PersonVOTest &#123; @Mock PersonService personService;&#125; in this case, if you use the @InjectMocks annotation, then you are able to solve this problem. 1234567891011121314151617import org.mockito.Mock;public class PersonVOTest() &#123; @Mock PersonVO personVO; @InjectMocks PersonService personService; @Before public void setUp() &#123; MockitoAnnotations.initMocks(this); &#125;&#125; 5. when().thenReturn()12345678910111213141516171819202122232425262728293031323334353637import org.mockito.Mock;public class PersonVOTest() &#123; @Mock PersonVO personVO; @InjectMocks PersonService personService; @Before public void setUp() &#123; MockitoAnnotations.initMocks(this); &#125; @Test public void example() &#123; when(personVO.getName()).thenReturn(&quot;Mark&quot;); // when you call the &#x27;personVO.getName()&#x27; function then please return the &#x27;Mark&#x27; String. when(personVO.getAge()).thenReturn(20); // when you call the &#x27;personVO.getAge()&#x27; function then return &#x27;20&#x27;. when(personVO.getMajor()).thenReturn(&quot;Computer Engineering&quot;); // when you call the &#x27;personVO.getMajor()&#x27; then return &#x27;Computer Engineering&#x27;. assertTrue(personVO.getName().equals(&quot;Mark&quot;)) // True assertTrue(personVO.getAge() == 20) // True assertTrue(personVO.getMajor().equals(&quot;Computer Engineering&quot;)) // True assertTrue(personVO.getName().equals(&quot;Chris&quot;)) // False assertTrue(personVO.getAge() == 30) // False assertTrue(personVO.getMajor().equals(&quot;Electric Engineering&quot;)) // False &#125;&#125; 6. doThrow()123456789101112131415161718192021222324import org.mockito.Mock;public class PersonVOTest() &#123; @Mock PersonVO personVO; @InjectMocks PersonService personService; @Before public void setUp() &#123; MockitoAnnotations.initMocks(this); &#125; @Test(expected = IllegalArgumentException.class) public void example() &#123; doThrow(new IllegalArgumentException()).when(p).setName(eq(&quot;JDM&quot;)); // eq... personVO.setName(&quot;JDM&quot;); &#125;&#125; 7. doNothing()1234567891011121314151617181920212223import org.mockito.Mock;public class PersonVOTest() &#123; @Mock PersonVO personVO; @InjectMocks PersonService personService; @Before public void setUp() &#123; MockitoAnnotations.initMocks(this); &#125; @Test public void example()&#123; doNothing().when(personVO).setAge(anyInt()); verify(personVO).setAge(anyInt()); &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Test","slug":"Test","permalink":"http://kidongyun.github.io/tags/Test/"}]},{"title":"Interpark - Lombok in Intellij","slug":"2019-12-08-lombok","date":"2019-12-07T23:47:54.000Z","updated":"2022-05-31T07:11:42.000Z","comments":true,"path":"2019/12/08/","link":"","permalink":"http://kidongyun.github.io/2019/12/08/","excerpt":"","text":"Config Default Spring Project.If you can’t config Spring Project then please read the article before following this. Add the dependencies at the build.gradle123456789101112131415161718192021222324252627// AS-ISplugins &#123; id &#x27;java&#x27; id &#x27;war&#x27;&#125;apply plugin: &#x27;war&#x27;group &#x27;com.kidongyun&#x27;version &#x27;1.0-SNAPSHOT&#x27;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.11&#x27; testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.12&#x27; providedCompile group: &#x27;javax.servlet&#x27;, name: &#x27;javax.servlet-api&#x27;, version: &#x27;3.1.0&#x27; compile &#x27;org.springframework:spring-webmvc:4.3.18.RELEASE&#x27; runtime &#x27;javax.servlet:jstl:1.1.2&#x27;&#125; Let’s add the new dependencies for the lombok. The above thing is the before adding and The below is the after. 123456789101112131415161718192021222324252627282930// TO-BEplugins &#123; id &#x27;java&#x27; id &#x27;war&#x27;&#125;apply plugin: &#x27;war&#x27;group &#x27;com.kidongyun&#x27;version &#x27;1.0-SNAPSHOT&#x27;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.11&#x27; testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.12&#x27; providedCompile group: &#x27;javax.servlet&#x27;, name: &#x27;javax.servlet-api&#x27;, version: &#x27;3.1.0&#x27; compile &#x27;org.springframework:spring-webmvc:4.3.18.RELEASE&#x27; runtime &#x27;javax.servlet:jstl:1.1.2&#x27; compileOnly &#x27;org.projectlombok:lombok:1.18.6&#x27; annotationProcessor &#x27;org.projectlombok:lombok:1.18.6&#x27;&#125; Installing the Lombok plugin.1File &gt; Settings &gt; Search &#x27;plugin&#x27; &gt; Search &#x27;lombok&#x27; Let’s install the Lombok plugin. Let’s set ‘Enable annotation processing’.1File &gt; Settings &gt; Build, Execution, Deployment &gt; Compiler &gt; Annotation Processors &gt; Check the &#x27;Enable annotation processing&#x27;. Let’s make new VO file.123456789101112package com.kidongyun.vo;import lombok.Data;@Datapublic class PersonVO &#123; String name; int age; String major;&#125; Let’s re-config the Controller file.Check whether the lombok configuration is right or not. 123456789101112131415161718192021222324252627282930package com.kidongyun.controller;import com.kidongyun.vo.PersonVO;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HomeController &#123; @RequestMapping(value = &quot;/&quot;) public String hello(Model model)&#123; PersonVO personVO = new PersonVO(); personVO.setName(&quot;Mark&quot;); personVO.setAge(20);s personVO.setMajor(&quot;Computer Engineering&quot;); System.out.println(personVO.getName()); System.out.println(personVO.getAge()); System.out.println(personVO.getMajor()); System.out.println(personVO.toString()); model.addAttribute(&quot;msg&quot;, &quot;Hello World!&quot;); return &quot;index&quot;; &#125;&#125; When you want to use the builder pattern. You are able to use the builder pattern like the below 123456789101112131415package com.kidongyun.vo;import lombok.Data;@Getter@Setter@ToString@Accessors(chain = true)public class PersonVO &#123; String name; int age; String major;&#125; @BuilderYou can use the builder pattern style coding only with this annotation. This annotaion can be located at the above of class name. but your domain class should have the super class, It might be not worked well. So The below coding style more better although It’s more longer. 12345678910111213141516171819202122232425262728293031323334@Getter@Setter@ToString@Entity@Table(name = &quot;OBJECTIVE&quot;)public class Objective extends Base &#123; @Column(name = &quot;OBJ_TITLE&quot;) private String title; @Column(name = &quot;OBJ_DESCRIPTION&quot;) private String description; @Column(name = &quot;OBJ_DEADLINE&quot;) private LocalDate deadline; @Column(name = &quot;OBJ_PRIORITY&quot;) private int priority; @Column(name = &quot;OBJ_STATUS&quot;) private int status; @Builder public Objective(String type, long id, String title, String description, LocalDate deadline, int priority, int status) &#123; super.type = type; super.id = id; this.title = title; this.description = description; this.deadline = deadline; this.priority = priority; this.status = status; &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Lombok","slug":"Lombok","permalink":"http://kidongyun.github.io/tags/Lombok/"}]},{"title":"The Usage of Selectkey option of Mybatis","slug":"2019-12-06-mybatis-selectkey","date":"2019-12-05T23:47:54.000Z","updated":"2022-05-31T07:11:37.000Z","comments":true,"path":"2019/12/06/","link":"","permalink":"http://kidongyun.github.io/2019/12/06/","excerpt":"","text":"1. CREATE TABLEIn my case, I use Oracle 11g Database. 12345678CREATE SEQUENCE PLAYER_NO_SEQ START WITH 1 INCREMENT BY 1 MAXVALUE 10000 MINVALUE 1 NOCYCLE; 12345678CREATE TABLE PLAYER( NO NUMBER(5) PRIMARY KEY, NAME VARCHAR(5) NOT NULL, AGE NUMBER(3) NOT NULL, BIRTHDAY DATE NOT NULL) 2. Default SettingThe detail is written at the article so if you can’t build the project configuration of Spring + Mybatis + Oracle then I recommand to read that. The above is the directory structure when you finished the configuration of this project. 12345678910111213141516171819202122232425- src - main - java - com.kidongyun - controller PlayerController.java - dao PlayerDAO.java // It&#x27;s interface - service PlayerService.java - vo PlayerVO.java - resources - mappers playerMappers.xml mybatis-config.xml - webapp - WEB-INF - view index.jsp applicationContext.xml dispatcher-servlet.xml web.xml Config every each files.build.gradle12345678910111213141516171819202122232425262728293031323334plugins &#123; id &#x27;java&#x27; id &#x27;war&#x27;&#125;apply plugin: &#x27;war&#x27;group &#x27;com.kidongyun&#x27;version &#x27;1.0-SNAPSHOT&#x27;sourceCompatibility = 1.8repositories &#123; mavenCentral() maven() &#123; url &quot;http://repo.spring.io/plugins-release/&quot; &#125;&#125;dependencies &#123; testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.11&#x27; testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.12&#x27; providedCompile group: &#x27;javax.servlet&#x27;, name: &#x27;javax.servlet-api&#x27;, version: &#x27;3.1.0&#x27; runtime &#x27;javax.servlet:jstl:1.1.2&#x27; compile group: &#x27;javax.annotation&#x27;, name: &#x27;javax.annotation-api&#x27;, version: &#x27;1.3.2&#x27; compile &#x27;org.springframework:spring-webmvc:4.3.18.RELEASE&#x27; compile group: &#x27;org.springframework&#x27;, name: &#x27;spring-jdbc&#x27;, version: &#x27;3.1.0.RELEASE&#x27; compile group: &#x27;org.mybatis&#x27;, name: &#x27;mybatis-spring&#x27;, version: &#x27;1.1.0&#x27; compile group: &#x27;commons-dbcp&#x27;, name: &#x27;commons-dbcp&#x27;, version: &#x27;1.4&#x27; compile group: &#x27;com.oracle&#x27;, name: &#x27;ojdbc6&#x27;, version: &#x27;12.1.0.1-atlassian-hosted&#x27;&#125; web.xml1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; dispatcher-servlet.xml123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;mvc:annotation-driven /&gt; &lt;context:component-scan base-package=&quot;com.kidongyun&quot; /&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; applicationContext.xml123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot; id=&quot;dataSource&quot;&gt; &lt;property value=&quot;oracle.jdbc.driver.OracleDriver&quot; name=&quot;driverClassName&quot; /&gt; &lt;property value=&quot;jdbc:oracle:thin:@localhost:1521:XE&quot; name=&quot;url&quot; /&gt; &lt;property value=&quot;c##scott&quot; name=&quot;username&quot; /&gt; &lt;property value=&quot;tiger&quot; name=&quot;password&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mappers/**/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.kidongyun&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; index.jsp1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;no&#125;&lt;/body&gt;&lt;/html&gt; mybatis-config.xml123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0/EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;/configuration&gt; playerMappers.xmlIt’s maybe best important file for understanding the function named ‘SelectKey’. The tag ‘selectKey’ is getting the next value of ‘PLAYERNO_SEQ’. Actually This value means the primary key. and we can use this value via the name ‘no’ but You can also control this name using the _keyProperty attribute. I am naming ‘no’ in this project. so at the part of INSERT Query, I use this ‘no’ value for NO column in PLAYER table. like this ‘#{no}’. It apperently mean ‘SELECT PLAYERNO_SEQ.NEXTVAL FROM DUAL’. You can change the _keyProperty attribute if you want and also you can change the resultType attribute as your key data. 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kidongyun.dao.PlayerDAO&quot;&gt; &lt;insert id=&quot;insertPerson&quot; parameterType=&quot;com.kidongyun.vo.PlayerVO&quot;&gt; &lt;selectKey keyProperty=&quot;no&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt; SELECT PLAYER_NO_SEQ.NEXTVAL FROM DUAL &lt;/selectKey&gt; INSERT INTO PLAYER VALUES ( #&#123;no&#125;, #&#123;name&#125;, #&#123;age&#125;, TO_DATE(#&#123;birthday&#125;, &#x27;yyyyMMdd&#x27;) ) &lt;/insert&gt;&lt;/mapper&gt; PlayerVO.java123456789101112131415161718192021222324252627282930313233343536package com.kidongyun.vo;public class PlayerVO &#123; int no; String name; int age; String birthday; public int getNo() &#123; return no; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return &quot;PlayerVO&#123;&quot; + &quot;no=&quot; + no + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, birthday=&#x27;&quot; + birthday + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; PlayerDAO.javaYou should know the one thing. Let’s see the below PlayerDAO code. insertPerson function doesn’t have the return type actually, but The purpose of using selectKey tag is for getting the some information associated with the data you insert. but This function doesn’t have the return type as you know. It’s little weird. Eventually The take information from ‘selelctKey’ is saven to parameter. That is The result is stored in the parameter. selectKey tag is usually used when you insert some data to the database. Acutally You don’t need any primary key like ‘no’ when you insert your data. so This value is always empty. and ‘selectKey’ tag return the new primary key to this empty space. 1234567891011package com.kidongyun.dao;import com.kidongyun.vo.PlayerVO;import org.springframework.stereotype.Repository;@Repositorypublic interface PlayerDAO &#123; public void insertPerson(PlayerVO playerVO);&#125; PlayerService.javalike the below code, you can get the result of ‘selectKey’ via the parameter variable. 123456789101112131415161718192021222324252627package com.kidongyun.service;import com.kidongyun.dao.PlayerDAO;import com.kidongyun.vo.PlayerVO;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Servicepublic class PlayerService &#123; @Resource private PlayerDAO playerDAO; public int insertPerson() &#123; PlayerVO playerVO = new PlayerVO(); playerVO.setName(&quot;Mark&quot;); playerVO.setAge(20); playerVO.setBirthday(&quot;19901212&quot;); playerDAO.insertPerson(playerVO); return playerVO.getNo(); &#125;&#125; PlayerController.java12345678910111213141516171819202122232425package com.kidongyun.controller;import com.kidongyun.service.PlayerService;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;@Controllerpublic class PlayerController &#123; @Resource PlayerService playerService; @RequestMapping(value = &quot;/&quot;) public String hello(Model model)&#123; int no = playerService.insertPerson(); model.addAttribute(&quot;no&quot;, no); return &quot;index&quot;; &#125;&#125; This number is the PLAYER_NO_SEQ.NEXTVAL.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://kidongyun.github.io/tags/Mybatis/"}]},{"title":"Create Custom AMI","slug":"2019-11-27-aws-create-ami","date":"2019-11-26T15:20:00.000Z","updated":"2022-05-31T07:11:32.000Z","comments":true,"path":"2019/11/27/","link":"","permalink":"http://kidongyun.github.io/2019/11/27/","excerpt":"","text":"Create Custom AMIWe can create custom ami using the instance setting information, which made before. Let’s modify as the below code and Press the ‘Create image’ button 1234567Image name : web9Image description : web9No reboot : check This image offer the information that ami is created. 1Name : web9 Enter ami menu and modify the name of ami","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Cloud","slug":"Cloud","permalink":"http://kidongyun.github.io/tags/Cloud/"},{"name":"AWS","slug":"AWS","permalink":"http://kidongyun.github.io/tags/AWS/"},{"name":"Network","slug":"Network","permalink":"http://kidongyun.github.io/tags/Network/"}]},{"title":"Configuration of AWS ALB","slug":"2019-11-26-aws-alb","date":"2019-11-25T23:47:54.000Z","updated":"2022-05-31T07:11:20.000Z","comments":true,"path":"2019/11/26/","link":"","permalink":"http://kidongyun.github.io/2019/11/26/","excerpt":"","text":"Configuration of Amazon Load Balancer Do you know the function of Load Balancer in the network? if you have just a one web server and the number of your customer is not too many, then actually You don’t need it. But your service is big enough and when you think to consider about expanding your server system because of lack of the server bandwidth. then You can select two ways for solving this maybe. Buying the new one more expensive and high spec. The important thing is this solution can’t use your previous server. that means you would spend the money a lot. Buy the new one which is same spec with before. If you use the Load Balancer for those, then you can use both. in this situration, You can use the Load Balancer and ALB(Amazon Load Balancer) is also same concept function with the above. and the main function of Load Balancer is distribution of traffic. in ALB, You can categorize the one as the criteria of data like L2, L3, L4 and L7. and You can prepare for any disorder occured in server. You can see the below screen when you press the tab named ‘Load Balancers’ located in left side menu. If you know the OSI Network Layer then you can understand about these more easiler than it’s not. The below picture have the 3 types of Load Balancer. Let’s start to study about those. Application Load Balancer : It’s same with L7 Load Balancer. It’s for the protocols like HTTP, FTP, SFTP, POP and SSH. Network Load Balancer : It’s same with L3 Load Balancer. It’s for the ip protocols. Classic Load Balancer : This Load Balancer has the all of the type of Load Balancer. Acutally it’s previous tech. Let’s start to press the ‘Applicatio Load Balancer’ for your web server. please type the text like the below and then press ‘Next: Configure Security Settings’ button. 1234567891011Name : ip99VPC : vpc-..... | ip-99Availability Zones ap-northeast-2a : subnet-..... (public-a) ap-northeast-2c : subnet-..... (public-c) Don’t do anything just press ‘Next: Configure Security Groups’ button. please modify like the below and then press ‘Next: Configure Routing’ button. 12345Assign a security group : Create a new Security groupType : HTTP type ‘ip99-tg’ to Name and then press ‘Next: Register Targets’ button 1Name : ip99-tg If you press the button named ‘Add to registed’ with clicking ‘web-a’ instance running now then Your thing is registed at the above part named ‘Registed targets’. If you finished, press the ‘Next: Review’ button. It’s the step for reviewing the setting status one more. if you don’t have any problem Let’s press the ‘Create’ button. You can see the screen what Load Balancer is created like the above. Let’s press the part of your Load Balancer ‘Description’ then you can see the DNS name information at there. If you can see the below screen when you access this url, then The installation of AWS Load Balancer is finished perfectly.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Cloud","slug":"Cloud","permalink":"http://kidongyun.github.io/tags/Cloud/"},{"name":"AWS","slug":"AWS","permalink":"http://kidongyun.github.io/tags/AWS/"},{"name":"Network","slug":"Network","permalink":"http://kidongyun.github.io/tags/Network/"}]},{"title":"Configuration of AWS EC2","slug":"2019-11-26-aws-ec2","date":"2019-11-25T23:47:54.000Z","updated":"2022-05-31T07:11:25.000Z","comments":true,"path":"2019/11/26/","link":"","permalink":"http://kidongyun.github.io/2019/11/26/","excerpt":"","text":"Configuration of EC2 instance Let’s start to configure the AWS EC2 in the subnet when you complete to configure the network. EC2EC2 means the abbreviation of ‘Elastic Compute Cloud’. We can define this using just one word. It’s a computer. but EC2 actually can change every hardware spec like Capacity of SSD, The type of CPU, The Capacity of RAM… It’s literally Cloud Computer. so It can change many hardware things more easiler than normal computer. so now We will install this EC2 at our Subnet made previous article. Let start. We can access the EC2 Dachboard site using the search function at the AWS Management Console. the above picture is the thing for searching ‘EC2’ and the the below thing is the EC2 Dashboard. You can see the screen like the above when you click the ‘Instances’ among left side menu. Let’s build the web server with creating new instance. please press ‘Launch Instance’ button. in the above screen, you can see a lot of countless AMI what can install to instance. Acutally AMI is the abbreviation of ‘Amazon Machine Image’. in the AWS system, We can’t install any programs using physical way like CD, USB because AWS is definitely Cloud Service. so AWS already occur this AMI function for installing the programs for customer convenience. We usually use AMI for installing OS like Windows Server or Linux. Let’s select the second thing called ‘Amazon Linux AMI 2018.03.0 (HVM), SSD Volume Type’ You can choose the various type of instance in one instance either. The types are different as the various hardware spec like ROM, RAM, CPU, GPU. AWS calculate the cost using these usage of therir resource please select ‘t2.micro’ and then press ‘Next: Configure Instance Details’ button. The above screen has many part should be typed but We only touch 3 things. please follow the below codes and then press ‘Next: Add Storage’ button. 1234567891011121314Network : vpc-..... | ip-99Subnet : subnet-..... | private-a | .....User Data :#!/bin/sh yum -y install httpd php chkconfig httpd on /etc/init.d/httpd start cd /var/www/html wget https://s3.ap-northeast-2.amazonaws.com/arang-trail-seoul/Source/web-php-v1.tar.gz tar -zxvf web-php-v1.tar.gz you don’t need to control anything in the above section so press ‘Next: Add Tags’ button without any change. Press ‘Add Tag’ button please type like the below and if you finished then please press ‘Next: Configure Security Group’ button 123Key : NameValue : web-a Change the type to ‘HTTP’ and then press the ‘Review and Launch’ button This is for reviewing the setting information you made until now. You don’t have any problems then press ‘Launch’ button Select ‘Proceed without a key pair’ thing and then please check the checkbox. Let’s press ‘Launch Instances’ button. If you can see the above page then you success to install instance with EC2. We can check the ‘web-a’ instance is running set by us like the above. and We can also check whether The instance is operated normally or not at the Instance Settings’s Get Instance Screenshot and System log.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Cloud","slug":"Cloud","permalink":"http://kidongyun.github.io/tags/Cloud/"},{"name":"AWS","slug":"AWS","permalink":"http://kidongyun.github.io/tags/AWS/"},{"name":"Network","slug":"Network","permalink":"http://kidongyun.github.io/tags/Network/"}]},{"title":"Configuration of Network for AWS (1/2)","slug":"2019-11-20-aws-network-1","date":"2019-11-19T23:47:54.000Z","updated":"2022-05-31T07:11:08.000Z","comments":true,"path":"2019/11/20/","link":"","permalink":"http://kidongyun.github.io/2019/11/20/","excerpt":"","text":"Configuration of AWS Network Flow Enter AWS Website and Joining at there Create VPC Create Subnet Create Internet Gateway and Attach this to VPC Create NAT Gateway Create Route Table Mapping with Subnet and Route Table 1. Access AWS Management ConsoleLet’s to sign in the below site AWS Management Console Let’s access the AWS Management Console Website via above link. If you are the first time about this, then you maybe face the login page. Let’s start to make the your account of AWS, if you don’t have it and especially You need any mastercard or visa card for joining there. If you don’t use the premium service of this, then You don’t worry about the any cost in this service, That’s apparently free during 1 years partly. But You should remember the one thing what is The AWS take just 1 dollar from us for checking whether your card information is right or not. Eventually if you can see the below picture then yes! you were success. Additionally You are able to change the language at the bottom of this Website so If you are possible, I would like to recommend to use the english version of this. because as you know, AWS is really international service so It support many languages, but sometimes the article written by another languages except English isn’t a latest version of description for AWS service. 2. Create VPCVPC is acutally the abbreviation of Virtual Private Cloud and It is the concept of the logical isolated space for the AWS customer. That is exactly similar thing with the house as you can put down everything in there if you want. Yes, You can configure any network, system, service in the VPC like the house. Only Difference is It’s logical thing. Existing Cloud Services occur baiscally these service(Network, System). That’s we can’t control about those but AWS is really different about this point. You can directly configure all of things in your VPC including Network setting. so It’ really important to configure with the secure for preventing any exposure the your resources. because All of AWS Resource are money. below figures are for creating the VPC using AWS Management Console. Please keep going with me Let’s search ‘VPC’ at The Textfield bar located in Find Services Press the ‘Your VPCs’ text at the left side menu tabs Above is the screen for showing some status of VPC setting of currently account. We can see the one VPC already configured although you are first. We will make the new one for understanding the way of creating the VPC. Let’s press the button named ‘Create VPC’ located left above part. Let’s type the name and ip of VPC you want. below if my example. If you don’t want to think about this then just follow me. 123Name tag : ip-99IPv4 CIDR block* : 10.0.0.0/16 Press the ‘Create’ button when you finished. Finally you complete creating the VPC if you see the label ‘The following VPC was created : VPC ID …’ in the green box. 3. Create SubnetAs the usage of Network is bigger, The needs of the network bandwidth expansion is appealed because of the limitation of IPv4 network capacity. Existing IP class is only divided 3 types like A, B, C. They indicate the network size exactly. but this way is too insensive, static, unflexible… so Many experts studied for solving this problem. the one solution among them is to divide more and more the IP class using the way named subnet maksing. It is the background of creating The concept of Subnet. and We usually use the subnet mask for applying subnet tech. If we use the subnet mask, then we can control the network bandwidth more sensitively than previous. Actually the IPv6 is a sure method for solving the lack of IP addresses, but It’s little difficult to migrate from current IPv4 system to there. and We can’t take any the need of IPv6 beacuse of many alternative solutions like Subnet, DHCP, NAT. Let’s press ‘Subnets’ button at the left menu. then you can see like above. You can see 3 configuration of subnet in your VPC. Let’s make new subnet for your new VPC. Press the ‘Create subnet’ 1234567Name tag : public-aVPC : vpc-0274d58ad106c5933 // This number maybe is different to each peopleAvailability Zone : ap-northeast-2aIPv4 CIDR block* : 10.0.1.0/24 For creating the subnet, Let’s type name, VPC, Availability Zonesubset(AZ), IPv4 address. in VPC, AZ case, You can see the available list when you press the textbox. if you completed, then you can see the picture like above with the label ‘The follwing Subnet was created: Subnet ID …’ in the green box. Let’s create the subnets more using above way. The belows are information of each subnet. 1234567Name tag : public-cVPC : vpc-0274d58ad106c5933 // This number maybe is different to each peopleAvailability Zone : ap-northeast-2cIPv4 CIDR block* : 10.0.2.0/24 1234567Name tag : private-aVPC : vpc-0274d58ad106c5933 // This number maybe is different to each peopleAvailability Zone : ap-northeast-2aIPv4 CIDR block* : 10.0.11.0/24 1234567Name tag : private-cVPC : vpc-0274d58ad106c5933 // This number maybe is different to each peopleAvailability Zone : ap-northeast-2cIPv4 CIDR block* : 10.0.12.0/24 If you have the 4 subnets totally like above picture, then you created the subnets successfully.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Cloud","slug":"Cloud","permalink":"http://kidongyun.github.io/tags/Cloud/"},{"name":"AWS","slug":"AWS","permalink":"http://kidongyun.github.io/tags/AWS/"},{"name":"Network","slug":"Network","permalink":"http://kidongyun.github.io/tags/Network/"}]},{"title":"Configuration of Network for AWS (2/2)","slug":"2019-11-20-aws-network-2","date":"2019-11-19T23:47:54.000Z","updated":"2022-05-31T07:11:15.000Z","comments":true,"path":"2019/11/20/","link":"","permalink":"http://kidongyun.github.io/2019/11/20/","excerpt":"","text":"Configuration of AWS Network Flow Enter AWS Website and Joining at there Create VPC Create Subnet Create Internet Gateway and Attach this to VPC Create NAT Gateway Create Route Table Mapping with Subnet and Route Table 4. Create Internet GatewayIt is the component of VPC and actually a sort of gateway to access Internet. in the real configuration of network, the router is for connecting every each isolated network. whenever some datas go to the terminal in the another network, these data should encounter the router. in this case, We can think the concept of gateway and actually Internet Gateway also is not too different with these. in this point, Let’s understand that Internet Gateway is for connecting with Internet usually used everywhere. Press the ‘Internet Gateways’ tabs at the left side menus. Let me see that, You can see the Internet Gateway already configured. We don’t want to use this. Let’s start to create new Internet Gateway using the button named ‘Create Internet gateway’. We can create the Internet Gateway with just a Name tag. 1Name tag : ip99-igw when your typing finished, Let’s press the ‘Create’ buttion for creating Internet Gateway. If you create Internet Gateway successfully, then you can see the label ‘The following internet gateway was created : Internet gateway ID …’ in the green box like the above. Let’s see the Internet gateway named ‘ip99-igw’ except existing the one been from previous. this internet gateway’s the state is detached now because It doesn’t have any VPC Connection. so We will connect this with the ‘ip-99’ VPC made by us. Press the ‘Actions’ button and click ‘Attach to VPC’. then The screen is switched something for choosing target VPC. Choose the VPC named ip-99, Press ‘Attach’ button. like the above picture, Eventually We can check that ‘ip99-igw’ Internet gateway is attached with ip-99 VPC. 5. Create NAT GatewayActually NAT is the abbreviation of ‘Network Address Translation’. It means the technic to change the ip address when the network is changed. This technic has the two mainly advantage. 1231. This technic can save the number of IPv4 address.2. This technic can enhance the secure of private network more. First case, It operate like the ip sharing device. the public ip is only allocated with the main ip sharing device, and Another user use this device with the person who friend, parent or someone had your relationship. That is many peaple don’t need to get the ip address each one. so NAT can save the number of Ipv4 address. Once again, If you can’t understand this process then just imagine the ip sharing device in your house. Second, It doesn’t matter to go out public network from private network and this case is usual. but the opposite case, If you want to access the any host been in the private network from public area, then It’s maybe not easy. because the terminal located public network can’t know the private ip address used private network. Definitely they only know the public ip address. so This technic can enhace the secure of private network either. Let’s press the ‘NAT Gatewats’ btn from left side menu. then you can see like the above. Press the ‘Create NAT Gateway’ button. configure the subnet related to public-a to Subnet part and press the ‘Create New EIP’ button. 123Subnet : public-aElastic IP Allocation ID : Press the &#x27;Create New EIP&#x27; If you finished, Press the Create a NAT Gateway button. Those are a proof what you finished creating NAT Gateway successfully. 6. Create Route TableWhen the router find the network to transfer some data to any hosts, It has any rules. this rule information is actually Route Table. In real network configuration, The router needs many setting for configuration network. Most of this setting task are definitely the things related to Route Table. more easily You can understand that the route table is like the map for the electric data. They can find the destination using this map. when the electric data want to go somewhere, this map will indicate any direction for going this place. sulely, The ways how to set this mapping information are lots of things. for example static, OSPF, and so on. but these ways are not the content for learning AWS. so I will write new article about those when i have the time enough. In here, These route table are created for the Subnets made by us. Press the ‘Route Tables’ button at the left side menu and press the ‘Create route table’ button. Let’s type like the below. 123Name tag : rt-publicVPC : ip-99 if you finished well, please make one more using the below informations. 123Name tag : rt-privateVPC : ip-99 Eventually, You should have the two route tables named ‘rt-public’ and ‘rt-private’ like the above picture. please follow the process written below 1press route table of rt-public &gt; press the Route menu below &gt; press the &#x27;Edit routes&#x27; button Press the ‘Add route’ button and follow the below process and when you finished, press the ‘save routes’ button. 12345// rt-public Destination : 0.0.0.0/0Target : igw-.... // It has the auto-recommendation. Press the ‘Add route’ button and follow the below process and when you finished, press the ‘save routes’ button. 12345// rt-privateDestination : 0.0.0.0/0Target : nat-.... // It has the auto-recommendation. 7. Subnet, Route table mappingPress the ‘Subnets’ button at the left side menu. Let’s connect the rt-public with public subnet installed internet gateway and connect rt-private with private subnet installed NAT gateway. 1Press public-a &gt; Press &#x27;Route Table&#x27; tab below &gt; Press &#x27;Edit route table association&#x27; button Please change the Route Table ID to ‘rt-public’ and then press the ‘Save’ button. Let’s connect the route table with every Subnets using same way shown above. and Don’t forget setting the ‘rt-private’ for private subnets not ‘rt-public’. Thank you for reading my articles. Every basic network setting is finished.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Cloud","slug":"Cloud","permalink":"http://kidongyun.github.io/tags/Cloud/"},{"name":"AWS","slug":"AWS","permalink":"http://kidongyun.github.io/tags/AWS/"},{"name":"Network","slug":"Network","permalink":"http://kidongyun.github.io/tags/Network/"}]},{"title":"Usage of JUnit Basic","slug":"2019-11-19-junit","date":"2019-11-18T23:47:54.000Z","updated":"2022-05-31T07:11:04.000Z","comments":true,"path":"2019/11/19/","link":"","permalink":"http://kidongyun.github.io/2019/11/19/","excerpt":"","text":"How to Use Junit1. Calculator ExampleWe need two files for testing JUnit. One is Calculator.java and the other is CalculatorTest.java Let’s start to make the package and files for that. 1234&gt; mkdir src/main/java/com/kidongyun&gt; touch src/main/java/com/kidongyun/Calculator&gt; mkdir src/test/java/com/kidongyun&gt; touch src/test/java/com/kidongyun/CalculatorTest Calculator.java 12345678910111213package com.kidongyun;public class Calculator &#123; public int add(int num1, int num2) &#123; return num1 + num2; &#125; public int sub(int num1, int num2) &#123; return num1 - num2; &#125;&#125; CaculatorTest.java 123456789101112131415161718192021222324252627package com.kidongyun;import org.junit.Before;import org.junit.Test;import static org.junit.Assert.assertEquals;public class CalculatorTest &#123; Calculator calculator; @Before public void setUp() &#123; calculator = new Calculator(); &#125; @Test public void testAdd() &#123; assertEquals(30, calculator.add(10, 20)); &#125; @Test public void testSub() &#123; assertEquals(20, calculator.sub(30, 10)); &#125;&#125; When you want to test your code like Calculator.add() or Calculator.sub(), then you can use JUnit library like CalculatorTest Code Let’s see the code of CalculatorTest.testAdd(). It’s for Calculator.add() Code. and assertEquals() function is for checking whether the code operate right or not, For example we hope to get 30 value when we use calculator.add(10, 20) If we get 30 from calculator.add() function then maybe testAdd() will return something means success. otherwise it may return fail. 2. Explanation of annotation @Test We usually use @Test annotation when we want to test some code. yes, Actually It’s really basic annotation in JUnit library. @Test(timeout=5000) for testing related to time, then you can use like this annotation. @Test(expected=….) whenever you encounter the error what can be predicted like try catch syntax then please use this annotation. @Before If you want to set some envrionment or code before testing, then you can use this annotation named @Before. You can initialize everything if you use before test code. @After Otherwise above annotation, If you need to arrange the code after testing, then you are able to use @After annotation. @BeforeClass It’s execute only once at the test class before test something. @AfterClass It’s execute only once at the test class after test something. 3. Explanation of function assertEquals(a, b) For checking whether object a‘s value and object b‘s value are same or not. ex) like “a”.equals(“b”) assertArrayEquals(a, b) For checking whether Array a and object b are same or not. assertSame(a, b) For checking whether object a and object b are same or not. ex) like “a” == “b” assertTrue(a) Is a true or not? assertNotNull(a) Is a null or not? JUnit Usage you should remember Unit tesing is not about finding bugs. (단위 테스트는 버그를 찾기 위한 것이 아니다.) Acutally Unit testing like JUnit isn’t for bugs. It’s just only for checking the functions separately. If It’s for only finding some errors, Testing all of system at a once is more effectively then unit test. Test only one code unit at a time. (하나의 테스트 케이스는 단위 기능 중 하나의 시나리오만 테스트 하라.) the most important thing when you do Unit-Test is that you have to make the test code for only one scenario. 123456789101112131415function sample(param1, param2) &#123; return result&#125;/* param1 param2 Scenario 1. normal null Scenario 2. null normal Scenario 3. null null Scenario 4. normal normal*/ Above sample function can have 4 scenarios at least. Every test codes and Scenarios should operate independently. Don’t make unnecessary assertions. (불필요한 검증 구문을 작성하지 마라.) Unit-Test isn’t to observe everything of the project code, So you don’t need to make the test code for all things. Otherwise Making a test code will be to throw away your precious time. Don’t use unit-test fore configuration environment settings. (시스템 설정 파일에 관한 단위 테스트를 작성하지 마라.) Naming of Unit-Test should be clearly and consistently. (단위 테스트 케이스의 이름은 명확하고 일관데게 테스트의 의미를 반영해야 한다.) Let’s write the independent test code about external system or service more earlier than it isn’t. (외부 시스템이나 서비스에 대한 의존성이 가장 낮은 메소드들에 대해 테스트를 먼저 작성하자.) Create Unit-Test using target exceptions if you can. (예상된 예외 사항을 테스트하는 단위 테스트 코드를 작성하라.) Put the parameters keeping the order properly. (검증 구문 파라미터들은 적합한 순서대로 배치하라.) Test code should be separated from the production. (테스트를 위한 코드는 제품 코드에서 분리되어야 한다.) Don’t print out anything in the Unit-Test code. (테스트 코드 내에서 아무것도 출력하지 마라.) Don’t use static members for the test class. If you used then re-initialize for each test. (정적 변수를 테스트 클래스에 사용하지 마라. 만약 사용했다면 각 테스트 케이스 실행시마다 재 초기화해라.)","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Test","slug":"Test","permalink":"http://kidongyun.github.io/tags/Test/"}]},{"title":"Let's set the environment of Spring + Mybatis + Oracle in Intellij","slug":"2019-11-18-spring-mybatis-oracle","date":"2019-11-17T23:47:54.000Z","updated":"2022-05-31T07:10:58.000Z","comments":true,"path":"2019/11/18/","link":"","permalink":"http://kidongyun.github.io/2019/11/18/","excerpt":"","text":"1. Create Project.1File &gt; New &gt; Project Please select Gradle Category and then You can see many various libraries for this. then Let’s start to add 2 options named Java , Web like below. If you completed then please click Next button. You can type any sentences or words for GroupId, ArtifactId If you want. But If you do, maybe you will confuse because of the java package, so I recommand to follow like my styles. 12GroupId : com.kidongyunArtifactId : SpringMybatisOracle If you completed, Let’s press Next button. Project Name is maybe same with the ArtifactId, It’s not considerable to change the name. so If you want, You can change the name. But If you are a novice about the Spring Framework, then Let’s follow me for preventing any errors. 1Project name : SpringMybatisOracle Press Finish button. then you can see below pictures. that is the final screen enable seen if you success above process perfectly. 2. Configure the build.gradle12345678910111213141516171819202122232425262728293031plugins &#123; id &#x27;java&#x27; id &#x27;war&#x27;&#125;apply plugin: &#x27;war&#x27;group &#x27;com.kidongyun&#x27;version &#x27;1.0-SNAPSHOT&#x27;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.11&#x27; testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.12&#x27; providedCompile group: &#x27;javax.servlet&#x27;, name: &#x27;javax.servlet-api&#x27;, version: &#x27;3.1.0&#x27; runtime &#x27;javax.servlet:jstl:1.1.2&#x27; compile group: &#x27;javax.annotation&#x27;, name: &#x27;javax.annotation-api&#x27;, version: &#x27;1.3.2&#x27; compile &#x27;org.springframework:spring-webmvc:4.3.18.RELEASE&#x27; compile group: &#x27;org.springframework&#x27;, name: &#x27;spring-jdbc&#x27;, version: &#x27;3.1.0.RELEASE&#x27; compile group: &#x27;org.mybatis&#x27;, name: &#x27;mybatis-spring&#x27;, version: &#x27;1.1.0&#x27; compile group: &#x27;commons-dbcp&#x27;, name: &#x27;commons-dbcp&#x27;, version: &#x27;1.4&#x27;&#125; Please copy &amp; paste the above code to your project. Actually mavenCentral() is default repository offered by Maven. But there can’t serve OJDBC library directly cause Copyright of Oracle. So We should include the code maven() { url …} to use ojdbc 1compile group: &#x27;javax.annotation&#x27;, name: &#x27;javax.annotation-api&#x27;, version: &#x27;1.3.2&#x27; if you want to use @Resource annotation, Let’s add the above dependency. 12compile &#x27;org.springframework:spring-webmvc:4.3.18.RELEASE&#x27;compile group: &#x27;org.springframework&#x27;, name: &#x27;spring-jdbc&#x27;, version: &#x27;3.1.0.RELEASE&#x27; Those are the things for applying basic functions of Spring Framework 1compile group: &#x27;com.oracle&#x27;, name: &#x27;ojdbc6&#x27;, version: &#x27;12.1.0.1-atlassian-hosted&#x27; If you don’t add the new repository, then your project maybe will have errors what can’t get ojdbc6 library at above code. 1compile group: &#x27;commons-dbcp&#x27;, name: &#x27;commons-dbcp&#x27;, version: &#x27;1.4&#x27; For Connection Pool. Your DB System is better than not when use this. 3. Import the local ‘ojdbc6.jar’ fileLet’s download ojdbc6.jar You have to read this thing not the above. the repository for ‘OJDBC’ is not working after yesterday. for solving this problem, We will import the ‘OJDBC’ library locally. that is we will download the ‘.jar’ file related to ‘OJDBC’ and import that thing like the below Create new folder named ‘lib’ for the local jar file ‘OJDBC’. 123workspace/src/main/webapp/WEB-INF&gt; mkdir lib and then Let’s copy and paste your local file. Press Ctrl + Shift + Alt + S to open the Project Structure window and src1Ctrl + Shift + Alt + S -&gt; Libraries Tab -&gt; &#x27;+&#x27; Button -&gt; Java &gt; Select your file &gt; Apply 4. Delete index.jsp files for new one1&gt; rm src/main/webapp/index.jsp 5. Make the Directories and Files.12345678910111213141516171819202122&gt; mkdir src/main/webapp/WEB-INF&gt; touch src/main/webapp/WEB-INF/web.xml&gt; touch src/main/webapp/WEB-INF/dispatcher-servlet.xml&gt; touch src/main/webapp/WEB-INF/applicationContext.xml&gt; mkdir src/main/webapp/WEB-INF/view&gt; touch src/main/webapp/WEB-INF/view/index.jsp&gt; touch src/main/resources/mybatis-config.xml&gt; mkdir src/main/resources/mappers&gt; touch src/main/resources/mappers/personMappers.xml &gt; mkdir src/main/java/com/kidongyun&gt; mkdir src/main/java/com/kidongyun/vo/&gt; touch src/main/java/com/kidongyun/vo/PersonVO.java&gt; mkdir src/main/java/com/kidongyun/dao&gt; touch src/main/java/com/kidongyun/dao/PersonDAO.java /* Interface */&gt; mkdir src/main/java/com/kidongyun/service&gt; touch src/main/java/com/kidongyun/service/PersonService.java&gt; mkdir src/main/java/com/kidongyun/controller&gt; touch src/main/java/com/kidongyun/controller/PersonController.java PersonDAO.java is java interface file. so Don’t make this as just class type file 6. Setiing for each files.src/main/webapp/WEB-INF/web.xml12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; src/main/webapp/WEB-INF/dispatcher-servlet.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;mvc:annotation-driven /&gt; &lt;context:component-scan base-package=&quot;com.kidongyun&quot; /&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; src/main/webapp/WEB-INF/applicationContext.xml12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot; id=&quot;dataSource&quot;&gt; &lt;property value=&quot;oracle.jdbc.driver.OracleDriver&quot; name=&quot;driverClassName&quot; /&gt; &lt;property value=&quot;jdbc:oracle:thin:@localhost:1521:XE&quot; name=&quot;url&quot; /&gt; &lt;property value=&quot;c##scott&quot; name=&quot;username&quot; /&gt; &lt;property value=&quot;tiger&quot; name=&quot;password&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mappers/**/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.kidongyun&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; src/main/webapp/WEB-INF/view/index.jsp123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;data&#125;&lt;/body&gt;&lt;/html&gt; src/main/resources/mybatis-config.xml1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0/EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;/configuration&gt; src/main/resources/mappers/personMappers.xml12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kidongyun.dao.PersonDAO&quot;&gt; &lt;select id=&quot;selectPerson&quot; resultType=&quot;com.kidongyun.vo.PersonVO&quot;&gt; SELECT * FROM PERSON &lt;/select&gt;&lt;/mapper&gt; src/main/java/com/kidongyun/vo/PersonVO.java1234567891011121314151617package com.kidongyun.vo;public class PersonVO &#123; String name; int age; String birthday; // ALT + INSERT -&gt; GENERATE toString() @Override public String toString() &#123; return &quot;PersonVO&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, birthday=&#x27;&quot; + birthday + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; src/main/java/com/kidongyun/dao/PersonDAO.java1234567891011package com.kidongyun.dao;import com.kidongyun.vo.PersonVO;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface PersonDAO &#123; public List&lt;PersonVO&gt; selectPerson();&#125; src/main/java/com/kidongyun/service/PersonService.java12345678910111213141516171819package com.kidongyun.service;import com.kidongyun.dao.PersonDAO;import com.kidongyun.vo.PersonVO;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;@Servicepublic class PersonService &#123; @Resource private PersonDAO personDAO; public List&lt;PersonVO&gt; selectPerson() &#123; return personDAO.selectPerson(); &#125;&#125; src/main/java/com/kidongyun/controller/PersonController.java12345678910111213141516171819202122232425package com.kidongyun.controller;import com.kidongyun.service.PersonService;import com.kidongyun.vo.PersonVO;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;import java.util.List;@Controllerpublic class PersonController &#123; @Resource PersonService personService; @RequestMapping(value = &quot;/&quot;) public String hello(Model model)&#123; List&lt;PersonVO&gt; data = personService.selectPerson(); model.addAttribute(&quot;data&quot;, data.toString()); return &quot;index&quot;; &#125;&#125; 7. Make the Person Table using Oracle DB12345CREATE TABLE PERSON ( NAME VARCHAR2(10), AGE NUMBER(3), BIRTHDAY DATE) It’s for making the new PERSON Table at Oracle. 1INSERT INTO PERSON VALUES (&#x27;martin&#x27;, 18, SYSDATE); and this query for putting the dummy datas.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://kidongyun.github.io/tags/Mybatis/"}]},{"title":"Spring controller data types","slug":"2019-11-04-spring-controller-data-types","date":"2019-11-03T23:47:54.000Z","updated":"2022-05-31T07:10:51.000Z","comments":true,"path":"2019/11/04/","link":"","permalink":"http://kidongyun.github.io/2019/11/04/","excerpt":"","text":"HttpServletRequest1234567891011121314151617function httpServletRequestSample() &#123; let data = &#123; &quot;name&quot; : &quot;kidongyun&quot;, &quot;age&quot; : 26 &#125; $.ajax(&#123; url:&#x27;/httpServletRequestSample&#x27;, type:&#x27;get&#x27;, data: data, success:function()&#123; &#125; &#125;)&#125; 12345678910@RequestMapping(value = &quot;/httpServletRequestSample&quot;)public void httpServletRequestSample(HttpServletRequest request)&#123; String name = request.getParameter(&quot;name&quot;); String age = request.getParameter(&quot;age&quot;); System.out.println(&quot;HttpServletRequest(Object -&gt; Primitive) : &quot; + name + &quot;, &quot; + age);&#125; @RequestParam1234567891011121314151617function requestParamSample() &#123; let data = &#123; &quot;name&quot; : &quot;kidongyun&quot;, &quot;age&quot; : 26 &#125; $.ajax(&#123; url:&#x27;/requestParamSample&#x27;, type:&#x27;get&#x27;, data: data, success:function()&#123; &#125; &#125;)&#125; 123456@RequestMapping(value = &quot;/requestParamSample&quot;)public void requestParamSample(@RequestParam String name, @RequestParam int age) &#123; System.out.println(&quot;RequestParam(Object -&gt; Primitive) : &quot; + name + &quot;, &quot; + age);&#125; @RequestBody Map123456789101112131415161718function requestBodyMapTypeSample() &#123; let data = &#123; &quot;name&quot; : &quot;kidongyun&quot;, &quot;age&quot; : 26 &#125; $.ajax(&#123; url:&#x27;/requestBodyMapTypeSample&#x27;, type:&#x27;post&#x27;, contentType: &#x27;application/json&#x27;, data: JSON.stringify(data), success:function()&#123; &#125; &#125;)&#125; 123456@RequestMapping(value = &quot;/requestBodyMapTypeSample&quot;)public void requestBodyMapTypeSample(@RequestBody Map&lt;String, Object&gt; param) &#123; System.out.println(&quot;RequestBody(Json -&gt; Map) : &quot; + param.get(&quot;name&quot;) + &quot;, &quot; + param.get(&quot;age&quot;));&#125; @RequestBody VO123456789101112131415161718function requestBodyVOTypeSample() &#123; let data = &#123; &quot;name&quot; : &quot;kidongyun&quot;, &quot;age&quot; : 26 &#125; $.ajax(&#123; url:&#x27;/requestBodyVOTypeSample&#x27;, type:&#x27;post&#x27;, contentType: &#x27;application/json&#x27;, data: JSON.stringify(data), success:function()&#123; &#125; &#125;)&#125; 123456@RequestMapping(value = &quot;/requestBodyVOTypeSample&quot;)public void requestBodyVOTypeSample(@RequestBody Human human) &#123; System.out.println(&quot;RequestBody(Json -&gt; VO) : &quot; + human.getName() + &quot;, &quot; + human.getAge());&#125; ModelAndView123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ModelAndViewSamplePage&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;name&#125; $&#123;age&#125;&lt;/body&gt;&lt;/html&gt; 123456789101112@RequestMapping(value = &quot;/modelAndViewSample&quot;)public ModelAndView modelAndViewSample() &#123; ModelAndView view = new ModelAndView(); view.addObject(&quot;name&quot;, &quot;kidongyun&quot;); view.addObject(&quot;age&quot;, 26); view.setViewName(&quot;/modelAndViewSamplePage&quot;); return view;&#125; ViewResolver1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ViewResolverSample&lt;/title&gt;&lt;/head&gt;&lt;body&gt; ViewResolverSample&lt;/body&gt;&lt;/html&gt; 123456@RequestMapping(value = &quot;/viewResolverSample&quot;)public String viewResolverSample() &#123; return &quot;viewResolverSample&quot;;&#125; HttpServletResponse123456789101112131415@RequestMapping(value = &quot;/httpServletResponseSample&quot;)public void httpServletResponseSample(HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=UTF-8&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&lt;title&gt;httpServletResponseSample&lt;/title&gt;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;name : kidongyun&quot;); out.println(&quot;age : 26&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;);&#125; @ResponseBody1234567891011function responseBodyStringTypeSample() &#123; $.ajax(&#123; url:&#x27;/responseBodyStringTypeSample&#x27;, type:&#x27;get&#x27;, success:function(data)&#123; console.log(data); &#125; &#125;)&#125; 1234567@ResponseBody@RequestMapping(value = &quot;/responseBodyStringTypeSample&quot;)public String responseBodyStringTypeSample() &#123; return &quot;It&#x27;s plain String Type&quot;;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"Controller","slug":"Controller","permalink":"http://kidongyun.github.io/tags/Controller/"}]},{"title":"The basic concept of IoC","slug":"2019-10-30-ioc","date":"2019-10-29T23:47:54.000Z","updated":"2022-05-31T07:10:45.000Z","comments":true,"path":"2019/10/30/","link":"","permalink":"http://kidongyun.github.io/2019/10/30/","excerpt":"","text":"IoC (Inversion of Control)Tradionally The java grammer usually use the ‘new’ keyword when you want to make the new object something. but It’s really different in The Spring Framework. If you want to create new instance then The Spring Framework always recommands to use the Spring Container or IoC. (Actually they are same thing.) and This coding style named as ‘IoC’. It means Inversion of Control. Actually It includes many meaningful concepts but the most important thinking is that we don’t need to make the new instance at the inner code anymore. So It’s Inversion of Control. POJO (Plain Old Java Object)Do you know the correct definition of POJO Class? actually I don’t know either. but I can understand just little bit about this. It’s the really pure java code style without any annotation or somthing make more complexible. The below is simple example for understaing. 12345678910111213141516171819202122class Hello &#123; String name; Printer printer; public String sayHello() &#123; return &quot;Hello &quot; + name; &#125; public void print() &#123; this.printer.print(sayHello()); &#125; public void setName(String name) &#123; this.name = name; &#125; public void setPringter(Printer printer) &#123; this.printer = printer; &#125;&#125; BeanDefinitionMany Spring Project existed over the world usually use the ‘xml’ file for setiing the meta information for Spring Container. So We can make some misconception of SpringFramework. It’s ‘Spring Container Setiing Information must be made by xml files’ but It’s not true. Spring Framework has the BeanDefinition Interface. Fundamentally any type of files for setting the Information of Spring Container can be converted to this interface using BeanDefinitionReader Interface. and Actually The type of Spring Container setting information is always BeanDefinition. 12Meta Resource file(.xml) &gt; BeanDefinitionReader &gt; BeanDefinition Example of IoC for Understanding12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.beans.factory.support.RootBeanDefinition;import org.springframework.context.support.StaticApplicationContext;import static org.hamcrest.CoreMatchers.is;import static org.hamcrest.CoreMatchers.not;import static org.hamcrest.core.IsNull.notNullValue;import static org.junit.Assert.*;public class Main &#123; public static void main(String[] args) &#123; StaticApplicationContext ac = new StaticApplicationContext(); // create Spring Container ac.registerSingleton(&quot;hello1&quot;, Hello.class); // register the Hello POJO Class in Spring Container as the method of Singleton // create the bean using the setting information offered StaticApplicationContext basically without BeanDefinition Hello hello1 = ac.getBean(&quot;hello1&quot;, Hello.class); // get the Hello instance using the Spring Container assertThat(hello1, is(notNullValue())); // It like one of the unit test, It is for checking whether the hello1 object is taken an instance from Spring Container or not BeanDefinition helloDef = new RootBeanDefinition(Hello.class); // proclaim the BeanDefinition for controlling the setting information of IoC Container directly helloDef.getPropertyValues().addPropertyValue(&quot;name&quot;, &quot;Spring&quot;); // add the attributes ac.registerBeanDefinition(&quot;hello2&quot;, helloDef); // create the object using the BeanDefinition meta information and StaticApplicationContext BeanDefinition Hello hello2 = ac.getBean(&quot;hello2&quot;, Hello.class); assertThat(hello2.sayHello(), is(&quot;Hello Spring&quot;)); assertThat(hello1, is(not(hello2))); assertThat(ac.getBeanFactory().getBeanDefinitionCount(), is(2)); &#125;&#125;class Hello &#123; String name; Printer printer; public String sayHello() &#123; return &quot;Hello &quot; + name; &#125; public void print() &#123; this.printer.print(sayHello()); &#125; public void setName(String name) &#123; this.name = name; &#125; public void setPringter(Printer printer) &#123; this.printer = printer; &#125;&#125;interface Printer &#123; void print(String message);&#125;class StringPrinter implements Printer &#123; private StringBuffer buffer = new StringBuffer(); public void print(String message) &#123; this.buffer.append(message); &#125; public String toString() &#123; return this.buffer.toString(); &#125;&#125;class ConsolePrinter implements Printer &#123; public void print(String message) &#123; System.out.println(message); &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"DI","slug":"DI","permalink":"http://kidongyun.github.io/tags/DI/"}]},{"title":"Building Spring MVC via Intellij IDEA","slug":"2019-10-24-build-spring-mvc","date":"2019-10-23T23:47:54.000Z","updated":"2022-05-31T07:10:41.000Z","comments":true,"path":"2019/10/24/","link":"","permalink":"http://kidongyun.github.io/2019/10/24/","excerpt":"","text":"This article is the Summary of building Spring MVC Project via Intellij IDEA IDE. 1. To make the new projectplease click like below process. 1File &gt; New &gt; Project then You can see the new window for building the project like below. Select below Two Options Java Web If you finished, please press the next button located bottom of the window input the contents 12345678GroupId - com.kidongyunArtifactId - SpringMVCVersion - 1.0-SNAPSHOT// keep the default value. If you finished, please press the next button input the contents 12345Project name - SpringMVCProject location - random please press the finish button then you can see the process of building the new project. Below is the file structure of your new project. 2. To modify build.gradle fileLet’s copy the below code to your build.gradle file in project. 12345678910111213141516171819202122232425plugins &#123; id &#x27;java&#x27; id &#x27;war&#x27;&#125;apply plugin: &#x27;war&#x27;group &#x27;com.kidongyun&#x27;version &#x27;1.0-SNAPSHOT&#x27;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.11&#x27; testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.12&#x27; providedCompile group: &#x27;javax.servlet&#x27;, name: &#x27;javax.servlet-api&#x27;, version: &#x27;3.1.0&#x27; compile &#x27;org.springframework:spring-webmvc:4.3.18.RELEASE&#x27; runtime &#x27;javax.servlet:jstl:1.1.2&#x27;&#125; 3. To delete root/src/main/webapp/index.jsp fileYou have to delete root/src/main/webapp/index.jsp file like below picture. 4. To make the new directories and filesLet’s make new directories and files 123456789101112mkdir root/src/main/webapp/WEB-INFtouch root/src/main/webapp/WEB-INF/web.xmltouch root/src/main/webapp/WEB-INF/dispatcher-servlet.xmltouch root/src/main/webapp/WEB-INF/applicationContext.xmlmkdir root/src/main/java/com/kidongyun/controller/touch root/src/main/java/com/kidongyun/controller/HomeController.javamkdir root/src/main/webapp/WEB-INF/viewtouch root/src/main/webapp/WEB-INF/view/index.jsp 5. to fullfill the below codes at proper files.web.xml 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; dispatcher-servlet.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;mvc:annotation-driven /&gt; &lt;context:component-scan base-package=&quot;com.kidongyun.controller&quot; /&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; applicationContext.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; HomeController.java 12345678910111213141516package com.kidongyun.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HomeController &#123; @RequestMapping(value = &quot;/&quot;) public String hello(Model model)&#123; model.addAttribute(&quot;msg&quot;, &quot;Hello World!&quot;); return &quot;index&quot;; &#125;&#125; index.jsp 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello&lt;/title&gt; &lt;/head&gt; &lt;body&gt; $&#123;msg&#125; &lt;/body&gt;&lt;/html&gt; 6. To set the Tomcat123Run &gt; Edit Configurations Let’s open ‘Edit configurations’ window. To add new Tomcat Server To select the Tomcat server at Application server part and To press the fix button located bottom of window. and then finally, Let’s add the artifact for making war file and building. 7. Annotation EnableLet’s get in those tabs. 123File &gt; Settings &gt; Build, Execution, Deployment &gt; Compiler &gt; Annotation Processors then you can see below window. Let’s check the Enable annotation processing for annotation syntax. 8. Tomcat RunningLet’s run your new project, then you can see this browser content","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"}]},{"title":"Let's build React with Spring boot Server ver.1","slug":"2019-10-12-build-react-springboot-first","date":"2019-10-11T17:58:54.000Z","updated":"2022-05-31T07:10:28.000Z","comments":true,"path":"2019/10/12/","link":"","permalink":"http://kidongyun.github.io/2019/10/12/","excerpt":"","text":"1. Spring Boot를 활용한 Spring Framework 개발환경 구축 Visual Studio Code 플러그인 확장.Ctrl + Shift + x 를 눌러 Marketplace를 열고 아래 두 항목을 찾아 Install한다. 123451. Java Extension Pack2. Spring Boot Extension Pack java.home 경로 설정상단 메뉴에서 File &gt; Preferences &gt; Settings 으로 들어간 후 jdk를 검색하고 ‘Edit in settings.json’ 눌러 settings.json 파일 안에 java.home 값을 추가한다. Spring-boot project 생성Ctrl + Shift + p 를 눌러 나타난 상단 바에 Spring Initalizr: Generate Maven Project Spring 을 선택한다. Java를 선택하고 원하는 Group Id와 Artifact Id를 작성한다. 예를 들어 Group Id가 com.example 이고 Artifact Id가 helloworld 이라면 패키지는 com.example.helloworld 가 된다. Spring boot 버전은 최신 버전을 선택한다 의존성은 아래 두가지 항목을 추가한다. 123451. (Spring Boot) DevTools2. (Spring) Web 파일탐색기가 열리면 프로젝트 생성을 원하는 폴더를 선택한다. 성공적으로 프로젝트 생성이 완료되었다면 Open을 클릭해 프로젝트를 열자. JSP, JSTL을 위한 의존성 추가pom.xml을 열어 아래 두 의존성을 추가하기 위한 코드를 작성한다. 1234567&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 1234567&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; application.yml 파일 추가Spring-boot에서 프로젝트 설정은 annotation이나 application.properties 파일에서 처리된다. application.properties 파일은 보기에 불편한 감이 있어 이를 삭제하고 application.yml 파일로 대체한다. src/main/resources/ 디렉토리에 있는 application.properties 파일을 제거하고 application.yml 파일을 생성한다. 아래의 코드를 application.yml 파일 안에 작성한다. 12345678910111213spring: http: encoding: charset: UTF-8 mvc: view: prefix: /jsp/ suffix: .jspserver: tomcat: uri-encoding: UTF-8 Spring Server 테스트 실행Ctrl + Shift + ` 또는 상단 메뉴에서 터미널을 클릭해 터미널을 띄운 후 프로젝트 루트 디렉토리에서 mvnm spring-boot:run 명령어를 실행하여 서버가 잘 실행되는지 확인한다. 실행이 잘 된다면 위와 같은 화면에서 터미널이 request를 listening하는 상태가 된다. 여기까지 한다면 Spring-boot를 활용한 Spring Framework 서버를 구현을 완료한 것이다. 2. React 개발환경 구축package.json 파일 생성새로운 터미널을 하나 더 열고 프로젝트 루트 디렉토리에서 npm init 명령어를 활용해 새로운 노드 프로젝트를 만든다. (모든 질문에 엔터만 눌러도 무방하며, 이 행위의 결과로 단순히 package.json 파일만 생성된다.) React 의존 라이브러리 설치.React 개발환경 구성을 위해 react, react-dom, @babel/core, @babel/preset-env, @babel/preset-react, babel-loader, css-loader, style-loader, webpack, webpack-cli 의존 라이브러리를 설치한다. 12345&gt; npm i react react-dom&gt; npm i @babel/core @babel/preset-env @babel/preset-react babel-loader css-loader style-loader webpack webpack-cli -D 설치가 잘 진행 되었다면 package.json 파일에 dependencies 항목과 devDependencies 항목에 설치한 라이브러리 이름들이 잘 추가되었을 것이다. webpack 설정webpack 설정을 추가하기 위해 프로젝트의 루트 디렉토리에 webpack.config.js 파일을 생성하고 아래의 코드를 작성한다. 123456789101112131415161718192021222324252627282930313233var path = require(&#x27;path&#x27;); module.exports = &#123; context: path.resolve(__dirname, &#x27;src/main/jsx&#x27;), entry: &#123; main: &#x27;./MainPage.jsx&#x27;, page1: &#x27;./Page1Page.jsx&#x27; &#125;, devtool: &#x27;sourcemaps&#x27;, cache: true, output: &#123; path: __dirname, filename: &#x27;./src/main/webapp/js/react/[name].bundle.js&#x27; &#125;, mode: &#x27;none&#x27;, module: &#123; rules: [ &#123; test: /\\.jsx?$/, exclude: /(node_modules)/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; presets: [ &#x27;@babel/preset-env&#x27;, &#x27;@babel/preset-react&#x27; ] &#125; &#125; &#125;, &#123; test: /\\.css$/, use: [ &#x27;style-loader&#x27;, &#x27;css-loader&#x27; ] &#125; ] &#125;&#125;; 3. Server Side Skeleton 코드 작성MyController.javaReact, Spring을 활용한 개발 환경은 구성되었다. 기본적으로 필요한 코드들을 작성해보자. 우선은 클라이언트 쪽에서 요청이 들어왔을 때 서버쪽에서 최우선적으로 처리해주는 Controller 자바코드를 작성하자. src/main 안쪽 프로젝트의 패키지 경로에 MyController.java 클래스 파일을 생성하고 아래의 코드를 작성한다. 12345678910111213141516171819package com.example.helloworld;// package 경로는 본인의 프로젝트에 맞추어서 변경한다.import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable; @Controllerpublic class MyController &#123; @GetMapping(&quot;/&#123;name&#125;.html&quot;) public String page(@PathVariable String name, Model model) &#123; model.addAttribute(&quot;pageName&quot;, name); return &quot;page&quot;; &#125; &#125; page.jspsrc/main/webapp/jsp 경로에 page.jsp 파일을 만들고 아래의 코드를 작성한다. (해당 디렉토리가 없다면 생성한다.) 1234567891011121314&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;%&gt;&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$&#123;pageName&#125;&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/js/react/$&#123;pageName&#125;.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; custom.csscss-loader가 잘 동작하는지 확인하기 위해 src/main/webapp/css/custom.css 파일을 만든다. 그리고 아래와 같이 코드를 작성한다 (해당 디렉토리가 없다면 생성한다.) 1234.main &#123; font-size: 24px; border-bottom: solid 1px black; &#125;.page1 &#123; font-size: 14px; background-color: yellow; &#125; 4. Client Side Skeleton 코드 작성MainPage.jsxReact 구성으로 Main 페이지에 해당하는 코드를 작성하자. src/main/jsx 폴더 아래에 MainPage.jsx 파일을 생성하고 아래의 코드를 작성한다. 12345678910111213141516import &#x27;../webapp/css/custom.css&#x27;; import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;; class MainPage extends React.Component &#123; render() &#123; return &lt;div className=&quot;main&quot;&gt;메인 페이지&lt;/div&gt;; &#125; &#125; ReactDOM.render(&lt;MainPage/&gt;, document.getElementById(&#x27;root&#x27;)); Page1Page.jsxsrc/main/jsx 폴더 아래에 Page1Page.jsx 파일을 생성하고 아래의 코드를 작성한다. 12345678910111213141516import &#x27;../webapp/css/custom.css&#x27;; import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;; class Page1Page extends React.Component &#123; render() &#123; return &lt;div className=&quot;page1&quot;&gt;Page1 페이지&lt;/div&gt;; &#125; &#125; ReactDOM.render(&lt;Page1Page/&gt;, document.getElementById(&#x27;root&#x27;)); 클라이언트 스크립트 빌드React는 리소스 파일들을 바로 사용하지 않고 webpack을 활용하여 빌드한 후에 그 bundle 파일을 활용한다. 위에서 만든 jsx 파일을 빌드하기 위해 터미널에서 루트 디렉토리로 이동하고 아래의 명령어를 작성한다. watch 명령어는 JSX 파일 수정시에 자동적으로 지속 빌드할 수 있도록 도와준다. 1&gt; node_modules/.bin/webpack --watch -d package.json 파일 script 수정자주 사용하는 복잡한 명령어는 package.json 파일에서 script 옵션을 통해 간단하게 줄일 수 있다. script 옵션에 아래와 같이 추가한다. start에 들어가는 JAVA_HOME 옵션은 위에서 settings.json 파일에 추가한 java.home 경로와 같다. 본인의 환경에 맞도록 경로를 수정하자. 1234567&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;set JAVA_HOME=C:\\\\Program Files\\\\Java\\\\jdk-12.0.2&amp;&amp;mvnw spring-boot:run&quot;, &quot;watch&quot;: &quot;node_modules\\\\.bin\\\\webpack --watch -d&quot;&#125; 5. 최종 빌드1&gt; npm run watch 루트 디렉토리에서 위와 같은 명령어를 작성하게 되면 webpack을 통해 bundle.js 파일을 만들게 된다. watch 옵션을 켜두었음으로 해당 명령어는 종료되지 않고 jsx 파일이 수정되면 자동적으로 새롭게 빌드된다. 1&gt; npm run start 위 명령어를 통해 Spring 서버가 실행되었다. 아래의 두 링크를 통해 만들어 놓은 Skeleton 코드들이 잘 동작하는지 확인하자. MainPage.jsx Page1Page.jsx","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"React","slug":"React","permalink":"http://kidongyun.github.io/tags/React/"},{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"}]},{"title":"Let's build React with Spring boot Server ver.2","slug":"2019-10-12-build-react-springboot-second","date":"2019-10-11T17:58:54.000Z","updated":"2022-05-31T07:10:34.000Z","comments":true,"path":"2019/10/12/","link":"","permalink":"http://kidongyun.github.io/2019/10/12/","excerpt":"","text":"1. Spring Boot를 활용한 Spring Framework 개발환경 구축 Visual Studio Code 플러그인 확장.Ctrl + Shift + x 를 눌러 Marketplace를 열고 아래 두 항목을 찾아 Install한다. 123451. Java Extension Pack2. Spring Boot Extension Pack java.home 경로 설정상단 메뉴에서 File &gt; Preferences &gt; Settings 으로 들어간 후 jdk를 검색하고 ‘Edit in settings.json’ 눌러 settings.json 파일 안에 java.home 값을 추가한다. Spring-boot project 생성Ctrl + Shift + p 를 눌러 나타난 상단 바에 Spring Initalizr: Generate Maven Project Spring 을 선택한다. Java를 선택하고 원하는 Group Id와 Artifact Id를 작성한다. 예를 들어 Group Id가 com.example 이고 Artifact Id가 helloworld 이라면 패키지는 com.example.helloworld 가 된다. Spring boot 버전은 최신 버전을 선택한다 의존성은 아래 두가지 항목을 추가한다. 123451. (Spring Boot) DevTools2. (Spring) Web 파일탐색기가 열리면 프로젝트 생성을 원하는 폴더를 선택한다. 성공적으로 프로젝트 생성이 완료되었다면 Open을 클릭해 프로젝트를 열자. JSP, JSTL을 위한 의존성 추가pom.xml을 열어 아래 두 의존성을 추가하기 위한 코드를 작성한다. 1234567&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 1234567&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; application.yml 파일 추가Spring-boot에서 프로젝트 설정은 annotation이나 application.properties 파일에서 처리된다. application.properties 파일은 보기에 불편한 감이 있어 이를 삭제하고 application.yml 파일로 대체한다. src/main/resources/ 디렉토리에 있는 application.properties 파일을 제거하고 application.yml 파일을 생성한다. 아래의 코드를 application.yml 파일 안에 작성한다. 12345678910111213spring: http: encoding: charset: UTF-8 mvc: view: prefix: /public/ suffix: .htmlserver: tomcat: uri-encoding: UTF-8 Spring Server 테스트 실행Ctrl + Shift + ` 또는 상단 메뉴에서 터미널을 클릭해 터미널을 띄운 후 프로젝트 루트 디렉토리에서 mvnm spring-boot:run 명령어를 실행하여 서버가 잘 실행되는지 확인한다. 실행이 잘 된다면 위와 같은 화면에서 터미널이 request를 listening하는 상태가 된다. 여기까지 한다면 Spring-boot를 활용한 Spring Framework 서버를 구현을 완료한 것이다. 2. React 개발환경 구축package.json 파일 생성새로운 터미널을 하나 더 열고 프로젝트 루트 디렉토리에서 npm init 명령어를 활용해 새로운 노드 프로젝트를 만든다. (모든 질문에 엔터만 눌러도 무방하며, 이 행위의 결과로 단순히 package.json 파일만 생성된다.) React 의존 라이브러리 설치.React 개발환경 구성을 위해 react, react-dom, @babel/core, @babel/preset-env, @babel/preset-react, babel-loader, css-loader, style-loader, webpack, webpack-cli 의존 라이브러리를 설치한다. 12345&gt; npm i react react-dom&gt; npm i @babel/core @babel/preset-env @babel/preset-react babel-loader css-loader style-loader webpack webpack-cli -D 설치가 잘 진행 되었다면 package.json 파일에 dependencies 항목과 devDependencies 항목에 설치한 라이브러리 이름들이 잘 추가되었을 것이다. webpack 설정webpack 설정을 추가하기 위해 프로젝트의 루트 디렉토리에 webpack.config.js 파일을 생성하고 아래의 코드를 작성한다. 123456789101112131415161718192021222324252627282930var path = require(&#x27;path&#x27;); module.exports = &#123; context: path.resolve(__dirname, &#x27;src/main/webapp/jsx&#x27;), entry: &#123; first: &#x27;./first/index.jsx&#x27;, second: &#x27;./second/index.jsx&#x27; &#125;, output: &#123; path: __dirname, filename: &#x27;./src/main/webapp/build/[name].bundle.js&#x27; &#125;, module: &#123; rules: [ &#123; test: /\\.jsx?$/, exclude: /(node_modules)/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; presets: [ &#x27;@babel/preset-env&#x27;, &#x27;@babel/preset-react&#x27; ] &#125; &#125; &#125;, &#123; test: /\\.css$/, use: [ &#x27;style-loader&#x27;, &#x27;css-loader&#x27; ] &#125; ] &#125;&#125;; 3. Server Side Skeleton 코드 작성MyController.javaReact, Spring을 활용한 개발 환경은 구성되었다. 기본적으로 필요한 코드들을 작성해보자. 우선은 클라이언트 쪽에서 요청이 들어왔을 때 서버쪽에서 최우선적으로 처리해주는 Controller 자바코드를 작성하자. src/main 안쪽 프로젝트의 패키지 경로에 MyController.java 클래스 파일을 생성하고 아래의 코드를 작성한다. 12345678910111213141516package com.example.helloworld;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable; @Controllerpublic class MyController &#123; @GetMapping(&quot;/&#123;name&#125;.html&quot;) public String page(@PathVariable String name, Model model) &#123; return name; &#125;&#125; first.htmlsrc/main/webapp/public 경로에 first.html 파일을 만들고 아래의 코드를 작성한다. (해당 디렉토리가 없다면 생성한다.) 12345678910111213&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;FIRST PAGE&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../build/first.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; second.htmlsrc/main/webapp/public 경로에 second.html 파일을 만들고 아래의 코드를 작성한다. (해당 디렉토리가 없다면 생성한다.) 123456789101112&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;SECOND PAGE&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../build/second.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; first/app.csscss-loader가 잘 동작하는지 확인하기 위해 src/main/webapp/css/first/app.css 파일을 만든다. 그리고 아래와 같이 코드를 작성한다 (해당 디렉토리가 없다면 생성한다.) 123.first &#123; font-size: 24px; border-bottom: solid 1px black; &#125; second/app.csscss-loader가 잘 동작하는지 확인하기 위해 src/main/webapp/css/second/app.css 파일을 만든다. 그리고 아래와 같이 코드를 작성한다 (해당 디렉토리가 없다면 생성한다.) 123.second &#123; font-size: 14px; background-color: yellow; &#125; 4. Client Side Skeleton 코드 작성first/App.jsxsrc/main/jsx/first 폴더 아래에 App.jsx 파일을 생성하고 아래의 코드를 작성한다. 12345678910111213141516import &#x27;../../css/first/app.css&#x27;import React from &#x27;react&#x27;; class App extends React.Component &#123; render()&#123; return ( &lt;h1 className=&quot;first&quot;&gt;Hello First React Skeleton&lt;/h1&gt; ); &#125;&#125;export default App; first/index.jsxsrc/main/jsx/first 폴더 아래에 index.jsx 파일을 생성하고 아래의 코드를 작성한다. 12345678import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import App from &#x27;./App.jsx&#x27;;const rootElement = document.getElementById(&#x27;root&#x27;);ReactDOM.render(&lt;App /&gt;, rootElement); second/app.jsxsrc/main/jsx/second 폴더 아래에 App.jsx 파일을 생성하고 아래의 코드를 작성한다. 12345678910111213141516import &#x27;../../css/second/app.css&#x27;import React from &#x27;react&#x27;; class App extends React.Component &#123; render()&#123; return ( &lt;h1 className=&quot;second&quot;&gt;Hello Second React Skeleton&lt;/h1&gt; ); &#125;&#125;export default App; second/index.jsx12345678import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import App from &#x27;./App.jsx&#x27;;const rootElement = document.getElementById(&#x27;root&#x27;);ReactDOM.render(&lt;App /&gt;, rootElement); 클라이언트 스크립트 빌드React는 리소스 파일들을 바로 사용하지 않고 webpack을 활용하여 빌드한 후에 그 bundle 파일을 활용한다. 위에서 만든 jsx 파일을 빌드하기 위해 터미널에서 루트 디렉토리로 이동하고 아래의 명령어를 작성한다. watch 명령어는 JSX 파일 수정시에 자동적으로 지속 빌드할 수 있도록 도와준다. 1&gt; node_modules/.bin/webpack --watch -d package.json 파일 script 수정자주 사용하는 복잡한 명령어는 package.json 파일에서 script 옵션을 통해 간단하게 줄일 수 있다. script 옵션에 아래와 같이 추가한다. start에 들어가는 JAVA_HOME 옵션은 위에서 settings.json 파일에 추가한 java.home 경로와 같다. 본인의 환경에 맞도록 경로를 수정하자. 1234567&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;set JAVA_HOME=C:\\\\Program Files\\\\Java\\\\jdk-12.0.2&amp;&amp;mvnw spring-boot:run&quot;, &quot;watch&quot;: &quot;node_modules\\\\.bin\\\\webpack --watch -d&quot;&#125; 5. 최종 빌드1&gt; npm run watch 루트 디렉토리에서 위와 같은 명령어를 작성하게 되면 webpack을 통해 bundle.js 파일을 만들게 된다. watch 옵션을 켜두었음으로 해당 명령어는 종료되지 않고 jsx 파일이 수정되면 자동적으로 새롭게 빌드된다. 1&gt; npm run start 위 명령어를 통해 Spring 서버가 실행되었다. 아래의 두 링크를 통해 만들어 놓은 Skeleton 코드들이 잘 동작하는지 확인하자. MainPage.jsx Page1Page.jsx","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"React","slug":"React","permalink":"http://kidongyun.github.io/tags/React/"},{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"}]},{"title":"Farthest Node / Dijkstra","slug":"2019-09-29-farthest-node","date":"2019-09-29T02:21:54.000Z","updated":"2022-05-31T07:10:15.000Z","comments":true,"path":"2019/09/29/","link":"","permalink":"http://kidongyun.github.io/2019/09/29/","excerpt":"","text":"Core123Dijkstra 알고리즘을 활용해 최단경로를 구하자. Questionn개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다. 노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요. 12input : int n, int[][] edgeoutput : int answer 문제 보기 SolutionDijkstra 알고리즘을 활용하여 각 노드마다 최단거리를 구하고 가장 긴 거리의 개수를 구하면 된다. 최단경로 알고리즘을 많이 접해본 경우 쉽게 해결할 수 있는 문제이다. Dijkstra 알고리즘을 구현하기 위해 각 노드마다 거리 정보를 가지고 있는 int[] distances와 방문 여부를 확인하기 위한 boolean[] visits 그리고 간선 정보를 알기 위한 그래프 데이터가 필요하다. Dijkstra 알고리즘은 매 스텝마다 거리 정보를 최적화하고 가장 가까운 노드를 찾아 재귀호출하는 것이 핵심이다. Data Structure각 노드의 거리 정보를 위한 int[] distances, 각 노드의 방문 여부를 확인하기 위한 boolean[] visits, 간선 정보를 저장하기 위한 map[][] 이 필요하다. map은 그래프로 표현함으로 인접행렬, 인접리스트 두가지로 구현이 가능하다. 성능상으로 볼때 인접리스트가 더 효율적임으로 이 방법을 외워두도록 하자. 123456int n // 입력으로 들어온 노드의 개수int[] distances; // 거리 정보 저장boolean[] visits; // 방문 여부List&lt;List&lt;Integer&gt;&gt; map; // 입력으로 들어온 간선 정보 만약 간선에 가중치 정보가 필요하다면 Class를 통해 새로운 자료형을 구현해야한다. Algorithm우선 인접리스트를 활용해 간선 정보를 가지는 map 변수를 초기화 한다. 1234567891011List&lt;List&lt;Integer&gt;&gt; map = new ArrayList&lt;&gt;();for(int i=1; i&lt;n+1; i++) // 노드 개수 만큼 0 인덱스는 고려하지 않고 1부터 계산한다. map.add(new ArrayList&lt;&gt;());for(int i=0; i&lt;edge.length; i++) &#123; map.get(edge[i][0]).add(edge[i][1]); map.get(edge[i][1]).add(edge[i][0]); // 무방향 그래프임으로 두 방향에서 값을 설정&#125; 핵심 dijkstra 알고리즘을 구현한다. 1234567891011121314151617181920212223242526272829303132333435dijkstra(int target) &#123; int min = Interger.MAX_VALUE; int min_index = -1; visit[target] = true; count++; for(int i=0; i&lt;map.get(target).size(); i++) &#123; // 방문하지 않고 인접한 노드의 경우 거리 정보를 업데이트 if(!visits[map.get(target).get(i)]) &#123; if(first) &#123; distances[map.get(target).get(i)] = 1; &#125; else &#123; if(distances[map.get(target).get(i)] &gt; map.get(target).get(i) + 1) distances[map.get(target).get(i)] = map.get(target).get(i) + 1; &#125; &#125; &#125; for(int i=0; i&lt;distances.length; i++) &#123; // 방문하지 않은 노드에 대하여 최소 거리를 가지고 있는 노드를 찾음 if(!visit[i]) &#123; if(min &gt; distances[i]) &#123; min = distances[i]; min_index = i; &#125; &#125; &#125; if(first) first = false; if(count != distances.length - 1) dijkstra(min_index);&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Rotate Two Dimensional Matrix","slug":"2019-09-29-rotate-two-dim-matrix","date":"2019-09-29T02:21:54.000Z","updated":"2022-05-31T07:10:20.000Z","comments":true,"path":"2019/09/29/","link":"","permalink":"http://kidongyun.github.io/2019/09/29/","excerpt":"","text":"Core1234시계방향 : [x][y] -&gt; [n-y][x]반시계방향 : [x][y] -&gt; [y][n-x] Question12input : String s, int noutput : String answer 문제 보기 SolutionData StructureAlgorithm","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Camouflage / Combination","slug":"2019-09-28-camouflage","date":"2019-09-28T02:21:54.000Z","updated":"2022-05-31T07:09:47.000Z","comments":true,"path":"2019/09/28/","link":"","permalink":"http://kidongyun.github.io/2019/09/28/","excerpt":"","text":"Core123A + B + C + AB + AC + BC + ABC = (A+1)(B+1)(C+1) - 1 Question스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다. 예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다. 12345종류 이름얼굴 동그란 안경, 선글라스상의 파란색 티셔츠하의 청바지겉옷 긴 코트 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요. 12input : String s, int noutput : String answer 문제 보기 Solution옷의 개수는 1개 이상 입으면 옷을 입은 것으로 간주된다. 그리고 각 옷의 종류에 따라서 혼합하여 옷을 입을 수도 있다. 잠깐 생각해보면 복잡해 보일 수 있지만 이는 수학의 조합이라는 규칙을 가지고 있다. 예를 들어 옷의 종류가 A, B, C가 있고 각 종류 마다 2, 3, 3 가지의 옷을 가지고 있다. A만 입는 방법, B만 입는 방법, C만 입는 방법, A와 B를 혼합하여 입는 방법, A와 C를 혼합하여 입는 방법, A와 C를 혼합하여 입는 방법, A와 B와 C를 혼합하여 입는 방법이 존재한다. 1총 옷 입는 가짓 수 = A + B + C + AB + AC + BC + ABC 위의 수식이 일정한 규칙을 가지고 있지만. 이를 그대로 활용하여 코딩하기는 복잡하다. 따라서 수식을 아래와 같이 수정하여 진행한다. 1(A+1)(B+1)(C+1) - 1 두 수식은 동일한 값을 가지며 전개를 해보면 명확히 알 수 있다. 1A + B + C + AB + AC + BC + ABC = (A+1)(B+1)(C+1) - 1 Data Structure특별한 자료구조가 필요하지 않다. Algorithm각 옷의 종류마다 옷의 개수를 알아내고 공식을 활용해 풀어낸다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Graph","slug":"2019-09-28-graph","date":"2019-09-28T02:21:54.000Z","updated":"2022-05-31T07:09:52.000Z","comments":true,"path":"2019/09/28/","link":"","permalink":"http://kidongyun.github.io/2019/09/28/","excerpt":"","text":"Graph1234Graph 자료구조를 표현하기 위한 2가지 방법을 정리한다.1. 인접행렬을 활용한 그래프 표현2. 인접리스트를 활용한 그래프 표현 Data Structure1234567// 인접행렬을 활용한 그래프 표현, 각 값은 간선의 가중치를 나타냄.int[][] graph;// 인접리스트를 활용한 그래프 표현, 각 값은 간선의 가중치를 나타냄.List&lt;List&lt;Integer&gt;&gt; graph; Input Data12345678910111213// 인접행렬for(int i=0; i&lt;graph.length; i++) for(int j=0; j&lt;graph.length; j++) if(graph == input) graph[i][j] = input[i][j];// 인접리스트for(int i=0; i&lt;graph.size(); i++) graph = new ArrayList&lt;&gt;();for(int i=0; i&lt;input.length; i++) graph.get(input[0]).add(input[1]);","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Target Number / PowerSet","slug":"2019-09-28-target-number","date":"2019-09-28T02:21:54.000Z","updated":"2022-05-31T07:10:10.000Z","comments":true,"path":"2019/09/28/","link":"","permalink":"http://kidongyun.github.io/2019/09/28/","excerpt":"","text":"Core123부분집합을 구하는 PowerSet 알고리즘 구현 형태를 외워두자. Questionn개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다. 12345-1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3 사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요. 12input : int[] numbers, int targetoutput : int answer 문제 보기 Solution각 자리 수는 +, - 값을 가질 수 있다. 경우의 수를 따지면 총 수가 n개 일때 가능한 조합의 수는 2의 n승 가지 이다. 즉 이 조합 방법은 부분집합을 구하는 형태와 같으며 이 문제는 powerSet 알고리즘을 활용하면 모든 경우의 수에 대해 접근할 수 있다. powerSet 알고리즘은 재귀형태로 구현하는 것이 가장 간단하다. 이를 위해 powerSet() 함수를 구현하며 또 각 자릿 수의 +, -를 확인하기 위한 boolean[] 타입의 flags 변수를 선언한다. Data Structure각 자리의 수 정보를 담겨 있는 int[] numbers 배열을 그대로 사용하며, 각 자리의 +, -를 확인하기 위한 boolean[] flags를 선언한다. 배열의 크기는 numbers의 크기와 동일하다. 1234int[] numbers;boolean[] flags = new boolean[numbers.length]; AlgorithmpowerSet 알고리즘을 재귀적으로 구현한다. 이는 배열의 앞자리부터 +, - 두 방향으로 계속 분기해 나간다.마침내 배열의 끝자리까지 도달하게 되면 특정한 +, -가 생성됨으로 이를 활용하여 요구되어지는 작업을 수행한다. 12345678910111213powerSet(0);public void powerSet(int depth) &#123; if(depth == length) &#123; // numbers와 flags를 활용해 target과 같은 수가 있으면 answer++ 한다. &#125; numbers[depth] = false; powerSet(depth+1); numbers[depth] = true; powerSet(depth+1);&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Printer / Class, Queue","slug":"2019-09-24-printer","date":"2019-09-24T02:21:54.000Z","updated":"2022-05-31T07:09:36.000Z","comments":true,"path":"2019/09/24/","link":"","permalink":"http://kidongyun.github.io/2019/09/24/","excerpt":"","text":"Core1234561. 기본으로 제공되는 자료형으로 구현하기 어려울 때는 Class를 통해 새로운 객체를 만들자.2. Java Collection Framework에서 제공하는 Queue 혹은 Stack 자료구조는 중간에 있는 값들에 접근을 할 수가 없다.즉 중간에 존재하는 값들과 비교연산이 불가능 함으로 필요한 경우에는 List 구조를 사용하도록 하자. Question일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다. 123451. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.3. 그렇지 않으면 J를 인쇄합니다. 예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다. 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다. 현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요. 12input : int[] priorities, int locationoutput : int[] answer 문제 보기 Solutionpriorities 배열을 바꿔가다 보면 location 변수가 지칭하는 값이 어떤 녀석인지 잃게 된다. 이를 위해 location 값을 priorities 배열이 변형을 일으킬 때마다 맞추어서 값을 바꿔주는 방법도 있지만. 여기서는 보다 심플하게 새로운 자료형을 만든다. Document 라는 객체는 location값과 priority값을 가지고 있는 자료형이다. 문제에서 제시된 방법대로 printer를 동작시키기 위해 Queue와 유사하게 동작하는 List를 하나 구현한다. 타입은 Document이다. Data StructureDocument라는 새로운 자료형을 만든다 그리고 priorities를 문제에 제시된 방법처럼 동작시키기 위해 List 하나 구현하여 priorities 배열의 내용을 넣는다. 123456789101112131415// Document라는 새로운 자료형.class Document &#123; int loc; int prior; public Document(int loc, int prior) &#123; this.loc = loc; this.prior = prior; &#125;&#125;// ListList&lt;Document&gt; list &lt;- new Document(priorities, index); Algorithmlist가 아무것도 없을 때까지 반복문을 돌리고 매 값에 대해서 가장 높은 priority를 가졌는지 확인 한다. 그럴 경우 인쇄를하고, 그렇지 않으면 poll() 한다음 다시 list의 가장 끝으로 집어 넣는다. 123456789101112while(!list.isEmpty()) &#123; int prior = list.get(0).prior; if(isImportant(prior, list)) &#123; result.add(list.get(0)); list.remove(0); &#125; else &#123; list.add(list.get(0)); list.remove(0); &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Skill Tree / DFS","slug":"2019-09-24-skill-tree","date":"2019-09-24T02:21:54.000Z","updated":"2022-05-31T07:09:41.000Z","comments":true,"path":"2019/09/24/","link":"","permalink":"http://kidongyun.github.io/2019/09/24/","excerpt":"","text":"Core1234561. 기본으로 제공되는 자료형으로 구현하기 어려울 때는 Class를 통해 새로운 객체를 만들자.2. Java Collection Framework에서 제공하는 Queue 혹은 Stack 자료구조는 중간에 있는 값들에 접근을 할 수가 없다.즉 중간에 존재하는 값들과 비교연산이 불가능 함으로 필요한 경우에는 List 구조를 사용하도록 하자. Question일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다. 123451. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.3. 그렇지 않으면 J를 인쇄합니다. 예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다. 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다. 현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요. 12input : int[] priorities, int locationoutput : int[] answer 문제 보기 Solutionpriorities 배열을 바꿔가다 보면 location 변수가 지칭하는 값이 어떤 녀석인지 잃게 된다. 이를 위해 location 값을 priorities 배열이 변형을 일으킬 때마다 맞추어서 값을 바꿔주는 방법도 있지만. 여기서는 보다 심플하게 새로운 자료형을 만든다. Document 라는 객체는 location값과 priority값을 가지고 있는 자료형이다. 문제에서 제시된 방법대로 printer를 동작시키기 위해 Queue와 유사하게 동작하는 List를 하나 구현한다. 타입은 Document이다. Data StructureDocument라는 새로운 자료형을 만든다 그리고 priorities를 문제에 제시된 방법처럼 동작시키기 위해 List 하나 구현하여 priorities 배열의 내용을 넣는다. 123456789101112131415// Document라는 새로운 자료형.class Document &#123; int loc; int prior; public Document(int loc, int prior) &#123; this.loc = loc; this.prior = prior; &#125;&#125;// ListList&lt;Document&gt; list &lt;- new Document(priorities, index); Algorithmlist가 아무것도 없을 때까지 반복문을 돌리고 매 값에 대해서 가장 높은 priority를 가졌는지 확인 한다. 그럴 경우 인쇄를하고, 그렇지 않으면 poll() 한다음 다시 list의 가장 끝으로 집어 넣는다. 123456789101112while(!list.isEmpty()) &#123; int prior = list.get(0).prior; if(isImportant(prior, list)) &#123; result.add(list.get(0)); list.remove(0); &#125; else &#123; list.add(list.get(0)); list.remove(0); &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"An fulfilled player / HashMap","slug":"2019-09-23-an-unfulfilled-player","date":"2019-09-23T02:21:54.000Z","updated":"2022-05-31T07:08:11.000Z","comments":true,"path":"2019/09/23/","link":"","permalink":"http://kidongyun.github.io/2019/09/23/","excerpt":"","text":"Core12345key가 int형이 아닐 경우 배열보다 Hashmap을 사용하면 시간복잡도를 크게 줄일 수 있다. Question수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 12input : String[] participant, String[] completionoutput : String answer 문제 보기 Solution완주하지 못한 선수의 이름을 알기 위해서 participant 선수 목록과 completion 선수 목록을 비교해 없는 사람을 찾아낸다. 완주하지 못한 사람은 단 한명으로 제한되어 있음으로 participant - completion 하게되면 그 한명을 구할 수 있다. 또 사람이 중복 될 수 있음을 고려해야 한다. Data Structure기본적으로 주어진 입력값 String[] 자료구조를 바로 이용하게 된다면 배열의 특성상 int형의 index를 기준으로 데이터들을 구분하기 때문에 participant와 completion의 선수 목록을 비교할 때 두 String이 값이 같을 때까지 계속 반복하며 비교해야 함으로 2중 for문을 사용해야 한다. 이렇게 데이터를 구분하는 기준이 int형이 아닐 경우 배열보단 Hashmap을 사용하는 것이 훨씬 효율적이다. 선수 이름 자체가 key값 임으로 선수 이름을 찾기 위한 시간 복잡도가 줄어든다. 선수 이름이 중복되는 경우를 고려하기 위해 각 key에 대해 value값을 Integer로 두어 같은 이름을 가진 선수의 수를 체크하도록 한다. 123456/* Data Structure : HashMap Key : 선수 이름 Value : 그 이름을 가진 선수의 수*/HashMap&lt;String, Integer&gt; map; Algorithmparticipant 선수 목록을 map에 추가하고 completion 선수 목록을 제거한다. 최종적으로 남은 한 사람이 완주하지 못한 선수이다. 123456789for(i=0 ~ participant.length) if(map.containKey()) map.put(i, i+1) else map.put(i, 1)for(i=0 ~ completion.length) if(map.get(i) == 1) map.remove(i) else map.put(i, i-1)","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Coding Test - Caesar Cipher / Modulus, ASCII","slug":"2019-09-23-caesar-cipher","date":"2019-09-23T02:21:54.000Z","updated":"2022-05-31T07:08:15.000Z","comments":true,"path":"2019/09/23/","link":"","permalink":"http://kidongyun.github.io/2019/09/23/","excerpt":"","text":"Core1234Character 자료형을 가지고 노는 문제는 ASC 코드를 활용할 확률이 높다.문자들이 순환되어져야 한다면 Modulus 연산을 활용하자. Question어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 AB는 1만큼 밀면 BC가 되고, 3만큼 밀면 DE가 됩니다. z는 1만큼 밀면 a가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요. 12input : String s, int noutput : String answer 문제 보기 SolutionASC 코드를 활용하여 알파벳을 밀어내는 경우를 구현할 수 있다. 대문자와 소문자의 ASC코드값은 다름으로 둘은 구분해서 구현 해야한다. ‘Z’ -&gt; ‘A’ 갈 수 있도록 하기 위해 Modulus 연산을 활용해야 한다. 총 알파벳의 개수는 26임으로 26으로 나누어 27 부터는 다시 1로 돌아갈 수 있도록 만든다. Data Structure특별한 자료구조가 필요하지 않다. Algorithm대문자, 소문자, 공백을 구분하고 각각에 대해 Modulus 연산을 활용해 n만큼 숫자를 밀어준다. 12345678910111213for(int i=0; i&lt;s.length(); i++) &#123; if(s.charAt(i) &gt;= 97 &amp;&amp; s.charAt(i) &lt;= 122) &#123; int value = ((s.charAt(i) - 97 + n) % 26) + 97; answer += (char)value; &#125; else if(s.charAt(i) &gt;= 65 &amp;&amp; s.charAt(i) &lt;= 90) &#123; int value = ((s.charAt(i) - 65 + n) % 26) + 65; answer += (char)value; &#125; else &#123; answer += &quot; &quot;; &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Data Type Casting","slug":"2019-09-23-data-type-casting","date":"2019-09-23T02:21:54.000Z","updated":"2022-05-31T07:08:20.000Z","comments":true,"path":"2019/09/23/","link":"","permalink":"http://kidongyun.github.io/2019/09/23/","excerpt":"","text":"Data Type Casting1Java8 이상에서 제공하는 자료형들의 데이터 타입 변환을 위한 함수들을 정리한다. String -&gt; char[]12String str = &quot;something&quot;;char[] chs = str.toCharArray(); char[] -&gt; string12char[] chs = &#123;&#x27;s&#x27;, &#x27;o&#x27;, &#x27;m&#x27;, &#x27;e&#x27;, &#x27;t&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;g&#x27;&#125;;String str = new String(chs, 0, chs.length); String -&gt; int12String str = &quot;72&quot;;int num = Integer.parseInt(str); int -&gt; String12int num = 72;String str = 72 + &quot;&quot;; char -&gt; int12char ch = &#x27;8&#x27;;int num = Integer.parseInt(ch + &quot;&quot;); int -&gt; char12int num = 8;char ch = Character.forDigit(num, 10); // forDigit 2번째 파라미터는 10진법을 의미 int[] -&gt; Integer[]12int[] num1 = &#123;1, 2, 3, 4&#125;;Integer[] num2 = Arrays.stream(num1).boxed().toArray(Integer[]::new); Integer[] -&gt; int[]12Integer[] num1 = &#123;1, 2, 3, 4&#125;;int[] num2 = Arrays.stream(num1).mapToInt(Integer::intValue).toArray(); String -&gt; Character[]12String str = &quot;something&quot;;Character[] ch = str.chars().mapToObj(c -&gt; (char)c).toArray(Character[]::new); Character[] -&gt; String12Character[] ch = &#123;&#x27;s&#x27;, &#x27;o&#x27;, &#x27;m&#x27;, &#x27;e&#x27;, &#x27;t&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;g&#x27;&#125;;String str = Arrays.stream(ch1).map(String::valueOf).collect(Collectors.joining()); char[] -&gt; Character[]12char[] ch1 = &#123;&#x27;s&#x27;, &#x27;o&#x27;, &#x27;m&#x27;, &#x27;e&#x27;, &#x27;t&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;g&#x27;&#125;;Character[] ch2 = new String(ch1, 0, ch1.length).chars().mapToObj(c -&gt; (char)c).toArray(Character[]::new); Character[] -&gt; char[]12Character[] ch1 = &#123;&#x27;s&#x27;, &#x27;o&#x27;, &#x27;m&#x27;, &#x27;e&#x27;, &#x27;t&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;g&#x27;&#125;;char[] ch2 = Arrays.stream(ch1).map(String::valueOf).collect(Collectors.joining()).toCharArray(); T[] -&gt; List12T[] arr; // Generic임으로 T에 primitive 자료형은 사용 불가List&lt;T&gt; list = Arrays.asList(arr); List -&gt; T[]12List&lt;T&gt; list; // Generic임으로 T에 primitive 자료형은 사용 불가T[] arr = list.toArray(new T[list.size()]);","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Determining Square Root / String","slug":"2019-09-23-determining-square_root","date":"2019-09-23T02:21:54.000Z","updated":"2022-05-31T07:08:25.000Z","comments":true,"path":"2019/09/23/","link":"","permalink":"http://kidongyun.github.io/2019/09/23/","excerpt":"","text":"Core1234String 문자열을 특정 구분자를 활용해 String[]로 나눌때 split()함수를 활용한다.특히 주의할 점은 구분자가 &quot;.&quot;이라면 &quot;\\\\.&quot;로 표기해야한다. Question임의의 양의 정수 n에 대해, n이 어떤 양의 정수 x의 제곱인지 아닌지 판단하려 합니다. n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요. 12input : long noutput : String answer 문제 보기 Solution입력된 값 n에 제곱근을 취했을 때 정수라면 n값에 1을 더하고 제곱을 하여 반환한다. 이 문제는 split() 함수를 사용할 때 구분자가 “.”일 경우 다르게 표기해야 하기 때문에 주의가 필요하다. Data Structure특별한 자료구조가 필요하지 않다. Algorithm1234if((Math.sqrt(n)+&quot;&quot;).split(&quot;\\\\.&quot;)[1].equals(&quot;0&quot;)) answer = (long)Math.pow((Integer.parseInt((Math.sqrt(n)+&quot;&quot;).split(&quot;\\\\.&quot;)[0])+1), 2);","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Dividing Sequence Of Numbers / Modulus","slug":"2019-09-23-dividing-sequence-of-number","date":"2019-09-23T02:21:54.000Z","updated":"2022-05-31T07:17:32.000Z","comments":true,"path":"2019/09/23/","link":"","permalink":"http://kidongyun.github.io/2019/09/23/","excerpt":"","text":"Core1나누어 떨어짐, 배수등을 연산하기 위해 Modulus 연산자를 사용하자. Questionarray의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성해주세요. divisor로 나누어 떨어지는 element가 하나도 없다면 배열에 -1을 담아 반환하세요. 12input : int[] arr, int divisoroutput : int[] answer 문제 보기 Solution입력 파라미터로 들어온 int[] arr에 대해 반복문을 돌려서 각 값이 divisor로 나누어 진다면 answer에 추가하자. 나누어진다는 것은 나머지 연산자를 사용했을 때 나머지가 0임을 의미한다. Data Structure간단한 문제임으로 새로운 자료구조는 사용하지 않고 입력값의 자료형 int[]을 그대로 사용한다. 12// Data Structure : int[]int[] arr; Algorithm나누어 떨어지는 경우 answer 배열에 추가해주면 된다. 123for(0 ~ arr.length) if(arr[i] % divisor == 0) answer.add(arr[i]);","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"find Prime number / Prime Number","slug":"2019-09-23-find-prime-number","date":"2019-09-23T02:21:54.000Z","updated":"2022-05-31T07:08:42.000Z","comments":true,"path":"2019/09/23/","link":"","permalink":"http://kidongyun.github.io/2019/09/23/","excerpt":"","text":"Core123456789소수 찾기 문제는 두가지의 형태로 구분된다.Q. 어떤 숫자 범위에 소수의 개수 구하기. Solution) &#x27;에라토스테네스의 체&#x27; 알고리즘 활용Q. 하나의 수 n이 소수인지 판별하기. Solution) Math.sqrt(n)까지 까지 반복문을 돌려 나누어지는 경우가 있는지 확인 Question1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요. 소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다. (1은 소수가 아닙니다.) 12input : int noutput : int answer 문제 보기 Solution숫자 n까지의 소수의 개수를 구하는 문제임으로 ‘에라토스테네스의 체’ 알고리즘을 활용하여 해결한다. 이는 n까지의 숫자 중에 각 소수들의 배수에 해당하는 수들을 제거하고 최종적으로 남는 수들을 소수로 판단하는 방법이다. Data Structure각 수들이 소수인지 아닌지를 구분하기 위하여 boolean[]을 생성한다. 각 인덱스는 수를 의미하며 0번째 인덱스는 사용하지 않는다. 1234// Data Structure : boolean[]boolean[] primeArr = new boolean[n+1]; Algorithm2부터 Math.sqrt(n)까지 반복하며 각 수의 배수들은 소수가 아님으로 prime = false 해준다. 최종적으로 남은 true값들이 소수가 된다. 12345for(int i=2; i*i&lt;prime.length; i++) for(int j=2; j*i&lt;prime.length; j++) prime[j*i] = false;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"GCD LCM / GCD LCM","slug":"2019-09-23-gcd_lcm","date":"2019-09-23T02:21:54.000Z","updated":"2022-05-31T07:08:47.000Z","comments":true,"path":"2019/09/23/","link":"","permalink":"http://kidongyun.github.io/2019/09/23/","excerpt":"","text":"Core12gcd를 구하는 함수를 구현하는 것은 단순함으로 그 형태를 외우거나 본인처럼 항상 접근할 수 있는 곳에 범용적인 형태로 구현해두자.그러면 필요할 때 lcm과 gcd 값을 얻을 수 있다. Question두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다. 12input : int n, int moutput : int[] answer 문제 보기 Solution우선 gcd를 구하는 함수를 구현하게 되면 두 입력값과 gcd 값을 통해서 lcm을 얻을 수 있다. Data Structure특별한 자료구조가 필요하지 않다. Algorithm123456789101112131415public int gcd(int num1, int num2) &#123; while(num2!=0) &#123; int temp = num1%num2; num1 = num2; num2 = temp; &#125; return num1;&#125;public int lcm(int num1, int num2) &#123; return num1 * num2 / gcd(num1, num2);&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Kth Digit / Sort","slug":"2019-09-23-k-th-digit","date":"2019-09-23T02:21:54.000Z","updated":"2022-05-31T07:08:52.000Z","comments":true,"path":"2019/09/23/","link":"","permalink":"http://kidongyun.github.io/2019/09/23/","excerpt":"","text":"Core12345678여러가지 정렬방법이 있지만 간단하게는 아래 두가지 방법을 활용할 수 있다. 1. Arrays.sort() 2. PriorityQueue여기서는 Arrays.sort() 방법을 활용한다. Question배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다. 예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면 array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다. 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요. 12input : int[] array, int[][] commandsoutput : int[] answer 문제 보기 Solution주어진 array에 대해서 i부터 j까지 분할하여 새로운 배열을 만든다음 오름차순으로 정렬하고 k번째에 해당하는 값을 answer 배열에 저장한다. 즉 primitive한 int형 배열을 사용하여 새로운 배열을 만들고 Arrays.sort()를 활용해 오름차순으로 정렬하고 k 인덱스의 값을 도출한다. Data StructureArrays.sort() 함수는 primitive 자료형에만 적용 가능함으로 int[]을 사용한다. 1234// Data Structure : int[]int[] temp = array.subString(i, j); Algorithmi부터 j까지의 값을 새로운 배열에 저장하고 정렬한다. 그리고 k번째 값을 얻어낸다. 12345// FIRST CASEfor(0 ~ command.length) answer[i] = Arrays.sort(temp)[k]","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Mock Test / Modulus","slug":"2019-09-23-mock-test","date":"2019-09-23T02:21:54.000Z","updated":"2022-05-31T07:08:56.000Z","comments":true,"path":"2019/09/23/","link":"","permalink":"http://kidongyun.github.io/2019/09/23/","excerpt":"","text":"Core1반복문 안에서 일정 주기로 적용해야하는 무언가가 있다면 Modulus 연산자를 의심해보자. Question수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, … 2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, … 3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, … 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요. 12input : int[] answersoutput : int[] answer 문제 보기 Solution1, 2, 3번 수포자들이 문제를 찍는 방식은 모두 일정 주기로 반복된다. 이러한 문제에서 유용한 코딩 방법은 %연산자를 사용하는 것이다. 3인의 수포자들의 찍는 방식을 저장하기 위한 배열 3개를 만들고 문제 수 만큼 반복문을 돌려 맞은 개수를 확인한다. Data Structure1, 2, 3번 수포자들의 정답지를 저장하기 위한 int[] 타입의 변수 3개를 활용하자. 12345678/* Data Structure : int[] 세 변수는 각각 수포자 1, 2, 3의 정답지를 의미한다.*/int[] sol1 = &#123;1, 2, 3, 4, 5&#125;;int[] sol2 = &#123;2, 1, 2, 3, 2, 4, 2, 5&#125;;int[] sol3 = &#123;3, 3, 1, 1, 2, 2, 4, 4, 5, 5&#125;; Algorithm 문제 수(answers.length) 만큼 반복문을 돌려 각 수포자들의 정답 개수를 확인한다. 123456789 numOfAnswers;for(i=0 ~ answers.length) &#123; if(answers[i] == sol1[i%5]) numOfAnswers[0]++; if(answers[i] == sol2[i%8]) numOfAnswers[1]++; if(answers[i] == sol3[i%10]) numOfAnswers[2]++;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Number of PY / String","slug":"2019-09-23-number-of-py","date":"2019-09-23T02:21:54.000Z","updated":"2022-05-31T07:09:02.000Z","comments":true,"path":"2019/09/23/","link":"","permalink":"http://kidongyun.github.io/2019/09/23/","excerpt":"","text":"Core1String의 대소문자 구분으로 인해 문제풀이가 번거로운 경우 toUpperCase(), toLowerCase() 함수로 통일하자. Question대문자와 소문자가 섞여있는 문자열 s가 주어집니다. s에 ‘p’의 개수와 ‘y’의 개수를 비교해 같으면 True, 다르면 False를 return 하는 solution를 완성하세요. ‘p’, ‘y’ 모두 하나도 없는 경우는 항상 True를 리턴합니다. 단, 개수를 비교할 때 대문자와 소문자는 구별하지 않습니다. 예를 들어 s가 pPoooyY면 true를 return하고 Pyy라면 false를 return합니다. 12input : String soutput : boolean answer 문제 보기 Solution입력 파라미터 s를 toUpperCase(), toLowerCase()를 활용해 대문자 혹은 소문자로 통일하고 , s의 크기만큼 반복문을 돌려 p와 y의 개수를 센다. 결과적으로 두 수가 동일하면 true, 아니면 false를 반환한다. Data Structure입력으로 들어온 String 자료형을 그대로 사용한다. 즉 특별한 자료구조가 필요하지 않으며 다만 대문자 혹은 소문자 일치시키기 위한 작업을 선처리한다. 그리고 p, y의 개수를 체크하기 위한 int형 변수 2개를 추가한다. 1234String s = s.toLowerCase(); // 입력으로 받은 값이다int p, y; Algorithms0부터 s의 크기만큼 반복문을 돌리고 그 안에서 p, y의 개수를 카운트한다. 123456for(0 ~ s.length) &#123; if(s.charAt(i) == &#x27;y&#x27;) y++; else if(s.charAt(i) == &#x27;p&#x27;)p++;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Sum between Two Integers / Arithmetic Sequence","slug":"2019-09-23-sum-between-two-integers","date":"2019-09-23T02:21:54.000Z","updated":"2022-05-31T07:09:16.000Z","comments":true,"path":"2019/09/23/","link":"","permalink":"http://kidongyun.github.io/2019/09/23/","excerpt":"","text":"Coresum = {(first + last) size \\over 2}Question두 정수 a, b가 주어졌을 때 a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, solution을 완성하세요. 예를 들어 a = 3, b = 5인 경우, 3 + 4 + 5 = 12이므로 12를 리턴합니다. 12input : int a, int boutput : long answer 문제 보기 Solution반복문을 활용하여 a부터 b까지의 합을 구할수도 있지만 등차수열의 합 공식을 활용하면 훨씬 효율적인 방법으로 계산할 수 있다. ‘두 정수 사이의 합 = (첫항 + 끝항) * 항의 개수 / 2’ 을 활용하면 바로 정답을 구할 수 있다. Data Structure자료구조가 필요하지 않은 문제다. Algorithm등차수열의 합을 활용하자. 123return (a+b) * (a-b+1) / 2;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"String in Descending Order / Sort","slug":"2019-09-23-string-in-descending-order","date":"2019-09-23T02:21:54.000Z","updated":"2022-05-31T07:09:11.000Z","comments":true,"path":"2019/09/23/","link":"","permalink":"http://kidongyun.github.io/2019/09/23/","excerpt":"","text":"Core12345기본적으로 설정되어 있는 char 타입의 정렬 기준은 ASC값을 따른다. Question문자열 s에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 문자열을 리턴하는 함수, solution을 완성해주세요. s는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다. 12input : String soutput : String 문제 보기 Solution입력값으로 들어온 s를 Arrays.sort()함수를 적용하기 위해 char[] 배열로 변환하자. 내림차순으로 정렬하기 위해서 새로운 기준이 필요한 것이 아니기 때문에 Collections.reverseOrder()를 활용하여 내림차순 정렬한다. Data Structure각 영문자들을 정렬하기 위해서 char[] 자료형을 사용해야한다. 그러나 추가적으로 사용한 Collections.reverseOrder() 함수는 primitive 자료형에는 적용할 수가 없다. 따라서 Character[] 자료형를 사용한다. 1234// Data Structure : Character[]Character[] chs; Algorithm입력값 s를 Character[] 자료형으로 변환한다. Arrays.sort()함수와 Collections.reverseOrder()를 활용하여 내림차순으로 정렬한 후 다시 String형 변환하여 답을 도출한다. 123Character[] ch = s.chars().mapToObj(c -&gt; (char)c).toArray(Character[]::new); // String -&gt; Character[] Arrays.sort(ch, Collections.reverseOrder()); // Descending Sortingreturn Arrays.stream(ch).map(String::valueOf).collect(Collectors.joining()); // Character[] -&gt; String","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Workout Clothes / Greedy","slug":"2019-09-23-workout-clothes","date":"2019-09-23T02:21:54.000Z","updated":"2022-05-31T07:09:21.000Z","comments":true,"path":"2019/09/23/","link":"","permalink":"http://kidongyun.github.io/2019/09/23/","excerpt":"","text":"Core12345Greedy 접근법의 핵심은 해당 문제에 대한 근시안적 방법이 최선의 해결책임을 증명하는 것이다. Question점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다. 전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요. 12input : int n, int[] lost, int[] reserveoutput : int[] answer 문제 보기 Solution이 문제를 Greedy하게 풀 수 있음을 나타내는 부분은 바로 체격의 조건이다. 여벌의 체육복을 가지고 있는 학생이 지원할 수 있는 범위는 자신의 앞 번호와 뒷 번호 그 둘로 제한되어 있다. 이제 문제를 가장 잘 해결하기 위한 자료구조를 선정해야 한다. 앞 번호와 뒷 번호를 명확히 보이게 하기 위해 각 학생들을 번호순으로 일렬로 나열시키고 체육복의 개수를 나타내게 하자. 즉 int[] 배열에 학생 번호 순서대로 각 학생들이 가지고 있는 체육복 개수를 넣는다. 맨 앞번호 부터 끝번호까지 체육복이 없는 사람이 있다면 여유가 있는 앞 뒤 학생이 빌려주도록 반복한다. Data Structure각 학생들의 체육복의 개수를 나타내기 위한 int[] 자료형을 사용한다. 1234567/* Data Structure : int[] 각 값들은 학생이 가지고 있는 체육복의 개수를 의미*/int[] students; Algorithm체육복이 없는 학생의 경우 그 앞, 뒤에 있는 학생이 여벌이 있다면 빌려주도록 하자. 최종적으로 students 배열에 1이상의 수를 세면 정답이 된다. 1234567891011for(1 ~ students.length) &#123; if(students[i] == 0) &#123; if(students[i-1] == 2) &#123; students[i-1]--; students[i]++; &#125; else if(students[i+1] == 2) &#123; students[i+1]--; students[i]++; &#125; &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Sort using Comparator / Sort","slug":"2019-09-23-sort-using-comparator","date":"2019-09-23T02:21:54.000Z","updated":"2022-05-31T07:09:06.000Z","comments":true,"path":"2019/09/23/","link":"","permalink":"http://kidongyun.github.io/2019/09/23/","excerpt":"","text":"Core1Comparator 클래스를 활용하여 Custom Sorting을 구현해보자. Question문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 [sun, bed, car]이고 n이 1이면 각 단어의 인덱스 1의 문자 u, e, a로 strings를 정렬합니다. 12input : String[] strings, int noutput : String[] answer 문제 보기 SolutionArray.sort() 함수는 자료의 타입이 String일 때 기본적으로 사전순으로 나열한다. 그러나 이 문제처럼 특별한 기준으로 정렬하고 싶을 때에는 Comparator 클래스를 상속하거나 Comparable 인터페이스를 구현하여 문제를 해결한다. 비교 대상이 primitive 자료형일 경우 Comparator 클래스를 상속하는게 보다 간단하며 새로운 객체를 구현해야 하는 경우는 Comparable 인터페이스를 구현한다. Array.sort() 함수에 두번째 파라미터로 Comparator 객체를 전달하면 이 기준으로 정렬하도록 도와준다. Data Structure자료구조가 필요하지 않은 문제다. Algorithms알고리즘이라기 보다는 Comparator 클래스의 사용법을 이해하자. 특히 이 문제에서 n으로 정렬시 비기는 경우가 발생하면 사전순으로 정렬하도록 요구한다. 이럴때는 Comparator 클래스에서 return 0가 나와야 하는 부분에 compareTo() 함수를 사용해 기존의 정렬방법을 사용할수 있도록 구현한다. 추가적으로 return 1과 return -1의 부분만 변경해주면 오름차순에서 내림차순으로 혹은 그 반대로 정렬할 수 있다. 12345678910111213Arrays.sort(strings, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; if(o1.charAt(n) &gt; o2.charAt(n)) return 1; else if(o1.charAt(n) &lt; o2.charAt(n)) return -1; else return o1.compareTo(o2); &#125;&#125;);","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Network / DFS","slug":"2019-09-28-network","date":"2019-08-11T02:21:54.000Z","updated":"2022-05-31T07:09:59.000Z","comments":true,"path":"2019/08/11/","link":"","permalink":"http://kidongyun.github.io/2019/08/11/","excerpt":"","text":"Core123그래프에서 서로 연결되어 있지 않은 경우를 생각해보자. Question네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다. 컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오. 12input : int n, int[][] computersoutput : int answer 문제 보기 Solution그래프의 모든 노드를 탐색하면서 서로 연결되어있다면 그냥 지나가고 그렇지 않다면 네트워크가 구분되어져 있는것으로 간주할 수 있기 때문에 answer++ 해준다. 그래프를 탐색시 DFS 알고리즘을 활용한다. DFS 알고리즘은 깊이를 우선하여서 모든 노드를 탐색하는 것으로. 간선으로 연결되어 있다는 가정 하에 모든 노드들에 접근이 가능하다. 즉 DFS 알고리즘의 노드들이 간선으로 연결 되어진 경우에만 탐색이 가능하다 이는 하나의 네트워크임을 의미하며 모든 노드가 방문할 수 있도록 DFS 알고리즘을 반복한다. 최종적으로 DFS 알고리즘이 몇번 반복되어졌는지에 따라서 네트워크의 개수가 결정된다. Data Structure각 노드들의 방문여부를 확인하기 위해서 boolean[] visits 변수를 선언한다. 그리고 그래프를 표현하기 위한 데이터는 입력 파라미터에 인접행렬 int[][] computers로 주어졌음으로 그대로 사용한다. 12345boolean[] visits; // 노드 방문여부를 확인하기 위한 flag 변수int[][] computers; // 각 간선들의 가중치 값 // (여기서는 1과 0으로 오로지 연결됨과 그렇지 않음만을 나타낸다.) AlgorithmDFS 알고리즘을 반복문 코드와 재귀 호출 코드 두가지로 구현한다. 1234567891011public void dfs(target) &#123; visits[target] = true; // to do something for(int i=0; i&lt;length; i++) if(!visits[i] &amp;&amp; computers[target][i] != 0) dfs(i);&#125; DFS 알고리즘은 서로 연결된 곳만 확인이 가능함으로 별도의 네트워크는 DFS 한바퀴를 돈다 해도 방문할수 없다. 이를 활용하여 모든 노드에 대하여 반복문을 취하고 방문하지 않았을 때 새로운 네트워크로 간주하여 갯수를 올린다. 1234567891011public void Solution() &#123; for(int i=0; i&lt;length; i++) &#123; if(!visits[i]) &#123; count++; dfs(i); &#125; &#125;&#125;","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Scanner","slug":"2019-09-28-scanner","date":"2019-08-11T02:21:54.000Z","updated":"2022-05-31T07:10:03.000Z","comments":true,"path":"2019/08/11/","link":"","permalink":"http://kidongyun.github.io/2019/08/11/","excerpt":"","text":"Scanner1표준입력 클래스인 Scanner에 대해서 정리해두자. Scanner 인스턴스 생성123456789import java.util.Scanner; // Scanner Class 가져오기.public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); // sc 인스턴스 생성. &#125;&#125; int &lt;- scanner.nextInt()1234567int num1 = sc.nextInt();int num2 = sc.nextInt();// 입력시 띄어쓰기로 두개의 값이 구분됨으로 개행을 해줄 필요는 없다.// 물론 개행도 가능하다. int[] &lt;- scanner.nextInt()12345678int num[];for(int i=0; i&lt;length; i++) num[i] = sc.nextInt();// 배열을 위한 별도의 입력 라이브러리가 존재하지 않는다.// 반복문을 활용하여 구현하여야 한다. double &lt;- scanner.nextDouble()1234567double num1 = sc.nextDouble();double num2 = sc.nextDouble();// 입력시 띄어쓰기로 두개의 값이 구분됨으로 개행을 해줄 필요는 없다.// 물론 개행도 가능하다. double[] &lt;- scanner.nextDouble()123456789double num[];for(int i=0; i&lt;length; i++) num[i] = sc.nextDouble();// 배열을 위한 별도의 입력 라이브러리가 존재하지 않는다.// 반복문을 활용하여 구현하여야 한다. char &lt;- scanner.next().charAt(0)1234567char ch1 = sc.next().charAt(0);char ch2 = sc.next().charAt(0);// 입력시 띄어쓰기로 두개의 값이 구분됨으로 개행을 해줄 필요는 없다.// 물론 개행도 가능하다. char[] &lt;- scanner.nextLine().toCharArray()123456char[] ch = sc.nextLine().toCharArray();// 띄어쓰기와 개행없이 한번에 입력시킬 수 있다.// 만약 문제에서 띄어쓰기가 있다면 위 char &lt;- scanner.next().charAt(0) 방법을 반복문 돌리면 될 것이다. String &lt;- scanner.nextLine()12345String str = sc.nextLine();// nextLine() 함수는 개행을 기준으로 입력된 문자열들을 구분한다. String[] &lt;- scanner.next()12345678910String[][] map;for(int i=0; i&lt;length; i++) for(int j=0; j&lt;length; j++) map[i][j] = sc.next()// String 자료형의 2차원 배열에 데이터를 채울때 반복문을 사용하여 많이 사용한다.// 띄어쓰기와 개행 모두로 입력 구분이 가능함으로 효율적으로 입력이 가능하다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"}]},{"title":"Image Search (Kakaopay Internship)","slug":"2019-08-06-image-search-using-kakao-api","date":"2019-08-06T02:21:54.000Z","updated":"2022-05-31T07:08:06.000Z","comments":true,"path":"2019/08/06/","link":"","permalink":"http://kidongyun.github.io/2019/08/06/","excerpt":"","text":"1. Background카카오 인턴쉽 과제로 Kakao Image Search API를 활용한 어플리케이션을 제작하였습니다. 약 7일간 진행하는 소규모 프로젝트이므로 시간관리는 물론 주어진 기능들을 우선적으로 개발하는 것과 본인 역량 가능한 범위 내에 유용한 기능들을 개발하는 것이 중요했습니다. 2. EnvironmentPlatform : Anroid Native App Language : Java Library : ConstraintLayout, JSONObject, Snackbar, PhotoView 3. Technical Detail1. ConstraintLayout 이전에 WKU라는 프로젝트를 진행할 때에는 LinearLayout 과 RelativeLayout 을 적절히 섞어가면서 Layout작업을 진행했었습니다. IOS Storyboard에서 사용하는 제약조건을 활용한 레이아웃 디자인이 강력하다 생각했었는데 이것이 안드로이드에서는 ConstraintLayout 임을 이번에 알게 되었고, 정말 편리하다는 느낌을 얻었습니다. 2. Animation 이번 프로젝트에는 Scale Animation, Scroll Animation, Color Animation 3가지 종류의 animation이 들어갔습니다. Scale은 Animation 객체를 상속하여 구현하였고, Scroll은 touchListener, Animation 를 상속, 마지막으로 Color는 ValueAnimator 를 사용하였습니다. 3. DownloadManager 이미지 다운로드 기능을 구현하기 위하여 DownloadManager 객체를 활용하였습니다. checkPermission 을 통하여 예외처리를 구현하고 BroadcastReceiver 를 통해 다운로드가 완료되었을 때 Snackbar 알림을 띄우도록 했습니다. kidongyun.apk source_code.zip kidongyun.apk - From Github Source code - From Github","categories":[{"name":"Service","slug":"Service","permalink":"http://kidongyun.github.io/categories/Service/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://kidongyun.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"Normalization, Overfitting, Underfitting","slug":"2019-08-05-normalization-overfitting-underfitting","date":"2019-08-05T02:21:54.000Z","updated":"2022-05-31T07:07:56.000Z","comments":true,"path":"2019/08/05/","link":"","permalink":"http://kidongyun.github.io/2019/08/05/","excerpt":"","text":"Normalization입력 데이터를 들어오는 그대로 사용하면 문제가 생길수도 있다. 예를 들어 2개의 입력을 받아서 1개의 결과를 도출하는 Machine Learning Model이라고 생각해보자. 근데 이 2개의 입력 값의 범주가 1개는 1 ~ 10 범위를 가지고 있고 다른 하나는 1000 ~ 10000이라면 단지 이 데이터의 수치에 의해 그 입력값의 가중치가 결정되어 버린다. 이를 위해 입력 데이터를 적절히 선처리작업을 진행해야 한다. Unnormalized의 경우 모델의 Coutour Plot이 찌그러져서 나타나는 걸 볼 수 있다. 이는 입력값에 존재하는 차이 때문에 그럴수 있다. 이를 개선하기 위해 Normalization을 진행한다. 이는 각 입력값들의 차이를 없애주는 작업으로써 아래의 수식을 적용하면 간단하게 마무리 된다. x_{normalized} = { {x_{origin} - average} \\over range }원래의 x값에 해당 데이터들의 평균값으로 뺴주고난 다음 그 데이터의 범위(range) 만큼으로 나누어 준다. range 값은 데이터 중 최대값 - 최소값이 될수도 있으며 Deviation을 구할 수도 있다. 이를 통해 입력 값들의 차이를 줄이고 모델은 보다 나은 학습을 진행할 수 있다. Overfitting, Underfitting 이전에 서술한 Linear Regression의 경우는 실제로 문제를 다룰 때에는 High bias한 경우가 많다. 이 말은 너무 고정적이라서 데이터의 변화를 감당하지 못한다는 것이다. 위의 그래프에서 가장 왼쪽 Underfitting의 경우를 보면 선형모델이 데이터를 표현하고 있지만 뭔가 조금은 아쉽다. 이렇게 모델이 High bias하여 데이터들의 특성을 모두 표현해내지 못하는 경우 Underfitting이라고 한다. 반대로 가장 오른쪽의 Overfitting의 경우를 보자. 이 모델은 너무 High variance하다. Data를 표현하기 위해서 너무 많은 변화를 가지고 있는 모델임을 의미한다. 데이터를 완벽하게 표현함으로 당연히 가장 좋은 모델일 것이라고 생각할 수 있지만 그렇지 않다. 우리가 모델을 만드는 이유는 데이터를 잘 표현해내서 미지의 새로운 데이터가 발생했을 때 모델을 근거로 하여 예측하고 대처하기 위함이다. 그러나 이렇게 High variance하다면 현재 가지고 있는 학습 데이터셋에 과적합이 되어버려서 새로운 데이터의 특성을 받아들이기가 어려워진다. 이러한 경우를 Overfitting이라고 한다. Overfitting, Underfitting 문제는 Learning System에서 중요시 다뤄지는 사안이다. 이를 Optimal한 모델로 구현하기 위해서 다양한 노력이 있는데 그 중 대표적인 것은 학습 데이터 셋을 train set, validation set, test set 3가지로 구분하는 것이다. 구분하게 된다면 모델에 대한 평가가 가능해진다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Machine learning","slug":"Machine-learning","permalink":"http://kidongyun.github.io/tags/Machine-learning/"}]},{"title":"Train set, Validation set, Test set","slug":"2019-08-05-train-validation-test-set","date":"2019-08-05T02:21:54.000Z","updated":"2022-05-31T07:08:01.000Z","comments":true,"path":"2019/08/05/","link":"","permalink":"http://kidongyun.github.io/2019/08/05/","excerpt":"","text":"각 Data Set의 역할.일반적으로 Overfitting을 방지하기 위해서 Data set을 3가지로 구분하여 학습을 진행한다. 1. Train Set 학습을 위한 데이터셋이다. 가장 기본적으로 사용되며 일반적으로 Data Set의 60%를 사용한다. 2. Validation Set 모델을 평가하기 위한 데이터셋이다. 하이퍼 파라미터나 Hypothesis의 결함을 발견하기 위해서 사용한다. 일반적으로 Data Set의 20%을 사용한다. 3. Test Set Learning System의 최종 점검을 위해 사용한다. 마지막 남은 Data Set의 20%를 사용한다. Cross Validation Set학습 데이터의 양이 충분하지 않을 경우에는 Validation Set을 없애고 Train Set과 Test Set을 지속 번갈아 가면서 테스트를 하게 되는데 이 방법을 교차 검증(Cross Validation)이라고 부른다. 학습 데이터가 적다면 Test set의 데이터가 더욱 적어서 성능 평가시에 편향이 생기게 된다. 이를 위해 교차 검증은 모든 데이터가 최소 한 번은 테스트 셋으로 쓰일 수 있도록 계속 Iteration한다. 위의 예처럼 train set이 총 5개로 분할 되었다면 각 반복시점에서 한번씩은 Test Set으로 사용할 수 있도록하고 각 반복에서 얻어낸 값을 평균 내어 모델을 수정한다. Detail of Cross Validation","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Machine learning","slug":"Machine-learning","permalink":"http://kidongyun.github.io/tags/Machine-learning/"}]},{"title":"Convex Function","slug":"2019-08-04-convex-function","date":"2019-08-04T02:21:54.000Z","updated":"2022-05-31T07:07:41.000Z","comments":true,"path":"2019/08/04/","link":"","permalink":"http://kidongyun.github.io/2019/08/04/","excerpt":"","text":"Convex FunctionConvex 함수는 2차함수 처럼 볼록하게 생긴 함수를 말한다. 단순히 모양을 칭하는 말이지만 이것은 Gradient Descent에서는 꽤나 중요하게 작용한다. Convex Function Non Convex Function Gradient Descent 알고리즘에서 최소값을 구하기 위해서 미분이 0이 되는 지점을 찾는다. 만약 위에 그림에서 Non Convex Function과 같은 경우 미분이 0이 되는 지점이 2군데나 존재한다. 만약 Cost Function이 Non Convex 모양이라면 랜덤하게 시작되는 처음 위치에 따라서 올바른 최소값을 찾아갈수도 있고 그렇지 않을 수도 있다. 이렇게 되면 훌륭한 알고리즘이라고 보기 어려워진다. 따라서 Gradient Descent에서는 Cost Function을 Convex한 모양으로 유지시켜주는 것이 중요하다. Global Minimum, Local MinimumNon Convex Function에서 최소값이 여러군데에서 존재할 때. 전역 범위에서 가장 작은 값은 Global Minimun 이라고 하고 국지적인 관점에서 작은 값을 Local Minimum 이라고 한다. 위의 그래프에서 빨간 점선이 Global Minimim 에 해당하고 보라색 점선이 Local Minimum이다. 위 그래프는 변수가 2가지 일때 나타나는 Non Convex 모델이다. 파란색으로 칠해진 부분이 Minimum에 가까워지는 부분이며, 총 2군데가 있음을 알 수 있다. Non Convex 모델에 따른 Local Minimum 문제를 해결하기 위해서는 Gradient Descent 알고리즘을 사용시에 Cost Function을 Convex 모형으로 변형 시켜주는 것이 최선이다. 대표적으로 Cross Entropy loss 알고리즘이 있다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Machine learning","slug":"Machine-learning","permalink":"http://kidongyun.github.io/tags/Machine-learning/"}]},{"title":"Logistic Regression","slug":"2019-08-04-logistic-regression","date":"2019-08-04T02:21:54.000Z","updated":"2022-05-31T07:07:46.000Z","comments":true,"path":"2019/08/04/","link":"","permalink":"http://kidongyun.github.io/2019/08/04/","excerpt":"","text":"Logistic Regression의 필요성 및 Linear Regression의 한계 Linear Regression은 일반적으로 결과인 y값이 연속적인 값을 가질때 데이터르 표현하기에 유용하다. 그러나 만약 y값이 이산적이라면 어떨까. 두번째 그래프는 y값이 붉은색과 푸른색으로 2가지 형태만 가지고 있다. 합격과 불합격을 의미하도록 만들었다. 데이터가 만약 이러한 특성을 가진다면 Linear Regression 모델만으로는 이산적인 값을 가지는 데이터들을 표현하기는 부적합하다. 그래서 Logistic Regression을 사용한다. 부가적인 설명으로 machine learning 에서는 y값이 이산적인 상황에서 사용되는 기법을 Classification 이라고 한다. 대표적으로 KNN, SVM 모델들을 예로 들수 있으며, Regression은 함수식으로 표현되기 때문에 연속적인 수치들도 표현이 가능하다. 그러나 Regression에서도 이산적인 경우를 위한 방법을 제공하는데이를 Logistic Regression이라고 한다. Sigmoid Function y 값을 2개만 가지는 데이터의 특성에 반면 무한한 값을 가지는 linear regression은 부적합하다. 이를 위해 새로운 모델을 생각해 보자. 무언가 2개를 명확히 구분할 수 있도록 하는 모델이면 좋을듯 하다. y = {1 \\over {1 + e^{-z}}}위와 같은 형태의 함수를 시그모이드라고 부른다. S자 모양을 닮아서 그렇다고 한다. 보면 가운데 부분을 제외하고 양 날개 부분은 값이 합격과 불합격으로 분명하게 나뉜다. 선형회귀 모델 보다는 2분법적으로 무언가를 나누는데에 적합한것 같다. 위의 그래프의 시그모이드 모형은 조금은 이상적이며 실제적으로 쓰이는 것은 아래와 같다. 0.5 값을 기준으로 y 값이 달라진다고 생각하면 된다. 위의 예를 활용한다면 0.5 이하는 불합격, 0.5 이상은 합격이다. 보면 y 값은 0 ~ 1의 범주를 가진다. 이는 확률과 굉장히 유사한 개념이며 이와 동일하게 생각해도 좋다. 즉 50% 이하는 불합격, 50% 이상은 합격인 것이다. 즉 기존의 선형회귀와는 달리 확률론을 모델에 적용하여 이분법적인 사고를 가능하게 만드는 것이 Logistic Regression에서 Sigmoid model이다. Activation FunctionLogistic Regression의 Hypothesis model을 결정할 때 Sigmoid Model이 Linear Model 대체하는 개념이 아니다. Linear Model과 같은 실제 Hypothesis model이 존재한다면 그 결과값(y)를 다시 sigmoid model의 입력으로 받아서 값의 범주를 0 ~ 1 안으로 들어오게만 바꿔준다. 기존의 선형 회귀 모델이론에 확률을 추가하는 느낌이다. 이렇게 실제 가설 모델 의 결과값을 다시 입력값으로 받아 시스템이 처리하기 쉽게 바꿔주는 함수들을 activation function이라고 부르며 sigmoid 말고도 ReLU, Tanh 등이 존재한다. Hypothesis지금까지 배운 Sigmoid Model을 활용해 Logistic Regression의 Hypothesis model을 세워보자. 이는 아래와 같다. y = {1 \\over {1 + e^{-z}}}, \\,\\,\\,\\,\\,\\,\\, z = WX + by = {1 \\over {1 + e^{-(WX + b)}}}z 값이 이전에 배운 Linear Regression의 출력값으로 활용되었다. 전체적인 흐름은 아래와 같다. 그리고 이해를 위해 앞으로는 Hypothesis를 h(x)로표현하도록 하겠다. 1Input values -&gt; Linear Model -&gt; Sigmoid Model -&gt; Output value h(x) = {1 \\over {1 + e^{-(WX + b)}}}Cost Function이번 Cost Function은 Linear Regression과는 많이 다르다. Logistic Regression이 Linear Regression과 가장 다른 부분인것 같다.Gradient Descent 알고리즘을 적용하기 위해서는 Cost Function이 Convex한 모양을 가져야 한다. 그렇지 않으면 Local Minimum 문제에 도달할 수 있다. 그러나 이번 Logistic Regression Hypothesis는 아래와 같이 자연로그를 포함하고 있어 Linear Regression과 같이 최소제곱법을 사용하게 된다면 이는 Non Convex 모양이 되어버린다. Logistic Regression Hypothesis y = {1 \\over {1 + e^{-(WX + b)}}}Logistic Regression에서 Cost Function이 Convex 모양을 갖기 위한 새로운 알고리즘을 소개한다. Cross Entropy Loss라고 부르며 Log함수를 활용한다. Cost Function에서 가장 중요한 점은 Hypothesis 모델이 데이터를 잘 표현하고 있다면 에러 값을 작게하고 그렇지 않다면 크게 하도록 만드는 것이다. 이와 동일하게 Logistic Regression에서는 출력값이 참 혹은 아니오 2가지 밖에 없음으로 만약 Hypothesis 모델의 예측이 데이터와 같다면 잘 표현한 것으로 에러를 적게 하고 반대의 경우로 예측이 틀렸다면 에러를 높이면 된다. Cross Entropy LossCost Function = \\{ \\begin{matrix} -ln(h(x)) : y = 1 \\\\ -ln(1 - h(x)) : y = 0 \\end{matrix}Cross Entropy Loss 는 실제 데이터의 y값이 1인경우 0인경우에 따라서 이용하는 함수가 달라진다. 우선 각 y = 1인 경우를 살펴보자. -ln(h(x)) 실제 데이터의 결과 y = 1 일때 사용하는 함수의 그래프이다. 실제 데이터의 결과가 y = 1이라면 Hypothesis model을 통한 예측값이 1일 떄는 데이터를 잘 표현한 것임으로 에러는 적은 값을 가져야하고 0일 때에는 데이터를 잘 표현하지 못했음으로(예측을 틀렸음으로) 에러는 큰 값을 가져야 한다. 이 모델을 살펴보면 hypothesis model을 의미하는 h(x)가 입력 값으로 들어가고 있다. 위의 파란 그래프 따라서 보면 이 입력값이 1일 때는 Error는 0을 가리키며 반대로 0일 경우 예측에 틀림으로 무한대의 에러값을 가지고 있다. -ln(1 - h(x)) 실제 데이터의 결과 y = 0 일때 사용하는 함수의 그래프이다. 실제 데이터의 결과가 y=0 이라면 Hypothesis model을 통한 예측값이 0일 떄는 데이터를 잘 표현한 것임으로 에러는 적은 값을 가져야하고 1일 때에는 데이터를 잘 표현하지 못했음으로 에러는 큰 값을 가져야 한다. 이는 위 y = 1의 경우와 반대로 이루어진다고 보면 된다. 초록색 그래프를 잘 살펴보자. hypothesis model을 의미하는 h(x)가 입력 값으로 들어가고 있다. 이 입력 값이 0일 때에는 Error는 0을 가리키며 반대로 1일 경우 예측에 틀림으로 무한대의 에러값을 가지고 있다. 한가지 명심해야할 사항은 입력값으로 들어오는 h(x) 값의 범위는 Sigmoid 함수를 사용하고 있음으로 0 ~ 1이다. 그럼으로 그 외의 범위에 있는 값은 신경 쓸 필요가 없다. 위의 Cross Entropy Loss는 y값의 경우에 따라서 2개의 수식으로 나누어져 있는데 이는 단지 이해를 위한 것으로 이번에는 하나의 수식으로 표현해 보겠다. Cost\\,Function = yln(h(x)) - (1-y)ln(1 - h(x))y 값의 경우에 따라서 두 부분의 수식이 상반되며 활성화 되었다가 비활성화된다. 이는 위의 2개의 수식을 표현한 것과 일치함을 보인다. 이는 한개의 데이터에 대한 Error 수치임으로 모든 데이터에 대해서 적용할 수 있도록 Cost Function을 확장하자. 그리고 데이터의 개수가 영향을 주면 안됨으로 데이터의 개수만큼 나누어 주자. 즉 평균을 구한다. Cost\\,Function = {1 \\over n} \\sum_{i=1}^n (y_iln(h(x_i)) - (1 - y_i)ln(1 - h(x_i)))Gradient DescentCost Function을 Convex한 모양으로 만들었음으로 Gradient Descent 알고리즘을 동일하게 적용하여 Hypothesis의 weight 값과 bias 값을 수정하면 된다. 아래는 Cost Function의 편미분과 Gradient Descent 알고리즘이 적용된 Delta Rule 이다. Partial Derivative {\\partial \\over \\partial w_1} Cost\\,Function = {1 \\over n} \\sum_{i=1}^{n} (h(x^{(i)}) - y^{(i)})x_1^{(i)} \\\\ {\\partial \\over \\partial w_2} Cost\\,Function = {1 \\over n} \\sum_{i=1}^{n} (h(x^{(i)}) - y^{(i)})x_2^{(i)} \\\\ {\\partial \\over \\partial w_3} Cost\\,Function = {1 \\over n} \\sum_{i=1}^{n} (h(x^{(i)}) - y^{(i)})x_3^{(i)} \\\\ \\\\ ... \\\\ {\\partial \\over \\partial b} Cost\\,Function = {1 \\over n} \\sum_{i=1}^{n} (h(x^{(i)}) - y^{(i)})Cross Entropy Loss 미분 상세 과정{: target=”_blank”} Delta Rule w_1^{(n+1)} = w_1^{(n)} - \\alpha { \\partial \\over \\partial w_1} Cost Function \\\\ w_2^{(n+1)} = w_2^{(n)} - \\alpha { \\partial \\over \\partial w_2} Cost Function \\\\ w_3^{(n+1)} = w_3^{(n)} - \\alpha { \\partial \\over \\partial w_3} Cost Function \\\\ \\\\ ... \\\\ b^{(n+1)} = b^{(n)} - \\alpha { \\partial \\over \\partial b} Cost Function","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Machine learning","slug":"Machine-learning","permalink":"http://kidongyun.github.io/tags/Machine-learning/"}]},{"title":"Softmax","slug":"2019-08-04-softmax","date":"2019-08-04T02:21:54.000Z","updated":"2022-05-31T07:07:51.000Z","comments":true,"path":"2019/08/04/","link":"","permalink":"http://kidongyun.github.io/2019/08/04/","excerpt":"","text":"Logistic Regression의 확장Logistic Regression은 참 혹은 아니오 같은 이분법 분류만 가능한 Classification기법 이였다. 그러나 Regression을 활용하여 더 많은 수의 이산적 수치를 구분 할 수 있는 모델이 있을까? 답은 가능하다.Logistic Regression 모델을 중첩하여 2개 이상의 결과를 가진 데이터를 구분하는 모델을 만들어 보자. Decision Boundary2개 이상의 결과를 구분하기 위한 Softmax를 살펴보기 이전에 Decision Boundary라는 것을 살펴보자. 이는 Classification시 데이터의 구분을 보다 쉽게 이해하기 위한 그래프의 종류이다. 우선 이해를 위해 아래의 Sigmoid 그래프를 보자. 이 그래프의 수식은 아래와 같다. h(x) = {1 \\over {1 + e^{-z}}} 이 Sigmoid 함수는 입력값 z를 받고 결과 h를 도출하고 있다. 결과는 이전에 공부한대로 0 ~ 1의 범주를 가지고 있다. 전과 달리 이번엔 z값에 집중해보자. 아래 Sigmoid 함수에서 붉은색 영역을 보면 z값이 0보다 작다. 이는 확률이 50%를 넘지 못함으로 결과적으로 h는 0을 갖게되고 푸른색 영역에서는 z값이 0보다 커서 확률이 50% 이상이 되어 h는 1의 값을 가지게 된다. 이전에 Logistic Regression에서 Hypothesis로 정의한 Sigmoid 함수식을 보자. h(x) = {1 \\over {1 + e^{-(wx + b)}}} 위의 예에서 z값이 0을 기준으로 결과 h값이 변하는 것을 확인했다. z값은 linear model인 wx + b값과 같음으로 이는 wx + b 기준으로 결과 h값이 변한다고 말할 수 있다. 즉 아래와 같다. 푸른색의 원이 가리키는 선형회귀 모델의 윗부분은 hypothesis의 결과값 h가 1이 되는 영역이고 반대로 붉은색 원이 가리키는 아랫 부분은 결과값 h가 0이 되는 영역이다. 이렇게 Hypothesis model에서 Activation Function을 거치지 않고 그 전의 모델을 그래프로 그려서 판단하는 것은 Decision Boundary라고 한다. 이는 때에 따라서 굉장히 문제를 직관적으로 볼수 있어 유용하다. 이제부터 볼 Softmax도 이에 해당한다. Softmax Logistic Regression은 1 혹은 0과 같이 2분법적으로만 Classification이 가능했다. 그렇다면 위의 그래프와 같이 3개의 경우의 수가 있다면 어떻게 해결해야 할까. 우리는 Softmax라고 불리는 Logistic Regression의 중첩방법으로 해결한다. 3개의 결과값을 가지는 데이터들이라면 이를 위해 총 3개의 가설을 세운다. 즉 3개의 Hypothesis model을 가진다. 각 가설은 다음과 같다. 1. 푸른색 엑스 데이터면 참 아니면 거짓. 2. 초록색 세모 데이터면 참 아니면 거짓. 3. 주황색 원 데이터면 참 아니면 거짓. 각 가설 하나 하나는 이분법적 계산을 함으로 Logistic Regression으로 구현이 가능하다. 전의 Logistic Regression의 과정대로 학습시켜 잘 표현된 모델 3개를 구현한다. 이는 아래와 같다. 푸른색 선은 1. 푸른색 엑스 데이터면 참 아니면 거짓에 의한 모델, 초록색 선은 2. 초록색 세모 데이터면 참 아니면 거짓에 의한 모델, 3. 주황색 선은 주황색 원 데이터면 참 아니면 거짓에 의한 모델이다. 최종적으로 새로운 데이터가 어느 분류에 속하는가를 예측하기 위해서 각 모델을 통해 예측을 진행하고 가장 확률이 높게 나온 모델을 참으로 본다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Machine learning","slug":"Machine-learning","permalink":"http://kidongyun.github.io/tags/Machine-learning/"}]},{"title":"Linear Regression with Multiple Variables","slug":"2019-08-03-linear-regression-with-multiple-variables","date":"2019-08-03T02:21:54.000Z","updated":"2022-05-31T07:07:29.000Z","comments":true,"path":"2019/08/03/","link":"","permalink":"http://kidongyun.github.io/2019/08/03/","excerpt":"","text":"Hypothesis 확장y = wx + bSimple Linear Regression은 입력되어질 수 있는 변수가 x 한가지이다. 보다 복잡한 상황들을 견뎌낼 수 있는 모델이 필요하다. 이번에는 변수를 2개 이상 가질 수 있는 Linear Regression을 소개한다. y = w_2x_2 + w_1x_1 + b이는 변수 2개를 가질 수 있는 모델이며 같은 방법으로 계속 확장해 나갈 수 있다. y = ... w_3x_3 + w_2x_2 + w_1x_1 + b만약 행렬을 쓴다면 위의 수식을 아래처럼 보다 간단하게 표현할 수 있다 y = WX + b W = \\begin{pmatrix} w_1 & w_2 & w_3 & ... \\end{pmatrix} \\,\\,\\,\\,\\,\\, X = \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ ... \\end{pmatrix}변수가 2개일 때의 Linear Regression의 Hypothesis를 살펴본다면 아래와 같을 것이다. 마찬가지로 변수가 3개일 때는 4차원의 공간에 표현된다. 즉 변수 한개가 늘어날 수록 이를 그래프로 표현하기 위해서는 차원이 하나씩 늘어나야 함을 의미한다. 용어의 의미.y = ...\\,w_3x_3 + w_2x_2 + w_1x_1 + bRegression 이론에서 사용되는 용어들을 다시 한번 정리할 필요성 있다. Linear Regression이 변수가 1개였던 때 보다 모델이 확장되면서 이 모델을 바라보는 시선도 조금은 바뀌어야 한다. x값 1개에 무조건 w값 1개가 붙어있다. 이 의미는 x라는 입력값이 y를 도출하는데에 얼마나 중요한 요인인가에 따라서 그 중요도를 w값에 숫자로 넣는 것이다. 그래서 w값은 weight 즉 가중치를 의미한다. x값은 machine learning에서 보통 특성값이라고 한다. 결국 machine learning은 데이터의 특성을 학습하는 것이고 그 특성에 따라 모델이 데이터를 잘 표현하게 된다. Cost Function 확장Cost\\,Function = {1 \\over 2n}\\sum_{i=1}^{n} (wx_i + b - y_i)^2변수가 1개일 때의 Cost Function이다. 이를 변수가 여러개 일때도 사용할 수 있도록 확장시켜 보자.확장된 Hypothesis를 적용시키면 될것이다. 혼란을 방지하기 위해서 각 데이터를 의미하는 i 변수는 아래첨자에서 윗첨자로 변경하였다. Cost\\,Function = {1 \\over 2n}\\sum_{i=1}^{n} ((w_1x_1^{(i)} + w_2x_2^{(i)} + w_3x_3^{(i)} + ... + b) - y^{(i)})^2Cost\\,Function = {1 \\over 2n}\\sum_{i=1}^{n} (WX^{(i)} + b) - y^{(i)})^2Gradient Descent 확장늘어난 변수만큼 각 변수에 대하여 편미분을 진행한 다음 Gradient Descent 알고리즘에 따라 가중치 값을 바꾸어 주자. 우선 편미분을 진행하면 다음과 같다. {\\partial \\over \\partial w_1} Cost\\,Function = {1 \\over n} \\sum_{i=1}^{n} (w_1x_1^{(i)} + w_2x_2^{(i)} + w_3x_3^{(i)} + ... + b - y^{(i)}) (x_1^{(i)}){\\partial \\over \\partial w_2} Cost\\,Function = {1 \\over n} \\sum_{i=1}^{n} (w_1x_1^{(i)} + w_2x_2^{(i)} + w_3x_3^{(i)} + ... + b - y^{(i)}) (x_2^{(i)}){\\partial \\over \\partial w_3} Cost\\,Function = {1 \\over n} \\sum_{i=1}^{n} (w_1x_1^{(i)} + w_2x_2^{(i)} + w_3x_3^{(i)} + ... + b - y^{(i)}) (x_3^{(i)})...{\\partial \\over \\partial b} Cost\\,Function = {1 \\over n} \\sum_{i=1}^{n} (w_1x_1^{(i)} + w_2x_2^{(i)} + w_3x_3^{(i)} + ... + b - y^{(i)})아래는 Gradient Descent 알고리즘이 적용될 Delta Rule이다. w_1^{(n+1)} = w_1^{(n)} - \\alpha { \\partial \\over \\partial w_1} Cost Functionw_2^{(n+1)} = w_2^{(n)} - \\alpha { \\partial \\over \\partial w_2} Cost Functionw_3^{(n+1)} = w_3^{(n)} - \\alpha { \\partial \\over \\partial w_3} Cost Function...b^{(n+1)} = b^{(n)} - \\alpha { \\partial \\over \\partial b} Cost Function","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Machine learning","slug":"Machine-learning","permalink":"http://kidongyun.github.io/tags/Machine-learning/"}]},{"title":"Linear Regression with Weight, Bias","slug":"2019-08-03-linear-regression-with-weight-bias","date":"2019-08-03T02:21:54.000Z","updated":"2022-05-31T07:07:36.000Z","comments":true,"path":"2019/08/03/","link":"","permalink":"http://kidongyun.github.io/2019/08/03/","excerpt":"","text":"선형 회귀 이론의 확장.기존의 선형회귀 이론은 Hypothesis 모델이 y = wx 로 구하려고 하는 변수가 w값 1개 였다.그러나 실제로 이렇게 단순한 모델로 적용할 수 있는 상황은 그렇게 많지 않다. 이번에는 생략했던 b값도 추가하여 y = wx + b 의 모델로 선형 회귀 이론에 대해서 알아보자. Hypothesis개념은 Linear Regression with One Variable 와 동일하다. 다만 모델이 y = wx + b 로 생략되었던 b를 추가하여 진행한다. 궁극적으로 이 모델이 데이터를 잘 표현하기 위한 w, b 두개의 값을 구해야 한다. Hypothesis : y = wx + b Cost Function마찬가지로 개념은 동일하지만 Hypothesis 모델이 변함으로 인해 수식이 조금은 변경된다. 아래를 확인하자. Error = (predicted - real)^2 = ((wx_i + b) - y_i)^2 = (wx_i + b - y_i)^2 $$ $$ Summation\\,of\\,Error = Cost\\,Function = {1 \\over 2n}\\sum_{i=1}^{n} (wx_i + b - y_i)^2 $$ $$ Cost\\,Function = {1 \\over 2n}\\sum_{i=1}^{n} (wx_i + b - y_i)^2이제 Cost Function을 그래프로 그리기 위해서는 좌표평면으로는 부족하다. 잘 생각해보면 Error를 w, b 2가지의 관점에서 고려해야 하기 떄문이다. 즉 고려해야할 변수가 1개가 아닌 2개로 늘어났다. 아마 이를 시각화 시키면 아래와 같다. 그래프에서 y축에 해당하는 J는 Error와 동일하며 x, z 축이 w와 b값을 의미하고 있다. Cost가 최소값을 가지도록 w, b 값을 조절해야한다. Gradient Descent 방법을 활용하여 해결하자. Contour Plot그래프를 3차원으로 표현하는 것은 사람에게 익숙하지 않다. 따라서 위와 같은 Cost Function을 2차원으로 표현하기 위해 Contour Plot 그래프를 자주 사용한다. 이 그래프는 y축 즉 하늘에서 아래로 바라보는 방향을 가지고 있으며 색상을 통해서 Error 값이 높은지 낮은지를 표현한다. 가운데로 갈수록 진한 파란색으로 표현되는데 이는 에러가 낮음을, 붉은색은 높음을 표현하고 있다. 빨간 x표시는 현재 모델의 에러 값을 나타내는 것이며 Gradient Descent 학습을 통해 점점 최소값으로 다가가고 있음을 나타낸다. Gradient Descent적용하는 방법은 변수 1개일 때와 다른 것이 없다. 다만 변수가 2개임으로 편미분을 진행해야 한다. 즉 하나는 w를 기준으로, 다른 하나는 b를 기준으로 미분해야한다. Cost\\,Function = {1 \\over 2n}\\sum_{i=1}^{n} (wx_i + b - y_i)^2Partial Derivative based w. {\\partial \\over \\partial w} Cost\\,Function = {1 \\over n} \\sum_{i=1}^{n} (wx_i + b - y_i) (x_i)Partial Derivative based b. {\\partial \\over \\partial b} Cost\\,Function = {1 \\over n} \\sum_{i=1}^{n} (wx_i + b - y_i)중요한것은 각 반복마다 이 편미분된 값들이 업데이트 될때 서로가 영향을 미치지 않으며 동시에 업데이트가 되어야 한다. 즉 코드를 작성할 때 어떤 연산의 우선순위를 갖고 다른 값에 변화를 주면 안된다. w_{n+1} = w_n - \\alpha { \\partial \\over \\partial w} Cost Functionb_{n+1} = b_n - \\alpha { \\partial \\over \\partial b} Cost Function최종적인 Gradient Descent 알고리즘이다. 지속적인 반복을 통해 w와 b값을 최소값에 다다르게 하면 Hypothesis Model은 데이터를 잘 표현할 수 있다. 1234567891011121314151617181920212223242526import tensorflow as tfimport osos.environ[&#x27;TF_CPP_MIN_LOG_LEVEL&#x27;] = &#x27;2&#x27;x_train = [1.60, 1.63, 1.65, 1.66, 1.71, 1.70, 1.73, 1.70, 1.73]y_train = [23.0, 23.5, 24.0, 23.5, 24.0, 24.0, 24.5, 24.0, 25.0]a = tf.Variable(tf.random_normal([1]), name=&#x27;a&#x27;)b = tf.Variable(tf.random_normal([1]), name=&#x27;b&#x27;)hypothesis = a * x_train + be = tf.reduce_mean(tf.square(hypothesis - y_train))optimizer =tf.train.GradientDescentOptimizer(learning_rate=0.01)train = optimizer.minimize(e)sess. tf.Session()sess.run(tf.global_variables_initializer())for step in range(2001) : sess.run(train) if step % 20 == 0 : print(&quot;Iteration : &quot;, step, &quot; e : &quot;, sess.run(e), &quot; ( y =&quot;, sess.run(a), &quot; x + &quot;, sess.run(b), &quot;)&quot; )","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Machine learning","slug":"Machine-learning","permalink":"http://kidongyun.github.io/tags/Machine-learning/"}]},{"title":"Alpha. Learning Rate","slug":"2019-08-02-alpha-learning-rate","date":"2019-08-02T02:21:54.000Z","updated":"2022-05-31T07:07:19.000Z","comments":true,"path":"2019/08/02/","link":"","permalink":"http://kidongyun.github.io/2019/08/02/","excerpt":"","text":"Learning rate 란?w_{n+1} = w_n - \\alpha { \\partial \\over \\partial w} Cost Function 위 수식과 그래프는 Gradient Descent 알고리즘을 표현한다. 그래프에서 빨간 점은 반복됨에 따라서 점점 최소값을 향해 가고 있다. 위 수식에서 alpha는 learning rate라고 불리며 학습을 진행할 때 Step size를 조절하는 하이퍼 파라미터이다. 즉 alpha 값이 크다면 빨간점이 한 반복에서 크게 변화하고 작다면 반대로 조금씩 변화하게 된다. 너무 작은 Learning Rate, 너무 큰 Learning Rate.Learning rate가 작으면 좋을까, 크면 좋을까 이는 한쪽으로 치중될 수 없으며 적절한 수치를 찾아야 한다.너무 작았을 때에 일어날 수 있는 문제점과 마찬가지로 너무 클 경우에 발생할 수 있는 문제점에 대해서 알아보자. Learning Rate가 너무 작을 경우 반복을 충분히 했음에도 불구하고 최소값에 다다르지 못하고 중단되는 현상이 발생할 수 있다. 이를 개선하기 위해 Learning Rate 값을 작게 그대로 두고 반복을 더욱 많이 한다면 이는 Computing Resource를 더욱 많이 사용하게 됨으로 시스템에 부하가 걸릴 수 있다. 또 Cost Function이 완전한 Convex Function이 아닐경우 작은 언덕 하나 넘지 못하고 Local minimum에 빠질 수 있다. 아래에 그래프 중 가장 왼쪽의 Too low 그래프를 참조하자. 반대로 Learning Rate가 너무 클 경우 값이 최소값에 다다르지 못하고 오히려 더 커질 수가 있다. 즉 수렴하지 못하고 발산하려 한다. 위 그래프는 learning rate가 반복되면서 loss (= error) 가 어떻게 변하는지를 보여주는 그래프이다. Very high learning rate 위에서 언급한대로 최소값에 수렴하지 못하고 오히려 발산하는 현상이다. 보면 반복됨에 따라 loss 값이 반대로 올라가고 있다. Low learning rate 마찬가지로 위에서 언급한 형태이다. Good learning rate와 비교해서 보면 너무 작은 Step size로 최종적으로 최소값에 도달하지 못했다. Hight learning rate High learning rate는 Very High learning rate와는 다르게 수렴은 하고있다. 그러나 보면 최소점에 다다르지 못하고 일정 Loss 값을 유지하고 있다. 이는 Step size가 커서 저 작은 값들로 내려가지 못하는 현상이다. 최소값을 두고 빙글빙글 돌고 있는 형태로 보면 되겠다. Gradient descent 알고리즘은 최저점에 다다를수록 보다 더 섬세하게 다가간다.처음에 하나의 Learning rate를 정하게 되면 그 Step size로 계속 최소값에 다다르는 줄 알았었다. 하지만 Gradient Descent 알고리즘을 면밀히 살펴보니 그렇지 않음을 알았다. w_{n+1} = w_n - \\alpha { \\partial \\over \\partial w} Cost Function위의 Gradient Descent 수식을 보면 다음 w값은 이번 w값에 Learning rate와 Cost의 미분한 값을 곱하여 차감한다. 비록 Learning rate값은 지속 동일하여도 cost의 값이 최저점에 다다를수록 점점 작아지기 때문에 Gradient Descent 알고리즘의 관점에서 보면 Step size는 점점 작아진다.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Machine learning","slug":"Machine-learning","permalink":"http://kidongyun.github.io/tags/Machine-learning/"}]},{"title":"Linear Regression with One Variable","slug":"2019-08-02-linear-regression-with-one-variable","date":"2019-08-02T02:21:54.000Z","updated":"2022-05-31T07:07:24.000Z","comments":true,"path":"2019/08/02/","link":"","permalink":"http://kidongyun.github.io/2019/08/02/","excerpt":"","text":"What is the linkear regression theory?Regression theory is widely used in Computer Science nowadays. The main feature of this theory is this theory use the mathmatical function expression to predict future don’t know now. for that, the features of data should be expressed as a numeric one to make a mathematical function. and secondly we should find the best model represent the data. if this model can be expressed as linear model. then it is usually named Linear Regression. let’s know about linear regression theory now. 3 steps of linear regression model. Defining Hypothesis model. Defining Cost function to calculate errors. Minify the errors with Gradient Descent. Defining Hypothesis model.The hypothesis model is needed to generalize the data in regression theory. you should make a choice the hypothesis model before the calculation. if you choose the linear model for hypthesis than it would be called linear regression model. Defining Cost function to calculate errors.The errors means the difference between the real data and predicted data with hypothesis. if the errors is smaller than the hypothesis model is more fit with the data. if this model is good enough than you can extract valuable information with this hypothesis model. Minify the errors with Gradient Descent.we should find the way decrease errors enough to get optimized hypothesis model. Gradient Descent way is one of the solution can find the minimum of errors value point. Hypothesis.간단히 말해, 주어진 데이터들이 좌표평면 공간에 표현되어 있을 때 이를 가장 잘 표현할 수 있는 하나의 함수식, 모델을 결정하는 일이다. 이해를 위해 한가지 예를 들어 진행해보자. 아래의 그래프에 표현된 것은 ‘공부한 시간’과 ‘성적’의 관계에 대한 데이터다. 양의 상관관계를 가지는 ‘공부한 시간’, ‘성적’와 관련된 데이터들을 표현하기 위해 여러가지 모델들을 고려해 보자. 아래의 모델들이 충분히 후보군에 포함될 수 있을 것이다. Candidate of Hypothesis Models 모두 보기에 합리적일 것 같은 후보 모델들이다. 여기서 나는 보라색 점선을 가진 3번째 모델을 선택하도록 하겠다. 그 이유는 모델이 일차함수로 만들어져 있기 때문이다. 실제로 이 데이터들을 표현하는 모델을 결정하는 일은 굉장히 중요하다. 모델을 보다 정확하게 하기 위해서는 보다 많은 데이터들을 가지는 것이 좋다. 또 좋은 모델을 결정하기 위한 일련의 절차가 있는데 이는 추후에 알아보도록 하자. 보라색 점선은 일차함수이다. 고로 분명 y = wx + b 함수식의 형태로 표현될 것이다. Linear Regression에서 궁극적으로 목표하는 것은 이 일차함수 식이 보라색 점선처럼 될 수 있도록 w, b 값을 유추해내는 것이다. model : y = wx + b그러나 이번 글에서는 보다 쉬운 이해를 이해 b 변수는 생략한 모델로 진행하도록 하겠다. Model : y = wxCost Function. (에러의 정의와 산출)앞서 표현한 Hypothesis Model이 데이터를 가장 잘 표현하게 하기 위해서 Error의 개념을 사용하여 Cost Function을 정의한다. 위 그래프를 보자. 검은 점들은 실제 데이터들을 나타내고 보라색 점선은 가설 모델이다. 그리고 빨간 실선은 실제 데이터와 모델을 통해 예측되어진 값의 차이를 보여준다. 이 값을 앞으로 Error라고 표현하겠다. 1Error = 실제 데이터와 예측된 값의 차이 만약 위 그래프에 표현된 실제 데이터의 위치를 (x, y) 라고 한다면 Error는 다음과 같이 표현될 수 있다. Error = (wx - y)^2Error는 Scalar 값이기 때문에 부호를 없애기 위해서 제곱을 취했다. 자 이제 이 Error의 개념을 모든 데이터들에게 적용시켜 보자. Errors = \\sum_{i=1}^{n} (wx_i - y_i)^2모든 데이터를 적용하기 위해 Error 수식에 i, n 변수를 사용했다. n은 데이터들의 총 개수를 뜻하며 i는 각 데이터들이다. 그러나 지금 이 수식은 완전하지 못하다. Error의 의미는 실제 데이터들과 모델을 통한 예측값의 차이를 표현하는 것인데 지금 수식을 통해서는 데이터가 많아져도 Error 값이 커진다. 이를 위해 n 값으로 나누어 주자. Errors = {1 \\over n}\\sum_{i=1}^{n} (wx_i - y_i)^2위와 같은 Error를 구하기 위한 방법론은 machine learning에만 국한된 것이 아닌 범용적으로 사용되는 알고리즘이다. 최소제곱법(Least Squared Method)라고 부르며 알고리즘 자체에 궁금한 것이 있다면 이를 검색해 찾아보자. 마지막으로 다음 단계인 Gradient Descent 에서는 미분을 진행한다. 이를 위해 계산을 편히 하기 위하여 미리 2로 나누어 주자. Cost Function = {1 \\over 2n}\\sum_{i=1}^{n} (wx_i - y_i)^2Gradient Descent (에러의 최소화)Gradient Descent 단계를 진행하기 앞서 지금까지의 내용을 간략히 정리해 보자. Hypothesis 단계에서 데이터를 표현하기 위한 모델 하나를 결정 했다. 그리고 이 모델이 데이터를 가장 잘 표현하게 하기 위해서 Error의 개념을 도입했고 이 Error는 실제 데이터의 값과 모델을 통한 예측 값의 차이를 의미한다. 마지막으로 모든 데이터들의 Error 값을 합한 것이 Cost Function이였다. 즉 Cost Function은 실제 데이터 값과 예측 값의 차이의 합임으로 이 값이 최소화된다면 Model이 data를 잘 표현했다고 말할 수 있다. Model : y = wxCost Function = {1 \\over 2n}\\sum_{i=1}^{n} (wx_i - y_i)^2앞서 정의된 Cost Function을 최소화 시키기 위하여 경사감소법(Gradient Descent)를 활용한다. 이번엔 Cost Function의 그래프를 그려보도록 하자. 이 그래프는 이차함수로 표현된다. 이는 Cost Function의 수식을 살펴보거나 직접 값을 대입해보면 충분히 이해할 수 있을 것이다. 현재 Cost Function 그래프에 나타나 있는 초록색 점이 우리의 현재 값이라고 가정해보자. 이 값이 최소값을 가지게 하려면 보라색 점이 있는 곳 까지 도달해야 한다. 이를 위해 미분을 활용해보자. 미분은 그래프 상에서 접선의 기울기로 표현된다. 보라색 점에 도달하게 되면 그 때의 접선의 기울기는 0이기 때문에 미분 값을 0으로 볼 수 있다. { \\partial \\over \\partial w } Cost Function = {1 \\over n}\\sum_{i=1}^{n} (wx_i - y_i) (x_i) = 0여기서 중요한 것은 현재 우리가 구하려는 것은 데이터를 가장 잘 표현하기 위한 모델임으로 결국 w의 값을 찾는 것임을 명심하자. 그렇기 때문에 w값 기준으로 미분하였다. x, y 값은 실제 데이터다. 앞에서 Cost Function의 미분 값이 0에 도달 했을 때 모델이 데이터를 가장 잘 표현한다는 것은 이해했다. 이제 0에 도달하기 위하여 Gradient Descent 방법을 활용한다. 이는 크게 어려운 것이 아니고 미분 값이 0에 도달할 때 까지 w값을 바꾸어 가며 반복하는 것이다. w_{n+1} = w_n - \\alpha { \\partial \\over \\partial w} Cost Function위의 수식이 Gradient Descent Cost Function의 미분 값이 0에 수렴하도록 계속 반복하면서 w의 값을 바꾸는 구조를 가지고 있다. alpha 값은 하이퍼 파라미터로 Gradient Descent의 반복할 때 값이 변하는 크기를 결정한다. 보통 learning rate라고 표현하며 자세히는 alpha : learning rate{: target=”_blank”} 글을 참고하라. SummaryMachine Learning 분야에서 Linear Regression에 대해서 살펴보았다. 이는 Hypothesis, Cost Function, Gradient Descent 3단계로 구분되는데 Hypothesis에서 데이터들을 가장 잘 표현하기 위한 모델을 선정하였고 Linear Regression 이 모델이 일차함수로 나타난다. Cost Function을 통해 데이터과 모델의 차이를 정의하였고 이를 Gradient Descent 방법으로 최소화하여 데이터를 가장 잘 표현하는 모델을 만드는 방법을 알아보았다. Tesorflow Example1234567891011121314151617181920212223242526import tensorflow as tfimport osos.environ[&#x27;TF_CPP_MIN_LOG_LEVEL&#x27;] = &#x27;2&#x27;x_train = [1.60, 1.63, 1.65, 1.66, 1.71, 1.70, 1.73, 1.70, 1.73]y_train = [23.0, 23.5, 24.0, 23.5, 24.0, 24.0, 24.5, 24.0, 25.0]a = tf.Variable(tf.random_normal([1]), name=&#x27;a&#x27;)b = tf.Variable(tf.random_normal([1]), name=&#x27;b&#x27;)hypothesis = a * x_train + be = tf.reduce_mean(tf.square(hypothesis - y_train))optimizer =tf.train.GradientDescentOptimizer(learning_rate=0.01)train = optimizer.minimize(e)sess. tf.Session()sess.run(tf.global_variables_initializer())for step in range(2001) : sess.run(train) if step % 20 == 0 : print(&quot;Iteration : &quot;, step, &quot; e : &quot;, sess.run(e), &quot; ( y =&quot;, sess.run(a), &quot; x + &quot;, sess.run(b), &quot;)&quot; )","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Machine learning","slug":"Machine-learning","permalink":"http://kidongyun.github.io/tags/Machine-learning/"}]},{"title":"Conventional programming vs Machine Learning programming","slug":"2019-08-01-conventional-programming-vs-machine-learning-programming","date":"2019-08-01T02:21:54.000Z","updated":"2022-05-31T07:07:12.000Z","comments":true,"path":"2019/08/01/","link":"","permalink":"http://kidongyun.github.io/2019/08/01/","excerpt":"","text":"What is Conventional Programming ?It’s the normal programming way. Developer should define all of the cases that client do. Everythings is dependent on the developer. when you see the program, many programs would be devloped as Convetional Programming. What is Machine Learning Programming ?Unlike conventional programming, The programmade as Machine Learning Programming is driven by data not developer. If the business has many cases like STT or Computer Vision, this programming way would be better. White Box Testing vs Black Box TestingWhite Box Testing means just checking the logic of the functions located in internal system. these function are usually so tiny part of the system. one of the main features of White Box Testing is that you can see the interal logic in the system. Unlike White Box Testing, Black Box Testing can see the internal of system. so It can only test input and output of this system. The program made as Machine learning technique could not be seen because it’s operated by data not developer. so We can only test with Black Box Testing in this progamming way case. Why do we use the Machine Learning ?Actually, This way has a big strength unlike Conventional thing. We always consider about the exception of program when we build the system. but Let’s try to suppose that this program has a lof of the exception innumerable. then It’s impossible to make the program using Conventional Programming way because We can’t know all of the exception. In this case, Machine Learning programming way is more proper than former. For example, If we make the program for recognizing the handwriting which figure many various using Convetional thing, We have to know the figure of handwriting by all over the people because It’s always different.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Machine learning","slug":"Machine-learning","permalink":"http://kidongyun.github.io/tags/Machine-learning/"}]},{"title":"Artineer","slug":"2019-07-28-artineer","date":"2019-07-28T02:21:54.000Z","updated":"2022-05-31T07:06:57.000Z","comments":true,"path":"2019/07/28/","link":"","permalink":"http://kidongyun.github.io/2019/07/28/","excerpt":"","text":"1. EnvironmentServer : Linux + Apache + Mysql + PHP Language : HTML+CSS+JS Library : JQuery Sample Site Github Source code","categories":[{"name":"Service","slug":"Service","permalink":"http://kidongyun.github.io/categories/Service/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://kidongyun.github.io/tags/Javascript/"},{"name":"Php","slug":"Php","permalink":"http://kidongyun.github.io/tags/Php/"}]},{"title":"LOCAT","slug":"2019-07-28-social-service-based-location","date":"2019-07-28T02:21:54.000Z","updated":"2022-05-31T07:07:02.000Z","comments":true,"path":"2019/07/28/","link":"","permalink":"http://kidongyun.github.io/2019/07/28/","excerpt":"","text":"2. EnvironmentServer : LAMP Web server Language : SCSS, ESMA6 Javascript Framework : Ionic Sample Video Github Source code","categories":[{"name":"Service","slug":"Service","permalink":"http://kidongyun.github.io/categories/Service/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://kidongyun.github.io/tags/Javascript/"},{"name":"Ionic","slug":"Ionic","permalink":"http://kidongyun.github.io/tags/Ionic/"}]},{"title":"DIP","slug":"2019-07-24-design-in-programming","date":"2019-07-24T02:21:54.000Z","updated":"2022-05-31T07:06:35.000Z","comments":true,"path":"2019/07/24/","link":"","permalink":"http://kidongyun.github.io/2019/07/24/","excerpt":"","text":"1. Backgroundi thought the traditional way creating webpage takes too a long time at that time. so I wanna the function that we can create website easier with WYSIWYG technique like Stroyboard in XCode. and I made core engine of this WYSIWYG technique only used vanila javascript. after this project, i realized the necessity of technique named data binding. I created about it myself, it’s really not easy to me at that time so i have learned SPA like React or Vue.js. 2. EnvironmentServer : Linux + Apache + Mysql + PHP Language : HTML+CSS, ESMA6 Javascript Library : JQuery, VanilaJS 3. Technical Detail1. Coding javascript as O.O.P style. we don’t usually need to create JS code as O.O.P style. because it’s used as a script code for processing dynamical in website. and this processing is enough with functional script code. but O.O.P coding style is needed to implement WYSIWYG properly. so I would try it and i knew the prototype syntax of Javascript. and after ES6, you can also use class keyword in Javascript like just Java 2. Understanding deeply about DOM structure. Implementation WYSIWYG technique in webpage need the understanding deely about DOM structure. whenever someone drag and drop the object in there, DOM structre should be changed properly. 3. Understaning the benefit of data binding. Javascript value and the field in DOM is separated. so although you change the javascript value, the field in DOM is not changed. data binding technique connect between javascript value and the value in DOM. so if you apply this, it will be modify automatically. data binding Angular.js : two-way data binding (JS &lt;-&gt; DOM) Vue.js : two-way data binding (JS &lt;-&gt; DOM) React.js : one-way data binding (JS -&gt; DOM) Sample Video Github Source code","categories":[{"name":"Service","slug":"Service","permalink":"http://kidongyun.github.io/categories/Service/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://kidongyun.github.io/tags/Javascript/"},{"name":"Web","slug":"Web","permalink":"http://kidongyun.github.io/tags/Web/"},{"name":"Php","slug":"Php","permalink":"http://kidongyun.github.io/tags/Php/"}]},{"title":"Ecguide","slug":"2019-07-24-guide-system-for-engineering-college","date":"2019-07-24T02:21:54.000Z","updated":"2022-05-31T07:06:31.000Z","comments":true,"path":"2019/07/24/","link":"","permalink":"http://kidongyun.github.io/2019/07/24/","excerpt":"","text":"1. Backgroundthe building of my engineering college is like a maze. so the map for here always needed. so i created website operated in kiosk terminal located on entrace of this building. I developed the server and website. 2. EnvironmentServer : Linux + Apache + Mysql + PHP Language : HTML+CSS+JS Library : JQuery, Google Speech API 3. Technical Detail1. Google Speech API. this service is on the kiosk platform so the main interaction is a speech recognition. and I needed STT service for it. so i adopt Google Speech API Sample Site Github Source code","categories":[{"name":"Service","slug":"Service","permalink":"http://kidongyun.github.io/categories/Service/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://kidongyun.github.io/tags/Javascript/"},{"name":"Php","slug":"Php","permalink":"http://kidongyun.github.io/tags/Php/"},{"name":"STT","slug":"STT","permalink":"http://kidongyun.github.io/tags/STT/"}]},{"title":"Onebowl","slug":"2019-07-24-wonkwang-restaurant-social-application","date":"2019-07-24T02:21:54.000Z","updated":"2022-05-31T07:06:52.000Z","comments":true,"path":"2019/07/24/","link":"","permalink":"http://kidongyun.github.io/2019/07/24/","excerpt":"","text":"1. BackgroundIt’s just one of the assignments when i was undergraduate on software engineering major. It just introduce restraunts located on nearby wonkwang university campus. Especially, I developed this app with Phonegap, Cordova 2. EnvironmentServer : LAMP Web server Language : HTML+CSS+JS Framework : Phonegap, Cordova 3. Technical DetailHybrid app with Cordova This application is made on Web techniques. and It would convert to native app with Webview. I don’t use any framework for hybrid app like React Native, Ionic. Acutually i didn’t know the libraries at that time. maybe if i knew, then i would use it. Github Source code","categories":[{"name":"Service","slug":"Service","permalink":"http://kidongyun.github.io/categories/Service/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://kidongyun.github.io/tags/Javascript/"},{"name":"Php","slug":"Php","permalink":"http://kidongyun.github.io/tags/Php/"},{"name":"Webapp","slug":"Webapp","permalink":"http://kidongyun.github.io/tags/Webapp/"}]},{"title":"Knights Landing Processor","slug":"2019-07-24-knights-landing-study","date":"2019-07-24T02:21:54.000Z","updated":"2022-05-31T07:06:46.000Z","comments":true,"path":"2019/07/24/","link":"","permalink":"http://kidongyun.github.io/2019/07/24/","excerpt":"","text":"1. BackgroundI studied to improve the computing performance with Roofline model, Regression Predication. The main idea to improve the performance is Data migration. The KNL (= Kight Landing Processor) processor has two types cache memories. the first one is DRAM that we usually used in personal computer and the last one is HBM (= High Bandwidth Memory). Data migration means to migrate the data between DRAM and HBM as the features. 2. EnvironmentSystem : Linux based Knight Landing Processor Language : Python, Bash Shell Script Framework &amp; Library : numactl, Intel Advisor 3. Technical Detail1. Cache Coherence I had not ever been consider about the cache coherence. but after this study, I have realized the mechanism of it. It has two ways how keep the cache coherence. Snoopy Protocol firslty and the second one is Directory based Protocol. KNL has a many cache node so Snoopy Protocol is not good choice for this one. It will occur bottlenecks. 2. NUMA structure of KNL processor KNL memory structure is not UMA (= Uniform Memory Access) unless personal computer. this super computer consist of NUMA sturucture that it means cache node and the processor are dependent each. 3. Predication with Regression Model I use this regression model to decide whether the data needs to migrate or not. [논문] HyDM: Data Migration Methodology for Hybrid Memories.pdf [연구자료] Cache Coherence Protocols.pptx [연구자료] Roofline Model.pptx [연구자료] Applying Roofline Model to KNL.pptx [연구자료] Optimization.pptx [연구자료] Data Migration Algorithm.pptx","categories":[{"name":"Service","slug":"Service","permalink":"http://kidongyun.github.io/categories/Service/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://kidongyun.github.io/tags/Python/"},{"name":"Memory","slug":"Memory","permalink":"http://kidongyun.github.io/tags/Memory/"},{"name":"Regression","slug":"Regression","permalink":"http://kidongyun.github.io/tags/Regression/"},{"name":"Roofline","slug":"Roofline","permalink":"http://kidongyun.github.io/tags/Roofline/"}]},{"title":"How to use Flexbox basically","slug":"2019-05-25-css-flexbox","date":"2019-05-24T23:47:54.000Z","updated":"2022-05-31T07:06:20.000Z","comments":true,"path":"2019/05/25/","link":"","permalink":"http://kidongyun.github.io/2019/05/25/","excerpt":"","text":"Let’s know default way how use flex attribute in css 1. Default settingFirstly, we sould create the html code for testing. flex.html1234567891011121314&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;child2&quot;&gt; &lt;/div&gt; &lt;div class=&quot;child3&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; and let’s define background-color attribute and size attribute to know how flex attribute is operated. flex.css1234567891011121314151617181920212223.parent &#123; width: 300px; height: 300px; background-color: #cccccc;&#125;.child1 &#123; width: 60px; height: 60px; background-color: #222222;&#125;.child2 &#123; width: 60px; height: 60px; background-color: #555555;&#125;.child3 &#123; width: 60px; height: 60px; background-color: #888888;&#125; 2. flex container, flex itemflex attribute is consist of two elements. the one is flex container and the other is flex item. their relation is parent-children as you guess. to use flex attribute, you should define ‘display: flex‘ attribute in parent element (= flex container) flex.css123456789101112....parent &#123; width: 300px; height: 300px; background-color: #cccccc; display: flex; /* NEW CODE */&#125;... then the children element in parent can use flex attribute. and html basically render data from top to bottom but if you apply flex attribute, it will be change to horizontal. 3. flex-directionflex attribute basically change aligning direction from left to right. if you want to change it, you just modify flex-direction attribute. this attribute default value is row. to set aligning direction from top to bottom, change it to column. 12345678910111213....parent &#123; width: 300px; height: 300px; background-color: #cccccc; display: flex; flex-direction: column; /* NEW CODE */&#125;... if you align the data reversely then type row-reverse or column-reverse at flex_direction 12345678910111213....parent &#123; width: 300px; height: 300px; background-color: #cccccc; display: flex; flex-direction: row-reverse; /* NEW CODE */&#125;... flex-direction: row flex-direction: column flex-direction: row-reverse flex-direction: column-reverse 4. justify-contentjustify_content attribute in flex is for defining to align way at horizontal direction. you can set with this attribute where it places like left or center, how much it has free space and how it sets ratio between each free space. children elements will be applied when you define this attribute in parent element (= flex container) 1234567891011justify-content: flex-start; /* left (default) */justify-content: flex-end; /* right */justify-content: center; /* center */justify-content: space-between; /* flex item will have same size of free space */justify-content: space-around; /* All of free space has same size including the front of the first element and the back of last one */ the above attributes (flex-start, flex-end, center, space-between, space-around) usually used in real. 1234567891011121314....parent &#123; width: 300px; height: 300px; background-color: #cccccc; display: flex; flex-direction: row; justify-content: flex-start; /* NEW CODE */&#125;... justify-content: flex-start justify-content: flex-end justify-content: center justify-content: space-between justify-content: space-around 4. align-itemsunlike justify-content attribute, align_items attribute can defines vertical aligning. 123456align-items: stretch; /* The height of flex item is same with flex container&#x27;s height(default) */align-items: flex-start; /* assigning based on top */align-items: center; /* assigning based on center */align-items: flex-end; /* assigning based on bottom */ 1234567891011121314....parent &#123; width: 300px; height: 300px; background-color: #cccccc; display: flex; flex-direction: row; align-items: stretch;&#125;... align-items: stretch align-items: flex-start align-items: center align-items: flex-end You should remember the stretch attribute set same the height with flex-container. but if you define the height at children element then the stretch attributle is ignored. 12345678910111213141516171819202122232425262728.parent &#123; width: 300px; height: 300px; background-color: #cccccc; display: flex; flex-direction: row; align-items: stretch;&#125;.child1 &#123; width: 60px; // height: 60px; background-color: #222222;&#125;.child2 &#123; width: 60px; // height: 60px; background-color: #555555;&#125;.child3 &#123; width: 60px; // height: 60px; background-color: #888888;&#125; in my experence, flexbox in css is not usually used in real service. because old browsers don’t support this attribute. so you should also know about how can solve same problem without flexbox.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://kidongyun.github.io/tags/Css/"}]},{"title":"Yong Portfolio","slug":"2019-05-22-yong-portfolio","date":"2019-05-22T11:24:54.000Z","updated":"2022-05-31T07:06:12.000Z","comments":true,"path":"2019/05/22/","link":"","permalink":"http://kidongyun.github.io/2019/05/22/","excerpt":"","text":"1. BackgroundThis page is created as static page and it’s only for displaying the portfolio of the designer who is just my friend. This page requires front-end technique deeply like animation, reactive page, the template based development and so on. 2. EnvironmentServer : Git Page Language : HTML+CSS+JS Library : JQuery 3. Technical Detail1. Using git static page. I uploaded it in LAMP Server. but it’s too wasting only for this page. so I searched what is better idea to solve it. and I found git page service so i migrated this service to there. 2. Reactive web page for desktop, mobile both I just knew we can create reactive web page using media tag. but actually it’s not easy to express as i want when i made it. but i could usually sovle with CSS Flex Attribute. 3. One Web server, Multi Service It’s just related with apache setting (virtual-host in httpd.conf). when you want many services in just one web server than you set the domain mapped with each service. Sample Site Github Source code","categories":[{"name":"Service","slug":"Service","permalink":"http://kidongyun.github.io/categories/Service/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://kidongyun.github.io/tags/Javascript/"},{"name":"Css","slug":"Css","permalink":"http://kidongyun.github.io/tags/Css/"},{"name":"Html","slug":"Html","permalink":"http://kidongyun.github.io/tags/Html/"}]},{"title":"Wonkwang Univ. Intra Application","slug":"2019-05-10-wonkwang-university-application","date":"2019-05-10T02:21:54.000Z","updated":"2022-05-31T07:17:32.000Z","comments":true,"path":"2019/05/10/","link":"","permalink":"http://kidongyun.github.io/2019/05/10/","excerpt":"","text":"1. BackgroundIntra service for Wonkwang Univ already offered with Desktop before. but it is created too old so when you look this service with mobile, it’s not easy to use it. you always swipe your cellphone to expand the information in screen. I developed this service alone and you can take the information related with looking scholarships, timetables, scores, other that it will be useful to Wonkwang Univ student. but I stopped this service because of the security problem. i got the information by crawling technique. my university doesn’t give api for creating the service with itself. 2. EnvironmentPlatform : Android Native Application Language : Java Database : SQLite Library &amp; Detail : Jsoup, MPAndroidChart, RSA Encryption, Viewpager 3. Technical Detail1. Crawling Data related with Student. when you crawl the web page required any authentication, you could not get the information directly. you should make the bot is signing in there like the human. after this task, you could take the information. and i parse the web page with jsoup library like html, css code. i think now that it’s little not good way because It’s too dependent at web page but It was my best at that time. 2. Paging with Infinity Scroll. It’s my first time to use Infinity Scroll and Paging technique. The BBS service (= it is the sort of board service) has articles a lot. so Paging has to been needed at this board service. so I applied it in here. 3. Doing the long tasks in background thread. I thought deeply about the timing when is better to process storing data to database or crawling web page. They are needed the long time to process. And actually now, Android platform must process these task that don’t related with rendering in background (= other thread) but it’s not when i created it. Sample Video 1 Sample Video 2 Github Source code","categories":[{"name":"Service","slug":"Service","permalink":"http://kidongyun.github.io/categories/Service/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://kidongyun.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"}]},{"title":"Categorized Posts using Menu","slug":"2019-05-05-categories-jekyll-menu","date":"2019-05-05T02:38:54.000Z","updated":"2022-05-31T07:03:50.000Z","comments":true,"path":"2019/05/05/","link":"","permalink":"http://kidongyun.github.io/2019/05/05/","excerpt":"","text":"1. Decide categories of which you want.I will divide my posts to two parts. first is Jekyll and the last thing is React 1Think the way how to divide your posts 2. modify your _config.yml fileadd the new code in anywhere of your _config.yml file 12345menu: - title: Jekyll url: /jekyll/ - title: React url: /react/ below is your _config.yml file before modifying 12345678910111213141516171819title: Development Portfolioemail: oriondigestive@example.comdescription: &gt;- # this means to ignore newlines until &quot;baseurl:&quot; Computer Programming Development Web Application SPA Ajax Github Git Jekyll Blog React ReactNative NodeJS Express MachineLearning DataMinning ArtificialIntelligencebaseurl: &quot;&quot; url: &quot;&quot; twitter_username: jekyllrbgithub_username: kidongYunpermalink: /:title/markdown: kramdowntheme: minimaplugins: - jekyll-feed and below is your _config.yml file after changing 123456789101112131415161718192021222324252627title: Development Portfolioemail: oriondigestive@example.comdescription: &gt;- # this means to ignore newlines until &quot;baseurl:&quot; Computer Programming Development Web Application SPA Ajax Github Git Jekyll Blog React ReactNative NodeJS Express MachineLearning DataMinning ArtificialIntelligencebaseurl: &quot;&quot; url: &quot;&quot; twitter_username: jekyllrbgithub_username: kidongYunpermalink: /:title/####################################### START NEW CODEmenu: - title: Jekyll url: /jekyll/ - title: React url: /react/####################################### END NEW CODEmarkdown: kramdowntheme: minimaplugins: - jekyll-feed Even if the codes in _config.yml are a little different between your and mine, that’s okay. Just if you add above code related to menu at anywhere of _config.yml successfully. then your service is maybe operate well. if you finished, you can see the result on your jekyll page like below. Actually That’s shape is a little different because of Jekyll theme and You should check whether your Jekyll theme can apply menu attribute or not. if it isn’t, you must make this manually. Don’t follow my posts. 3. Make directories related to categoriesLet’s make the directories and you should keep their names are equal with url of menu attribute in _config.yml look carefully the above picture, highlighted directories is my new folders for categorizing. 4. Make a index.html files in each new folders 5. Lastly, filling your new index.html filesfollow code below. you should customize (code) to yours ex) (layout name), (category name) and (layout name) is found in the _layouts directory in your jekyll projects It’s my case if you want to fix category page concretely, You should understand about the structure or code of your jekyll service. and then fix your page manually. You can see the following as the result","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://kidongyun.github.io/tags/Javascript/"},{"name":"Node","slug":"Node","permalink":"http://kidongyun.github.io/tags/Node/"},{"name":"Webpack","slug":"Webpack","permalink":"http://kidongyun.github.io/tags/Webpack/"}]},{"title":"Let's update modification automatically in React using Webpack Watch attribute.","slug":"2019-05-02-webpack-watch","date":"2019-05-01T20:09:54.000Z","updated":"2022-05-31T07:03:31.000Z","comments":true,"path":"2019/05/02/","link":"","permalink":"http://kidongyun.github.io/2019/05/02/","excerpt":"","text":"Let’s update modification automatically in React using Webpack Watch attribute.add code below in webpack.config.js 1watch: true this attribution named watch is the function that can update bundle.js file automatically. and belows is the totally code of webpack.config.js before123456789101112131415161718192021222324252627module.exports = &#123; entry: [ &#x27;./src/index.js&#x27; ], module: &#123; rules: [ &#123; test: /\\.(js|jsx|)$/, exclude: /node_modules/, use: [&#x27;babel-loader&#x27;] &#125;, &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125; ] &#125;, resolve: &#123; extensions: [&#x27;*&#x27;, &#x27;.js&#x27;, &#x27;.jsx&#x27;] &#125;, output: &#123; path: __dirname + &#x27;/public&#x27;, filename: &#x27;bundle.js&#x27; &#125;&#125;; after123456789101112131415161718192021222324252627282930module.exports = &#123; entry: [ &#x27;./src/index.js&#x27; ], module: &#123; rules: [ &#123; test: /\\.(js|jsx|)$/, exclude: /node_modules/, use: [&#x27;babel-loader&#x27;] &#125;, &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125; ] &#125;, resolve: &#123; extensions: [&#x27;*&#x27;, &#x27;.js&#x27;, &#x27;.jsx&#x27;] &#125;, output: &#123; path: __dirname + &#x27;/public&#x27;, filename: &#x27;bundle.js&#x27; &#125;, /////////////////////////////////////////////////////// START NEW CODE watch: true /////////////////////////////////////////////////////// END NEW CODE&#125;; Don’t forget to add comma between new code and previous thing. then you can see the result below in the end when you use npm run build 1npm run build","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://kidongyun.github.io/tags/Javascript/"},{"name":"Node","slug":"Node","permalink":"http://kidongyun.github.io/tags/Node/"},{"name":"Webpack","slug":"Webpack","permalink":"http://kidongyun.github.io/tags/Webpack/"}]},{"title":"The way how to using CSS format in React","slug":"2019-04-27-using-css-react","date":"2019-04-26T18:23:00.000Z","updated":"2022-05-31T07:03:26.000Z","comments":true,"path":"2019/04/27/","link":"","permalink":"http://kidongyun.github.io/2019/04/27/","excerpt":"","text":"Let’s find out the way how to modify your React project when you want to operate CSS format files in yours If it doesn’t work with showing message like below. the reason doesn’t operate is because you did’t install the things relate to CSS Styling so now, we will install 2 packages using npm. they are css-loader and style-loader. 1. Let’s install css-loader, style-loader via npmfollow command below at your React project folder 1.../my_react_express &gt; npm install --save-dev css-loader style-loader 2. Update your webpack.config.js fileadd code below in your webpack.config.js 1234&#123; test: /\\.css$/, use: [&#x27;css-loader&#x27;, &#x27;style-loader&#x27;]&#125; Originally, your webpack.config.js maybe is like below. Before1234567891011121314151617181920212223module.exports = &#123; entry: [ &#x27;./src/index.js&#x27; ], module: &#123; rules: [ &#123; test: /\\.(js|jsx)$/, exclude: /node_modules/, use: [&#x27;babel-loader&#x27;] &#125; ] &#125;, resolve: &#123; extensions: [&#x27;*&#x27;, &#x27;.js&#x27;, &#x27;.jsx&#x27;] &#125;, output: &#123; path: __dirname + &#x27;/public&#x27;, filename: &#x27;bundle.js&#x27; &#125;&#125;; Let’s modify it like below. After1234567891011121314151617181920212223242526272829module.exports = &#123; entry: [ &#x27;./src/index.js&#x27; ], module: &#123; rules: [ &#123; test: /\\.(js|jsx)$/, exclude: /node_modules/, use: [&#x27;babel-loader&#x27;] &#125;, /////////////////////////////////////////////////////// START NEW CODE &#123; test: /\\.css$/, use: [&#x27;css-loader&#x27;, &#x27;style-loader&#x27;] &#125; /////////////////////////////////////////////////////// END NEW CODE ] &#125;, resolve: &#123; extensions: [&#x27;*&#x27;, &#x27;.js&#x27;, &#x27;.jsx&#x27;] &#125;, output: &#123; path: __dirname + &#x27;/public&#x27;, filename: &#x27;bundle.js&#x27; &#125;&#125;; Don’t miss the comma ‘,’ between the code associated with babel-loader and css-loader when you modify your webpack.config.js If you do the above successfully, then your React system will understand .css files","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"React","slug":"React","permalink":"http://kidongyun.github.io/tags/React/"},{"name":"Javascript","slug":"Javascript","permalink":"http://kidongyun.github.io/tags/Javascript/"},{"name":"Css","slug":"Css","permalink":"http://kidongyun.github.io/tags/Css/"}]},{"title":"Let's build React with Express Server","slug":"2019-04-26-build-react-express","date":"2019-04-25T17:58:54.000Z","updated":"2022-05-31T07:03:17.000Z","comments":true,"path":"2019/04/26/","link":"","permalink":"http://kidongyun.github.io/2019/04/26/","excerpt":"","text":"If you are the first React, please search create-react-app, see other posts. Building React Service manually without create-react-app is somewhat difficult for beginners. I will build React via npm package manager. It needs node so if you don’t have then please download in here. 1. To create node projectFirst of all, you should make the directory for using your react project. 123... &gt; mkdir my_react_express... &gt; cd my_react_express.../my_react_express &gt; when you want to make node project, you just use command below.1.../my_react_express &gt; npm init -yif you don’t use the option ‘-y’ then you should treat the detail of your new node project. and you can check package.json file in your project directory. 2. To install express, react, react-dom at dependeciesfollow below command at your folder 1.../my_react_express &gt; npm install -save express react react-dom You can see node_modules folder in your react directory.and you can also check the new addition, associated with express, react, react-dom at dependencies of package.json 3. To install @babel/core, @babel/preset-env, @babel/preset-react, babel-loader, webpack, webpack-cli at devDependeciesfollow command below at your folder 1.../my_react_express &gt; npm install --save-dev @babel/core @babel/preset-env @babel/preset-react babel-loader webpack webpack-cli and then Let’s check your package.json file one more. devDependencies entry has been added to package.json file, and what is installed in it. 4. Let’s consist all files, folders properly to your React directory.First, Let’s make 3 folders in your React directory. follow command below.123.../my_react_express &gt; mkdir public.../my_react_express &gt; mkdir server.../my_react_express &gt; mkdir src next step, make 6 files in your React directory.123456.../my_react_express/webpack.config.js.../my_react_express/.babelrc.../my_react_express/public/index.html.../my_react_express/src/App.js.../my_react_express/src/index.js.../my_react_express/server/main.js 5. Let’s fill in your new files.…/my_react_express/webpack.config.jstyping code below in your webpack.config.js 1234567891011121314151617181920212223module.exports = &#123; entry: [ &#x27;./src/index.js&#x27; ], module: &#123; rules: [ &#123; test: /\\.(js|jsx)$/, exclude: /node_modules/, use: [&#x27;babel-loader&#x27;] &#125; ] &#125;, resolve: &#123; extensions: [&#x27;*&#x27;, &#x27;.js&#x27;, &#x27;.jsx&#x27;] &#125;, output: &#123; path: __dirname + &#x27;/public&#x27;, filename: &#x27;bundle.js&#x27; &#125;&#125;; One of the important features of webpack is gathering static files and resources together and then extract what to bundle.js …/my_react_express/.babelrc123&#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot;]&#125; …/my_react_express/public/index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;React App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; …/my_react_express/src/App.js123456789101112import React from &#x27;react&#x27;; class App extends React.Component &#123; render()&#123; return ( &lt;h1&gt;Hello React Skeleton&lt;/h1&gt; ); &#125;&#125; export default App; …/my_react_express/src/index.js123456import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import App from &#x27;./App&#x27;; const rootElement = document.getElementById(&#x27;root&#x27;);ReactDOM.render(&lt;App /&gt;, rootElement); …/my_react_express/server/main.js12345678910111213var express = require(&#x27;express&#x27;)var app = express()var path = require(&#x27;path&#x27;)app.use(express.static(&#x27;public&#x27;))app.listen(3000, function() &#123; console.log(&quot;start! express server on port 3000&quot;)&#125;)app.get(&#x27;/&#x27;, function(req, res) &#123; res.sendFile(path.join(__dirname, &quot;../public/index.html&quot;))&#125;) 6. Update new code your package.json fileplease add new code below in your scripts of package.json 12&quot;start&quot;: &quot;nodemon ./server/main.js&quot;,&quot;build&quot;: &quot;webpack -p&quot; The below is all the code in package.json 1234567891011121314151617181920212223242526272829&#123; &quot;name&quot;: &quot;my_react_express&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, /////////////////////////////////////////////////////// START NEW CODE &quot;start&quot;: &quot;nodemon ./server/main.js&quot;, &quot;build&quot;: &quot;webpack -p&quot; /////////////////////////////////////////////////////// END NEW CODE &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;^4.16.4&quot;, &quot;react&quot;: &quot;^16.8.6&quot;, &quot;react-dom&quot;: &quot;^16.8.6&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;^7.4.3&quot;, &quot;@babel/preset-env&quot;: &quot;^7.4.3&quot;, &quot;@babel/preset-react&quot;: &quot;^7.0.0&quot;, &quot;webpack&quot;: &quot;^4.30.0&quot;, &quot;webpack-cli&quot;: &quot;^3.3.1&quot; &#125;&#125; if you don’t do thing above, you can’t execute your React 7. Run your React using npm scriptfollow code below1.../my_react_express &gt; npm run buildas I mentioned before, if you finished, you can get a bundle.js file. 1.../my_react_express &gt; npm start Finally, Let’s go to localhost:3000 Thank you for reading so far.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"React","slug":"React","permalink":"http://kidongyun.github.io/tags/React/"},{"name":"Javascript","slug":"Javascript","permalink":"http://kidongyun.github.io/tags/Javascript/"},{"name":"Node","slug":"Node","permalink":"http://kidongyun.github.io/tags/Node/"}]},{"title":"How to post The Jekyll page via Markdown","slug":"2019-04-25-how-post-jekyll","date":"2019-04-24T18:23:00.000Z","updated":"2022-05-31T07:03:13.000Z","comments":true,"path":"2019/04/25/","link":"","permalink":"http://kidongyun.github.io/2019/04/25/","excerpt":"","text":"1. Make a .md file in …/_posts//_posts folder is for holding your Jekyll posts. and I recommend you to use the editor(Atom, VSCode, Editplus) for typing this. I commonly use VSCode. if you want, you can download VSCode in here then please open your Jekyll Project folder in File &gt; Open Folder and make a .md file in /_posts folder. you should keep the shape of your file name like below when you making Jekyll posts.123date-title.mdexample) 2019-04-25-jekyll-test.md then you can check your updates at locally 2. Let’s fill the content in your post please type what you want in your post as shown below. 3. Push your updates to Github Repository.123git add .git commit -m &quot;anything&quot;git push -u origin master and also you can check your updates at your github pages.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://kidongyun.github.io/tags/Blog/"},{"name":"Jekyll","slug":"Jekyll","permalink":"http://kidongyun.github.io/tags/Jekyll/"}]},{"title":"Let's apply Jekyll Theme","slug":"2019-04-24-apply-jekyll-theme","date":"2019-04-23T19:21:00.000Z","updated":"2022-05-31T07:03:08.000Z","comments":true,"path":"2019/04/24/","link":"","permalink":"http://kidongyun.github.io/2019/04/24/","excerpt":"","text":"1. Download the zip file of the desired Jekyll Theme.Let’s get the Jekyll Theme you want on this page first. and please download the zip files of the desired Jekyll Theme. I downloaded the hydejack theme in my case. 2. Copy and Paste zip files of Jekyll Theme to your Jekyll Proejct directory.When you’re done, please unzip your theme file. then copy and paste these all files to your jekyll project folder. and when you received above message, you should surely press the skip button. Don’t overwrite the file. Never! otherwise your Jekyll service is not operating. 3. Serve Your Jekyll Page locallyplease you operate your Jekyll Server using below command at your Jekyll directory. actually, we already seen this command at Jekyll-1 Let’s build the jekyll page in local if you can’t understand this, I recommend you looking at the above post. 1.../my_jekyll &gt; jekyll serve you can see below image as a result. I think it is more awesome then default theme. 4. update Jekyll Theme to Github.it is also so simple just you do to upload your updated to github. following these commands at your Jekyll project folder.123.../my_jekyll &gt; git add ..../my_jekyll &gt; git commit -m &quot;first&quot;.../my_jekyll &gt; git push -u origin master then you can also see the same with above picture.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://kidongyun.github.io/tags/Blog/"},{"name":"Jekyll","slug":"Jekyll","permalink":"http://kidongyun.github.io/tags/Jekyll/"}]},{"title":"Let's upload the your jekyll to github page","slug":"2019-04-21-upload-jekyll-github-page","date":"2019-04-20T18:56:54.000Z","updated":"2022-05-31T07:03:02.000Z","comments":true,"path":"2019/04/21/","link":"","permalink":"http://kidongyun.github.io/2019/04/21/","excerpt":"","text":"First of all, your system should be installed Git program before following this post. if you don’t, you can get Git at this page 1. Make a new repository of github for Jekyll page.Let’s go to github site and please login your account. If you don’t have, please sign in. and then please press new button located on left of this above site you should type your repository name like below at next page.1[username].github.io you should type your own name at the part of username. in my case, i wrote ‘kidongYun’ as you see. 2. Let’s link between github repository and your local jekyll directory using Gitexecute git bash and change the directory to your jekyll workspace. I have changed my directory to ‘…/my_jekyll’ as you can see at above picture. following below’s code in git bash12345.../my_jekyll &gt; git init.../my_jekyll &gt; git add ..../my_jekyll &gt; git commit -m &quot;first&quot;.../my_jekyll &gt; git remote origin add [your git repository].../my_jekyll &gt; git push -u origin master you can confirm [your git repository] at your github repository. When you completed all of the aboves, you can see the your jekyll page loaded in github repository via your officially github page url. maybe your url look like this https://[username].github.io My page is a bit different from the default pages which already saw at previous post because of Jekyll Theme We will take a look at the Jekyll Theme in following posts.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://kidongyun.github.io/tags/Blog/"},{"name":"Jekyll","slug":"Jekyll","permalink":"http://kidongyun.github.io/tags/Jekyll/"}]},{"title":"Let's build the jekyll page in local","slug":"2019-04-20-build-jekyll-page-locally","date":"2019-04-19T17:24:54.000Z","updated":"2022-05-31T07:02:51.000Z","comments":true,"path":"2019/04/20/","link":"","permalink":"http://kidongyun.github.io/2019/04/20/","excerpt":"","text":"when I was building this jekyll page, I have been through a lot of trials and errors. so I felt at that time I should write some posts associated with Jekyll to record my working and to share to the others. this post is to know the way how to build the jekyll page in local system. Specially, you should install Ruby in your system before following below process. if you don’t have Ruby in your system, you can download it in this page. 1. To install Jekyll via gem of RubyExecute ‘cmd’ Please press Windows + R buttons simultaneously then you can see the window like above. then press the confirm button. Typing these in Command123.../&gt; mkdir my_jekyll.../&gt; cd my_jekyll.../my_jekyll&gt; gem install jekyll Let’s change directory using ‘cd’, ‘mkdir’ to your workspace where you want. you can install Jekyll through gem of Ruby. Let’s follow the above command line. 2. Let’s make a new jekyll project in workspaceTyping below’s code in Command1.../my_jekyll &gt; jekyll new . you can see the new files made by the above command in your workspace.these files are the things for building your static web page used Jekyll 3. Let’s execute your jekyll page service locally.Typing below’s code in Command1.../my_jekyll &gt; jekyll serve if you saw the same texts like my in your command, your jekyll service work successfully. Let’s enter the jekyll page via localhost:4000 if you saw the page same with me, it works well.","categories":[{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://kidongyun.github.io/tags/Blog/"},{"name":"Jekyll","slug":"Jekyll","permalink":"http://kidongyun.github.io/tags/Jekyll/"}]}],"categories":[{"name":"Todo","slug":"Todo","permalink":"http://kidongyun.github.io/categories/Todo/"},{"name":"Devlog","slug":"Devlog","permalink":"http://kidongyun.github.io/categories/Devlog/"},{"name":"Yunhwadngdng","slug":"Yunhwadngdng","permalink":"http://kidongyun.github.io/categories/Yunhwadngdng/"},{"name":"Service","slug":"Service","permalink":"http://kidongyun.github.io/categories/Service/"}],"tags":[{"name":"Cheat Engine","slug":"Cheat-Engine","permalink":"http://kidongyun.github.io/tags/Cheat-Engine/"},{"name":"Draft","slug":"Draft","permalink":"http://kidongyun.github.io/tags/Draft/"},{"name":"Kotest","slug":"Kotest","permalink":"http://kidongyun.github.io/tags/Kotest/"},{"name":"Docker","slug":"Docker","permalink":"http://kidongyun.github.io/tags/Docker/"},{"name":"Docker Compose","slug":"Docker-Compose","permalink":"http://kidongyun.github.io/tags/Docker-Compose/"},{"name":"Ableton","slug":"Ableton","permalink":"http://kidongyun.github.io/tags/Ableton/"},{"name":"Recording","slug":"Recording","permalink":"http://kidongyun.github.io/tags/Recording/"},{"name":"Facade Pattern","slug":"Facade-Pattern","permalink":"http://kidongyun.github.io/tags/Facade-Pattern/"},{"name":"Java","slug":"Java","permalink":"http://kidongyun.github.io/tags/Java/"},{"name":"Enum","slug":"Enum","permalink":"http://kidongyun.github.io/tags/Enum/"},{"name":"Enum Inheritance","slug":"Enum-Inheritance","permalink":"http://kidongyun.github.io/tags/Enum-Inheritance/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://kidongyun.github.io/tags/Kotlin/"},{"name":"DslMarker","slug":"DslMarker","permalink":"http://kidongyun.github.io/tags/DslMarker/"},{"name":"Message Queue","slug":"Message-Queue","permalink":"http://kidongyun.github.io/tags/Message-Queue/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://kidongyun.github.io/tags/RabbitMQ/"},{"name":"Spring","slug":"Spring","permalink":"http://kidongyun.github.io/tags/Spring/"},{"name":"GraalVM","slug":"GraalVM","permalink":"http://kidongyun.github.io/tags/GraalVM/"},{"name":"Webclient","slug":"Webclient","permalink":"http://kidongyun.github.io/tags/Webclient/"},{"name":"Hexo","slug":"Hexo","permalink":"http://kidongyun.github.io/tags/Hexo/"},{"name":"LaTeX","slug":"LaTeX","permalink":"http://kidongyun.github.io/tags/LaTeX/"},{"name":"Web","slug":"Web","permalink":"http://kidongyun.github.io/tags/Web/"},{"name":"CORS","slug":"CORS","permalink":"http://kidongyun.github.io/tags/CORS/"},{"name":"Webflux","slug":"Webflux","permalink":"http://kidongyun.github.io/tags/Webflux/"},{"name":"JUnit","slug":"JUnit","permalink":"http://kidongyun.github.io/tags/JUnit/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://kidongyun.github.io/tags/Spring-Cloud/"},{"name":"Redis","slug":"Redis","permalink":"http://kidongyun.github.io/tags/Redis/"},{"name":"Gradle","slug":"Gradle","permalink":"http://kidongyun.github.io/tags/Gradle/"},{"name":"JPA","slug":"JPA","permalink":"http://kidongyun.github.io/tags/JPA/"},{"name":"Entity","slug":"Entity","permalink":"http://kidongyun.github.io/tags/Entity/"},{"name":"Linux","slug":"Linux","permalink":"http://kidongyun.github.io/tags/Linux/"},{"name":"Reactor","slug":"Reactor","permalink":"http://kidongyun.github.io/tags/Reactor/"},{"name":"Spring Batch","slug":"Spring-Batch","permalink":"http://kidongyun.github.io/tags/Spring-Batch/"},{"name":"Flutter","slug":"Flutter","permalink":"http://kidongyun.github.io/tags/Flutter/"},{"name":"Dart","slug":"Dart","permalink":"http://kidongyun.github.io/tags/Dart/"},{"name":"AWS","slug":"AWS","permalink":"http://kidongyun.github.io/tags/AWS/"},{"name":"Git","slug":"Git","permalink":"http://kidongyun.github.io/tags/Git/"},{"name":"EC2","slug":"EC2","permalink":"http://kidongyun.github.io/tags/EC2/"},{"name":"RDS","slug":"RDS","permalink":"http://kidongyun.github.io/tags/RDS/"},{"name":"SfDatePicker","slug":"SfDatePicker","permalink":"http://kidongyun.github.io/tags/SfDatePicker/"},{"name":"HandlerMapping","slug":"HandlerMapping","permalink":"http://kidongyun.github.io/tags/HandlerMapping/"},{"name":"Blog","slug":"Blog","permalink":"http://kidongyun.github.io/tags/Blog/"},{"name":"Brew","slug":"Brew","permalink":"http://kidongyun.github.io/tags/Brew/"},{"name":"Mac","slug":"Mac","permalink":"http://kidongyun.github.io/tags/Mac/"},{"name":"Git Flow","slug":"Git-Flow","permalink":"http://kidongyun.github.io/tags/Git-Flow/"},{"name":"MSA","slug":"MSA","permalink":"http://kidongyun.github.io/tags/MSA/"},{"name":"ConfigurationProperties","slug":"ConfigurationProperties","permalink":"http://kidongyun.github.io/tags/ConfigurationProperties/"},{"name":"Database","slug":"Database","permalink":"http://kidongyun.github.io/tags/Database/"},{"name":"Object","slug":"Object","permalink":"http://kidongyun.github.io/tags/Object/"},{"name":"Javascript","slug":"Javascript","permalink":"http://kidongyun.github.io/tags/Javascript/"},{"name":"JQuery","slug":"JQuery","permalink":"http://kidongyun.github.io/tags/JQuery/"},{"name":"Monitoring","slug":"Monitoring","permalink":"http://kidongyun.github.io/tags/Monitoring/"},{"name":"Sentry","slug":"Sentry","permalink":"http://kidongyun.github.io/tags/Sentry/"},{"name":"Kibana","slug":"Kibana","permalink":"http://kidongyun.github.io/tags/Kibana/"},{"name":"A.O.P","slug":"A-O-P","permalink":"http://kidongyun.github.io/tags/A-O-P/"},{"name":"Test","slug":"Test","permalink":"http://kidongyun.github.io/tags/Test/"},{"name":"Junit","slug":"Junit","permalink":"http://kidongyun.github.io/tags/Junit/"},{"name":"Vue","slug":"Vue","permalink":"http://kidongyun.github.io/tags/Vue/"},{"name":"Keyboard Event","slug":"Keyboard-Event","permalink":"http://kidongyun.github.io/tags/Keyboard-Event/"},{"name":"Validation","slug":"Validation","permalink":"http://kidongyun.github.io/tags/Validation/"},{"name":"Serialize","slug":"Serialize","permalink":"http://kidongyun.github.io/tags/Serialize/"},{"name":"Timestamp","slug":"Timestamp","permalink":"http://kidongyun.github.io/tags/Timestamp/"},{"name":"Abstract Class","slug":"Abstract-Class","permalink":"http://kidongyun.github.io/tags/Abstract-Class/"},{"name":"Postgresql","slug":"Postgresql","permalink":"http://kidongyun.github.io/tags/Postgresql/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://kidongyun.github.io/tags/ElasticSearch/"},{"name":"High Level ElasticSearch","slug":"High-Level-ElasticSearch","permalink":"http://kidongyun.github.io/tags/High-Level-ElasticSearch/"},{"name":"DSL","slug":"DSL","permalink":"http://kidongyun.github.io/tags/DSL/"},{"name":"Computer Science","slug":"Computer-Science","permalink":"http://kidongyun.github.io/tags/Computer-Science/"},{"name":"Interview","slug":"Interview","permalink":"http://kidongyun.github.io/tags/Interview/"},{"name":"Cache","slug":"Cache","permalink":"http://kidongyun.github.io/tags/Cache/"},{"name":"Index","slug":"Index","permalink":"http://kidongyun.github.io/tags/Index/"},{"name":"Network","slug":"Network","permalink":"http://kidongyun.github.io/tags/Network/"},{"name":"TLS","slug":"TLS","permalink":"http://kidongyun.github.io/tags/TLS/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://kidongyun.github.io/tags/HTTPS/"},{"name":"Functional Programming","slug":"Functional-Programming","permalink":"http://kidongyun.github.io/tags/Functional-Programming/"},{"name":"Elastic Search","slug":"Elastic-Search","permalink":"http://kidongyun.github.io/tags/Elastic-Search/"},{"name":"Process","slug":"Process","permalink":"http://kidongyun.github.io/tags/Process/"},{"name":"Thread","slug":"Thread","permalink":"http://kidongyun.github.io/tags/Thread/"},{"name":"TCP","slug":"TCP","permalink":"http://kidongyun.github.io/tags/TCP/"},{"name":"UDP","slug":"UDP","permalink":"http://kidongyun.github.io/tags/UDP/"},{"name":"Oracle","slug":"Oracle","permalink":"http://kidongyun.github.io/tags/Oracle/"},{"name":"Tunning","slug":"Tunning","permalink":"http://kidongyun.github.io/tags/Tunning/"},{"name":"O.O.P","slug":"O-O-P","permalink":"http://kidongyun.github.io/tags/O-O-P/"},{"name":"Matcher","slug":"Matcher","permalink":"http://kidongyun.github.io/tags/Matcher/"},{"name":"Transaction","slug":"Transaction","permalink":"http://kidongyun.github.io/tags/Transaction/"},{"name":"interview","slug":"interview","permalink":"http://kidongyun.github.io/tags/interview/"},{"name":"Computer Architecture","slug":"Computer-Architecture","permalink":"http://kidongyun.github.io/tags/Computer-Architecture/"},{"name":"Operating System","slug":"Operating-System","permalink":"http://kidongyun.github.io/tags/Operating-System/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://kidongyun.github.io/tags/Algorithm/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://kidongyun.github.io/tags/Design-Pattern/"},{"name":"Singleton Pattern","slug":"Singleton-Pattern","permalink":"http://kidongyun.github.io/tags/Singleton-Pattern/"},{"name":"Flyweight Pattern","slug":"Flyweight-Pattern","permalink":"http://kidongyun.github.io/tags/Flyweight-Pattern/"},{"name":"Builder Pattern","slug":"Builder-Pattern","permalink":"http://kidongyun.github.io/tags/Builder-Pattern/"},{"name":"Observer Pattern","slug":"Observer-Pattern","permalink":"http://kidongyun.github.io/tags/Observer-Pattern/"},{"name":"Adapter Pattern","slug":"Adapter-Pattern","permalink":"http://kidongyun.github.io/tags/Adapter-Pattern/"},{"name":"Lombok","slug":"Lombok","permalink":"http://kidongyun.github.io/tags/Lombok/"},{"name":"Intellij","slug":"Intellij","permalink":"http://kidongyun.github.io/tags/Intellij/"},{"name":"Jackson","slug":"Jackson","permalink":"http://kidongyun.github.io/tags/Jackson/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"http://kidongyun.github.io/tags/Spring-Security/"},{"name":"JWT","slug":"JWT","permalink":"http://kidongyun.github.io/tags/JWT/"},{"name":"Swagger","slug":"Swagger","permalink":"http://kidongyun.github.io/tags/Swagger/"},{"name":"API","slug":"API","permalink":"http://kidongyun.github.io/tags/API/"},{"name":"Annotation","slug":"Annotation","permalink":"http://kidongyun.github.io/tags/Annotation/"},{"name":"Stub","slug":"Stub","permalink":"http://kidongyun.github.io/tags/Stub/"},{"name":"ExceptionHandling","slug":"ExceptionHandling","permalink":"http://kidongyun.github.io/tags/ExceptionHandling/"},{"name":"Gitlab","slug":"Gitlab","permalink":"http://kidongyun.github.io/tags/Gitlab/"},{"name":"Jira","slug":"Jira","permalink":"http://kidongyun.github.io/tags/Jira/"},{"name":"Maven","slug":"Maven","permalink":"http://kidongyun.github.io/tags/Maven/"},{"name":"Jad","slug":"Jad","permalink":"http://kidongyun.github.io/tags/Jad/"},{"name":"Decompile","slug":"Decompile","permalink":"http://kidongyun.github.io/tags/Decompile/"},{"name":"FunctionalInterface","slug":"FunctionalInterface","permalink":"http://kidongyun.github.io/tags/FunctionalInterface/"},{"name":"Spring - API - Response","slug":"Spring-API-Response","permalink":"http://kidongyun.github.io/tags/Spring-API-Response/"},{"name":"React","slug":"React","permalink":"http://kidongyun.github.io/tags/React/"},{"name":"Spring - HttpClient","slug":"Spring-HttpClient","permalink":"http://kidongyun.github.io/tags/Spring-HttpClient/"},{"name":"Git - Merge","slug":"Git-Merge","permalink":"http://kidongyun.github.io/tags/Git-Merge/"},{"name":"React - Mobx","slug":"React-Mobx","permalink":"http://kidongyun.github.io/tags/React-Mobx/"},{"name":"Java - O.O.P","slug":"Java-O-O-P","permalink":"http://kidongyun.github.io/tags/Java-O-O-P/"},{"name":"F.P","slug":"F-P","permalink":"http://kidongyun.github.io/tags/F-P/"},{"name":"Jpa","slug":"Jpa","permalink":"http://kidongyun.github.io/tags/Jpa/"},{"name":"Telnet","slug":"Telnet","permalink":"http://kidongyun.github.io/tags/Telnet/"},{"name":"Excel","slug":"Excel","permalink":"http://kidongyun.github.io/tags/Excel/"},{"name":"Container","slug":"Container","permalink":"http://kidongyun.github.io/tags/Container/"},{"name":"Css","slug":"Css","permalink":"http://kidongyun.github.io/tags/Css/"},{"name":"Dto","slug":"Dto","permalink":"http://kidongyun.github.io/tags/Dto/"},{"name":"Rest","slug":"Rest","permalink":"http://kidongyun.github.io/tags/Rest/"},{"name":"Mysql","slug":"Mysql","permalink":"http://kidongyun.github.io/tags/Mysql/"},{"name":"Jmeter","slug":"Jmeter","permalink":"http://kidongyun.github.io/tags/Jmeter/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://kidongyun.github.io/tags/Mybatis/"},{"name":"Typescript","slug":"Typescript","permalink":"http://kidongyun.github.io/tags/Typescript/"},{"name":"Graphql","slug":"Graphql","permalink":"http://kidongyun.github.io/tags/Graphql/"},{"name":"Xml","slug":"Xml","permalink":"http://kidongyun.github.io/tags/Xml/"},{"name":"Json","slug":"Json","permalink":"http://kidongyun.github.io/tags/Json/"},{"name":"Controller","slug":"Controller","permalink":"http://kidongyun.github.io/tags/Controller/"},{"name":"Cloud","slug":"Cloud","permalink":"http://kidongyun.github.io/tags/Cloud/"},{"name":"DI","slug":"DI","permalink":"http://kidongyun.github.io/tags/DI/"},{"name":"Android","slug":"Android","permalink":"http://kidongyun.github.io/tags/Android/"},{"name":"Machine learning","slug":"Machine-learning","permalink":"http://kidongyun.github.io/tags/Machine-learning/"},{"name":"Php","slug":"Php","permalink":"http://kidongyun.github.io/tags/Php/"},{"name":"Ionic","slug":"Ionic","permalink":"http://kidongyun.github.io/tags/Ionic/"},{"name":"STT","slug":"STT","permalink":"http://kidongyun.github.io/tags/STT/"},{"name":"Webapp","slug":"Webapp","permalink":"http://kidongyun.github.io/tags/Webapp/"},{"name":"Python","slug":"Python","permalink":"http://kidongyun.github.io/tags/Python/"},{"name":"Memory","slug":"Memory","permalink":"http://kidongyun.github.io/tags/Memory/"},{"name":"Regression","slug":"Regression","permalink":"http://kidongyun.github.io/tags/Regression/"},{"name":"Roofline","slug":"Roofline","permalink":"http://kidongyun.github.io/tags/Roofline/"},{"name":"Html","slug":"Html","permalink":"http://kidongyun.github.io/tags/Html/"},{"name":"Node","slug":"Node","permalink":"http://kidongyun.github.io/tags/Node/"},{"name":"Webpack","slug":"Webpack","permalink":"http://kidongyun.github.io/tags/Webpack/"},{"name":"Jekyll","slug":"Jekyll","permalink":"http://kidongyun.github.io/tags/Jekyll/"}]}